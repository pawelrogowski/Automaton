// /home/feiron/Dokumenty/Automaton/electron/constants/actionBarItems.js
//start file
const actionBarItems = {
  exuraMaxVita: {
    name: 'Exura Max Vita',
    iconName: 'Restoration',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [240, 248, 255],
      [227, 241, 255],
      [215, 235, 255],
    ],
  },
  exuraVita: {
    name: 'Exura Vita',
    iconName: 'Ultimate_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [215, 235, 254],
      [223, 239, 255],
      [228, 242, 255],
    ],
  },
  exuraGran: {
    name: 'Exura Gran',
    iconName: 'Intense_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [235, 238, 243],
      [224, 227, 233],
      [233, 229, 233],
    ],
  },
  exura: {
    name: 'Exura',
    iconName: 'Light_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [228, 210, 216],
      [223, 209, 217],
      [229, 228, 234],
    ],
  },
  exuraInfir: {
    name: 'Exura Infir',
    iconName: 'Magic_Patch',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [222, 215, 223],
      [216, 210, 218],
      [210, 199, 209],
    ],
  },
  utetaResVen: {
    name: 'Uteta Res Ven',
    iconName: 'Avatar_Of_Storm',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [173, 152, 240],
      [153, 103, 253],
      [255, 255, 255],
    ],
  },
  cancelMagicShield: {
    name: 'Exana Vita',
    iconName: 'Cancel_Magic_Shield',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [249, 200, 193],
      [251, 210, 203],
      [213, 139, 198],
    ],
  },
  curePoison: {
    name: 'Exana Pox',
    iconName: 'Cure_Poison',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [211, 236, 243],
      [184, 217, 222],
      [229, 242, 243],
    ],
  },
  exposeWeakness: {
    name: 'Exori Moe',
    iconName: 'Expose_Weakness',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [59, 63, 40],
      [59, 63, 40],
      [103, 113, 69],
    ],
  },
  magicShield: {
    name: 'Utamo Vita',
    iconName: 'Magic_Shield',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [147, 115, 27],
      [182, 151, 28],
      [226, 129, 206],
    ],
  },
  sapStrength: {
    name: 'Exori Kor',
    iconName: 'Sap_Strength',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [153, 169, 101],
      [180, 187, 118],
      [27, 27, 27],
      [22, 22, 22],
      [22, 22, 22],
    ],
  },
  utaniGranHur: {
    name: 'Utani Gran Hur',
    iconName: 'Strong_Haste',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [38, 116, 112],
      [11, 37, 36],
      [7, 29, 28],
      [6, 29, 28],
      [6, 30, 28],
    ],
  },
  utaniHur: {
    name: 'Utani Hur',
    iconName: 'Haste',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [78, 173, 166],
      [69, 157, 151],
      [12, 32, 31],
      [11, 27, 26],
      [11, 27, 26],
      [18, 44, 42],
      [29, 74, 70],
    ],
  },
  ultimateManaPotion: {
    name: 'Ultimate Mana Potion',
    iconName: 'Ultimate_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [141, 53, 102],
      [152, 58, 109],
      [116, 39, 87],
      [171, 58, 129],
      [151, 47, 114],
      [48, 44, 44],
    ],
  },
  greatManaPotion: {
    name: 'Great Mana Potion',
    iconName: 'Great_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [141, 53, 102],
      [152, 58, 109],
      [116, 39, 87],
      [171, 58, 129],
      [151, 47, 114],
      [143, 43, 109],
    ],
  },
  strongManaPotion: {
    name: 'Strong Mana Potion',
    iconName: 'Strong_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [169, 0, 131],
      [184, 0, 153],
      [143, 0, 89],
    ],
  },
  ManaPotion: {
    name: 'Mana Potion',
    iconName: 'Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [125, 6, 111],
      [150, 25, 148],
      [136, 7, 121],
    ],
  },
  healthPotion: {
    name: 'Health Potion',
    iconName: 'Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 11, 0],
      [170, 16, 16],
      [193, 47, 54],
    ],
  },
  supremeHealthPotion: {
    name: 'Supreme Health Potion',
    iconName: 'Supreme_Health_Potion',
    categories: ['potion'],
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [[222, 3, 0], 'any', 'any', [53, 43, 40]],
  },
  ultimateHealthPotion: {
    name: 'Ultimate Health Potion',
    iconName: 'Ultimate_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [247, 49, 67],
      [240, 70, 85],
      [238, 55, 66],
    ],
  },
  greatHealthPotion: {
    name: 'Great Health Potion',
    iconName: 'Great_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [247, 49, 67],
      [240, 70, 85],
      [238, 55, 66],
      [208, 2, 0],
      [161, 1, 0],
      [168, 1, 0],
    ],
  },
  strongHealthPotion: {
    name: 'Strong Health Potion',
    iconName: 'Strong_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [228, 0, 17],
      [229, 0, 17],
      [229, 1, 15],
    ],
  },
  smallHealthPotion: {
    name: 'Small Health Potion',
    iconName: 'Small_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [5, 2, 0],
      [67, 67, 67],
      [69, 69, 69],
      [109, 13, 0],
    ],
  },
  ultimateSpiritPotion: {
    name: 'Ultimate Spirit Potion',
    iconName: 'Ultimate_Spirit_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 35, 0],
      [92, 37, 0],
      [75, 30, 0],
      [111, 44, 0],
      [111, 44, 0],
      [48, 44, 44],
    ],
  },
  greatSpiritPotion: {
    name: 'Great Spirit Potion',
    iconName: 'Great_Spirit_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 35, 0],
      [92, 37, 0],
      [75, 30, 0],
      [111, 44, 0],
      [122, 59, 0],
    ],
  },
  avalancheRune: {
    name: 'Avalanche Rune',
    iconName: 'Avalanche',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [44, 81, 131],
      [45, 86, 135],
      [1, 2, 4],
      [0, 0, 0],
      [66, 129, 176],
    ],
  },
  thunderstormRune: {
    name: 'Thunderstorm Rune',
    iconName: 'Thunderstorm',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [124, 62, 162],
      [11, 5, 14],
      [9, 4, 9],
      [134, 62, 170],
    ],
  },
  greatFireballRune: {
    name: 'Great Fireball Rune',
    iconName: 'Great_Fireball',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [199, 71, 57],
      [237, 88, 72],
      [178, 73, 55],
    ],
  },
  stoneShowerRune: {
    name: 'Stone Shower Rune',
    iconName: 'Stone_Shower',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [181, 191, 133],
      [126, 166, 93],
      [116, 157, 85],
    ],
  },
  ultimateHealingRune: {
    name: 'Ultimate Healing Rune',
    iconName: 'Ultimate_Healing_Rune',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [18, 18, 18],
      [185, 185, 185],
      [255, 255, 255],
      [235, 235, 235],
      [233, 233, 233],
      [225, 225, 225],
      [209, 209, 209],
      [211, 211, 211],
      [210, 210, 210],
      [101, 101, 101],
    ],
  },
  suddenDeathRune: {
    name: 'Sudden Death Rune',
    iconName: 'Sudden_Death',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [148, 142, 132],
      [146, 137, 127],
      [79, 75, 70],
    ],
  },
  intenseHealingRune: {
    name: 'Intense Healing Rune',
    iconName: 'Intense_Healing_Rune',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [210, 210, 210],
      [100, 100, 100],
      [200, 200, 200],
    ],
  },
  explosionRune: {
    name: 'Explosion Rune',
    iconName: 'Explosion_Rune',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [13, 6, 16],
      [60, 30, 78],
      [142, 69, 182],
    ],
  },
  stoneSkinAmulet: {
    name: 'Stone Skin Amulet',
    iconName: 'Stone_Skin_Amulet',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [115, 115, 115],
      [65, 65, 65],
      [73, 73, 73],
      [73, 74, 73],
      [69, 69, 69],
      [68, 68, 68],
      [68, 69, 69],
      [73, 73, 73],
      [67, 67, 67],
      [73, 73, 73],
      [67, 67, 67],
      [74, 74, 74],
      [65, 65, 65],
      [67, 68, 68],
      [70, 71, 71],
      [0, 0, 0],
      [59, 59, 59],
      [135, 135, 135],
    ],
  },
  mightRing: {
    name: 'Might Ring',
    iconName: 'Might_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [115, 115, 115],
      [65, 65, 65],
      [73, 73, 73],
      [73, 74, 73],
      [69, 69, 69],
      [68, 68, 68],
      [68, 69, 69],
      [73, 73, 73],
      [67, 67, 67],
      [73, 73, 73],
      [67, 67, 67],
      [74, 74, 74],
      [65, 65, 65],
      [67, 68, 68],
      [0, 0, 0],
      [205, 172, 69],
    ],
  },
  mastermindPotion: {
    name: 'Mastermind Potion',
    iconName: 'Mastermind_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [67, 68, 68],
      [0, 0, 3],
      [87, 142, 92],
      [90, 160, 98],
    ],
  },
  bullseyePotion: {
    name: 'Bullseye Potion',
    iconName: 'Bullseye_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [57, 49, 44],
      [93, 80, 72],
      [115, 98, 87],
    ],
  },
  berserkPotion: {
    name: 'Berserk Potion',
    iconName: 'Berserk_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [116, 76, 36],
      [147, 91, 34],
      [137, 80, 19],
    ],
  },
  transcendencePotion: {
    name: 'Transcendence Potion',
    iconName: 'Transcendence_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [109, 82, 36],
      [109, 82, 36],
      [59, 43, 16],
      [59, 43, 16],
    ],
  },
  magicShieldPotion: {
    name: 'Magic Shield Potion',
    iconName: 'Magic_Shield_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [67, 67, 67],
      [69, 69, 69],
      [0, 0, 0],
      [239, 244, 253],
    ],
  },
  createThunderstormRune: {
    name: 'Create Thunderstorm Rune',
    iconName: 'Create_Thunderstorm_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [136, 68, 159],
      [63, 37, 64],
      [57, 34, 57],
    ],
  },
  createGreatFireballRune: {
    name: 'Create Great Fireball Rune',
    iconName: 'Create_Great_Fireball_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [89, 39, 17],
      [80, 32, 13],
      [61, 24, 8],
    ],
  },
  createSuddenDeathRune: {
    name: 'Create Sudden Death Rune',
    iconName: 'Create_Sudden_Death_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [134, 128, 122],
      [93, 90, 87],
      [50, 50, 50],
    ],
  },
  createMagicWallRune: {
    name: 'Create Magic Wall Rune',
    iconName: 'Create_Magic_Wall_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [138, 143, 93],
      [93, 106, 77],
      [100, 124, 90],
    ],
  },
  createExplosionRune: {
    name: 'Create Explosion Rune',
    iconName: 'Create_Explosion_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [39, 27, 46],
      [180, 98, 181],
      [108, 59, 133],
    ],
  },
  energyRing: {
    name: 'Energy Ring',
    iconName: 'Energy_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [88, 227, 177],
      [200, 255, 255],
      [57, 149, 118],
      [0, 0, 0],
    ],
  },
  lifeRing: {
    name: 'Life Ring',
    iconName: 'Life_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [91, 206, 68],
      [175, 253, 171],
      [60, 137, 45],
      [0, 0, 0],
    ],
  },
  dwarvenRing: {
    name: 'Dwarven Ring',
    iconName: 'Dwarven_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [196, 196, 196],
      [255, 255, 255],
      [150, 150, 150],
      [0, 0, 0],
    ],
  },
  axeRing: {
    name: 'Axe Ring',
    iconName: 'Axe_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [137, 137, 137],
      [212, 212, 212],
      [91, 91, 91],
      [0, 0, 0],
    ],
  },
  clubRing: {
    name: 'Club Ring',
    iconName: 'Club_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [206, 68, 172],
      [253, 171, 221],
      [137, 45, 114],
      [0, 0, 0],
    ],
  },
  powerRing: {
    name: 'Power Ring',
    iconName: 'Power_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [124, 53, 197],
      [214, 147, 253],
      [79, 39, 119],
      [0, 0, 0],
    ],
  },
  stealthRing: {
    name: 'Stealth Ring',
    iconName: 'Stealth_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [68, 114, 206],
      [171, 186, 253],
      [45, 75, 137],
      [0, 0, 0],
    ],
  },
  swordRing: {
    name: 'Sword Ring',
    iconName: 'Sword_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [226, 122, 0],
      [255, 212, 121],
      [134, 73, 0],
      [0, 0, 0],
    ],
  },
  timeRing: {
    name: 'Time Ring',
    iconName: 'Time_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [66, 66, 66],
      [141, 141, 141],
      [20, 20, 20],
      [0, 0, 0],
    ],
  },
  collarOfGreenPlasma: {
    name: 'Collar of Green Plasma',
    iconName: 'Collar_Of_Green_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [14, 107, 68],
      [120, 255, 198],
      [14, 107, 68],
    ],
  },
  collarOfOrangePlasma: {
    name: 'Collar of Orange Plasma',
    iconName: 'Collar_Of_Orange_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [107, 57, 14],
      [255, 182, 120],
      [107, 57, 14],
    ],
  },
  collarOfRedPlasma: {
    name: 'Collar of Red Plasma',
    iconName: 'Collar_Of_Red_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [107, 14, 53],
      [255, 120, 177],
      [107, 14, 53],
    ],
  },
  collarOfBluePlasma: {
    name: 'Collar of Blue Plasma',
    iconName: 'Collar_Of_Blue_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [14, 51, 107],
      [120, 175, 255],
      [14, 51, 107],
    ],
  },
  ringOfGreenPlasma: {
    name: 'Ring of Green Plasma',
    iconName: 'Ring_Of_Green_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [14, 107, 68],
      [210, 255, 236],
      [14, 107, 68],
    ],
  },
  ringOfRedPlasma: {
    name: 'Ring of Red Plasma',
    iconName: 'Ring_Of_Red_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [107, 14, 53],
      [255, 210, 229],
      [107, 14, 53],
    ],
  },
  ringOfOrangePlasma: {
    name: 'Ring of Orange Plasma',
    iconName: 'Ring_Of_Orange_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [107, 57, 14],
      [255, 231, 210],
      [107, 57, 14],
    ],
  },
  ringOfBluePlasma: {
    name: 'Ring of Blue Plasma',
    iconName: 'Ring_Of_Blue_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [14, 51, 107],
      [210, 228, 255],
      [14, 51, 107],
    ],
  },
  softBoots: {
    name: 'Soft Boots',
    iconName: 'Soft_Boots',
    categories: ['equipment'],
    slot: 'boots',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 117],
      [70, 70, 70],
      [71, 71, 71],
      [83, 84, 83],
      [69, 70, 69],
      [72, 72, 72],
      [74, 74, 74],
      [72, 73, 72],
      [0, 0, 0],
      [77, 62, 145],
      [124, 109, 195],
      [17, 0, 54],
    ],
  },
  blankRune: {
    name: 'Blank Rune',
    iconName: 'Blank_Rune',
    categories: ['others'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [143, 136, 127],
      [167, 161, 153],
      [180, 173, 164],
    ],
  },
  exuraSio: {
    name: 'Exura Sio',
    iconName: 'Heal_Friend',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [179, 228, 247],
      [201, 232, 245],
      [208, 239, 247],
      [27, 111, 135],
      [8, 33, 39],
    ],
  },
  exuraGranSio: {
    name: 'Exura Gran Sio',
    iconName: 'Natures_Embrace',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [198, 232, 247],
      [196, 232, 248],
      [201, 235, 247],
      [11, 110, 172],
      [44, 60, 79],
      [94, 108, 131],
    ],
  },
  uturaMasSio: {
    name: 'Utura Mas Sio',
    iconName: 'Heal_Party',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [31, 14, 16],
      [46, 19, 22],
      [125, 78, 84],
      [243, 236, 238],
      [243, 241, 245],
    ],
  },
  utanaVid: {
    name: 'Utana Vid',
    iconName: 'Invisible',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [59, 107, 107],
      [91, 98, 228],
      [52, 99, 98],
      [41, 94, 91],
    ],
  },
  exuraGranMasRes: {
    name: 'Exura Gran Mas Res',
    iconName: 'Mass_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [220, 241, 250],
      [199, 229, 240],
      [208, 234, 248],
      [196, 213, 218],
      [192, 205, 204],
    ],
  },
  exanaKor: {
    name: 'Exana Kor',
    iconName: 'Cure_Bleeding',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [213, 231, 242],
      [190, 203, 216],
      [232, 237, 240],
      [116, 35, 48],
    ],
  },
  exanaFlam: {
    name: 'Exana Flam',
    iconName: 'Cure_Burning',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [151, 99, 80],
      [185, 137, 102],
      [227, 166, 128],
      [213, 192, 138],
    ],
  },
  exanaVis: {
    name: 'Exana Vis',
    iconName: 'Cure_Electrification',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 114, 163],
      [214, 232, 253],
      [203, 224, 252],
      [90, 108, 172],
    ],
  },
  exanaMort: {
    name: 'Exana Mort',
    iconName: 'Cure_Curse',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [219, 241, 250],
      [209, 236, 247],
      [242, 251, 254],
      [229, 246, 252],
      [209, 238, 248],
    ],
  },
  utevoLux: {
    name: 'Utevo Lux',
    iconName: 'Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [253, 245, 204],
      [252, 228, 148],
      [244, 189, 99],
      [249, 201, 118],
    ],
  },
  utevoGranLux: {
    name: 'Utevo Gran Lux',
    iconName: 'Great_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [255, 252, 225],
      [255, 247, 195],
      [253, 232, 143],
      [254, 237, 164],
    ],
  },
  utevoVisLux: {
    name: 'Utevo Vis Lux',
    iconName: 'Ultimate_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [254, 253, 242],
      [255, 253, 249],
      [246, 240, 177],
      [232, 215, 104],
    ],
  },
  exuraSan: {
    name: 'Exura San',
    iconName: 'Divine_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [180, 97, 48],
      [245, 248, 221],
      [231, 243, 231],
      [204, 229, 232],
    ],
  },
  uturaGran: {
    name: 'Utura Gran',
    iconName: 'Intense_Recovery',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [51, 77, 91],
      [147, 183, 204],
      [188, 205, 209],
      [179, 179, 164],
    ],
  },
  exuraGranSan: {
    name: 'Exura Gran San',
    iconName: 'Salvation',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [199, 119, 32],
      [239, 212, 120],
      [236, 204, 117],
      [232, 199, 107],
      [201, 126, 42],
    ],
  },
  utetaResSac: {
    name: 'Uteta Res Sac',
    iconName: 'Avatar_Of_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [161, 108, 50],
      [199, 174, 147],
      [199, 174, 147],
      [27, 16, 17],
    ],
  },
  exanaIna: {
    name: 'Exana Ina',
    iconName: 'Cancel_Invisibility',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [12, 178, 167],
      [99, 99, 255],
      [9, 209, 201],
      [8, 212, 203],
    ],
  },
  utevoGravSan: {
    name: 'Utevo Grav San',
    iconName: 'Cancel_Invisibility',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [248, 247, 204],
      [247, 246, 199],
      [175, 161, 123],
    ],
  },
  utamoMasSio: {
    name: 'Utamo Mas Sio',
    iconName: 'Protect_Party',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [215, 245, 251],
      [13, 22, 21],
      [13, 22, 21],
      [13, 22, 21],
      [20, 30, 29],
      [189, 226, 232],
    ],
  },
  utitoTempoSan: {
    name: 'Utito Tempo San',
    iconName: 'Sharpshooter',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [23, 24, 25],
      [48, 50, 51],
      [48, 50, 51],
      [48, 50, 51],
      [112, 116, 118],
      [154, 159, 162],
    ],
  },
  utamoTempoSan: {
    name: 'Utamo Tempo San',
    iconName: 'Swift_Foot',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [21, 86, 81],
      [27, 91, 87],
      [47, 89, 83],
      [48, 93, 88],
    ],
  },
  exuraInfirIco: {
    name: 'Exura Infir Ico',
    iconName: 'Bruise_Bane',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [237, 219, 187],
      [244, 236, 212],
      [237, 242, 237],
      [219, 241, 250],
      [201, 232, 245],
      [207, 236, 247],
    ],
  },
  exuraMedIco: {
    name: 'Exura Med Ico',
    iconName: 'Fair_Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [240, 223, 188],
      [244, 233, 201],
      [240, 219, 181],
      [213, 152, 106],
    ],
  },
  exuraGranIco: {
    name: 'Exura Gran Ico',
    iconName: 'Intense_Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [244, 233, 197],
      [248, 241, 209],
      [246, 235, 198],
      [235, 215, 179],
    ],
  },
  woundCleansing: {
    name: 'Exura Ico',
    iconName: 'Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [236, 217, 183],
      [241, 229, 196],
      [236, 212, 174],
      [201, 129, 98],
    ],
  },
  utetaResEq: {
    name: 'Uteta Res Sac',
    iconName: 'Avatar_Of_Steel',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [42, 55, 70],
      [15, 15, 15],
      [46, 55, 71],
      [37, 46, 60],
    ],
  },
  utitoTempo: {
    name: 'Utito Tempo',
    iconName: 'Blood_Rage',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [219, 123, 119],
      [228, 172, 172],
      [236, 197, 197],
      [239, 167, 164],
    ],
  },
  utaniTempoHur: {
    name: 'Utani Tempo Hur',
    iconName: 'Charge',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [143, 80, 56],
      [196, 161, 147],
      [139, 105, 96],
      [66, 79, 65],
    ],
  },
  utamoTempo: {
    name: 'Utamo Tempo',
    iconName: 'Protector',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [41, 68, 62],
      [127, 136, 114],
      [122, 163, 141],
      [82, 108, 100],
    ],
  },
  utitoMasSio: {
    name: 'Utito Mas Sio',
    iconName: 'Train_Party',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [64, 189, 58],
      [122, 151, 106],
      [27, 111, 135],
      [8, 33, 39],
    ],
  },
  utetaResDru: {
    name: 'Utera Res Dru',
    iconName: 'Avatar_Of_Nature',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [21, 12, 8],
      [0, 0, 0],
      [0, 0, 0],
      [25, 25, 25],
      [0, 0, 0],
      [33, 33, 33],
    ],
  },
};

export default actionBarItems;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/battleListSequences.js
//start file
const battleListSequences = {
  // Border detection sequences for battle entries
  targetBorder: {
    offset: { x: 0, y: 0 },
    direction: 'horizontal',
    sequence: [
      [255, 0, 0], // Red target indicator
    ],
  },
  attackBorder: {
    offset: { x: 1, y: 1 },
    direction: 'horizontal',
    sequence: [
      [0, 0, 0], // Black attack indicator
    ],
  },
  healthBarValidation: {
    offset: { x: 0, y: 0 },
    direction: 'horizontal',
    sequence: [
      [0, 0, 0], // Black border validation
    ],
  },
  // Legacy sequences (can be removed if not used)
  battleEntry: {
    offset: { x: 0, y: 0 },
    direction: 'vertical',
    sequence: [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
  partyEntry: {
    offset: { x: 0, y: 0 },
    direction: 'vertical',
    sequence: [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
};

export default battleListSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/cooldownColorSequences.js
//start file
const cooldownColorSequences = {
  attack: {
    direction: 'vertical',
    sequence: [
      [0, 0, 6],
      [70, 13, 1],
      [171, 42, 9],
      [255, 255, 255],
    ],
    backupSequence: [
      [0, 0, 6],
      [70, 13, 1],
      [171, 42, 9],
      [255, 255, 255],
    ],
  },
  healing: {
    direction: 'vertical',
    sequence: [
      [1, 37, 102],
      [77, 111, 158],
      [39, 75, 116],
      [255, 255, 255],
    ],
  },
  support: {
    direction: 'vertical',
    sequence: [
      [0, 61, 52],
      [0, 109, 99],
      [52, 179, 172],
      [255, 255, 255],
    ],
  },
  attackInactive: {
    direction: 'vertical',
    sequence: [
      [71, 13, 2],
      [53, 10, 3],
      [0, 0, 0],
    ],
    backupSequence: [
      [72, 13, 2],
      [53, 11, 3],
      [0, 0, 0],
    ],
  },
  healingInactive: {
    direction: 'vertical',
    sequence: [
      [17, 29, 45],
      [6, 16, 30],
      [0, 0, 0],
    ],
  },
  supportInactive: {
    direction: 'vertical',
    sequence: [
      [42, 74, 73],
      [28, 50, 48],
      [0, 0, 0],
    ],
  },
};

export default cooldownColorSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/equippedItems.js
//start file
const equippedItems = {
  emptyRingSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [53, 56, 59],
      [35, 39, 42],
      [36, 39, 42],
      [66, 69, 72],
      [79, 81, 84],
      [37, 40, 43],
    ],
  },
  emptyAmuletSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [30, 33, 36],
      [65, 67, 70],
      [70, 73, 75],
      [82, 84, 87],
      [71, 73, 75],
      [67, 69, 72],
      [32, 35, 37],
    ],
  },
  emptyBootsSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [76, 78, 81],
      [61, 64, 66],
      [61, 64, 66],
      [52, 54, 57],
    ],
  },
  softBoots: {
    name: 'Soft Boots',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [36, 9, 93],
      [119, 92, 176],
      [115, 88, 172],
      [79, 52, 136],
    ],
  },
  mightRing: {
    name: 'Might Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [250, 237, 117],
      [246, 219, 98],
      [200, 166, 65],
      [221, 184, 71],
    ],
  },
  stoneSkinAmulet: {
    name: 'Stone Skin Amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [60, 60, 60],
      [110, 110, 110],
      [119, 119, 119],
      [110, 110, 110],
      [60, 60, 60],
    ],
  },
  energyRing: {
    name: 'Energy Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [88, 227, 177],
      [200, 255, 255],
      [57, 149, 118],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
  lifeRing: {
    name: 'Life Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [91, 206, 68],
      [175, 253, 171],
      [60, 137, 45],
    ],
  },
};

export default equippedItems;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/floorLevelIndicators.js
//start file
const floorLevelIndicators = {
  0: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[115, 182, 212]],
  },
  1: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[104, 165, 193]],
  },
  2: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[95, 152, 177]],
  },
  3: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[88, 140, 163]],
  },
  4: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[82, 130, 151]],
  },
  5: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[76, 121, 141]],
  },
  6: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[71, 114, 132]],
  },
  7: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[120, 147, 79]],
  },
  8: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[147, 100, 79]],
  },
  9: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[134, 90, 72]],
  },
  10: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[122, 83, 66]],
  },
  11: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[113, 76, 61]],
  },
  12: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[105, 71, 57]],
  },
  13: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[98, 66, 53]],
  },
  14: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[92, 62, 49]],
  },
  15: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[86, 58, 47]],
  },
};

export default floorLevelIndicators;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/index.js
//start file
export { default as regionColorSequences } from './regionColorSequeces.js';
export { default as regionDefinitions } from './regionDefinitions.js';
export { default as cooldownColorSequences } from './cooldownColorSequences.js';
export { default as battleListSequences } from './battleListSequences.js';
export { default as statusBarSequences } from './statusBarSequences.js';
export { default as resourceBars } from './resourceBars.js';
export { default as actionBarItems } from './actionBarItems.js';
export { default as equippedItems } from './equippedItems.js';
export { default as floorLevelIndicators } from './floorLevelIndicators.js';

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/palette.js
//start file
export const PALETTE_DATA = [
  { r: 0, g: 0, b: 0 },
  { r: 0, g: 102, b: 0 },
  { r: 0, g: 204, b: 0 },
  { r: 51, g: 102, b: 153 },
  { r: 102, g: 102, b: 102 },
  { r: 153, g: 51, b: 0 },
  { r: 153, g: 102, b: 51 },
  { r: 153, g: 153, b: 153 },
  { r: 153, g: 255, b: 102 },
  { r: 204, g: 255, b: 255 },
  { r: 255, g: 51, b: 0 },
  { r: 255, g: 102, b: 0 },
  { r: 255, g: 204, b: 153 },
  { r: 255, g: 255, b: 0 },
  { r: 255, g: 255, b: 255 },
];

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/regionColorSequeces.js
//start file
const regionColorSequences = {
  healthBar: {
    direction: 'horizontal',
    offset: { x: 5, y: 0 },
    sequence: [
      [241, 97, 97],
      [219, 91, 91],
      [103, 55, 55],
      'any',
      'any',
      [120, 61, 64],
    ],
  },
  manaBar: {
    direction: 'horizontal',
    offset: { x: 9, y: 0 },
    sequence: [
      [99, 96, 248],
      [95, 92, 219],
      [80, 79, 140],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [61, 61, 125],
    ],
  },
  minimap: {
    direction: 'horizontal',
    offset: { x: -117, y: 35 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  minimapFloorIndicatorColumn: {
    direction: 'horizontal',
    offset: { x: 33, y: 25 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  minimapFull: {
    direction: 'horizontal',
    offset: { x: -117, y: -20 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  cooldownBar: {
    direction: 'horizontal',
    offset: { x: -154, y: 8 },
    sequence: [
      [76, 75, 67],
      [77, 76, 71],
      [67, 66, 59],
    ],
    backupSequence: [
      [76, 75, 67],
      [76, 75, 71],
      [66, 65, 58],
    ],
  },
  // cooldownBarFallback: {
  //   direction: 'horizontal',
  //   offset: { x: -154, y: 8 },
  //   sequence: [
  //     [76, 75, 67],
  //     [77, 76, 71],
  //     [67, 66, 59],
  //   ],
  // },
  statusBar: {
    direction: 'horizontal',
    offset: { x: -99, y: 1 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  amuletSlot: {
    direction: 'horizontal',
    offset: { x: -100, y: -130 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  ringSlot: {
    direction: 'horizontal',
    offset: { x: -100, y: -58 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  bootsSlot: {
    direction: 'horizontal',
    offset: { x: -63, y: -36 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  // weaponSlot: {
  //   direction: 'horizontal',
  //   offset: { x: -100, y: -58 },
  //   sequence: [
  //     [41, 42, 42],
  //     [28, 28, 29],
  //     [44, 45, 45],
  //     [40, 40, 41],
  //     [44, 44, 44],
  //     [46, 46, 46],
  //     [112, 112, 113],
  //   ],
  // },
  chatOn: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [108, 108, 108],
      [110, 110, 110],
      [192, 192, 192],
      [161, 161, 161],
      [175, 175, 175],
      [185, 185, 185],
      [81, 81, 81],
    ],
  },
  chatOff: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [174, 174, 174],
      [183, 183, 183],
      [136, 136, 136],
      [174, 174, 174],
      [183, 183, 183],
      [128, 128, 128],
      [62, 62, 62],
    ],
  },

  hotkeyBarBottomStart: {
    direction: 'horizontal',
    offset: { x: 19, y: 0 },
    sequence: [
      [75, 75, 75],
      [68, 68, 68],
      [76, 76, 76],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [46, 46, 47],
      [53, 54, 54],
    ],
  },
  hotkeyBarBottomEnd: {
    direction: 'horizontal',
    offset: { x: -2, y: 0 },
    sequence: [
      [40, 40, 40],
      [43, 43, 43],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [66, 66, 66],
    ],
  },
  battleListStart: {
    direction: 'horizontal',
    offset: { x: 11, y: 17 },
    sequence: [
      [49, 49, 49],
      [129, 79, 41],
      [113, 91, 70],
      [56, 56, 56],
    ],
  },
  battleListEnd: {
    direction: 'horizontal',
    offset: { x: -137, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  partyListStart: {
    direction: 'horizontal',
    offset: { x: 13, y: 13 },
    sequence: [
      [30, 115, 255],
      [55, 55, 55],
      [113, 91, 70],
      [56, 56, 56],
    ],
  },
  partyListEnd: {
    direction: 'horizontal',
    offset: { x: -7, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  playerListStart: {
    direction: 'horizontal',
    offset: { x: 11, y: 17 },
    sequence: [
      [135, 86, 41],
      [159, 136, 40],
      [75, 74, 55],
      [61, 61, 61],
      [128, 193, 84],
      [128, 193, 84],
    ],
  },
  playerListEnd: {
    direction: 'horizontal',
    offset: { x: -137, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  onlineMarker: {
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [
      [118, 54, 54],
      [74, 74, 75],
      [72, 72, 72],
      [68, 66, 99],
    ],
  },
  gameWorldStart: {
    direction: 'horizontal',
    offset: { x: 1, y: 1 },
    sequence: [
      [22, 22, 22],
      [24, 24, 24],
      [23, 23, 23],
      [22, 22, 22],
      [21, 21, 21],
      [24, 24, 24],
      [23, 24, 23],
      [24, 24, 24],
      [27, 27, 26],
      [24, 24, 24],
      [22, 22, 22],
    ],
  },
  gameWorldEnd: {
    direction: 'horizontal',
    offset: { x: 9, y: -1 },
    sequence: [
      [111, 111, 111],
      [117, 117, 117],
      [116, 116, 116],
      [116, 116, 116],
      [113, 113, 113],
      [115, 115, 115],
      [116, 116, 115],
      [115, 115, 115],
      [118, 118, 117],
      [115, 115, 115],
      [114, 114, 114],
    ],
  },
  chatboxMainStart: {
    direction: 'vertical',
    offset: { x: 1, y: 5 },
    sequence: [
      [112, 112, 113],
      [116, 116, 117],
      'any',
      'any',
      [117, 117, 117],
      'any',
      [27, 27, 28],
    ],
  },
  chatboxSecondaryStart: {
    direction: 'horizontal',
    offset: { x: -1, y: 1 },
    sequence: [
      [63, 63, 63],
      [27, 27, 28],
      'any',
      'any',
      [117, 117, 117],
      [63, 63, 63],
      [27, 27, 28],
    ],
  },
  chatboxMainEnd: {
    direction: 'vertical',
    offset: { x: -7, y: 3 },
    sequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [54, 54, 54],
      [54, 54, 54],
    ],
    backupSequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      [115, 116, 115],
      [75, 75, 75],
    ],
  },
  chatboxSecondaryEnd: {
    direction: 'vertical',
    offset: { x: -7, y: 3 },
    sequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      [115, 116, 115],
      [75, 75, 75],
    ],
  },
  chatBoxTabRowStart: {
    direction: 'vertical',
    offset: { x: 13, y: -14 },
    sequence: [
      [112, 112, 113],
      [116, 116, 117],
      'any',
      'any',
      [117, 117, 117],
      'any',
      [27, 27, 28],
    ],
  },
  chatBoxTabRowEnd: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [89, 89, 89],
      [38, 38, 38],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [89, 89, 89],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [66, 66, 66],
    ],
  },
  skillsWidgetStart: {
    direction: 'horizontal',
    offset: { x: -3, y: 13 },
    sequence: [
      [170, 143, 100],
      [188, 174, 103],
      [55, 55, 55],
      [65, 65, 65],
    ],
  },
  skillsWidgetEnd: {
    direction: 'horizontal',
    offset: { x: -11, y: 1 },
    sequence: [
      [108, 108, 108],
      [160, 160, 160],
      [81, 81, 81],
      [67, 67, 67],
      [67, 67, 67],
    ],
  },
  preyWindow: {
    direction: 'horizontal',
    offset: { x: -13, y: -6 },
    sequence: [
      [229, 169, 24],
      [25, 70, 10],
      [39, 103, 18],
    ],
  },
  connectionLostCloseButton: {
    direction: 'horizontal',
    offset: { x: 129, y: 117 },
    sequence: [
      [56, 56, 56],
      [144, 144, 144],
      [144, 144, 144],
      [52, 52, 52],
      [64, 64, 64],
      [55, 56, 56],
      [144, 144, 144],
      [144, 144, 144],
      [67, 67, 67],
      [52, 52, 52],
      [144, 144, 144],
      [144, 144, 144],
      [48, 48, 48],
    ],
  },
};

export default regionColorSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/regionDefinitions.js
//start file
import actionBarItems from './actionBarItems.js';

const regionDefinitions = {
  healthBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 5, y: 0 },
    sequence: [
      [241, 97, 97],
      [219, 91, 91],
      [103, 55, 55],
      'any',
      'any',
      [120, 61, 64],
    ],
    width: 94,
    height: 14,
  },
  manaBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 9, y: 0 },
    sequence: [
      [99, 96, 248],
      [95, 92, 219],
      [80, 79, 140],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [61, 61, 125],
    ],
    width: 94,
    height: 14,
  },
  minimap: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -117, y: 35 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 106,
    height: 109,
  },
  minimapFloorIndicatorColumn: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 33, y: 25 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 2,
    height: 63,
  },
  minimapFull: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -117, y: -20 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 106,
    height: 109,
  },
  cooldownBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -154, y: 8 },
    sequence: [
      [76, 75, 67],
      [77, 76, 71],
      [67, 66, 59],
    ],
    backupSequence: [
      [76, 75, 67],
      [76, 75, 71],
      [66, 65, 58],
    ],
    width: 56,
    height: 4,
    children: {
      healing: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [1, 37, 102],
          [77, 111, 158],
          [39, 75, 116],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      support: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [0, 61, 52],
          [0, 109, 99],
          [52, 179, 172],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      attack: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [0, 0, 6],
          [70, 13, 1],
          [171, 42, 9],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      healingInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [17, 29, 45],
          [6, 16, 30],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
      supportInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [42, 74, 73],
          [28, 50, 48],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
      attackInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [71, 13, 2],
          [53, 10, 3],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
    },
  },
  statusBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -99, y: 1 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 104,
    height: 9,
    children: {
      inRestingArea: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [101, 157, 101],
          [120, 34, 34],
          [26, 45, 27],
        ],
      },
      inProtectedZone: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [172, 201, 246],
          [29, 77, 155],
          [118, 165, 242],
        ],
      },
      hungry: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [246, 212, 143],
          [246, 212, 143],
          [239, 180, 63],
        ],
      },
      poisoned: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [52, 118, 62],
          [54, 168, 70],
          [52, 118, 62],
        ],
      },
      hasted: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [176, 139, 80],
          [72, 57, 33],
          [249, 249, 248],
        ],
      },
      battleSign: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [151, 151, 156],
          [182, 182, 185],
          [124, 124, 128],
        ],
      },
      redBattleSign: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [55, 8, 8],
          [127, 0, 0],
          [173, 0, 0],
        ],
      },
      whiteSkull: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [242, 242, 242],
          [235, 235, 235],
          [232, 232, 232],
        ],
      },
      redSkull: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [213, 206, 206],
          [255, 173, 173],
          [255, 171, 171],
        ],
      },
      burning: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [174, 16, 13],
          [253, 139, 0],
          [218, 32, 4],
          [174, 16, 13],
        ],
      },
      magicShield: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [211, 198, 27],
          [86, 97, 91],
          [154, 26, 55],
        ],
      },
      strengthened: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [37, 170, 21],
          [32, 56, 30],
          [243, 153, 32],
        ],
      },
      cursed: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [9, 9, 9],
          [164, 164, 164],
          [210, 210, 210],
        ],
      },
      electrified: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [67, 21, 70],
          [241, 173, 245],
          [67, 21, 70],
        ],
      },
      paralyzed: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [120, 24, 24],
          [213, 8, 8],
          [243, 2, 2],
        ],
      },
      drowning: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [75, 206, 222],
          [208, 220, 224],
          [48, 142, 170],
        ],
      },
      bleeding: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [54, 28, 32],
          [128, 42, 50],
          [54, 28, 32],
        ],
      },
      freezing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [128, 255, 255],
          [190, 252, 252],
          [128, 255, 255],
        ],
      },
      eRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [30, 32, 119],
          [42, 46, 148],
          [26, 28, 111],
        ],
      },
      drunk: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [95, 79, 54],
          [151, 121, 74],
          [145, 116, 70],
        ],
      },
    },
  },
  amuletSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -100, y: -130 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    children: {
      emptyAmuletSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [30, 33, 36],
          [65, 67, 70],
          [70, 73, 75],
          [82, 84, 87],
          [71, 73, 75],
          [67, 69, 72],
          [32, 35, 37],
        ],
      },
      stoneSkinAmulet: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [60, 60, 60],
          [110, 110, 110],
          [119, 119, 119],
          [110, 110, 110],
          [60, 60, 60],
        ],
      },
    },
  },
  ringSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -100, y: -58 },
    sequence: [
      [41, 41, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    children: {
      emptyRingSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [53, 56, 59],
          [35, 39, 42],
          [36, 39, 42],
          [66, 69, 72],
          [79, 81, 84],
          [37, 40, 43],
        ],
      },
      mightRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [250, 237, 117],
          [246, 219, 98],
          [200, 166, 65],
          [221, 184, 71],
        ],
      },
      energyRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [88, 227, 177],
          [200, 255, 255],
          [57, 149, 118],
          [0, 0, 0],
          [0, 0, 0],
        ],
      },
      lifeRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [91, 206, 68],
          [175, 253, 171],
          [60, 137, 45],
        ],
      },
    },
  },
  bootsSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -63, y: -36 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    children: {
      emptyBootsSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [76, 78, 81],
          [61, 64, 66],
          [61, 64, 66],
          [52, 54, 57],
        ],
      },
      softBoots: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [36, 9, 93],
          [119, 92, 176],
          [115, 88, 172],
          [79, 52, 136],
        ],
      },
    },
  },
  chatOn: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [108, 108, 108],
      [110, 110, 110],
      [192, 192, 192],
      [161, 161, 161],
      [175, 175, 175],
      [185, 185, 185],
      [81, 81, 81],
    ],
    width: 8,
    height: 1,
  },
  chatOff: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [174, 174, 174],
      [183, 183, 183],
      [136, 136, 136],
      [174, 174, 174],
      [183, 183, 183],
      [128, 128, 128],
      [62, 62, 62],
    ],
    width: 7,
    height: 1,
  },
  hotkeyBar: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 19, y: 0 },
      sequence: [
        [75, 75, 75],
        [68, 68, 68],
        [76, 76, 76],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [46, 46, 47],
        [53, 54, 54],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -2, y: 0 },
      sequence: [
        [40, 40, 40],
        [43, 43, 43],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [66, 66, 66],
      ],
    },
    maxRight: 2000,
    maxDown: 110,
    children: Object.fromEntries(
      Object.entries(actionBarItems).map(([key, value]) => {
        const isVertical = value.direction === 'vertical';
        const seqLen = value.sequence.length;
        return [
          key,
          {
            type: 'single',
            direction: value.direction,
            offset: value.offset,
            sequence: value.sequence,
            width: isVertical ? 1 : seqLen,
            height: isVertical ? seqLen : 1,
          },
        ];
      }),
    ),
  },
  battleList: {
    ocrColors: [
      [192, 192, 192],
      [247, 247, 247],
    ],
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -4, y: -9 },
      sequence: [
        [113, 75, 43],
        [135, 86, 41],
        [159, 136, 40],
        [65, 65, 65],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: 9, y: 7 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
      ],
    },
    maxRight: 165,
    maxDown: 9999,
    children: {
      entries: {
        type: 'boundingBox',
        start: {
          direction: 'horizontal',
          offset: { x: -2, y: 4 },
          sequence: [
            [113, 75, 43],
            [135, 86, 41],
            [159, 136, 40],
            [65, 65, 65],
          ],
        },
        end: {
          direction: 'vertical',
          offset: { x: -7, y: -3 },
          sequence: [
            [159, 159, 159],
            [160, 160, 160],
            [104, 104, 104],
            [10, 10, 10],
          ],
        },
        maxRight: 180,
        maxDown: 9999,
      },
      close: {
        type: 'fixed',
        x: 164,
        y: 8,
        width: 3,
        height: 3,
      },
      minimize: {
        type: 'fixed',
        x: 151,
        y: 8,
        width: 3,
        height: 3,
      },
      types: {
        type: 'fixed',
        x: 136,
        y: 8,
        width: 3,
        height: 3,
      },
      order: {
        type: 'fixed',
        x: 125,
        y: 8,
        width: 3,
        height: 3,
      },
      new: {
        type: 'fixed',
        x: 112,
        y: 8,
        width: 3,
        height: 3,
      },
    },
  },
  partyList: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 13, y: 13 },
      sequence: [
        [30, 115, 255],
        [55, 55, 55],
        [113, 91, 70],
        [56, 56, 56],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -7, y: 0 },
      sequence: [
        [67, 67, 67],
        [78, 78, 78],
        [104, 104, 104],
        [67, 67, 67],
      ],
    },
    maxRight: 160,
    maxDown: 200,
  },
  playerList: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 11, y: 17 },
      sequence: [
        [135, 86, 41],
        [159, 136, 40],
        [75, 74, 55],
        [61, 61, 61],
        [128, 193, 84],
        [128, 193, 84],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -137, y: 0 },
      sequence: [
        [67, 67, 67],
        [78, 78, 78],
        [104, 104, 104],
        [67, 67, 67],
      ],
    },
    maxRight: 1920,
    maxDown: 1080,
  },
  gameWorld: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 1, y: 1 },
      sequence: [
        [22, 22, 22],
        [24, 24, 24],
        [23, 23, 23],
        [22, 22, 22],
        [21, 21, 21],
        [24, 24, 24],
        [23, 24, 23],
        [24, 24, 24],
        [27, 27, 26],
        [24, 24, 24],
        [22, 22, 22],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: 9, y: -1 },
      sequence: [
        [111, 111, 111],
        [117, 117, 117],
        [116, 116, 116],
        [116, 116, 116],
        [113, 113, 113],
        [115, 115, 115],
        [116, 116, 115],
        [115, 115, 115],
        [118, 118, 117],
        [115, 115, 115],
        [114, 114, 114],
      ],
    },
    maxRight: 'fullWidth',
    maxDown: 'fullHeight',
  },
  chatboxMain: {
    type: 'boundingBox',
    start: {
      direction: 'vertical',
      offset: { x: 1, y: 5 },
      sequence: [
        [112, 112, 113],
        [116, 116, 117],
        'any',
        'any',
        [117, 117, 117],
        'any',
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -7, y: 3 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [54, 54, 54],
        [54, 54, 54],
      ],
      backupSequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        [115, 116, 115],
        [75, 75, 75],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
    ocrColors: [
      [240, 240, 0],
      [248, 96, 96],
      [240, 240, 240],
      [96, 248, 248],
      [32, 160, 255],
      [160, 160, 255],
      [0, 240, 0],
    ],
  },
  chatboxSecondary: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -1, y: 1 },
      sequence: [
        [63, 63, 63],
        [27, 27, 28],
        'any',
        'any',
        [117, 117, 117],
        [63, 63, 63],
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -7, y: 3 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        [115, 116, 115],
        [75, 75, 75],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
    ocrColors: [
      [240, 240, 0],
      [248, 96, 96],
      [240, 240, 240],
      [96, 248, 248],
      [32, 160, 255],
      [160, 160, 255],
      [0, 240, 0],
    ],
  },
  chatBoxTabRow: {
    ocrColors: [
      [223, 223, 223],
      [247, 95, 95],
      [127, 127, 127],
    ],
    type: 'boundingBox',
    start: {
      direction: 'vertical',
      offset: { x: 13, y: -14 },
      sequence: [
        [112, 112, 113],
        [116, 116, 117],
        'any',
        'any',
        [117, 117, 117],
        'any',
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: 0, y: 0 },
      sequence: [
        [89, 89, 89],
        [38, 38, 38],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [89, 89, 89],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [66, 66, 66],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
  },
  skillsWidget: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -3, y: 13 },
      sequence: [
        [170, 143, 100],
        [188, 174, 103],
        [55, 55, 55],
        [65, 65, 65],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -11, y: 1 },
      sequence: [
        [108, 108, 108],
        [160, 160, 160],
        [81, 81, 81],
        [67, 67, 67],
        [67, 67, 67],
      ],
    },
    maxRight: 170,
    maxDown: 1000,
    ocrColors: [
      [192, 192, 192],
      [68, 173, 37],
    ],
  },
  loginModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [74, 74, 74],
      [192, 192, 192],
      [192, 192, 192],
      [75, 75, 75],
      [69, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [76, 76, 75],
      [74, 74, 73],
      [73, 74, 73],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [82, 82, 82],
      [72, 73, 72],
      [71, 72, 71],
      [74, 75, 75],
      [192, 192, 192],
      [192, 192, 192],
      [74, 74, 74],
    ],
    width: 1,
    height: 1,
    children: {
      emailInput: {
        type: 'fixed',
        x: 0,
        y: -76,
        width: 1,
        height: 1,
      },
      passwordInput: {
        type: 'fixed',
        x: 0,
        y: -43,
        width: 1,
        height: 1,
      },
      login: {
        type: 'fixed',
        x: 75,
        y: 39,
        width: 60,
        height: 3,
      },
      createNewAccount: {
        type: 'fixed',
        x: -71,
        y: 42,
        width: 60,
        height: 3,
      },
    },
  },
  connectionLostModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [144, 144, 144],
      [53, 53, 53],
      [55, 55, 55],
      [144, 144, 144],
      [144, 144, 144],
      [61, 61, 61],
      [49, 49, 49],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 57],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [62, 62, 62],
      [59, 60, 60],
      [61, 61, 61],
      [144, 144, 144],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 101,
        y: 118,
        width: 1,
        height: 1,
      },
    },
  },
  warningModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [56, 56, 57],
      [144, 144, 144],
      [144, 144, 144],
      [51, 51, 51],
      [144, 144, 144],
      [144, 144, 144],
      [47, 48, 48],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    children: {
      abort: {
        type: 'fixed',
        x: 93,
        y: 125,
        width: 1,
        height: 1,
      },
    },
  },
  connectionFailedModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [53, 53, 52],
      [144, 144, 144],
      [144, 144, 144],
      [49, 49, 49],
      [44, 44, 44],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 142,
        y: 166,
        width: 1,
        height: 1,
      },
    },
  },
  wrongPasswordModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [65, 65, 65],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [64, 64, 64],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [65, 65, 65],
      [62, 62, 62],
      [75, 76, 75],
      [76, 76, 76],
      [67, 67, 67],
      [65, 65, 65],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [70, 70, 70],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 45,
        y: 40,
        width: 1,
        height: 1,
      },
    },
  },
  connectingModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [56, 57, 56],
      [144, 144, 144],
      [144, 144, 144],
      [67, 68, 67],
      [58, 59, 58],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [54, 54, 54],
      [50, 50, 49],
      [144, 144, 144],
      [144, 144, 144],
      [53, 53, 53],
      [55, 55, 55],
      [144, 144, 144],
      [144, 144, 144],
      [61, 61, 61],
      [49, 49, 49],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 57],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [53, 53, 53],
    ],
    width: 1,
    height: 1,
    children: {
      cancel: {
        type: 'fixed',
        x: 192,
        y: 68,
        width: 1,
        height: 1,
      },
    },
  },
  pleaseWaitModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [65, 64, 64],
      [67, 68, 68],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [72, 72, 72],
    ],
    width: 1,
    height: 1,
    children: {
      abort: {
        type: 'fixed',
        x: 125,
        y: 93,
        width: 1,
        height: 1,
      },
    },
  },
  ipChangedModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [144, 144, 144],
      [144, 144, 144],
      [56, 56, 56],
      [59, 59, 59],
      [59, 60, 59],
      [52, 52, 52],
      [144, 144, 144],
      [144, 144, 144],
      [49, 49, 49],
      [52, 52, 52],
      [67, 67, 67],
      [52, 52, 52],
      [52, 53, 53],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [56, 56, 56],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 220,
        y: 65,
        width: 1,
        height: 1,
      },
    },
  },
  selectCharacterModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -358, y: 48 },
    sequence: [
      [144, 144, 144],
      [144, 144, 144],
      [55, 55, 54],
      [56, 56, 55],
      [54, 54, 54],
      [65, 65, 65],
      [49, 49, 49],
      [56, 57, 56],
      [144, 144, 144],
      [144, 144, 144],
      [54, 54, 53],
    ],
    width: 263,
    height: 266,
    ocrColors: [
      [244, 244, 244],
      [192, 192, 192],
    ],
    children: {
      ok: {
        type: 'fixed',
        x: 634,
        y: 345,
        width: 7,
        height: 7,
      },
      cancel: {
        type: 'fixed',
        x: 683,
        y: 347,
        width: 7,
        height: 7,
      },
    },
  },
  warningModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -99, y: -10 },
    sequence: [
      [52, 52, 51],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [58, 58, 58],
      [55, 55, 54],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 56],
      [52, 53, 52],
      [49, 49, 49],
      [144, 144, 144],
    ],
    width: 250,
    height: 157,
    children: {
      abort: {
        type: 'fixed',
        x: 213,
        y: 137,
        width: 5,
        height: 5,
      },
    },
  },
  notLoggedInAnymoreModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -271, y: -172 },
    sequence: [
      [192, 192, 192],
      [192, 192, 192],
      [67, 67, 66],
      [69, 70, 69],
      [192, 192, 192],
      [192, 192, 192],
      [73, 73, 73],
      [72, 73, 72],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [70, 70, 70],
      [61, 61, 61],
      [73, 73, 73],
      [192, 192, 192],
      [192, 192, 192],
      [76, 76, 76],
      [79, 79, 79],
      [192, 192, 192],
      [192, 192, 192],
      [65, 65, 65],
    ],
    width: 470,
    height: 100,
    children: {
      ok: {
        type: 'fixed',
        x: 154,
        y: 36,
        width: 5,
        height: 5,
      },
    },
  },

  gameLog: {
    type: 'fixed',
    x: 808,
    y: 695,
    width: 125,
    height: 11,
    ocrColors: [[240, 240, 240]],
  },
  onlineMarker: {
    type: 'single',
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [
      [118, 54, 54],
      [74, 74, 75],
      [72, 72, 72],
      [68, 66, 99],
    ],
    width: 1,
    height: 1,
  },
  vipWidget: {
    type: 'boundingBox',
    maxRight: 176,
    maxDown: 99999,
    ocrColors: [
      [248, 96, 96],
      [96, 248, 96],
    ],
    start: {
      direction: 'horizontal',
      offset: { x: -9, y: -9 },
      sequence: [
        [118, 93, 57],
        [108, 80, 41],
        [102, 87, 38],
        [121, 114, 48],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: 9, y: 6 },
      sequence: [
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
      ],
    },
  },
};

export default regionDefinitions;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/resourceBars.js
//start file
const resourceBars = {
  healthBar: [
    [120, 61, 64],
    [211, 79, 79],
    [219, 79, 79],
    [194, 74, 74],
    [100, 46, 49],
  ],
  manaBar: [
    [83, 80, 218],
    [77, 74, 194],
    [45, 45, 105],
    [61, 61, 125],
    [82, 79, 211],
  ],
  partyEntryHpBar: [
    [0, 192, 0],
    [96, 192, 96],
    [192, 192, 0],
    [192, 48, 48],
    [96, 0, 0],
  ],
};

export default resourceBars;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/statusBarSequences.js
//start file
const statusBarSequences = {
  inRestingArea: {
    direction: 'horizontal',
    sequence: [
      [101, 157, 101],
      [120, 34, 34],
      [26, 45, 27],
    ],
  },
  inProtectedZone: {
    direction: 'horizontal',
    sequence: [
      [172, 201, 246],
      [29, 77, 155],
      [118, 165, 242],
    ],
  },
  hungry: {
    direction: 'horizontal',
    sequence: [
      [246, 212, 143],
      [246, 212, 143],
      [239, 180, 63],
    ],
  },
  poisoned: {
    direction: 'horizontal',
    sequence: [
      [52, 118, 62],
      [54, 168, 70],
      [52, 118, 62],
    ],
  },
  hasted: {
    direction: 'horizontal',
    sequence: [
      [176, 139, 80],
      [72, 57, 33],
      [249, 249, 248],
    ],
  },
  battleSign: {
    direction: 'horizontal',
    sequence: [
      [151, 151, 156],
      [182, 182, 185],
      [124, 124, 128],
    ],
  },
  redBattleSign: {
    direction: 'horizontal',
    sequence: [
      [55, 8, 8],
      [127, 0, 0],
      [173, 0, 0],
    ],
  },
  whiteSkull: {
    direction: 'horizontal',
    sequence: [
      [242, 242, 242],
      [235, 235, 235],
      [232, 232, 232],
    ],
  },
  redSkull: {
    direction: 'horizontal',
    sequence: [
      [213, 206, 206],
      [255, 173, 173],
      [255, 171, 171],
    ],
  },
  burning: {
    direction: 'horizontal',
    sequence: [
      [174, 16, 13],
      [253, 139, 0],
      [218, 32, 4],
      [174, 16, 13],
    ],
  },
  magicShield: {
    direction: 'horizontal',
    sequence: [
      [211, 198, 27],
      [86, 97, 91],
      [154, 26, 55],
    ],
  },
  strengthened: {
    direction: 'horizontal',
    sequence: [
      [37, 170, 21],
      [32, 56, 30],
      [243, 153, 32],
    ],
  },
  cursed: {
    direction: 'horizontal',
    sequence: [
      [9, 9, 9],
      [164, 164, 164],
      [210, 210, 210],
    ],
  },
  electrified: {
    direction: 'horizontal',
    sequence: [
      [67, 21, 70],
      [241, 173, 245],
      [67, 21, 70],
    ],
  },
  paralyzed: {
    direction: 'horizontal',
    sequence: [
      [120, 24, 24],
      [213, 8, 8],
      [243, 2, 2],
    ],
  },
  drowning: {
    direction: 'horizontal',
    sequence: [
      [75, 206, 222],
      [208, 220, 224],
      [48, 142, 170],
    ],
  },
  bleeding: {
    direction: 'horizontal',
    sequence: [
      [54, 28, 32],
      [128, 42, 50],
      [54, 28, 32],
    ],
  },
  freezing: {
    direction: 'horizontal',
    sequence: [
      [128, 255, 255],
      [190, 252, 252],
      [128, 255, 255],
    ],
  },
  eRing: {
    direction: 'horizontal',
    sequence: [
      [30, 32, 119],
      [42, 46, 148],
      [26, 28, 111],
    ],
  },
  drunk: {
    direction: 'horizontal',
    sequence: [
      [95, 79, 54],
      [151, 121, 74],
      [145, 116, 70],
    ],
  },
};

export default statusBarSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/createMainWindow.js
//start file
import {
  app,
  ipcMain,
  BrowserWindow,
  Tray,
  Menu,
  dialog,
  nativeImage,
} from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';

import { loadRulesFromFile, saveRulesToFile } from './saveManager.js';
import {
  toggleNotifications,
  setGlobalShortcutsEnabled,
} from '../frontend/redux/slices/globalSlice.js';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import {
  registerGlobalShortcuts,
  unregisterGlobalShortcuts,
} from './globalShortcuts.js';

const HTML_PATH = '../dist/index.html';

let mainWindow;
let tray;
let isNotificationEnabled = false;
let isTrayVisible = true;
let widgetWindow = null;
let isMainWindowVisible = false;
let isWidgetWindowVisible = false;
let isGlobalShortcutsEnabled = true;

const filename = fileURLToPath(import.meta.url);
const dirname = path.dirname(filename);

const WIDGET_HTML_PATH = path.join(dirname, 'widget', 'widget.html');
const WIDGET_PRELOAD_PATH = path.join(dirname, 'widget', 'preload.js');

const ICON_PATHS = {
  white: path.join(dirname, './icons/white_dot.png'),
  green: path.join(dirname, './icons/green_dot.png'),
  red: path.join(dirname, './icons/red_dot.png'),
  app: path.join(dirname, './icons/automaton.png'),
};

const updateTrayIcon = () => {
  if (!tray) return;

  const state = store.getState().global;
  let iconPath;

  if (!state.windowId) {
    iconPath = ICON_PATHS.white;
  } else {
    iconPath = state.isBotEnabled ? ICON_PATHS.green : ICON_PATHS.red;
  }

  const icon = nativeImage.createFromPath(iconPath);
  tray.setImage(icon);
};

export const toggleTrayVisibility = () => {
  isTrayVisible = !isTrayVisible;
  if (isTrayVisible) {
    createTray();
  } else {
    tray.destroy();
    tray = null;
  }
  Menu.setApplicationMenu(buildAppMenu());
};

const buildTrayContextMenu = () => {
  const state = store.getState().global;
  return Menu.buildFromTemplate([
    {
      label: state.windowName || 'Bot',
    },
    { type: 'separator' },
    {
      label: 'Show/Hide Main Window',
      type: 'checkbox',
      checked: isMainWindowVisible,
      click: toggleMainWindowVisibility,
    },
    {
      label: 'Show/Hide Controls Widget',
      type: 'checkbox',
      checked: isWidgetWindowVisible,
      click: toggleWidgetWindowVisibility,
    },
    {
      label: 'Notifications',
      type: 'checkbox',
      checked: isNotificationEnabled,
      click: () => store.dispatch(toggleNotifications()),
    },
    {
      label: 'Global Shortcuts',
      type: 'checkbox',
      checked: isGlobalShortcutsEnabled,
      click: () =>
        store.dispatch(setGlobalShortcutsEnabled(!isGlobalShortcutsEnabled)),
    },
    {
      label: isTrayVisible ? 'Hide Tray' : 'Show Tray',
      click: toggleTrayVisibility,
    },
    { type: 'separator' },
    { label: 'Close', click: closeAppFromTray },
  ]);
};

const buildAppMenu = () => {
  const template = [
    {
      label: 'File',
      submenu: [
        {
          label: 'Show/Hide Main Window',
          type: 'checkbox',
          checked: isMainWindowVisible,
          click: toggleMainWindowVisibility,
        },
        {
          label: 'Show/Hide Controls Widget',
          type: 'checkbox',
          checked: isWidgetWindowVisible,
          click: toggleWidgetWindowVisibility,
        },
        { type: 'separator' },
        {
          label: 'Load Settings...',
          click: () => loadRulesFromFile(() => {}),
          accelerator: 'CmdOrCtrl+O',
        },
        {
          label: 'Save Settings As...',
          click: () => saveRulesToFile(() => {}),
          accelerator: 'CmdOrCtrl+S',
        },
        { type: 'separator' },
        { label: 'Close', click: closeAppFromTray },
      ],
    },
    {
      label: 'View',
      submenu: [
        {
          label: 'Notifications',
          type: 'checkbox',
          checked: isNotificationEnabled,
          click: () => store.dispatch(toggleNotifications()),
        },
        {
          label: 'Global Shortcuts',
          type: 'checkbox',
          checked: isGlobalShortcutsEnabled,
          click: () =>
            store.dispatch(
              setGlobalShortcutsEnabled(!isGlobalShortcutsEnabled),
            ),
        },
        {
          label: isTrayVisible ? 'Hide Tray' : 'Show Tray',
          click: toggleTrayVisibility,
        },
      ],
    },
  ];

  template.push({
    label: 'Developer',
    submenu: [
      { role: 'reload' },
      { role: 'forceReload' },
      { role: 'toggleDevTools' },
    ],
  });

  return Menu.buildFromTemplate(template);
};

const createTray = () => {
  const state = store.getState().global;
  let initialIconPath = ICON_PATHS.white;
  if (state.windowId) {
    initialIconPath = state.isBotEnabled ? ICON_PATHS.green : ICON_PATHS.red;
  }

  tray = new Tray(initialIconPath);
  tray.setToolTip('Click to show/hide the bot');
  tray.setContextMenu(buildTrayContextMenu());

  tray.on('click', toggleMainWindowVisibility);
};

const handleMainWindowClose = (event) => {
  event.preventDefault();
  app.quit();
};

const closeAppFromTray = () => {
  app.quit();
};

export const createMainWindow = (selectedWindowId, display, windowName) => {
  mainWindow = new BrowserWindow({
    minWidth: 1200,
    minHeight: 640,
    height: 640,
    width: 1200,
    resizable: false,
    icon: ICON_PATHS.app,
    autoHideMenuBar: true,
    titleBarStyle: 'hidden',
    alwaysOnTop: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(dirname, '/preload.js'),
    },
  });

  mainWindow
    .loadURL(`file://${path.join(dirname, HTML_PATH)}`)
    .catch((err) => console.error('Failed to load URL:', err));

  mainWindow.on('ready-to-show', () => {
    mainWindow.show();
    isMainWindowVisible = true;
    createTray();
    Menu.setApplicationMenu(buildAppMenu());
    setGlobalState('global/setWindowId', selectedWindowId);
    setGlobalState('global/setDisplay', display);
    setGlobalState('global/setWindowName', windowName);
    createWidgetWindow();
    toggleWidgetWindowVisibility();
    // Register global shortcuts on app start
    const { isGlobalShortcutsEnabled: globalShortcutsState } =
      store.getState().global;
    if (globalShortcutsState) {
      registerGlobalShortcuts();
    }
  });

  mainWindow.on('show', () => {
    mainWindow.setMinimizable(false);
    isMainWindowVisible = true;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  mainWindow.on('hide', () => {
    isMainWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  mainWindow.on('close', handleMainWindowClose);
  return mainWindow;
};

export const toggleMainWindowVisibility = () => {
  if (!mainWindow) return;

  if (mainWindow.isVisible()) {
    mainWindow.hide();
  } else {
    mainWindow.show();
    mainWindow.focus();
  }
  isMainWindowVisible = mainWindow.isVisible();
  Menu.setApplicationMenu(buildAppMenu());
  if (tray) tray.setContextMenu(buildTrayContextMenu());
};

export const createWidgetWindow = () => {
  if (widgetWindow && !widgetWindow.isDestroyed()) {
    if (widgetWindow.isMinimized()) widgetWindow.restore();
    widgetWindow.focus();
    return;
  }

  widgetWindow = new BrowserWindow({
    width: 210,
    height: 250,
    x: 100,
    y: 100,
    frame: false,
    show: false,
    resizable: false,
    maximizable: false,
    fullscreenable: false,
    transparent: true,
    icon: ICON_PATHS.app,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: WIDGET_PRELOAD_PATH,
      devTools: false,
    },
  });

  widgetWindow.loadURL(`file://${WIDGET_HTML_PATH}`).catch((err) => {
    console.error('Failed to load widget URL:', err);
    widgetWindow = null;
  });

  widgetWindow.on('closed', () => {
    widgetWindow = null;
    isWidgetWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  widgetWindow.on('show', () => {
    isWidgetWindowVisible = true;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  widgetWindow.on('hide', () => {
    isWidgetWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });
};

export const toggleWidgetWindowVisibility = () => {
  if (!widgetWindow) {
    createWidgetWindow();
    widgetWindow.on('ready-to-show', () => {
      widgetWindow.show();
      widgetWindow.focus();
      isWidgetWindowVisible = true;
      Menu.setApplicationMenu(buildAppMenu());
      if (tray) tray.setContextMenu(buildTrayContextMenu());
    });
  } else {
    if (widgetWindow.isVisible()) {
      widgetWindow.hide();
    } else {
      widgetWindow.show();
      widgetWindow.focus();
    }
    isWidgetWindowVisible = widgetWindow.isVisible();
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  }
};

store.subscribe(() => {
  const {
    notificationsEnabled,
    isGlobalShortcutsEnabled: globalShortcutsState,
  } = store.getState().global;
  isNotificationEnabled = notificationsEnabled;
  const prevGlobalShortcutsEnabled = isGlobalShortcutsEnabled;
  isGlobalShortcutsEnabled = globalShortcutsState;

  // Register/unregister global shortcuts based on state change
  if (isGlobalShortcutsEnabled && !prevGlobalShortcutsEnabled) {
    registerGlobalShortcuts();
  } else if (!isGlobalShortcutsEnabled && prevGlobalShortcutsEnabled) {
    unregisterGlobalShortcuts();
  }

  // Update visibility states based on actual window visibility
  isMainWindowVisible = mainWindow ? mainWindow.isVisible() : false;
  isWidgetWindowVisible = widgetWindow ? widgetWindow.isVisible() : false;

  if (tray) {
    tray.setContextMenu(buildTrayContextMenu());
    updateTrayIcon();
  }

  Menu.setApplicationMenu(buildAppMenu());
});

export const getMainWindow = () => mainWindow;
export const getWidgetWindow = () => widgetWindow;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/globalShortcuts.js
//start file
import { globalShortcut } from 'electron';
import setGlobalState from './setGlobalState.js';
import { getMainWindow } from './createMainWindow.js';

import { showNotification } from './notificationHandler.js';
import debounce from 'lodash/debounce.js';
import store from './store.js';
import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { exec } from 'child_process';
import { createLogger } from './utils/logger.js';

const log = createLogger();
const debounceTime = 25;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let windId = '';
let isBotEnabled = false;
let previousSectionStates = {};
let windowName = '';

store.subscribe(() => {
  const state = store.getState();
  const { global, rules, cavebot, lua, targeting } = state; // Destructure all relevant slices
  windId = global.windowId;
  isBotEnabled = global.isBotEnabled;
  previousSectionStates = global.previousSectionStates;
  windowName = global.windowName;

  // Log warnings if any slice is undefined, but don't prevent access
  if (!rules)
    log(
      'warn',
      '[Global Shortcuts] rules slice is undefined in store.getState()',
    );
  if (!cavebot)
    log(
      'warn',
      '[Global Shortcuts] cavebot slice is undefined in store.getState()',
    );
  if (!lua)
    log(
      'warn',
      '[Global Shortcuts] lua slice is undefined in store.getState()',
    );
  if (!targeting)
    log(
      'warn',
      '[Global Shortcuts] targeting slice is undefined in store.getState()',
    );
});

const soundCache = new Map();

export const playSound = (filePath) => {
  const asarPath = path.join(__dirname, 'sounds', filePath);
  if (soundCache.has(filePath)) {
    const cachedPath = soundCache.get(filePath);
    exec(`aplay '${cachedPath}'`);
  } else {
    const tempDir = path.join(os.tmpdir(), 'automaton-sounds');
    const tempFilePath = path.join(tempDir, filePath);
    fs.mkdirSync(tempDir, { recursive: true });
    fs.copyFileSync(asarPath, tempFilePath);
    soundCache.set(filePath, tempFilePath);
    exec(`aplay '${tempFilePath}'`);
  }
};

const getNotificationTitle = () => `Automaton - ${windowName}`;

const debouncedToggleisBotEnabled = debounce(() => {
  setGlobalState('global/toggleisBotEnabled');
  const status = isBotEnabled ? 'Disabled' : 'Enabled';
  showNotification(`Bot: ${status}`, getNotificationTitle());
  playSound(isBotEnabled ? 'disable.wav' : 'enable.wav');
}, debounceTime);

const debouncedToggleMainWindowVisibility = debounce(() => {
  const mainWindow = getMainWindow();
  if (mainWindow) {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
    }
  }
}, debounceTime);

const switchToPreset = debounce((presetIndex) => {
  setGlobalState('rules/setActivePresetIndex', presetIndex);
}, debounceTime);

const toggleSection = (sectionName, setEnabledAction) => {
  const state = store.getState();
  const currentEnabledState = state[sectionName]?.enabled ?? false;
  const newEnabledState = !currentEnabledState; // This is the state it will become

  console.log(
    `[DEBUG] Toggling ${sectionName}: current=${currentEnabledState}, new=${newEnabledState}, action=${setEnabledAction}`,
  );

  setGlobalState(setEnabledAction, newEnabledState); // Dispatch the action with the new state

  showNotification(
    `${sectionName.charAt(0).toUpperCase() + sectionName.slice(1)}: ${newEnabledState ? 'Enabled' : 'Disabled'}`, // Use newEnabledState for notification
    getNotificationTitle(),
  );
};

const debouncedToggleCavebot = debounce(
  () => toggleSection('cavebot', 'cavebot/setenabled'),
  debounceTime,
);
const debouncedToggleHealing = debounce(
  () => toggleSection('rules', 'rules/setenabled'),
  debounceTime,
);
const debouncedToggleScripts = debounce(
  () => toggleSection('lua', 'lua/setenabled'),
  debounceTime,
);
const debouncedToggleTargeting = debounce(
  () => toggleSection('targeting', 'targeting/setenabled'),
  debounceTime,
);

const debouncedToggleAllSections = debounce(() => {
  const state = store.getState();
  const allSections = {
    rules: state.rules?.enabled ?? false,
    cavebot: state.cavebot?.enabled ?? false,
    lua: state.lua?.enabled ?? false,
    targeting: state.targeting?.enabled ?? false,
  };

  const allEnabled = Object.values(allSections).every(Boolean);
  const allDisabled = Object.values(allSections).every((val) => !val);

  if (allEnabled) {
    // If all are enabled, disable all and store current states
    setGlobalState('global/setPreviousSectionStates', allSections);
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification('All sections disabled', getNotificationTitle());
  } else if (allDisabled) {
    // If all are disabled, restore previous states
    const restoredStates = previousSectionStates;
    setGlobalState('rules/setenabled', restoredStates.rules);
    setGlobalState('cavebot/setenabled', restoredStates.cavebot);
    setGlobalState('lua/setenabled', restoredStates.lua);
    setGlobalState('targeting/setenabled', restoredStates.targeting);
    showNotification(
      'Restored previous section states',
      getNotificationTitle(),
    );
  } else {
    // If mixed, disable all and store current states
    setGlobalState('global/setPreviousSectionStates', allSections);
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification(
      'Mixed states detected, all sections disabled',
      getNotificationTitle(),
    );
  }
}, debounceTime);

const debouncedToggleEverything = debounce(() => {
  const state = store.getState();
  const allSections = {
    rules: state.rules?.enabled ?? false,
    cavebot: state.cavebot?.enabled ?? false,
    lua: state.lua?.enabled ?? false,
    targeting: state.targeting?.enabled ?? false,
  };

  const allEnabled = Object.values(allSections).every(Boolean);
  const allDisabled = Object.values(allSections).every((val) => !val);

  if (!allEnabled) {
    // If not all enabled (mixed or all disabled), enable all
    setGlobalState('rules/setenabled', true);
    setGlobalState('cavebot/setenabled', true);
    setGlobalState('lua/setenabled', true);
    setGlobalState('targeting/setenabled', true);
    showNotification('All sections enabled', getNotificationTitle());
  } else {
    // If all are enabled, disable all
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification('All sections disabled', getNotificationTitle());
  }
}, debounceTime);

export const registerGlobalShortcuts = () => {
  try {
    if (globalShortcut.isRegistered('Alt+E')) {
      log('info', '[Global Shortcuts] already registered, skipping.');
      return;
    }
    log('info', '[Global Shortcuts] registering');
    globalShortcut.register('Alt+E', debouncedToggleisBotEnabled);
    globalShortcut.register('Alt+V', debouncedToggleMainWindowVisibility);

    globalShortcut.register('Alt+Escape', debouncedToggleAllSections);
    globalShortcut.register('Alt+C', debouncedToggleCavebot);
    globalShortcut.register('Alt+H', debouncedToggleHealing);
    globalShortcut.register('Alt+S', debouncedToggleScripts);
    globalShortcut.register('Alt+T', debouncedToggleTargeting);
    globalShortcut.register('Alt+B', debouncedToggleEverything);

    for (let i = 0; i < 5; i++) {
      const presetKey = `Alt+${i + 1}`;
      const debouncedSwitchToPreset = debounce(
        () => switchToPreset(i),
        debounceTime,
      );
      globalShortcut.register(presetKey, debouncedSwitchToPreset);
    }
    log('info', '[Global Shortcuts] registered');
  } catch (error) {
    log('error', `[Global Shortcuts] registration error: ${error}`);
  }
};

export const unregisterGlobalShortcuts = () => {
  try {
    log('info', '[Global Shortcuts] unregistering all');
    globalShortcut.unregisterAll();
  } catch (error) {
    log('error', `[Global Shortcuts] unregistration error: ${error}`);
  }
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/hardwareId.js
//start file
import { execSync } from 'child_process';
import { existsSync } from 'fs';

export function getLinuxHardwareId() {
  try {
    // Try machine-id first (most modern systems)
    if (existsSync('/etc/machine-id')) {
      const machineId = execSync('cat /etc/machine-id', {
        encoding: 'utf-8',
      }).trim();
      if (machineId.length >= 32) return machineId;
    }

    // Fallback to product_uuid (AWS/Azure/GCP and some VMs)
    if (existsSync('/sys/class/dmi/id/product_uuid')) {
      return execSync('cat /sys/class/dmi/id/product_uuid', {
        encoding: 'utf-8',
      }).trim();
    }

    // Final fallback using system information
    const fallbackId = execSync('uname -a | sha256sum | head -c 64', {
      encoding: 'utf-8',
    }).trim();
    return fallbackId || 'unknown-device';
  } catch (error) {
    console.error('Hardware ID detection failed:', error);
    return 'error-no-id';
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/ipcListeners.js
//start file
// /home/orimorfus/Documents/Automaton/electron/ipcListeners.js
import { ipcMain, BrowserWindow } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import store from './store.js';
import {
  saveRulesToFile,
  loadRulesFromFile,
  autoLoadRules,
} from './saveManager.js';
import { playSound, registerGlobalShortcuts } from './globalShortcuts.js';
import { getMainWindow } from './createMainWindow.js';
import luaSlice from '../frontend/redux/slices/luaSlice.js'; // Import the luaSlice
import setGlobalState from './setGlobalState.js';
const { updateScript, removeScript } = luaSlice.actions; // Destructure actions from the slice

const filename = fileURLToPath(import.meta.url);
const cwd = dirname(filename);
const preloadPath = path.join(cwd, '/preload.js');

// --- THIS IS THE CORRECTED LISTENER ---
ipcMain.on('state-change', (_, serializedAction) => {
  try {
    const action = JSON.parse(serializedAction);
    if (action.origin === 'renderer') {
      setGlobalState(action.type, action.payload);
    }
  } catch (error) {
    console.error('Error handling state-change from renderer:', error);
  }
});
// --- END CORRECTION ---

ipcMain.on('save-rules', async () => {
  const mainWindow = getMainWindow();
  mainWindow.minimize();
  await saveRulesToFile(() => {
    mainWindow.restore();
  });
});

ipcMain.handle('load-rules', async () => {
  const mainWindow = getMainWindow();
  mainWindow.minimize();
  await loadRulesFromFile(() => {
    mainWindow.restore();
  });
});

ipcMain.on('renderer-ready', () => {
  autoLoadRules();
  registerGlobalShortcuts();
});

// IPC handler to provide current control states to the widget
ipcMain.handle('get-control-states', () => {
  const state = store.getState();
  return {
    isRulesEnabled: state.rules.enabled,
    isCavebotEnabled: state.cavebot.enabled,
    isTargetingEnabled: state.targeting.enabled,
    isLuaEnabled: state.lua.enabled,
  };
});

// IPC handler for widget to toggle main window visibility
ipcMain.handle('toggle-main-window', () => {
  const mainWindow = getMainWindow();
  if (mainWindow) {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
      mainWindow.focus();
    }
    return mainWindow.isVisible();
  }
  return false;
});

// IPC handler to check if main window is visible
ipcMain.handle('is-main-window-visible', () => {
  const mainWindow = getMainWindow();
  return mainWindow ? mainWindow.isVisible() : false;
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/keyboardControll/keyPress.js
//start file
import keypress from 'keypress-native';

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

/**
 * Sends a single key press with an optional modifier.
 * @param {string} display - The display to send the key to (e.g., ':0').
 * @param {string} key - The key to press (e.g., 'a', 'f1', 'enter').
 * @param {object} [options] - Optional parameters.
 * @param {string|null} [options.modifier=null] - The modifier key (e.g., 'shift', 'ctrl').
 */
export const keyPress = async (display, key, { modifier = null } = {}) => {
  await keypress.sendKey(key, display, modifier);
};

/**
 * Sends a key press multiple times with a delay.
 * @param {string} display - The display to send the key to.
 * @param {string} key - The key to press.
 * @param {object} [options] - Optional parameters.
 * @param {number} [options.count=1] - The number of times to press the key.
 * @param {string|null} [options.modifier=null] - The modifier key.
 * @param {number} [options.delayMs=50] - The delay between key presses.
 */
export const keyPressMultiple = async (
  display,
  key,
  { count = 1, modifier = null, delayMs = 50 } = {},
) => {
  for (let i = 0; i < count; i++) {
    await keyPress(display, key, { modifier });
    if (i < count - 1) {
      await delay(delayMs);
    }
  }
};

/**
 * Types an array of strings with human-like behavior. This is the primary function for typing text.
 * It is aliased as 'type' in luaApi.js.
 * @param {string} display - The display to send the keys to.
 * @param {string[]} texts - An array of strings to type.
 * @param {boolean} [startAndEndWithEnter=true] - Whether to press Enter before and after each string.
 */
export const typeArray = async (
  display,
  texts,
  startAndEndWithEnter = true,
) => {
  // The native addon's typeArray function can handle both single and multiple strings efficiently.
  await keypress.typeArray(texts, display, startAndEndWithEnter);
};

/**
 * Simulates a complex rotation key sequence.
 * @param {string} display - The display to send the keys to.
 * @param {string} [direction] - An optional final direction ('n', 's', 'e', 'w').
 */
export const rotate = async (display, direction) => {
  await keypress.rotate(display, direction);
};

/**
 * A stub function to indicate typing status.
 * @returns {boolean} Always returns false.
 */
export const getIsTyping = () => false;

/**
 * Holds a key down.
 * @param {string} display - The display to send the key to.
 * @param {string} key - The key to hold down.
 * @param {object} [options] - Optional parameters.
 * @param {string|null} [options.modifier=null] - The modifier key.
 */
export const keyDown = (display, key, { modifier = null } = {}) => {
  keypress.keyDown(key, display, modifier);
};

/**
 * Releases a key.
 * @param {string} display - The display to send the key to.
 * @param {string} key - The key to release.
 * @param {object} [options] - Optional parameters.
 * @param {string|null} [options.modifier=null] - The modifier key.
 */
export const keyUp = (display, key, { modifier = null } = {}) => {
  keypress.keyUp(key, display, modifier);
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/loginWindow/loginWindow.js
//start file
document.getElementById('login-form').addEventListener('submit', (e) => {
  e.preventDefault();
  attemptLogin();
});

let currentHardwareId = null;
let resetTimer = null;
let autoLoginTimeout = null;

function toggleCheckbox(checkboxId) {
  const checkbox = document.getElementById(checkboxId);
  if (checkbox) {
    checkbox.checked = !checkbox.checked;
  }
}

function setLoadingState(isLoading) {
  const loginButton = document.querySelector('button[type="submit"]');
  loginButton.disabled = isLoading;
  loginButton.style.opacity = isLoading ? '0.7' : '1';
  if (isLoading) {
    loginButton.textContent = 'Authenticating...';
  }
}

function showButtonMessage(message, color) {
  const loginButton = document.querySelector('button[type="submit"]');
  clearTimeout(resetTimer);
  loginButton.textContent = message;
  loginButton.style.color = color;
  resetTimer = setTimeout(() => {
    loginButton.textContent = 'Login';
    loginButton.style.color = '';
  }, 10000);
}

async function checkHardwareId() {
  const hardwareIdElement = document.getElementById('hardware-id');
  try {
    hardwareIdElement.classList.remove('valid', 'invalid');
    currentHardwareId =
      await window.electron.ipcRenderer.invoke('get-hardware-id');

    if (!currentHardwareId || currentHardwareId.includes('error')) {
      throw new Error('Invalid hardware ID');
    }

    const storedHardwareId = localStorage.getItem('validHardwareId');
    const shortId =
      currentHardwareId.length > 53
        ? `${currentHardwareId.slice(-10)}`
        : currentHardwareId;
    hardwareIdElement.textContent = shortId;
    hardwareIdElement.title = `Device Fingerprint: ${currentHardwareId}`;

    if (storedHardwareId) {
      const isMatch = currentHardwareId === storedHardwareId;
      hardwareIdElement.classList.toggle('valid', isMatch);
      hardwareIdElement.classList.toggle('invalid', !isMatch);
      if (!isMatch)
        showButtonMessage('New device detected', 'var(--error-message)');
    }
  } catch (error) {
    console.error('Hardware check failed:', error);
    hardwareIdElement.textContent = 'ID UNAVAILABLE';
    hardwareIdElement.classList.add('invalid');
    showButtonMessage('Device verification failed', 'var(--error-message)');
  }
}

async function attemptLogin() {
  if (autoLoginTimeout) {
    clearTimeout(autoLoginTimeout);
    autoLoginTimeout = null;
  }

  const loginButton = document.querySelector('button[type="submit"]');
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  const rememberMeCheckbox = document.getElementById('remember-me');
  const autoLoginCheckbox = document.getElementById('auto-login');

  const username = usernameInput.value;
  const password = passwordInput.value;
  const rememberMe = rememberMeCheckbox.checked;
  const autoLogin = autoLoginCheckbox.checked;

  setLoadingState(true);

  try {
    const response = await fetch(
      'https://automaton-login-server-h3kn.onrender.com/login',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Device-ID': currentHardwareId,
        },
        body: JSON.stringify({
          email: username,
          password: password,
          hardwareId: currentHardwareId,
        }),
      },
    );

    const data = await response.json();

    if (response.ok) {
      localStorage.setItem('validHardwareId', currentHardwareId);
      if (rememberMe) {
        localStorage.setItem(
          'credentials',
          JSON.stringify({ username, password }),
        );
        if (autoLogin) {
          localStorage.setItem('autoLoginEnabled', 'true');
        } else {
          localStorage.removeItem('autoLoginEnabled');
        }
      } else {
        localStorage.removeItem('credentials');
        localStorage.removeItem('autoLoginEnabled');
      }
      showButtonMessage(data.message || 'Login successful!', '#00ff00');
      await new Promise((resolve) => setTimeout(resolve, 1500));
      window.electron.ipcRenderer.send('login-success');
    } else {
      showButtonMessage(
        data.message || `Error: ${response.status}`,
        'var(--error-message)',
      );
    }
  } catch (error) {
    showButtonMessage(
      'Connection error. Please try again.',
      'var(--error-message)',
    );
  } finally {
    setLoadingState(false);
  }
}

function cancelAutoLogin() {
  if (autoLoginTimeout) {
    clearTimeout(autoLoginTimeout);
    autoLoginTimeout = null;
    console.log('Auto-login cancelled due to user interaction.');
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  const rememberMeCheckbox = document.getElementById('remember-me');
  const autoLoginCheckbox = document.getElementById('auto-login');
  const loginButton = document.querySelector('button[type="submit"]');

  const credentials = JSON.parse(localStorage.getItem('credentials'));
  const autoLoginEnabled = localStorage.getItem('autoLoginEnabled') === 'true';

  if (credentials) {
    usernameInput.value = credentials.username;
    passwordInput.value = credentials.password;
    rememberMeCheckbox.checked = true;
    autoLoginCheckbox.checked = autoLoginEnabled;
  }

  checkHardwareId();

  if (credentials && autoLoginEnabled) {
    console.log('Auto-login enabled. Starting 1s timer...');
    autoLoginTimeout = setTimeout(() => {
      console.log('Auto-login timer expired. Attempting login...');
      autoLoginTimeout = null;
      attemptLogin();
    }, 1000);
  }

  usernameInput.addEventListener('input', cancelAutoLogin);
  passwordInput.addEventListener('input', cancelAutoLogin);
  loginButton.addEventListener('click', cancelAutoLogin);
  rememberMeCheckbox.addEventListener('change', cancelAutoLogin);
  autoLoginCheckbox.addEventListener('change', cancelAutoLogin);

  usernameInput.focus();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/main.js
//start file
import {
  app,
  ipcMain,
  BrowserWindow,
  dialog,
  Tray,
  Menu,
  nativeImage,
} from 'electron';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import path from 'path';
import { appendFile } from 'fs/promises';
import {
  createMainWindow,
  toggleWidgetWindowVisibility,
} from './createMainWindow.js';
import './ipcListeners.js';
import {
  unregisterGlobalShortcuts,
  registerGlobalShortcuts,
} from './globalShortcuts.js';
import { getLinuxHardwareId } from './hardwareId.js';
import { autoLoadRules } from './saveManager.js';
import { createLogger } from './utils/logger.js';
import workerManager from './workerManager.js';
import windowinfo from 'windowinfo-native';
import setGlobalState from './setGlobalState.js';

const MAIN_LOG_INTERVAL_MS = 10000;
const MAIN_LOG_FILE_NAME = 'main-process-memory-usage.log';
const MAIN_LOG_FILE_PATH = path.join(process.cwd(), MAIN_LOG_FILE_NAME);

const toMB = (bytes) => (bytes / 1024 / 1024).toFixed(2);

async function logMainProcessMemoryUsage() {
  try {
    const memoryUsage = process.memoryUsage();
    const timestamp = new Date().toISOString();
    const logEntry =
      `${timestamp} | ` +
      `RSS: ${toMB(memoryUsage.rss)} MB, ` +
      `HeapTotal: ${toMB(memoryUsage.heapTotal)} MB, ` +
      `HeapUsed: ${toMB(memoryUsage.heapUsed)} MB, ` +
      `External: ${toMB(memoryUsage.external)} MB\n`;

    await appendFile(MAIN_LOG_FILE_PATH, logEntry);
  } catch (error) {
    console.error(
      '[Main MemoryLogger] Failed to write to memory log file:',
      error,
    );
  }
}

const filename = fileURLToPath(import.meta.url);
const cwd = dirname(filename);
const preloadPath = path.join(cwd, '/preload.js');
const log = createLogger();

let selectWindow;
let mainWindow;
let isQuitting = false;

const createSelectWindow = () => {
  selectWindow = new BrowserWindow({
    width: 600,
    height: 400,
    autoHideMenuBar: true,
    titleBarStyle: 'hidden',
    resizable: false,
    maximizable: false,
    fullscreenable: false,
    devTools: false,
    frame: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(cwd, 'selectWindow', 'preload.js'),
    },
  });

  const selectHtmlPath = path.join(cwd, 'selectWindow', 'selectWindow.html');
  selectWindow.loadFile(selectHtmlPath);

  selectWindow.on('closed', () => {
    selectWindow = null;
    if (!isQuitting && !mainWindow) {
      app.quit();
    }
  });
};

app.whenReady().then(async () => {
  try {
    await autoLoadRules();
    createSelectWindow();

    workerManager.initialize(app, cwd, {});
    registerGlobalShortcuts(); // Register global shortcuts on startup
    setGlobalState('global/setGlobalShortcutsEnabled', true); // Set default to enabled

    (async () => {
      try {
        const header = `\n--- Main Process Session Started at ${new Date().toISOString()} ---\n`;
        await appendFile(MAIN_LOG_FILE_PATH, header);
        console.log(
          `[Main MemoryLogger] Memory usage logging is active. Outputting to ${MAIN_LOG_FILE_PATH}`,
        );

        await logMainProcessMemoryUsage();
        setInterval(logMainProcessMemoryUsage, MAIN_LOG_INTERVAL_MS);
      } catch (error) {
        console.error(
          '[Main MemoryLogger] Could not initialize memory log file:',
          error,
        );
      }
    })();
  } catch (error) {
    console.error('[Main] FATAL: Error during application startup:', error);
    dialog.showErrorBox(
      'Application Startup Error',
      `Failed to initialize critical components: ${error.message}\n\nPlease check logs for details. The application will now exit.`,
    );
    app.quit();
  }
});

app.on('before-quit', async (event) => {
  event.preventDefault();
  console.log('[Main] App is quitting. Terminating all workers...');
  await workerManager.stopAllWorkers();
  console.log('[Main] All workers terminated. Exiting now.');
  app.exit();
});
app.on('window-all-closed', () => {
  log('info', '[Main] All windows closed, initiating app quit.');
  app.quit();
});

ipcMain.handle('get-hardware-id', () => {
  try {
    return getLinuxHardwareId();
  } catch (error) {
    console.error('Hardware ID error:', error);
    return 'error-failed-retrieval';
  }
});

ipcMain.handle('get-tibia-window-list', async () => {
  try {
    const windowList = await windowinfo.getWindowList();
    return windowList;
  } catch (error) {
    console.error('[Main] Error getting Tibia window list:', error);
    return [];
  }
});

ipcMain.on('select-tibia-window', (event, windowId, display, windowName) => {
  if (selectWindow && !selectWindow.isDestroyed()) {
    selectWindow.close();
  }
  setGlobalState('global/setWindowId', windowId);
  setGlobalState('global/setDisplay', display);
  setGlobalState('global/setWindowName', windowName);

  mainWindow = createMainWindow(windowId, display, windowName);
});

ipcMain.on('exit-app', () => {
  isQuitting = true;
  app.quit();
});

ipcMain.on('update-bot-status', (event, { feature, isEnabled }) => {
  console.log(`[Main] Received update from widget: ${feature} - ${isEnabled}`);
  switch (feature) {
    case 'healing':
      setGlobalState('rules/setenabled', isEnabled);
      break;
    case 'cavebot':
      setGlobalState('cavebot/setenabled', isEnabled);
      break;
    case 'targeting':
      setGlobalState('targeting/setenabled', isEnabled);
      break;
    case 'scripts':
      setGlobalState('lua/setenabled', isEnabled);
      break;
    default:
      console.warn(`[Main] Unknown feature received from widget: ${feature}`);
  }
});

export default app;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/mouseControll/useItemOnCoordinates.js
//start file
import mouseController from 'mouse-controller';
import { keyPress } from '../keyboardControll/keyPress.js';

function useItemOnCoordinates(targetWindowId, display, targetX, targetY, key) {
  // Add display parameter
  // First press the key
  keyPress(display, key); // Pass display to keyPress

  // Then perform left click on coordinates
  mouseController.leftClick(
    parseInt(targetWindowId),
    parseInt(targetX),
    parseInt(targetY),
    display, // Pass display to mouseController
  );
}

export default useItemOnCoordinates;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/notificationHandler.js
//start file
import { Notification, nativeImage } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import store from './store.js';

let notiEnabled = false;

const __filenamePath = fileURLToPath(import.meta.url);
const __dirnamePath = path.dirname(__filenamePath);

const iconPath = path.join(__dirnamePath, 'icons', 'greenSkull.png');

let windowName = '';

store.subscribe(() => {
  const state = store.getState();
  notiEnabled = state.global.notificationsEnabled;
  windowName = state.global.windowName;
});

const createIconImage = () => {
  try {
    return nativeImage.createFromPath(iconPath);
  } catch (error) {
    console.error('Error creating icon image:', error);
    return null;
  }
};

export const showNotification = (body, customTitle) => {
  if (!notiEnabled) return;

  const title = customTitle || `Automaton - ${windowName}`;

  try {
    new Notification({
      title: title,
      body: body,
      icon: createIconImage(),
    }).show();
  } catch (error) {
    console.error('Error showing notification:', error);
  }
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/preload.js
//start file
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  ipcRenderer: {
    invoke: (channel, ...args) => ipcRenderer.invoke(channel, ...args),
    send: (channel, data) => ipcRenderer.send(channel, data),
    on: (channel, func) => ipcRenderer.on(channel, func),
  },
  saveRules: () => ipcRenderer.send('save-rules'),
  loadRules: () => ipcRenderer.invoke('load-rules'),
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/saveManager.js
//start file
import { app, dialog } from 'electron';
import fs from 'fs/promises';
import path from 'path';
import { showNotification } from './notificationHandler.js';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import throttle from 'lodash/throttle.js';
// Helper to normalize Lua scripts with a 'type' property if missing
const normalizeLuaScripts = (luaState) => {
  if (!luaState) return luaState;

  const normalizedState = { ...luaState };

  if (
    normalizedState.persistentScripts &&
    Array.isArray(normalizedState.persistentScripts)
  ) {
    normalizedState.persistentScripts = normalizedState.persistentScripts.map(
      (script) => ({
        ...script,
        type: script.type || 'persistent', // Ensure type is 'persistent'
      }),
    );
  }

  if (
    normalizedState.hotkeyScripts &&
    Array.isArray(normalizedState.hotkeyScripts)
  ) {
    normalizedState.hotkeyScripts = normalizedState.hotkeyScripts.map(
      (script) => ({
        ...script,
        type: script.type || 'hotkey', // Ensure type is 'hotkey'
      }),
    );
  }

  return normalizedState;
};

const user_data_path = app.getPath('userData');
const auto_load_file_path = path.join(user_data_path, 'autoLoadRules.json');

// Save state excluding window-specific data
export const saveRulesToFile = async (callback) => {
  try {
    const dialog_result = await dialog.showSaveDialog({
      title: 'Save State',
      filters: [{ name: 'JSON Files', extensions: ['json'] }],
    });

    if (!dialog_result.canceled && dialog_result.filePath) {
      const save_file_path = dialog_result.filePath.endsWith('.json')
        ? dialog_result.filePath
        : `${dialog_result.filePath}.json`;
      const state = store.getState();

      await fs.writeFile(save_file_path, JSON.stringify(state, null, 2));
      showNotification(`📥 Saved | ${path.basename(save_file_path)}`);
    }
    callback();
  } catch (err) {
    console.error('Failed to save state:', err);
    showNotification('❌ Failed to save state');
    callback();
  }
};

export const loadRulesFromFile = async (callback) => {
  try {
    const dialog_result = await dialog.showOpenDialog({
      title: 'Load State',
      filters: [{ name: 'JSON Files', extensions: ['json'] }],
      properties: ['openFile'],
    });

    if (!dialog_result.canceled && dialog_result.filePaths.length > 0) {
      const file_path = dialog_result.filePaths[0];
      const content = await fs.readFile(file_path, 'utf8');
      const loaded_state = JSON.parse(content);

      // Check for each slice before setting state to avoid errors with old/malformed files
      if (loaded_state.rules)
        setGlobalState('rules/setState', loaded_state.rules);
      if (loaded_state.global) {
        // Exclude windowId but keep windowName from global state
        const { windowId, ...globalWithoutWindowId } = loaded_state.global;
        setGlobalState('global/setState', globalWithoutWindowId);
      }
      if (loaded_state.lua)
        setGlobalState('lua/setState', normalizeLuaScripts(loaded_state.lua));
      if (loaded_state.cavebot) {
        const cavebotState = { ...loaded_state.cavebot, enabled: false };
        setGlobalState('cavebot/setState', cavebotState);
      }
      if (loaded_state.targeting) {
        const targetingState = { ...loaded_state.targeting, enabled: false };
        setGlobalState('targeting/setState', targetingState);
      }

      showNotification(`📤 Loaded | ${path.basename(file_path)}`);
    }
    callback();
  } catch (err) {
    console.error('Failed to load state:', err);
    showNotification('❌ Failed to load state');
    callback();
  }
};

// Auto-save state excluding window-specific data
const perform_auto_save = async () => {
  try {
    const state = store.getState();
    if (Object.keys(state).length > 0) {
      // Create a filtered state that excludes windowId but keeps windowName
      const filteredState = {
        ...state,
        global: {
          ...state.global,
          windowId: undefined,
        },
      };
      await fs.writeFile(
        auto_load_file_path,
        JSON.stringify(filteredState, null, 2),
      );
    }
  } catch (error) {
    console.error('Failed to auto-save rules:', error);
  }
};

const auto_save_rules = throttle(perform_auto_save, 1000, {
  leading: false,
  trailing: true,
});

export const autoLoadRules = async () => {
  try {
    await fs.access(auto_load_file_path);
    const content = await fs.readFile(auto_load_file_path, 'utf8');
    const loaded_state = JSON.parse(content);

    if (Object.keys(loaded_state).length > 0) {
      if (loaded_state.rules)
        setGlobalState('rules/setState', loaded_state.rules);
      if (loaded_state.global) {
        // Exclude windowId but keep windowName from global state
        const { windowId, ...globalWithoutWindowId } = loaded_state.global;
        setGlobalState('global/setState', globalWithoutWindowId);
      }
      if (loaded_state.lua)
        setGlobalState('lua/setState', normalizeLuaScripts(loaded_state.lua));
      if (loaded_state.cavebot) {
        const cavebotState = { ...loaded_state.cavebot, enabled: false };
        setGlobalState('cavebot/setState', cavebotState);
      }
      if (loaded_state.targeting) {
        const targetingState = { ...loaded_state.targeting, enabled: false };
        setGlobalState('targeting/setState', targetingState);
      }
    }
  } catch (error) {
    if (error.code === 'ENOENT') {
      // console.log('No auto-save file found. Starting with default state.');
    } else {
      console.error('Failed to auto-load rules:', error);
    }
  }
};

let previous_rules_state = null;
let previous_global_state = null;
let previous_lua_state = null;
let previous_cavebot_state = null;
let previous_targeting_state = null;

const has_state_changed = (new_state, prev_state) => {
  if (prev_state === null) return true;
  // Use JSON.stringify for a deep comparison, which is more reliable for nested objects.
  // This is safer for detecting changes in complex state slices.
  try {
    return JSON.stringify(new_state) !== JSON.stringify(prev_state);
  } catch (error) {
    console.error('Error comparing state for auto-save:', error);
    // If serialization fails, assume a change to be safe.
    return true;
  }
};

store.subscribe(() => {
  const { rules, global, lua, cavebot, targeting } = store.getState();

  const rules_changed = has_state_changed(rules, previous_rules_state);
  const global_changed = has_state_changed(global, previous_global_state);
  const lua_changed = has_state_changed(lua, previous_lua_state);
  const cavebot_changed = has_state_changed(cavebot, previous_cavebot_state);
  const targeting_changed = has_state_changed(
    targeting,
    previous_targeting_state,
  );

  if (
    rules_changed ||
    global_changed ||
    lua_changed ||
    cavebot_changed ||
    targeting_changed
  ) {
    auto_save_rules();

    // Update previous state only if it changed.
    // With immutable state, we can just store a reference to the new state object.
    if (rules_changed) previous_rules_state = rules;
    if (global_changed) previous_global_state = global;
    if (lua_changed) previous_lua_state = lua;
    if (cavebot_changed) previous_cavebot_state = cavebot;
    if (targeting_changed) previous_targeting_state = targeting;
  }
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePartyEntryRegions.js
//start file
export const calculatePartyEntryRegions = (partyListStart, entryCount) => {
  const regions = [];
  for (let i = 0; i < entryCount; i++) {
    regions.push({
      bar: {
        x: partyListStart.x + 1,
        y: partyListStart.y + 6 + i * 26,
        width: 130,
        height: 1,
      },
      name: {
        x: partyListStart.x + 1,
        y: partyListStart.y + i * 26,
        width: 15,
        height: 6,
      },
      uhCoordinates: {
        x: partyListStart.x,
        y: partyListStart.y + i * 26,
      },
    });
  }
  return regions;
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePartyHpPercentage.js
//start file
// screenMonitor/calcs/calculatePartyHpPercentage.js

/**
 * Calculates the percentage of matching pixels in a party member's HP bar.
 * This is now a convenience wrapper around the main calculatePercentages function.
 *
 * @param {Buffer} fullFrameBuffer - The full-frame image buffer, including its 8-byte header.
 * @param {object} fullFrameMeta - Metadata object { width, height } for the full frame.
 * @param {object} barAbsoluteCoords - The bar's absolute start {x, y} within the window.
 * @param {Array<Array<number>>} validColors - Array of valid [R, G, B] color arrays for the bar.
 * @param {number} barPixelWidth - The width of the bar in pixels to analyze.
 * @returns {number} The calculated HP percentage (0-100) or -1 on error.
 */
import calculatePercentages from './calculatePercentages.js'; // Assuming it's in the same folder

function calculatePartyHpPercentage(
  fullFrameBuffer,
  fullFrameMeta,
  barAbsoluteCoords,
  validColors,
  barPixelWidth,
) {
  // This function now just calls the main, more generic percentage calculator.
  // This reduces code duplication.
  return calculatePercentages(
    fullFrameBuffer,
    fullFrameMeta,
    barAbsoluteCoords,
    validColors,
    barPixelWidth,
  );
}

export default calculatePartyHpPercentage;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePercentages.js
//start file
// screenMonitor/calcs/calculatePercentages.js

/**
 * Calculates the percentage of matching pixels horizontally for a bar (like HP/Mana)
 * at a specific ABSOLUTE position within the full-frame image buffer.
 *
 * @param {Buffer} fullFrameBuffer - The full-frame image buffer, including its 8-byte header.
 * @param {object} fullFrameMeta - Metadata object { width, height } for the full frame.
 * @param {object} barAbsoluteCoords - The bar's absolute start {x, y} within the window.
 * @param {Array<Array<number>>} validColors - Array of valid [R, G, B] color arrays for the bar.
 * @param {number} barPixelWidth - The width of the bar in pixels to analyze.
 * @returns {number} The calculated percentage (0-100) or -1 on error.
 */
function calculatePercentages(
  fullFrameBuffer,
  fullFrameMeta,
  barAbsoluteCoords,
  validColors,
  barPixelWidth,
) {
  try {
    // 1. Validate Inputs
    if (
      !fullFrameBuffer ||
      fullFrameBuffer.length < 8 ||
      !fullFrameMeta ||
      !barAbsoluteCoords ||
      !validColors ||
      barPixelWidth <= 0
    ) {
      return -1;
    }

    const { width: imageWidth, height: imageHeight } = fullFrameMeta;

    if (imageWidth <= 0 || imageHeight <= 0) {
      return -1;
    }

    // 2. Constants for BGRA format
    const bytesPerPixel = 4; // BGRA format
    const headerSize = 8;
    const imageStride = imageWidth * bytesPerPixel;

    // 3. Calculate Start Byte Index in the full buffer
    const { x: absoluteBarStartX, y: absoluteBarStartY } = barAbsoluteCoords;

    // Ensure coordinates are within the buffer dimensions
    if (
      absoluteBarStartX < 0 ||
      absoluteBarStartX >= imageWidth ||
      absoluteBarStartY < 0 ||
      absoluteBarStartY >= imageHeight
    ) {
      return -1;
    }

    const startIndexBytes =
      headerSize +
      absoluteBarStartY * imageStride +
      absoluteBarStartX * bytesPerPixel;

    // 4. Bounds Check
    const endIndexBytes = startIndexBytes + barPixelWidth * bytesPerPixel;
    if (
      absoluteBarStartX + barPixelWidth > imageWidth ||
      startIndexBytes < headerSize ||
      endIndexBytes > fullFrameBuffer.length
    ) {
      return -1;
    }

    // 5. Prepare color set for quick lookup
    const colorSet = new Set(validColors.map((color) => color.join(',')));

    // 6. Count matching pixels
    let matchingPixelsCount = 0;
    for (let i = 0; i < barPixelWidth; i++) {
      const currentPixelIndex = startIndexBytes + i * bytesPerPixel;

      // Read BGRA, but we only care about RGB for comparison
      // B = index + 0, G = index + 1, R = index + 2
      const r = fullFrameBuffer[currentPixelIndex + 2];
      const g = fullFrameBuffer[currentPixelIndex + 1];
      const b = fullFrameBuffer[currentPixelIndex];

      if (colorSet.has(`${r},${g},${b}`)) {
        matchingPixelsCount++;
      }
    }

    if (barPixelWidth === 0) return 0;
    return Math.round((matchingPixelsCount / barPixelWidth) * 100);
  } catch (error) {
    console.error('Error in calculatePercentages:', error);
    return -1;
  }
}

export default calculatePercentages;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/selectWindow/preload.js
//start file
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  getTibiaWindowList: () => ipcRenderer.invoke('get-tibia-window-list'),
  selectTibiaWindow: (windowId, display, windowName) =>
    ipcRenderer.send('select-tibia-window', windowId, display, windowName),
  exitApp: () => ipcRenderer.send('exit-app'),
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/selectWindow/selectWindow.js
//start file
document.addEventListener('DOMContentLoaded', async () => {
  const windowList = document.getElementById('window-list');
  const selectButton = document.getElementById('select-button');
  const refreshButton = document.getElementById('refresh-button');
  const exitButton = document.getElementById('exit-button');
  const messageElement = document.getElementById('message');

  let availableWindows = [];

  const fetchWindows = async () => {
    messageElement.textContent = 'Searching for Tibia windows...';
    selectButton.disabled = true;
    windowList.innerHTML = ''; // Clear previous list

    try {
      availableWindows = await window.electronAPI.getTibiaWindowList();
      if (availableWindows.length > 0) {
        availableWindows.forEach((win) => {
          const option = document.createElement('option');
          option.value = win.windowId;
          option.textContent = `${win.name} (ID: ${win.windowId}, Display: ${win.display})`; // Assuming display info is added
          windowList.appendChild(option);
        });
        windowList.selectedIndex = 0; // Select the first one by default
        selectButton.disabled = false;
        messageElement.textContent = `${availableWindows.length} Tibia window(s) found.`;
      } else {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No Tibia windows found.';
        windowList.appendChild(option);
        messageElement.textContent =
          'No Tibia windows found. Please ensure Tibia is running.';
      }
    } catch (error) {
      console.error('Failed to fetch window list:', error);
      messageElement.textContent = `Error: ${error.message}. Could not retrieve window list.`;
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'Error loading windows.';
      windowList.appendChild(option);
    }
  };

  selectButton.addEventListener('click', () => {
    const selectedIndex = windowList.selectedIndex;
    if (selectedIndex !== -1) {
      const selectedWindow = availableWindows[selectedIndex];
      if (selectedWindow) {
        window.electronAPI.selectTibiaWindow(
          selectedWindow.windowId,
          selectedWindow.display,
          selectedWindow.name,
        ); // Pass ID, display, and window title
      }
    }
  });

  refreshButton.addEventListener('click', fetchWindows);
  exitButton.addEventListener('click', () => {
    window.electronAPI.exitApp();
  });

  // Initial fetch
  fetchWindows();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/setGlobalState.js
//start file
import store from './store.js';
import { getMainWindow, getWidgetWindow } from './createMainWindow.js';

let actionQueue = [];
let isScheduled = false;

function sendBatch() {
  if (actionQueue.length === 0) {
    isScheduled = false;
    return;
  }

  const mainWindow = getMainWindow();
  const widgetWindow = getWidgetWindow();
  const batch = [...actionQueue];
  actionQueue = [];

  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send('state-update-batch', batch);
  }
  if (widgetWindow && !widgetWindow.isDestroyed()) {
    widgetWindow.webContents.send('state-update-batch', batch);
  }

  isScheduled = false;
}

function scheduleBatch() {
  if (!isScheduled) {
    isScheduled = true;
    // Use setImmediate for high-throughput, non-UI-blocking batching
    setImmediate(sendBatch);
  }
}

/**
 * A centralized function to update the main process Redux store
 * and broadcast the change to the renderer process.
 * @param {string} type - The action type (e.g., 'cavebot/setEnabled').
 * @param {*} payload - The action payload.
 */
function setGlobalState(type, payload) {
  const action = {
    type,
    payload,
    origin: 'backend',
  };

  // 1. Dispatch the action to the main process store immediately.
  store.dispatch(action);

  // 2. Queue the action to be sent to the renderer in a batch.
  actionQueue.push(action);
  scheduleBatch();
}

export default setGlobalState;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/store.js
//start file
import { configureStore, combineReducers } from '@reduxjs/toolkit';
import globalSlice from '../frontend/redux/slices/globalSlice.js';
import ruleSlice from '../frontend/redux/slices/ruleSlice.js';
import gameStateSlice from '../frontend/redux/slices/gameStateSlice.js';
import luaSlice from '../frontend/redux/slices/luaSlice.js';
import cavebotSlice from '../frontend/redux/slices/cavebotSlice.js';
import targetingSlice from '../frontend/redux/slices/targetingSlice.js';
import statusMessagesSlice from '../frontend/redux/slices/statusMessagesSlice.js';
import regionCoordinatesSlice from '../frontend/redux/slices/regionCoordinatesSlice.js';
import ocrSlice from '../frontend/redux/slices/ocrSlice.js';
import uiValuesSlice from '../frontend/redux/slices/uiValuesSlice.js';
import battleListSlice from '../frontend/redux/slices/battleListSlice.js';

const rootReducer = combineReducers({
  global: globalSlice.reducer,
  gameState: gameStateSlice.reducer,
  rules: ruleSlice.reducer,
  lua: luaSlice.reducer,
  cavebot: cavebotSlice.reducer,
  targeting: targetingSlice.reducer,
  statusMessages: statusMessagesSlice.reducer,
  regionCoordinates: regionCoordinatesSlice.reducer,
  ocr: ocrSlice.reducer,
  uiValues: uiValuesSlice.reducer,
  battleList: battleListSlice.reducer,
});

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware(),
});

export default store;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/areStatusConditionsMet.js
//start file
/**
 * Check if character status conditions are met.
 * @param {Object} rule - The rule object.
 * @param {Object} gameState - The game state object.
 * @returns {boolean} - True if all conditions are met, false otherwise.
 */
const areCharStatusConditionsMet = (rule, gameState) => {
  // Check each condition in the rule's conditions array
  return rule.conditions.every((condition) => {
    const charStatusValue = gameState.characterStatus[condition.name];
    // If the condition's value is undefined or null, consider it unmet
    if (charStatusValue === undefined || charStatusValue === null) {
      return false;
    }
    return charStatusValue === condition.value;
  });
};

export default areCharStatusConditionsMet;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/gameWorldClickTranslator.js
//start file
// Player's fixed position on the screen within the game world window (0-indexed).
// This is a design constant representing the center of the viewport.
const PLAYER_SCREEN_TILE_X = 7; // 8th tile from the left
const PLAYER_SCREEN_TILE_Y = 5; // 6th tile from the top

/**
 * Translates absolute in-game world coordinates to absolute screen coordinates for clicking.
 * This function is pure and relies on dynamically detected region data passed as arguments.
 *
 * @param {number} targetGameX - The target absolute X coordinate in the game world.
 * @param {number} targetGameY - The target absolute Y coordinate in the game world.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current absolute position.
 * @param {object} gameWorldRegion - The dynamically found gameWorld region object {x, y, width, height}.
 * @param {object} tileSize - The dynamically calculated tile size object {width, height}.
 * @param {'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight' | 'center'} [targetPoint='center'] - The specific point within the tile to target.
 * @returns {{x: number, y: number}|null} The absolute screen coordinates for the click, or null if inputs are invalid.
 */
export function getAbsoluteGameWorldClickCoordinates(
  targetGameX,
  targetGameY,
  playerMinimapPosition,
  gameWorldRegion,
  tileSize,
  targetPoint = 'center',
) {
  // --- Input Validation ---
  if (!playerMinimapPosition) {
    console.error(
      '[ClickTranslator] Missing playerMinimapPosition for coordinate translation.',
    );
    return null;
  }
  if (!gameWorldRegion || !gameWorldRegion.width || !gameWorldRegion.height) {
    console.error(
      '[ClickTranslator] Missing or invalid gameWorldRegion for coordinate translation.',
    );
    return null;
  }
  if (!tileSize || !tileSize.width || !tileSize.height) {
    console.error(
      '[ClickTranslator] Missing or invalid tileSize for coordinate translation.',
    );
    return null;
  }

  // Calculate the difference in global game coordinates (in tiles)
  const deltaTilesX = targetGameX - playerMinimapPosition.x;
  const deltaTilesY = targetGameY - playerMinimapPosition.y;

  // Calculate the top-left pixel of the player's tile on screen using dynamic data
  const playerScreenPixelX_topLeft =
    gameWorldRegion.x + PLAYER_SCREEN_TILE_X * tileSize.width;
  const playerScreenPixelY_topLeft =
    gameWorldRegion.y + PLAYER_SCREEN_TILE_Y * tileSize.height;

  // Calculate the top-left pixel of the target tile on screen
  const targetTileScreenPixelX =
    playerScreenPixelX_topLeft + deltaTilesX * tileSize.width;
  const targetTileScreenPixelY =
    playerScreenPixelY_topLeft + deltaTilesY * tileSize.height;

  // Adjust based on targetPoint within the tile
  let finalClickX = targetTileScreenPixelX;
  let finalClickY = targetTileScreenPixelY;

  switch (targetPoint) {
    case 'topRight':
      finalClickX += tileSize.width;
      break;
    case 'bottomLeft':
      finalClickY += tileSize.height;
      break;
    case 'bottomRight':
      // Subtract a couple of pixels to ensure the click is inside the boundary
      finalClickX += tileSize.width - 2;
      finalClickY += tileSize.height - 2;
      break;
    case 'center':
    default: // Default to center for safety
      finalClickX += tileSize.width / 2;
      finalClickY += tileSize.height / 2;
      break;
  }

  // Return the final, rounded coordinates to ensure they are integers
  return { x: Math.round(finalClickX), y: Math.round(finalClickY) };
}

/**
 * Translates absolute screen coordinates to in-game world coordinates.
 *
 * @param {number} screenX - The absolute X coordinate on the screen.
 * @param {number} screenY - The absolute Y coordinate on the screen.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current absolute position.
 * @param {object} gameWorldRegion - The dynamically found gameWorld region object {x, y, width, height}.
 * @param {object} tileSize - The dynamically calculated tile size object {width, height}.
 * @returns {{x: number, y: number, z: number}|null} The absolute game world coordinates, or null if inputs are invalid.
 */
export function getGameCoordinatesFromScreen(
  screenX,
  screenY,
  playerMinimapPosition,
  gameWorldRegion,
  tileSize,
) {
  // --- Input Validation ---
  if (!playerMinimapPosition) {
    console.error(
      '[ClickTranslator] Missing playerMinimapPosition for coordinate translation.',
    );
    return null;
  }
  if (!gameWorldRegion || !gameWorldRegion.width || !gameWorldRegion.height) {
    console.error(
      '[ClickTranslator] Missing or invalid gameWorldRegion for coordinate translation.',
    );
    return null;
  }
  if (!tileSize || !tileSize.width || !tileSize.height) {
    console.error(
      '[ClickTranslator] Missing or invalid tileSize for coordinate translation.',
    );
    return null;
  }

  // --- Corrected Logic ---

  // 1. Calculate the entity's pixel position relative to the gameWorld region's origin.
  const relativeX = screenX - gameWorldRegion.x;
  const relativeY = screenY - gameWorldRegion.y;

  // 2. Convert the relative pixel position to a tile position within the gameWorld grid.
  const entityTileX = Math.floor(relativeX / tileSize.width);
  const entityTileY = Math.floor(relativeY / tileSize.height);

  // 3. Calculate the difference in tiles between the entity and the player's fixed screen position.
  const deltaTilesX = entityTileX - PLAYER_SCREEN_TILE_X;
  const deltaTilesY = entityTileY - PLAYER_SCREEN_TILE_Y;

  // 4. Add this tile difference to the player's absolute game world coordinates.
  const gameX = playerMinimapPosition.x + deltaTilesX;
  const gameY = playerMinimapPosition.y + deltaTilesY;

  return {
    x: gameX,
    y: gameY,
    z: playerMinimapPosition.z, // Z-level is the same as the player's
  };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/getRandomNumber.js
//start file
export const getRandomNumber = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/getWindowDimensions.js
//start file
import { spawn } from 'child_process';

class XdotoolManager {
  constructor() {
    this.process = null;
    this.commandQueue = [];
    this.isProcessing = false;
  }

  init() {
    if (this.process) return;

    this.process = spawn('xdotool', ['-']);

    // Handle process output
    this.process.stdout.on('data', (data) => {
      const result = data.toString().trim();
      if (this.commandQueue.length > 0) {
        const { resolve } = this.commandQueue.shift();
        resolve(result);
        this.processNextCommand();
      }
    });

    this.process.stderr.on('data', (data) => {
      if (this.commandQueue.length > 0) {
        const { reject } = this.commandQueue.shift();
        reject(new Error(data.toString()));
        this.processNextCommand();
      }
    });

    // Clean up on exit
    process.on('exit', () => {
      if (this.process) {
        this.process.kill();
      }
    });
  }

  async executeCommand(command) {
    return new Promise((resolve, reject) => {
      this.commandQueue.push({ command, resolve, reject });
      if (!this.isProcessing) {
        this.processNextCommand();
      }
    });
  }

  async processNextCommand() {
    if (this.commandQueue.length === 0) {
      this.isProcessing = false;
      return;
    }

    this.isProcessing = true;
    const { command } = this.commandQueue[0];

    try {
      // Send command through stdin
      this.process.stdin.write(`${command}\n`);
    } catch (error) {
      const { reject } = this.commandQueue.shift();
      reject(error);
      this.processNextCommand();
    }
  }
}

// Singleton instance
const xdotoolManager = new XdotoolManager();

async function getWindowDimensions(windowId) {
  xdotoolManager.init();

  try {
    const output = await xdotoolManager.executeCommand(
      `getwindowgeometry ${windowId}`,
    );
    const dimensions = output.match(/Geometry: (\d+)x(\d+)/);

    if (!dimensions) {
      throw new Error('Failed to parse window dimensions');
    }

    return {
      width: parseInt(dimensions[1]),
      height: parseInt(dimensions[2]),
    };
  } catch (error) {
    console.error('Error:', error);
    return null;
  }
}

export { getWindowDimensions, xdotoolManager };

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/logger.js
//start file
// electron/utils/logger.js
/**
 * Creates a configured logger function.
 *
 * @param {object} config - Logging configuration.
 * @param {boolean} [config.error=true] - Enable error logs.
 * @param {boolean} [config.warn=false] - Enable warning logs.
 * @param {boolean} [config.info=false] - Enable info logs.
 * @param {boolean} [config.debug=false] - Enable debug logs.
 * @param {boolean} [config.colors=true] - Enable colored output.
 * @returns {function(string, string, ...any): void} - The logging function.
 *   The function takes (level, message, ...optionalParams).
 */
export function createLogger(config = {}) {
  const defaultConfig = {
    error: true,
    warn: false,
    info: false,
    debug: false,
    colors: true,
  };

  // Merge provided config with default config
  const loggerConfig = { ...defaultConfig, ...config };

  const levels = {
    error: { tag: 'ERROR', color: 31, consoleMethod: 'error' }, // Red
    warn: { tag: 'WARN', color: 33, consoleMethod: 'warn' }, // Yellow
    info: { tag: 'INFO', color: 34, consoleMethod: 'log' }, // Blue
    debug: { tag: 'DEBUG', color: 32, consoleMethod: 'log' }, // Green
  };

  /**
   * Logs a message with a specific level.
   *
   * @param {string} level - The logging level ('error', 'warn', 'info', 'debug').
   * @param {string} message - The message to log.
   * @param {...any} optionalParams - Optional parameters to log (e.g., objects, variables).
   */
  return function log(level, message, ...optionalParams) {
    // Normalize level to lowercase for config lookup
    const lowerLevel = level.toLowerCase();
    const levelDetails = levels[lowerLevel];

    // Check if the level exists and is enabled in the config
    if (!levelDetails || !loggerConfig[lowerLevel]) {
      return; // Don't log if level is not configured or invalid
    }

    const now = new Date();
    // Format timestamp as YYYY-MM-DD HH:MM:SS.sss
    const timestamp = now.toISOString().replace('T', ' ').slice(0, 23);
    const tag = levelDetails.tag;
    const consoleMethod = levelDetails.consoleMethod;

    let formattedMessage;
    if (loggerConfig.colors) {
      const colorCode = levelDetails.color;
      // --- FIX: Apply color once at the start and reset once at the end ---
      // This ensures the tag, timestamp, and message are all the same color.
      // OLD: `\x1b[${colorCode}m[${tag}] [\x1b[90m${timestamp}\x1b[0m]\x1b[0m ${message}`
      formattedMessage = `\x1b[${colorCode}m[${tag}] [${timestamp}] ${message}\x1b[0m`;
    } else {
      // Format: [TAG] [TIMESTAMP] Message
      formattedMessage = `[${tag}] [${timestamp}] ${message}`;
    }

    // Use the appropriate console method to maintain console output streams (stdout vs stderr)
    console[consoleMethod](formattedMessage, ...optionalParams);
  };
}

// Example usage (can be removed or kept for testing)
// const defaultLogger = createLogger();
// defaultLogger('error', 'This is an error message.');
// defaultLogger('warn', 'This is a warning message.'); // Won't show with default config
// defaultLogger('info', 'This is an info message.');   // Won't show with default config
// defaultLogger('debug', 'This is a debug message.'); // Won't show with default config

// const verboseLogger = createLogger({ info: true, warn: true, debug: true });
// verboseLogger('error', 'This is an error message (verbose).');
// verboseLogger('warn', 'This is a warning message (verbose).');
// verboseLogger('info', 'This is an info message (verbose).');
// verboseLogger('debug', 'This is a debug message (verbose).', { data: 123 });

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/minimapClickTranslator.js
//start file
const MINIMAP_WIDTH = 106; // From preprocessMinimaps.js
const MINIMAP_HEIGHT = 109; // From preprocessMinimaps.js

/**
 * Translates global minimap coordinates to absolute screen coordinates for clicking.
 * @param {number} targetMapX - The target X coordinate on the global minimap.
 * @param {number} targetMapY - The target Y coordinate on the global minimap.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current position on the global minimap.
 * @param {{x: number, y: number, width: number, height: number}} minimapRegionDef - The screen coordinates and dimensions of the visible minimap.
 * @returns {{x: number, y: number}|null} The absolute screen coordinates for the click, or null if inputs are invalid.
 */
export function getAbsoluteClickCoordinates(
  targetMapX,
  targetMapY,
  playerMinimapPosition,
  minimapRegionDef,
) {
  if (!playerMinimapPosition || !minimapRegionDef) {
    console.error(
      'Missing playerMinimapPosition or minimapRegionDef for coordinate translation.',
    );
    return null;
  }

  // Calculate relative pixel position on the visible minimap
  const relativePixelX =
    targetMapX - playerMinimapPosition.x + MINIMAP_WIDTH / 2;
  const relativePixelY =
    targetMapY - playerMinimapPosition.y + MINIMAP_HEIGHT / 2;

  // Calculate absolute screen coordinates
  const absoluteClickX = minimapRegionDef.x + relativePixelX;
  const absoluteClickY = minimapRegionDef.y + relativePixelY;

  return { x: absoluteClickX, y: absoluteClickY };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/minimapMatcher.js
//start file
import fs from 'fs/promises';
import path from 'path';
import { createLogger } from './logger.js';
import MinimapMatcherNative from 'minimap_matcher-native';

const logger = createLogger({ info: true, error: true, debug: false });

let PREPROCESSED_BASE_DIR = null;

// Allow setting the base directory externally (e.g., from workerData)
export const setMinimapResourcesPath = (basePath) => {
  PREPROCESSED_BASE_DIR = basePath;
};

const getPreprocessedBaseDir = () => {
  if (!PREPROCESSED_BASE_DIR) {
    // Fallback for backward compatibility
    const getResourcesPath = () => {
      if (process.resourcesPath) {
        return process.resourcesPath;
      }
      return process.cwd();
    };
    return path.join(getResourcesPath(), 'resources', 'preprocessed_minimaps');
  }
  return PREPROCESSED_BASE_DIR;
};
const LANDMARK_SIZE = 3;
// The landmark pattern is now packed at 4-bits per pixel.
// The C++ addon will now work with 25-byte keys instead of 49-byte keys.
const LANDMARK_PATTERN_BYTES = Math.ceil((LANDMARK_SIZE * LANDMARK_SIZE) / 2); // 25

const EXCLUDED_COLORS_RGB = [
  { r: 51, g: 102, b: 153 },
  { r: 0, g: 0, b: 0 },
  { r: 255, g: 255, b: 255 },
  { r: 153, g: 153, b: 153 },
  { r: 0, g: 204, b: 0 },
  { r: 102, g: 102, b: 102 },
  { r: 255, g: 204, b: 153 },
  { r: 153, g: 102, b: 51 },
  { r: 255, g: 102, b: 0 },
];

class MinimapMatcher {
  constructor() {
    try {
      this.nativeMatcher = new MinimapMatcherNative.MinimapMatcher({
        LANDMARK_SIZE,
        LANDMARK_PATTERN_BYTES,
        EXCLUDED_COLORS_RGB,
      });
    } catch (error) {
      logger(
        'error',
        `Failed to load native minimap matcher module: ${error.message}`,
      );
      throw error;
    }

    this.isLoaded = false;
    this.lastKnownPositionByZ = new Map();
  }

  async loadMapData() {
    if (this.isLoaded) return;
    try {
      const baseDir = getPreprocessedBaseDir();
      const paletteFilePath = path.join(baseDir, 'palette.json');
      const palette = JSON.parse(await fs.readFile(paletteFilePath, 'utf8'));

      const landmarkData = new Map();

      const zLevelDirs = (await fs.readdir(baseDir, { withFileTypes: true }))
        .filter((d) => d.isDirectory() && d.name.startsWith('z'))
        .map((d) => parseInt(d.name.substring(1), 10));

      for (const z of zLevelDirs) {
        const zLevelDir = path.join(baseDir, `z${z}`);
        try {
          const landmarkBuffer = await fs.readFile(
            path.join(zLevelDir, 'landmarks.bin'),
          );
          const landmarks = [];

          // --- KEY CHANGE #2 ---
          // The size of each entry in the file is now based on the packed size.
          // 8 bytes for x/y coordinates + 25 bytes for the packed pattern.
          const landmarkEntrySize = 8 + LANDMARK_PATTERN_BYTES;

          for (let i = 0; i < landmarkBuffer.length; i += landmarkEntrySize) {
            landmarks.push({
              x: landmarkBuffer.readUInt32LE(i),
              y: landmarkBuffer.readUInt32LE(i + 4),
              // The pattern is now the 25-byte packed buffer.
              pattern: landmarkBuffer.subarray(i + 8, i + landmarkEntrySize),
            });
          }
          landmarkData.set(z, landmarks);
        } catch (e) {
          if (e.code === 'ENOENT') {
            logger(
              'warn',
              `No landmarks.bin found for Z=${z}. Position finding will be unavailable for this floor.`,
            );
          } else {
            logger(
              'error',
              `Could not load landmarks.bin for Z=${z}: ${e.message}`,
            );
          }
          landmarkData.set(z, []);
        }
      }

      // Sync data to the native module once on load
      this.nativeMatcher.palette = palette;
      this.nativeMatcher.landmarkData = Object.fromEntries(landmarkData);
      this.nativeMatcher.isLoaded = true;
      this.isLoaded = true;

      logger('info', `All minimap data loaded and synced to native module.`);
    } catch (error) {
      logger('error', `Failed to load minimap data: ${error.message}`);
      this.isLoaded = false;
      this.nativeMatcher.isLoaded = false;
    }
  }

  /**
   * Finds the player position asynchronously.
   * This method returns a promise that resolves with the position or rejects on error/cancellation.
   * It will automatically cancel any previously running search.
   * @param {Buffer} unpackedMinimap - A buffer of 8-bit palette indices.
   * @param {number} minimapWidth
   * @param {number} minimapHeight
   * @param {number} targetZ
   * @returns {Promise<object|null>} A promise that resolves with the result object.
   */
  async findPosition(unpackedMinimap, minimapWidth, minimapHeight, targetZ) {
    if (!this.isLoaded) {
      throw new Error(
        'MinimapMatcher is not loaded. Call loadMapData() first.',
      );
    }

    const resultPromise = this.nativeMatcher.findPosition(
      unpackedMinimap,
      minimapWidth,
      minimapHeight,
      targetZ,
    );

    resultPromise
      .then((result) => {
        if (result && result.position) {
          this.lastKnownPositionByZ.set(targetZ, {
            x: result.mapViewX,
            y: result.mapViewY,
          });
        }
      })
      .catch((err) => {
        if (err.message !== 'Search cancelled') {
          logger('error', `Native findPosition error: ${err.message}`);
        }
      });

    return resultPromise;
  }

  /**
   * Explicitly cancels any ongoing search.
   */
  cancelCurrentSearch() {
    this.nativeMatcher.cancelSearch();
  }
}

export { MinimapMatcher };

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/parseMathCondition.js
//start file
/**
 * Parse mathematical conditions for HP and mana triggers.
 * @param {string} condition - The mathematical condition to check.
 * @param {number} triggerPercentage - The trigger percentage value.
 * @param {number} actualPercentage - The actual percentage value to check against.
 * @returns {boolean} - True if the condition is met, false otherwise.
 */
const parseMathCondition = (condition, triggerPercentage, actualPercentage) => {
  switch (condition) {
    case '<':
      return actualPercentage < triggerPercentage;
    case '<=':
      return actualPercentage <= triggerPercentage;
    case '=':
      return actualPercentage === triggerPercentage;
    case '>':
      return actualPercentage > triggerPercentage;
    case '>=':
      return actualPercentage >= triggerPercentage;
    case '!=':
      return actualPercentage !== triggerPercentage;
    default:
      return false;
  }
};

export default parseMathCondition;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/widget/preload.js
//start file
// Automaton/electron/widget/preload.js
const { contextBridge, ipcRenderer } = require('electron');

// Expose controlled functions to the renderer process
contextBridge.exposeInMainWorld('electronAPI', {
  // Send messages to the main process
  send: (channel, ...args) => {
    ipcRenderer.send(channel, ...args);
  },
  // Receive messages from the main process
  on: (channel, listener) => {
    ipcRenderer.on(channel, listener);
  },
  // Invoke functions in the main process and wait for a response
  invoke: (channel, ...args) => {
    return ipcRenderer.invoke(channel, ...args);
  },
  // Remove a listener
  removeListener: (channel, listener) => {
    ipcRenderer.removeListener(channel, listener);
  },
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/widget/renderer.js
//start file
// Automaton/electron/widget/renderer.js

// Function to get current state from main process
async function getInitialStates() {
  try {
    const states = await window.electronAPI.invoke('get-control-states');
    if (states) {
      document.getElementById('healing-switch').checked = states.isRulesEnabled;
      document.getElementById('cavebot-switch').checked =
        states.isCavebotEnabled;
      document.getElementById('targeting-switch').checked =
        states.isTargetingEnabled;
      document.getElementById('scripts-switch').checked = states.isLuaEnabled;
    }
  } catch (error) {
    console.error('Error getting initial states:', error);
  }
}

// Function to handle switch changes
function handleSwitchChange(switchId, feature) {
  const switchElement = document.getElementById(switchId);
  switchElement.addEventListener('change', () => {
    window.electronAPI.send('update-bot-status', {
      feature,
      isEnabled: switchElement.checked,
    });
  });
}

// Function to handle state updates from main process
function handleStateUpdates() {
  window.electronAPI.on('state-update', (event, action) => {
    // Update switches based on state changes from main process
    switch (action.type) {
      case 'rules/setenabled':
        document.getElementById('healing-switch').checked = action.payload;
        break;
      case 'cavebot/setenabled':
        document.getElementById('cavebot-switch').checked = action.payload;
        break;
      case 'targeting/setenabled':
        document.getElementById('targeting-switch').checked = action.payload;
        break;
      case 'lua/setenabled':
        document.getElementById('scripts-switch').checked = action.payload;
        break;
      case 'rules/setState':
        if (action.payload) {
          document.getElementById('healing-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'cavebot/setState':
        if (action.payload) {
          document.getElementById('cavebot-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'targeting/setState':
        if (action.payload) {
          document.getElementById('targeting-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'lua/setState':
        if (action.payload) {
          document.getElementById('scripts-switch').checked =
            action.payload.enabled;
        }
        break;
    }
  });
}

// Function to update main window toggle button
async function updateMainWindowToggle() {
  const isVisible = await window.electronAPI.invoke('is-main-window-visible');
  const toggleIcon = document.getElementById('toggle-main-icon');

  if (isVisible) {
    toggleIcon.textContent = '🗔';
  } else {
    toggleIcon.textContent = '🗔';
  }
}

// Function to handle main window toggle
function handleMainWindowToggle() {
  const toggleBtn = document.getElementById('toggle-main-btn');
  toggleBtn.addEventListener('click', async () => {
    await window.electronAPI.invoke('toggle-main-window');
    await updateMainWindowToggle();
  });
}

// Initialize the widget when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
  // Get initial states
  await getInitialStates();
  await updateMainWindowToggle();

  // Set up switch change handlers
  handleSwitchChange('healing-switch', 'healing');
  handleSwitchChange('cavebot-switch', 'cavebot');
  handleSwitchChange('targeting-switch', 'targeting');
  handleSwitchChange('scripts-switch', 'scripts');

  // Set up state update listener
  handleStateUpdates();

  // Set up main window toggle
  handleMainWindowToggle();
});

// Clean up listeners when window is closed
window.addEventListener('beforeunload', () => {
  window.electronAPI.removeListener('state-update', handleStateUpdates);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workerManager.js
//start file
// @workerManager.js (Definitive Freeze Fix)

import { Worker } from 'worker_threads';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import { showNotification } from './notificationHandler.js';
import { createLogger } from './utils/logger.js';
import { BrowserWindow } from 'electron';
import { playSound } from './globalShortcuts.js';
import {
  PLAYER_POS_SAB_SIZE,
  PATH_DATA_SAB_SIZE,
} from './workers/sharedConstants.js';

const log = createLogger();

const DEFAULT_WORKER_CONFIG = {
  captureWorker: true,
  regionMonitor: true,
  screenMonitor: true,
  minimapMonitor: true,
  ocrWorker: true,
  cavebotWorker: true,
  pathfinderWorker: true,
  entityMonitor: true,
  enableLuaScriptWorkers: true,
};

const MAX_RESTART_ATTEMPTS = 5;
const RESTART_COOLDOWN = 500;
const RESTART_LOCK_TIMEOUT = 5000;
const WORKER_INIT_DELAY = 50;

function quickHash(obj) {
  let h = 0x811c9dc5;
  const str = JSON.stringify(obj);
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = (h * 0x01000193) >>> 0;
  }
  return h;
}

const WORKER_STATE_DEPENDENCIES = {
  cavebotWorker: [
    'cavebot',
    'global',
    'regionCoordinates',
    'statusMessages',
    'settings',
  ],
  regionMonitor: ['global'],
  entityMonitor: ['global', 'regionCoordinates', 'gameState'],
  screenMonitor: [
    'global',
    'regionCoordinates',
    'gameState',
    'rules',
    'uiValues',
  ],
  minimapMonitor: ['global', 'regionCoordinates'],
  ocrWorker: ['global', 'regionCoordinates'],
  captureWorker: ['global'],
  // Pathfinder is now handled with custom logic below to prevent feedback loops.
};

const GRACEFUL_SHUTDOWN_WORKERS = new Set([
  'regionMonitor',
  'screenMonitor',
  'minimapMonitor',
  'ocrWorker',
  'cavebotWorker',
  'pathfinderWorker',
  'entityMonitor',
]);

class WorkerManager {
  constructor() {
    const filename = fileURLToPath(import.meta.url);
    this.electronDir = dirname(filename);
    this.workers = new Map();
    this.workerPaths = new Map();
    this.restartLocks = new Map();
    this.restartAttempts = new Map();
    this.restartTimeouts = new Map();
    this.sharedData = null;
    this.workerConfig = {};
    this.paths = { utils: null, workers: null, minimapResources: null };
    this.previousState = null;
    this.storeUpdateTimeout = null;
    this.updateCount = 0;
    this.lastPerfReport = Date.now();
    this.reusableChangedSlices = {};
    this.workerStateCache = new Map();
    this.handleWorkerError = this.handleWorkerError.bind(this);
    this.handleWorkerExit = this.handleWorkerExit.bind(this);
    this.handleWorkerMessage = this.handleWorkerMessage.bind(this);
    this.handleStoreUpdate = this.handleStoreUpdate.bind(this);
    this.debouncedStoreUpdate = this.debouncedStoreUpdate.bind(this);
  }

  setupPaths(app, cwd) {
    if (app.isPackaged) {
      this.paths.utils = path.join(
        app.getAppPath(),
        '..',
        'resources',
        'x11utils',
      );
      this.paths.minimapResources = path.join(
        app.getAppPath(),
        '..',
        'resources',
        'preprocessed_minimaps',
      );
    } else {
      this.paths.utils = path.join(cwd, '..', 'resources', 'x11utils');
      this.paths.minimapResources = path.join(
        cwd,
        '..',
        'resources',
        'preprocessed_minimaps',
      );
    }
    if (!app.isPackaged) {
      log('info', '[Worker Manager] Paths initialized:', this.paths);
    }
  }

  resetRestartState(name) {
    this.restartLocks.set(name, false);
    this.restartAttempts.set(name, 0);
    clearTimeout(this.restartTimeouts.get(name));
    this.restartTimeouts.delete(name);
  }

  async clearRestartLockWithTimeout(name) {
    const timeout = setTimeout(() => {
      log('warn', `[Worker Manager] Force clearing restart lock: ${name}`);
      this.resetRestartState(name);
    }, RESTART_LOCK_TIMEOUT);
    this.restartTimeouts.set(name, timeout);
  }

  getWorkerPath(workerName) {
    const isUUID = /^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/.test(
      workerName,
    );
    if (isUUID) {
      return resolve(this.electronDir, './workers', 'luaScriptWorker.js');
    }
    return resolve(this.electronDir, './workers', `${workerName}.js`);
  }

  createSharedBuffers() {
    const maxImageSize = 3840 * 2160 * 4;
    const imageSAB = new SharedArrayBuffer(maxImageSize);
    const MAX_DIRTY_REGIONS = 64;
    const SYNC_BUFFER_SIZE = 5 + 1 + MAX_DIRTY_REGIONS * 4;
    const syncSAB = new SharedArrayBuffer(
      SYNC_BUFFER_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const playerPosSAB = new SharedArrayBuffer(
      PLAYER_POS_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const pathDataSAB = new SharedArrayBuffer(
      PATH_DATA_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    this.sharedData = { imageSAB, syncSAB, playerPosSAB, pathDataSAB };
    log('info', '[Worker Manager] Created SharedArrayBuffers.');
  }

  handleWorkerError(name, error) {
    log('error', `[Worker Manager] Worker error: ${name}`, error);
    if (!name.startsWith('script-') && !this.restartLocks.get(name)) {
      this.restartWorker(name).catch((err) =>
        log(
          'error',
          `[Worker Manager] Restart failed after error: ${name}`,
          err,
        ),
      );
    } else if (name.startsWith('script-')) {
      log(
        'info',
        `[Worker Manager] Script worker ${name} encountered an error. Lifecycle managed by store updates.`,
      );
      this.workers.delete(name);
    }
  }

  handleWorkerExit(name, code) {
    log('info', `[Worker Manager] Worker exited: ${name}, code ${code}`);
    this.workers.delete(name);
    this.workerPaths.delete(name);
    const isUUID = /^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/.test(
      name,
    );
    if (!isUUID && code !== 0) {
      const attempts = this.restartAttempts.get(name) || 0;
      if (!this.restartLocks.get(name) && attempts < MAX_RESTART_ATTEMPTS) {
        log(
          'error',
          `[Worker Manager] Non-script worker exited with error: ${name}, code ${code}, attempt ${attempts + 1}/${MAX_RESTART_ATTEMPTS}`,
        );
        setTimeout(
          () => {
            this.restartWorker(name).catch((err) =>
              log('error', `Failed to restart worker ${name} after exit:`, err),
            );
          },
          RESTART_COOLDOWN * (attempts + 1),
        );
      } else if (attempts >= MAX_RESTART_ATTEMPTS) {
        log(
          'error',
          `[Worker Manager] Max restart attempts reached for non-script worker: ${name}`,
        );
        this.resetRestartState(name);
      }
    }
  }

  handleWorkerMessage(message) {
    if (message.notification) {
      showNotification(message.notification.title, message.notification.body);
    } else if (message.storeUpdate) {
      this.incomingActionQueue.push({
        type: message.type,
        payload: message.payload,
      });
    } else if (message.type === 'batch-update') {
      for (const action of message.payload) {
        setGlobalState(action.type, action.payload);
      }
    } else if (message.command === 'requestRegionRescan') {
      const regionWorkerEntry = this.workers.get('regionMonitor');
      if (regionWorkerEntry?.worker) {
        regionWorkerEntry.worker.postMessage({ command: 'forceRegionSearch' });
      }
    } else if (message.command === 'executeLuaScript') {
      const state = store.getState();
      const { enabled: luaEnabled } = state.lua;
      const { script, id } = message.payload;
      if (!luaEnabled) {
        const cavebotWorkerEntry = this.workers.get('cavebotWorker');
        if (cavebotWorkerEntry?.worker) {
          cavebotWorkerEntry.worker.postMessage({
            type: 'script-finished',
            id,
            success: false,
            error: 'Lua scripts are disabled',
          });
        }
        return;
      }
      this.startWorker(id, { id, code: script, type: 'oneshot' }, this.paths);
    } else if (message.type === 'scriptExecutionResult') {
      const { id, success, error } = message;
      if (error)
        log(
          'error',
          `[Worker Manager] Script ${id} failed with error: ${error}`,
        );
      const cavebotWorkerEntry = this.workers.get('cavebotWorker');
      if (cavebotWorkerEntry?.worker) {
        cavebotWorkerEntry.worker.postMessage({ type: 'script-finished', id });
      }
      this.stopWorker(id);
    } else if (
      ['scriptError', 'luaPrint', 'luaStatusUpdate'].includes(message.type)
    ) {
      const { scriptId, message: logMessage } = message;
      if (scriptId) {
        setGlobalState('lua/addLogEntry', {
          id: scriptId,
          message: logMessage,
        });
        BrowserWindow.getAllWindows().forEach((win) => {
          if (!win.isDestroyed())
            win.webContents.send('script-log-update', {
              scriptId,
              message: logMessage,
            });
        });
      }
    } else if (message.type === 'play_alert') {
      playSound('alert.wav');
    }
  }

  startWorker(name, scriptConfig = null, paths = null) {
    if (this.workers.has(name)) return this.workers.get(name).worker;
    try {
      const workerPath = this.getWorkerPath(name);
      const needsSharedScreen = [
        'captureWorker',
        'screenMonitor',
        'minimapMonitor',
        'regionMonitor',
        'ocrWorker',
        'entityMonitor',
      ].includes(name);
      const needsPlayerPosSAB = [
        'minimapMonitor',
        'pathfinderWorker',
        'cavebotWorker',
        'entityMonitor',
      ].includes(name);
      const needsPathDataSAB = ['pathfinderWorker', 'cavebotWorker'].includes(
        name,
      );
      const workerData = {
        paths: paths || this.paths,
        sharedData: needsSharedScreen ? this.sharedData : null,
        playerPosSAB: needsPlayerPosSAB ? this.sharedData.playerPosSAB : null,
        pathDataSAB: needsPathDataSAB ? this.sharedData.pathDataSAB : null,
        enableMemoryLogging: true,
      };
      if (needsSharedScreen) {
        workerData.display = store.getState().global.display;
      }
      const worker = new Worker(workerPath, { name, workerData });
      this.workers.set(name, { worker, config: scriptConfig });
      worker.on('message', (msg) => this.handleWorkerMessage(msg));
      worker.on('error', (error) => this.handleWorkerError(name, error));
      worker.on('exit', (code) => this.handleWorkerExit(name, code));
      log('info', `[Worker Manager] Worker ${name} started successfully.`);
      setTimeout(() => {
        if (scriptConfig) {
          worker.postMessage({ type: 'init', script: scriptConfig });
        }
        if (
          name !== 'captureWorker' &&
          !(/^[0-9a-fA-F]{8}-/.test(name) && scriptConfig?.type === 'oneshot')
        ) {
          worker.postMessage(store.getState());
        }
      }, WORKER_INIT_DELAY);
      return worker;
    } catch (error) {
      log('error', `[Worker Manager] Failed to start worker: ${name}`, error);
      return null;
    }
  }

  async restartWorker(name, scriptConfig = null) {
    if (this.restartLocks.get(name)) return null;
    this.restartLocks.set(name, true);
    this.restartAttempts.set(name, (this.restartAttempts.get(name) || 0) + 1);
    this.clearRestartLockWithTimeout(name);
    try {
      await this.stopWorker(name);
      const newWorker = this.startWorker(name, scriptConfig, this.paths);
      if (!newWorker) throw new Error(`Failed to create new worker: ${name}`);
      log('info', `[Worker Manager] Worker ${name} restarted successfully.`);
      this.resetRestartState(name);
      return newWorker;
    } catch (error) {
      log('error', `[Worker Manager] Error during restart: ${name}`, error);
    } finally {
      this.restartLocks.set(name, false);
    }
  }

  stopWorker(name) {
    const workerEntry = this.workers.get(name);
    if (!workerEntry?.worker) return Promise.resolve();
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        if (this.workers.has(name) && !workerEntry.worker.killed) {
          workerEntry.worker.terminate();
        }
        resolve();
      }, 5000);
      workerEntry.worker.once('exit', () => {
        clearTimeout(timeout);
        resolve();
      });
      if (
        /^[0-9a-fA-F]{8}-/.test(name) ||
        GRACEFUL_SHUTDOWN_WORKERS.has(name)
      ) {
        workerEntry.worker.postMessage({ type: 'shutdown' });
      } else {
        workerEntry.worker.terminate();
      }
    });
  }

  async stopAllWorkers() {
    log('info', '[Worker Manager] Stopping all workers...');
    if (this.incomingActionInterval) {
      clearInterval(this.incomingActionInterval);
      this.incomingActionInterval = null;
    }
    await Promise.all(
      Array.from(this.workers.keys()).map((name) => this.stopWorker(name)),
    );
    log('info', '[Worker Manager] All workers have been terminated.');
  }

  getStateChanges(currentState, previousState) {
    const changedSlices = {};
    let hasChanges = false;
    for (const key in currentState) {
      if (currentState[key] !== previousState[key]) {
        changedSlices[key] = currentState[key];
        hasChanges = true;
      }
    }
    return hasChanges ? changedSlices : null;
  }

  broadcastStateUpdate(changedSlices) {
    const changedKeys = Object.keys(changedSlices);
    const currentState = store.getState(); // Get the full current state for comparison

    for (const [name, workerEntry] of this.workers) {
      if (
        !workerEntry.worker ||
        name === 'captureWorker' ||
        (/^[0-9a-fA-F]{8}-/.test(name) &&
          workerEntry.config?.type === 'oneshot')
      )
        continue;

      // --- FIX: Custom, precise dependency check for pathfinderWorker ---
      if (name === 'pathfinderWorker') {
        const relevantPayload = {};
        let needsUpdate = false;

        if (changedKeys.includes('gameState')) {
          needsUpdate = true;
          relevantPayload.gameState = changedSlices.gameState;
        }

        if (changedKeys.includes('cavebot')) {
          const oldCavebot = this.previousState.cavebot;
          const newCavebot = currentState.cavebot;
          // Only trigger an update if the *inputs* to the pathfinder have changed.
          // This prevents an update caused by its own `pathfindingFeedback` output.
          if (
            oldCavebot.wptId !== newCavebot.wptId ||
            oldCavebot.currentSection !== newCavebot.currentSection ||
            oldCavebot.waypointSections !== newCavebot.waypointSections ||
            oldCavebot.specialAreas !== newCavebot.specialAreas
          ) {
            needsUpdate = true;
            relevantPayload.cavebot = newCavebot;
          }
        }

        if (needsUpdate) {
          workerEntry.worker.postMessage({
            type: 'state_diff',
            payload: relevantPayload,
          });
        }
        continue; // Move to the next worker
      }
      // --- END FIX ---

      const workerDeps = WORKER_STATE_DEPENDENCIES[name];
      const relevant = {};
      let needsUpdate = false;
      if (workerDeps) {
        for (const k of changedKeys) {
          if (workerDeps.includes(k)) {
            relevant[k] = changedSlices[k];
            needsUpdate = true;
          }
        }
      } else {
        Object.assign(relevant, changedSlices);
        needsUpdate = true;
      }
      if (needsUpdate && Object.keys(relevant).length) {
        const hash = quickHash(relevant);
        if (this.workerStateCache.get(name) !== hash) {
          this.workerStateCache.set(name, hash);
          workerEntry.worker.postMessage({
            type: 'state_diff',
            payload: relevant,
          });
        }
      }
    }
  }

  logPerformanceStats() {
    const now = Date.now();
    if (now - this.lastPerfReport >= 10000) {
      const ups = (
        (this.updateCount / (now - this.lastPerfReport)) *
        1000
      ).toFixed(1);
      log(
        'debug',
        `[Worker Manager] Performance: ${ups} store updates/sec, ${this.workers.size} active workers`,
      );
      this.updateCount = 0;
      this.lastPerfReport = now;
    }
  }

  debouncedStoreUpdate() {
    this.handleStoreUpdate();
  }

  async handleStoreUpdate() {
    const perfStart = performance.now();
    this.updateCount++;
    try {
      const currentState = store.getState();
      const { windowId, display } = currentState.global;
      const { enabled: luaEnabled } = currentState.lua;

      if (windowId && display) {
        if (!this.sharedData) this.createSharedBuffers();
        if (
          !this.previousState ||
          currentState.global.windowId !== this.previousState.global.windowId
        ) {
          const syncArray = new Int32Array(this.sharedData.syncSAB);
          Atomics.store(syncArray, 4, parseInt(windowId, 10) || 0);
        }

        if (
          this.workerConfig.captureWorker &&
          !this.workers.has('captureWorker')
        )
          this.startWorker('captureWorker');
        if (
          this.workerConfig.regionMonitor &&
          !this.workers.has('regionMonitor')
        )
          this.startWorker('regionMonitor');
        if (
          this.workerConfig.entityMonitor &&
          !this.workers.has('entityMonitor')
        )
          this.startWorker('entityMonitor');
        if (
          this.workerConfig.screenMonitor &&
          !this.workers.has('screenMonitor')
        )
          this.startWorker('screenMonitor');
        if (
          this.workerConfig.minimapMonitor &&
          !this.workers.has('minimapMonitor')
        )
          this.startWorker('minimapMonitor');
        if (this.workerConfig.ocrWorker && !this.workers.has('ocrWorker'))
          this.startWorker('ocrWorker');
        if (
          this.workerConfig.cavebotWorker &&
          !this.workers.has('cavebotWorker')
        )
          this.startWorker('cavebotWorker');
        if (
          this.workerConfig.pathfinderWorker &&
          !this.workers.has('pathfinderWorker')
        )
          this.startWorker('pathfinderWorker');
      } else {
        const persistentWorkers = [
          'captureWorker',
          'regionMonitor',
          'screenMonitor',
          'minimapMonitor',
          'ocrWorker',
          'cavebotWorker',
          'pathfinderWorker',
          'entityMonitor',
        ];
        const workersToStop = Array.from(this.workers.keys()).filter((name) =>
          persistentWorkers.includes(name),
        );
        if (workersToStop.length > 0) {
          log(
            'info',
            '[Worker Manager] Window not detected, stopping persistent workers...',
          );
          await Promise.all(workersToStop.map((w) => this.stopWorker(w)));
        }
        if (this.sharedData) {
          log('info', '[Worker Manager] Clearing SharedArrayBuffers.');
          this.sharedData = null;
        }
      }

      await this.manageLuaWorkers(currentState, luaEnabled);

      if (this.previousState) {
        const changed = this.getStateChanges(currentState, this.previousState);
        if (changed) this.broadcastStateUpdate(changed);
      }
      this.previousState = currentState;
      this.logPerformanceStats();
    } catch (error) {
      log('error', '[Worker Manager] Error in handleStoreUpdate:', error);
    }
    const updateTime = performance.now() - perfStart;
    if (updateTime > 16) {
      log(
        'warn',
        `[Worker Manager] Slow store update: ${updateTime.toFixed(2)}ms`,
      );
    }
  }

  async manageLuaWorkers(currentState, luaEnabled) {
    const allPersistentScripts = currentState.lua.persistentScripts;
    const runningScriptWorkerIds = new Set(
      Array.from(this.workers.keys()).filter((n) => /^[0-9a-fA-F]{8}-/.test(n)),
    );
    if (this.workerConfig.enableLuaScriptWorkers && luaEnabled) {
      const activeScripts = allPersistentScripts.filter((s) => s.enabled);
      const activeScriptIds = new Set(activeScripts.map((s) => s.id));
      const workersToStop = Array.from(runningScriptWorkerIds).filter(
        (id) => !activeScriptIds.has(id),
      );
      if (workersToStop.length)
        await Promise.all(workersToStop.map((id) => this.stopWorker(id)));
      for (const script of activeScripts) {
        const entry = this.workers.get(script.id);
        if (!entry) {
          this.startWorker(script.id, script, this.paths);
        } else if (
          entry.config &&
          (entry.config.code !== script.code ||
            entry.config.loopMin !== script.loopMin ||
            entry.config.loopMax !== script.loopMax)
        ) {
          await this.restartWorker(script.id, script);
        } else {
          entry.config = script;
        }
      }
    } else {
      if (runningScriptWorkerIds.size > 0) {
        await Promise.all(
          Array.from(runningScriptWorkerIds).map((id) => this.stopWorker(id)),
        );
      }
    }
  }

  initialize(app, cwd, config = {}) {
    this.setupPaths(app, cwd);
    this.workerConfig = { ...DEFAULT_WORKER_CONFIG, ...config };
    log('info', '[Worker Manager] Initializing with debounced store updates.');
    this.previousState = store.getState();
    store.subscribe(this.debouncedStoreUpdate);

    this.incomingActionQueue = [];
    this.incomingActionInterval = setInterval(() => {
      if (this.incomingActionQueue.length > 0) {
        const batch = this.incomingActionQueue.splice(
          0,
          this.incomingActionQueue.length,
        );
        for (const action of batch) {
          setGlobalState(action.type, action.payload);
        }
      }
    }, 5);
  }
}

const workerManager = new WorkerManager();
export default workerManager;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/config.js
//start file
// --- Performance Logging ---
export const PERFORMANCE_LOGGING_ENABLED = true; // Set to false to disable logging
export const PERFORMANCE_LOG_INTERVAL_MS = 10000; // Log stats every 10 seconds
export const TARGET_FPS = 30;

// --- SharedArrayBuffer (SAB) Indices ---
export const FRAME_COUNTER_INDEX = 0;
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const WINDOW_ID_INDEX = 4;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

// --- Capture Limits ---
// This must match the value used when creating the SharedArrayBuffer
export const MAX_DIRTY_REGIONS = 64;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/core.js
//start file
// capture/core.js (Corrected)

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import X11RegionCapture from 'x11-region-capture-native';
import * as config from './config.js';
import { PerformanceTracker } from './performanceTracker.js';

// --- Worker State & Setup ---
const { sharedData, display } = workerData;
if (!sharedData) throw new Error('[CaptureCore] Shared data not provided.');

const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const imageBuffer = Buffer.from(imageSAB);

const captureInstance = X11RegionCapture
  ? new X11RegionCapture.X11RegionCapture(display)
  : null;
let isCapturing = false;

// --- Performance Tracking ---
const perfTracker = new PerformanceTracker();
let lastPerfReportTime = Date.now();

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function logPerformanceReport() {
  if (!config.PERFORMANCE_LOGGING_ENABLED) return;

  const now = Date.now();
  if (now - lastPerfReportTime >= config.PERFORMANCE_LOG_INTERVAL_MS) {
    console.log(perfTracker.getReport());
    perfTracker.reset();
    lastPerfReportTime = now;
  }
}

async function captureLoop() {
  if (!captureInstance) {
    console.error(
      '[CaptureCore] X11 native module is not available. Cannot start capture.',
    );
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  const windowId = Atomics.load(syncArray, config.WINDOW_ID_INDEX);
  if (!windowId) {
    console.error('[CaptureCore] No Window ID provided. Cannot start capture.');
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  try {
    captureInstance.startMonitorInstance(windowId, config.TARGET_FPS);
    isCapturing = true;
    console.log(
      `[CaptureCore] Started monitoring window: ${windowId} at ${config.TARGET_FPS} FPS.`,
    );
  } catch (err) {
    console.error(
      '[CaptureCore] Failed to start native capture instance:',
      err,
    );
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  Atomics.store(syncArray, config.IS_RUNNING_INDEX, 1);

  while (Atomics.load(syncArray, config.IS_RUNNING_INDEX) === 1) {
    const loopStartTime = performance.now();

    try {
      const frameResult = captureInstance.getLatestFrame(imageBuffer);

      if (frameResult) {
        // --- Write ALL data for the new frame FIRST ---
        // A static frame is still a new frame, just one with 0 dirty regions.

        const regionsToWrite = frameResult.changedRegions
          ? Math.min(
              frameResult.changedRegions.length,
              config.MAX_DIRTY_REGIONS,
            )
          : 0;

        // Write dirty regions count. This will be 0 for a static frame.
        Atomics.store(
          syncArray,
          config.DIRTY_REGION_COUNT_INDEX,
          regionsToWrite,
        );

        // Write dirty regions themselves (this loop will not run if regionsToWrite is 0)
        if (frameResult.changedRegions) {
          for (let i = 0; i < regionsToWrite; i++) {
            const rect = frameResult.changedRegions[i];
            const offset = config.DIRTY_REGIONS_START_INDEX + i * 4;
            Atomics.store(syncArray, offset + 0, rect.x);
            Atomics.store(syncArray, offset + 1, rect.y);
            Atomics.store(syncArray, offset + 2, rect.width);
            Atomics.store(syncArray, offset + 3, rect.height);
          }
        }

        // Write width and height, even for static frames, in case of resize.
        Atomics.store(syncArray, config.WIDTH_INDEX, frameResult.width);
        Atomics.store(syncArray, config.HEIGHT_INDEX, frameResult.height);

        // --- Now, as the FINAL step, announce the new frame ---
        // This is the heartbeat. It MUST be incremented on every cycle.
        Atomics.add(syncArray, config.FRAME_COUNTER_INDEX, 1);
        Atomics.notify(syncArray, config.FRAME_COUNTER_INDEX);

        // Performance tracking can happen after the commit
        const loopDuration = performance.now() - loopStartTime;
        perfTracker.addFrameMeasurement(loopDuration, regionsToWrite);
      }
    } catch (err) {
      console.error('[CaptureCore] Error in capture loop, stopping:', err);
      Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, config.IS_RUNNING_INDEX);
      break;
    }

    const loopDuration = performance.now() - loopStartTime;
    const delayTime = Math.max(0, 1000 / config.TARGET_FPS - loopDuration);
    await delay(delayTime);

    logPerformanceReport();
  }

  if (isCapturing) {
    captureInstance.stopMonitorInstance();
    isCapturing = false;
    console.log('[CaptureCore] Stopped capture instance.');
  }
}

function handleMessage(message) {
  if (message.command === 'stop') {
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
  }
}

export async function start() {
  console.log('[CaptureCore] Worker starting up...');
  parentPort.on('message', handleMessage);
  await captureLoop();
  console.log(
    '[CaptureCore] Worker has finished its capture loop and is shutting down.',
  );
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report capture performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  /**
   * Resets all statistics to their initial state.
   */
  reset() {
    this.frameTimes = [];
    this.totalFrameTime = 0;
    this.minFrameTime = Infinity;
    this.maxFrameTime = 0;

    this.dirtyRegionCounts = [];
    this.totalDirtyRegions = 0;
    this.minDirtyRegions = Infinity;
    this.maxDirtyRegions = 0;
  }

  /**
   * Adds a new frame measurement to the tracker.
   * @param {number} duration - The time in milliseconds for the frame capture loop.
   * @param {number} regionCount - The number of dirty regions in the frame.
   */
  addFrameMeasurement(duration, regionCount) {
    // Frame time stats
    this.frameTimes.push(duration);
    this.totalFrameTime += duration;
    if (duration < this.minFrameTime) this.minFrameTime = duration;
    if (duration > this.maxFrameTime) this.maxFrameTime = duration;

    // Dirty region stats
    this.dirtyRegionCounts.push(regionCount);
    this.totalDirtyRegions += regionCount;
    if (regionCount < this.minDirtyRegions) this.minDirtyRegions = regionCount;
    if (regionCount > this.maxDirtyRegions) this.maxDirtyRegions = regionCount;
  }

  /**
   * Generates a formatted string of the current performance statistics.
   * @returns {string|null} A report string or null if no data is available.
   */
  getReport() {
    const frameCount = this.frameTimes.length;
    if (frameCount === 0) {
      return '[CapturePerformance] No frames captured in the last period.';
    }

    const avgFrameTime = this.totalFrameTime / frameCount;
    const avgDirtyRegions = this.totalDirtyRegions / frameCount;

    const frameReport = `Frames: ${frameCount} | Avg Time: ${avgFrameTime.toFixed(2)}ms | Min: ${this.minFrameTime.toFixed(2)}ms | Max: ${this.maxFrameTime.toFixed(2)}ms`;
    const regionReport = `Dirty Regions: Avg: ${avgDirtyRegions.toFixed(1)} | Min: ${this.minDirtyRegions} | Max: ${this.maxDirtyRegions}`;

    return `[CapturePerformance] ${frameReport} | ${regionReport}`;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/captureWorker.js
//start file
/**
 * @file captureWorker.js
 * @summary A dedicated worker for capturing screen frames from a specific window.
 * @description This file is the entry point for the capture worker. It delegates
 * all logic to the modules in the /capture sub-directory for maintainability.
 */

import { workerData } from 'worker_threads';
import { start } from './capture/core.js';
import { IS_RUNNING_INDEX } from './capture/config.js';

start().catch((err) => {
  console.error(
    '[CaptureWorker] A fatal, unhandled error occurred during startup:',
    err,
  );

  // Attempt to notify other workers that we are not running.
  // This is a "best effort" signal in case of a catastrophic startup failure.
  try {
    // workerData is available synchronously at the top level of a worker module.
    const { sharedData } = workerData;
    if (sharedData?.syncSAB) {
      const syncArray = new Int32Array(sharedData.syncSAB);
      Atomics.store(syncArray, IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, IS_RUNNING_INDEX);
      console.log(
        '[CaptureWorker] Successfully signaled shutdown to other workers.',
      );
    } else {
      console.error(
        '[CaptureWorker] Could not signal shutdown: sharedData or syncSAB not available.',
      );
    }
  } catch (e) {
    console.error(
      '[CaptureWorker] An error occurred while trying to signal shutdown:',
      e,
    );
  }

  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebotLuaExecutor.js
//start file
import { LuaFactory } from 'wasmoon';
import { parentPort } from 'worker_threads';
import { performance } from 'perf_hooks';
import { createLuaApi } from './luaApi.js';
import { preprocessLuaScript } from './luaScriptProcessor.js';

export class CavebotLuaExecutor {
  /**
   * @param {object} context - The context from the cavebot worker.
   */
  constructor(context) {
    this.lua = null;
    this.logger = context.logger;
    this.context = context;
    this.isInitialized = false;
    this.isShuttingDown = false;

    // Performance tracking
    this.executionCount = 0;
    this.totalExecutionTime = 0;
    this.lastPerfReport = Date.now();

    // API state management
    this.asyncFunctionNames = [];
    this.navigationOccurred = false;
    this.lastApiSync = 0;
    this.apiSyncThrottleMs = 100; // Throttle API sync to 10fps max

    // Error tracking
    this.consecutiveErrors = 0;
    this.maxConsecutiveErrors = 5;

    // Reusable objects to reduce GC pressure
    this.reusableResult = {
      success: false,
      error: null,
      navigationOccurred: false,
    };

    this.logger(
      'info',
      '[CavebotLuaExecutor] Instance created with performance monitoring.',
    );
  }

  async initialize() {
    if (this.isShuttingDown) {
      return false;
    }

    this.logger('info', '[CavebotLuaExecutor] Initializing Lua VM...');

    try {
      const initStart = performance.now();

      const factory = new LuaFactory();
      this.lua = await factory.createEngine();

      // Pre-warm the API sync to avoid first-execution overhead
      this._syncApiToLua();

      const initTime = performance.now() - initStart;
      this.logger(
        'info',
        `[CavebotLuaExecutor] Lua VM initialized successfully in ${initTime.toFixed(2)}ms.`,
      );

      this.isInitialized = true;
      this.consecutiveErrors = 0;
      return true;
    } catch (error) {
      this.logger(
        'error',
        '[CavebotLuaExecutor] Failed to initialize Lua VM:',
        error,
      );
      this.isInitialized = false;
      return false;
    }
  }

  _shouldSyncApi() {
    const now = Date.now();
    return now - this.lastApiSync >= this.apiSyncThrottleMs;
  }

  _syncApiToLua() {
    if (!this.lua || this.isShuttingDown) return;

    const syncStart = performance.now();

    try {
      const { api, asyncFunctionNames, stateObject } = createLuaApi({
        type: 'cavebot',
        ...this.context,
        postSystemMessage: (message) => {
          if (!this.isShuttingDown) {
            parentPort.postMessage(message);
          }
        },
      });

      this.asyncFunctionNames = asyncFunctionNames;

      // Wrap navigation functions to track navigation events
      const wrappedApi = { ...api };
      const navFuncs = ['skipWaypoint', 'goToLabel', 'goToSection', 'goToWpt'];

      navFuncs.forEach((funcName) => {
        if (api[funcName]) {
          wrappedApi[funcName] = (...args) => {
            this.navigationOccurred = true;
            return api[funcName](...args);
          };
        }
      });

      // Batch API sync for better performance
      const globals = this.lua.global;
      for (const funcName in wrappedApi) {
        globals.set(funcName, wrappedApi[funcName]);
      }
      globals.set('__BOT_STATE__', stateObject);

      this.lastApiSync = Date.now();

      const syncTime = performance.now() - syncStart;
      if (syncTime > 10) {
        // Log slow syncs
        this.logger(
          'debug',
          `[CavebotLuaExecutor] Slow API sync: ${syncTime.toFixed(2)}ms`,
        );
      }
    } catch (error) {
      this.logger(
        'error',
        '[CavebotLuaExecutor] Failed to sync API to Lua:',
        error,
      );
      throw error; // Re-throw to handle in caller
    }
  }

  _logPerformanceStats() {
    const now = Date.now();
    const timeSinceLastReport = now - this.lastPerfReport;

    if (timeSinceLastReport >= 30000) {
      // Log every 30 seconds
      const avgExecTime =
        this.executionCount > 0
          ? (this.totalExecutionTime / this.executionCount).toFixed(2)
          : 0;
      const execPerMinute = (
        (this.executionCount / timeSinceLastReport) *
        60000
      ).toFixed(1);

      this.logger(
        'info',
        `[CavebotLuaExecutor] Performance: ${execPerMinute} executions/min, avg: ${avgExecTime}ms, errors: ${this.consecutiveErrors}`,
      );

      // Reset counters
      this.executionCount = 0;
      this.totalExecutionTime = 0;
      this.lastPerfReport = now;
    }
  }

  _resetResult() {
    this.reusableResult.success = false;
    this.reusableResult.error = null;
    this.reusableResult.navigationOccurred = false;
    return this.reusableResult;
  }

  async executeScript(scriptCode) {
    if (this.isShuttingDown) {
      const result = this._resetResult();
      result.error = 'Executor is shutting down';
      return result;
    }

    if (!this.isInitialized) {
      const result = this._resetResult();
      result.error = 'Lua VM is not initialized';
      return result;
    }

    // Check for circuit breaker condition
    if (this.consecutiveErrors >= this.maxConsecutiveErrors) {
      this.logger(
        'error',
        `[CavebotLuaExecutor] Circuit breaker triggered: ${this.consecutiveErrors} consecutive errors. Refusing execution.`,
      );
      const result = this._resetResult();
      result.error = 'Too many consecutive errors, execution disabled';
      return result;
    }

    if (!scriptCode?.trim()) {
      const result = this._resetResult();
      result.success = true;
      return result;
    }

    const execStart = performance.now();
    this.logger('debug', '[CavebotLuaExecutor] Executing script...');

    // Reset navigation flag before each execution
    this.navigationOccurred = false;

    try {
      // Throttled API sync to avoid overhead on frequent executions
      if (this._shouldSyncApi()) {
        this._syncApiToLua();
      }

      // Preprocess script with error handling
      let processedCode;
      try {
        processedCode = preprocessLuaScript(
          scriptCode,
          this.asyncFunctionNames,
        );
      } catch (preprocessError) {
        throw new Error(
          `Script preprocessing failed: ${preprocessError.message}`,
        );
      }

      // Execute the Lua code
      await this.lua.doString(processedCode);

      // Success case
      const execTime = performance.now() - execStart;
      this.executionCount++;
      this.totalExecutionTime += execTime;

      // Log slow executions
      if (execTime > 100) {
        this.logger(
          'warn',
          `[CavebotLuaExecutor] Slow script execution: ${execTime.toFixed(2)}ms`,
        );
      }

      // Reset error counter on success
      this.consecutiveErrors = 0;

      const result = this._resetResult();
      result.success = true;
      result.navigationOccurred = this.navigationOccurred;

      this._logPerformanceStats();
      return result;
    } catch (error) {
      const execTime = performance.now() - execStart;
      this.executionCount++;
      this.totalExecutionTime += execTime;
      this.consecutiveErrors++;

      const errorMessage = error.message || String(error);
      this.logger(
        'error',
        `[CavebotLuaExecutor] Script execution failed (attempt ${this.consecutiveErrors}): ${errorMessage}`,
      );

      // Enhanced error logging with context
      try {
        const currentState = this.context.getState();
        const scriptId = currentState?.cavebot?.wptId;

        if (scriptId) {
          this.context.postStoreUpdate('cavebot/addWaypointLogEntry', {
            id: scriptId,
            message: `[ERROR] ${errorMessage}`,
          });
        }
      } catch (storeError) {
        this.logger(
          'error',
          '[CavebotLuaExecutor] Failed to log error to store:',
          storeError,
        );
      }

      const result = this._resetResult();
      result.error = errorMessage;
      result.navigationOccurred = this.navigationOccurred;

      this._logPerformanceStats();
      return result;
    }
  }

  /**
   * Reset the circuit breaker and error state
   */
  reset() {
    this.consecutiveErrors = 0;
    this.logger('info', '[CavebotLuaExecutor] Error state reset.');
  }

  /**
   * Get current performance metrics
   */
  getMetrics() {
    return {
      isInitialized: this.isInitialized,
      isShuttingDown: this.isShuttingDown,
      executionCount: this.executionCount,
      avgExecutionTime:
        this.executionCount > 0
          ? this.totalExecutionTime / this.executionCount
          : 0,
      consecutiveErrors: this.consecutiveErrors,
      circuitBreakerTripped:
        this.consecutiveErrors >= this.maxConsecutiveErrors,
    };
  }

  /**
   * Graceful shutdown with cleanup
   */
  destroy() {
    this.logger('info', '[CavebotLuaExecutor] Starting graceful shutdown...');
    this.isShuttingDown = true;

    if (this.lua) {
      try {
        // Final performance report
        if (this.executionCount > 0) {
          const avgTime = (
            this.totalExecutionTime / this.executionCount
          ).toFixed(2);
          this.logger(
            'info',
            `[CavebotLuaExecutor] Final stats - Executions: ${this.executionCount}, Avg time: ${avgTime}ms`,
          );
        }

        this.lua.global.close();
        this.lua = null;
        this.isInitialized = false;

        this.logger(
          'info',
          '[CavebotLuaExecutor] Lua VM destroyed successfully.',
        );
      } catch (error) {
        this.logger(
          'error',
          '[CavebotLuaExecutor] Error during cleanup:',
          error,
        );
      }
    }

    // Clear references
    this.context = null;
    this.asyncFunctionNames = [];
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebotWorker.js
//start file
import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import keypress from 'keypress-native';
import mouseController from 'mouse-controller';
import { getAbsoluteClickCoordinates } from '../utils/minimapClickTranslator.js';
import { getAbsoluteGameWorldClickCoordinates } from '../utils/gameWorldClickTranslator.js';
import { createLogger } from '../utils/logger.js';
import { CavebotLuaExecutor } from './cavebotLuaExecutor.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_WAYPOINTS_START_INDEX,
  PATH_WAYPOINT_SIZE,
  PATH_START_X_INDEX,
  PATH_START_Y_INDEX,
  PATH_START_Z_INDEX,
  PATH_CHEBYSHEV_DISTANCE_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
  PATH_STATUS_PATH_FOUND,
  PATH_STATUS_WAYPOINT_REACHED,
  PATH_STATUS_NO_PATH_FOUND,
  PATH_STATUS_DIFFERENT_FLOOR,
  PATH_STATUS_ERROR,
  PATH_STATUS_NO_VALID_START_OR_END,
  MAX_PATH_WAYPOINTS,
} from './sharedConstants.js';

// --- Worker Configuration ---
const MAIN_LOOP_INTERVAL = 25;
const STATE_CHANGE_POLL_INTERVAL = 5;
const PERFORMANCE_LOG_INTERVAL = 10000;

// --- Configuration ---
const config = {
  actionStateChangeTimeoutMs: 200,
  preClickDelayMs: 250,
  toolHotkeyWaitMs: 150,
  teleportDistanceThreshold: 5,
  postTeleportGraceMs: 1250,
  moveConfirmTimeoutMs: 400,
};

// --- Worker State ---
let globalState = null;
let isShuttingDown = false;
let isInitialized = false;
let fsmState = 'IDLE';
let lastFsmState = null;

// --- SAB State ---
let lastPlayerPosCounter = -1;
let lastPathDataCounter = -1;
let playerMinimapPosition = null;
let path = [];
let pathChebyshevDistance = null;
let pathfindingStatus = PATH_STATUS_IDLE;

// --- Shared Buffer Setup ---
const { playerPosSAB, pathDataSAB } = workerData;
const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const pathDataArray = pathDataSAB ? new Int32Array(pathDataSAB) : null;

// --- Performance Tracking ---
let operationCount = 0;
let totalOperationTime = 0;
let lastPerfReport = Date.now();

// --- Cavebot Specific State ---
let luaExecutor = null;
let stuckDetectionGraceUntil = 0;
let floorChangeGraceUntil = 0;
let recentKeyboardFailures = [];
let lastProcessedWptId = null;

// --- Utility Functions & Logging ---
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const getDistance = (p1, p2) =>
  Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
const getDirectionKey = (current, target) => {
  const dx = target.x - current.x;
  const dy = target.y - current.y;
  if (dy < 0) {
    if (dx < 0) return 'q';
    if (dx === 0) return 'w';
    if (dx > 0) return 'e';
  } else if (dy === 0) {
    if (dx < 0) return 'a';
    if (dx > 0) return 'd';
  } else if (dy > 0) {
    if (dx < 0) return 'z';
    if (dx === 0) return 's';
    if (dx > 0) return 'c';
  }
  return null;
};
const logger = createLogger({ info: false, error: true, debug: false });
const pathingLogger = createLogger({
  info: true,
  error: true,
  debug: false,
  prefix: '[CavebotPathing]',
});

function logPerformanceStats() {
  const now = Date.now();
  if (now - lastPerfReport >= PERFORMANCE_LOG_INTERVAL) {
    const avgOpTime =
      operationCount > 0 ? (totalOperationTime / operationCount).toFixed(2) : 0;
    const opsPerSecond = (
      (operationCount / (now - lastPerfReport)) *
      1000
    ).toFixed(1);
    logger(
      'info',
      `[CavebotWorker] Performance: ${opsPerSecond} ops/sec, avg: ${avgOpTime}ms`,
    );
    operationCount = 0;
    totalOperationTime = 0;
    lastPerfReport = now;
  }
}

// --- Store & State Management ---
const postStoreUpdate = (type, payload) =>
  parentPort.postMessage({ storeUpdate: true, type, payload });

const awaitStateChange = (condition, timeoutMs) => {
  return new Promise((resolve) => {
    let intervalId = null;
    const timeoutId = setTimeout(() => {
      if (intervalId) clearInterval(intervalId);
      resolve(false);
    }, timeoutMs);
    intervalId = setInterval(() => {
      if (globalState && condition(globalState)) {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        resolve(true);
      }
    }, STATE_CHANGE_POLL_INTERVAL);
  });
};

const awaitZLevelChange = (initialZ, timeoutMs) => {
  return new Promise((resolve) => {
    const startTime = Date.now();
    const intervalId = setInterval(() => {
      const currentZ = Atomics.load(playerPosArray, PLAYER_Z_INDEX);

      // If Z-level has changed, the action was a success.
      if (currentZ !== initialZ) {
        clearInterval(intervalId);
        resolve(true);
      }

      // If the timeout is reached without a Z-level change, it failed.
      if (Date.now() - startTime > timeoutMs) {
        clearInterval(intervalId);
        resolve(false);
      }
    }, STATE_CHANGE_POLL_INTERVAL);
  });
};

// --- Navigation Functions ---
const advanceToNextWaypoint = async () => {
  if (!globalState?.cavebot) return false;
  const {
    waypointSections,
    currentSection,
    wptId: oldWptId,
  } = globalState.cavebot;
  const waypoints = waypointSections[currentSection]?.waypoints || [];
  if (waypoints.length === 0) return false;
  const currentIndex = waypoints.findIndex((wp) => wp.id === oldWptId);
  if (currentIndex === -1) return false;
  const nextIndex = (currentIndex + 1) % waypoints.length;
  const nextWpt = waypoints[nextIndex];
  if (nextWpt) {
    postStoreUpdate('cavebot/setwptId', nextWpt.id);
    const success = await awaitStateChange(
      (state) => state.cavebot.wptId === nextWpt.id,
      500,
    );
    if (success) {
      lastProcessedWptId = nextWpt.id;
    } else {
      pathingLogger(
        'error',
        `Failed to confirm waypoint advance from ${oldWptId} to ${nextWpt.id} within timeout!`,
      );
    }
    return success;
  }
  return false;
};

const goToLabel = async (label) => {
  const { waypointSections, currentSection } = globalState.cavebot;
  const targetWpt = waypointSections[currentSection].waypoints.find(
    (wpt) => wpt.label === label,
  );
  if (targetWpt) {
    postStoreUpdate('cavebot/setwptId', targetWpt.id);
  } else {
    await advanceToNextWaypoint();
  }
};

const goToSection = async (sectionName) => {
  const { waypointSections } = globalState.cavebot;
  const foundEntry = Object.entries(waypointSections).find(
    ([, section]) => section.name === sectionName,
  );
  if (foundEntry) {
    const [targetSectionId, targetSection] = foundEntry;
    if (targetSection.waypoints?.length > 0) {
      const firstWpt = targetSection.waypoints[0];
      postStoreUpdate('cavebot/setCurrentWaypointSection', targetSectionId);
      postStoreUpdate('cavebot/setwptId', firstWpt.id);
    } else {
      await advanceToNextWaypoint();
    }
  } else {
    await advanceToNextWaypoint();
  }
};

const goToWpt = async (index) => {
  const userIndex = parseInt(index, 10);
  if (isNaN(userIndex) || userIndex < 1) return;
  const arrayIndex = userIndex - 1;
  const { waypointSections, currentSection } = globalState.cavebot;
  const waypoints = waypointSections[currentSection]?.waypoints || [];
  if (arrayIndex < waypoints.length) {
    postStoreUpdate('cavebot/setwptId', waypoints[arrayIndex].id);
  }
};

// --- Action Handlers ---
const handleWalkAction = async () => {
  const nextStep = path[0];
  const posCounterBeforeMove = lastPlayerPosCounter;
  const pathCounterBeforeMove = lastPathDataCounter;
  keypress.sendKey(
    getDirectionKey(playerMinimapPosition, nextStep),
    globalState.global.display,
  );
  try {
    await awaitWalkConfirmation(
      posCounterBeforeMove,
      pathCounterBeforeMove,
      config.moveConfirmTimeoutMs,
    );
  } catch (error) {
    pathingLogger('error', `Walk step failed: ${error.message}`);
    recentKeyboardFailures.push(Date.now());
  }
};

const handleStandAction = async (targetWaypoint) => {
  const initialPos = { ...playerMinimapPosition };
  keypress.sendKey(
    getDirectionKey(initialPos, targetWaypoint),
    globalState.global.display,
  );
  try {
    const { finalPos } = await awaitStandConfirmation(
      initialPos,
      targetWaypoint,
      500,
    );
    if (finalPos.z !== initialPos.z) floorChangeGraceUntil = Date.now() + 500;
    if (getDistance(initialPos, finalPos) >= config.teleportDistanceThreshold) {
      stuckDetectionGraceUntil = Date.now() + config.postTeleportGraceMs;
    }
    return true;
  } catch (error) {
    pathingLogger('error', `Stand action failed: ${error.message}`);
    return false;
  }
};

const handleLadderAction = async (targetCoords) => {
  const initialPos = { ...playerMinimapPosition };
  if (!initialPos) return false; // Safety check

  await delay(config.preClickDelayMs);

  const { gameWorld, tileSize } = globalState.regionCoordinates.regions;
  if (!gameWorld || !tileSize) {
    logger(
      'error',
      '[handleLadderAction] Missing region coordinates for click.',
    );
    return false;
  }

  const clickCoords = getAbsoluteGameWorldClickCoordinates(
    targetCoords.x,
    targetCoords.y,
    initialPos,
    gameWorld,
    tileSize,
    'bottomRight', // Using 'bottomRight' as it was in the original code
  );

  if (!clickCoords) {
    logger(
      'error',
      '[handleLadderAction] Could not calculate click coordinates.',
    );
    return false;
  }

  mouseController.rightClick(
    parseInt(globalState.global.windowId, 10),
    clickCoords.x,
    clickCoords.y,
    globalState.global.display || ':0',
  );

  // Wait for a Z-level change within 500ms, as per your requirement.
  const zChanged = await awaitZLevelChange(initialPos.z, 500);

  if (zChanged) {
    // Success! Give the game a moment to settle after a floor change.
    floorChangeGraceUntil = Date.now() + 500;
    return true;
  }

  // Failure: Z-level did not change in time.
  return false;
};

const handleZLevelToolAction = async (toolType, targetCoords) => {
  const hotkey = globalState.settings.hotkeys[toolType.toLowerCase()];
  if (!hotkey) return false;
  const { gameWorld, tileSize } = globalState.regionCoordinates.regions;
  if (!gameWorld || !tileSize) return false;
  const initialPos = { ...playerMinimapPosition };
  keypress.sendKey(hotkey, globalState.global.display || ':0');
  await delay(config.toolHotkeyWaitMs + config.preClickDelayMs);
  const clickCoords = getAbsoluteGameWorldClickCoordinates(
    targetCoords.x,
    targetCoords.y,
    initialPos,
    gameWorld,
    tileSize,
    'center',
  );
  if (!clickCoords) return false;
  mouseController.leftClick(
    parseInt(globalState.global.windowId, 10),
    clickCoords.x,
    clickCoords.y,
    globalState.global.display || ':0',
  );
  const zChanged = await awaitStateChange(
    (state) => state.gameState?.playerMinimapPosition?.z !== initialPos.z,
    config.actionStateChangeTimeoutMs,
  );
  if (zChanged) {
    floorChangeGraceUntil = Date.now() + 500;
    const finalPos = globalState.gameState.playerMinimapPosition;
    if (getDistance(initialPos, finalPos) >= config.teleportDistanceThreshold) {
      stuckDetectionGraceUntil = Date.now() + config.postTeleportGraceMs;
    }
    return true;
  }
  return false;
};

const handleScriptAction = async (targetWpt) => {
  if (!luaExecutor || !luaExecutor.isInitialized) {
    await advanceToNextWaypoint();
    return;
  }
  const result = await luaExecutor.executeScript(targetWpt.script);
  if (result.success && !result.navigationOccurred) {
    await advanceToNextWaypoint();
  }
};

// --- Confirmation Utilities ---
const awaitWalkConfirmation = (
  posCounterBeforeMove,
  pathCounterBeforeMove,
  timeoutMs,
) => {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      clearInterval(intervalId);
      reject(new Error(`awaitWalkConfirmation timed out after ${timeoutMs}ms`));
    }, timeoutMs);
    const intervalId = setInterval(() => {
      const posChanged =
        Atomics.load(playerPosArray, PLAYER_POS_UPDATE_COUNTER_INDEX) >
        posCounterBeforeMove;
      const pathChanged =
        Atomics.load(pathDataArray, PATH_UPDATE_COUNTER_INDEX) >
        pathCounterBeforeMove;
      if (posChanged && pathChanged) {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        resolve(true);
      }
    }, STATE_CHANGE_POLL_INTERVAL);
  });
};

const awaitStandConfirmation = (initialPos, targetPos, timeoutMs) => {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    const intervalId = setInterval(() => {
      const finalPos = {
        x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
      };
      const zChanged = finalPos.z !== initialPos.z;
      const teleported =
        getDistance(initialPos, finalPos) >= config.teleportDistanceThreshold;
      const reachedTarget =
        finalPos.x === targetPos.x &&
        finalPos.y === targetPos.y &&
        finalPos.z === targetPos.z;
      if (zChanged || teleported || reachedTarget) {
        clearInterval(intervalId);
        resolve({ success: true, finalPos });
      }
      if (Date.now() - startTime > timeoutMs) {
        clearInterval(intervalId);
        reject(
          new Error(`awaitStandConfirmation timed out after ${timeoutMs}ms`),
        );
      }
    }, STATE_CHANGE_POLL_INTERVAL);
  });
};

// --- FINITE STATE MACHINE (FSM) ---
const fsm = {
  IDLE: {
    enter: () => postStoreUpdate('cavebot/setActionPaused', true),
    execute: (context) =>
      context.targetWaypoint ? 'EVALUATING_WAYPOINT' : 'IDLE',
  },

  EVALUATING_WAYPOINT: {
    execute: async (context) => {
      const { playerPos, targetWaypoint, status, path, chebyshevDist } =
        context;

      // Helper function for advancing to the next waypoint
      const handleAdvance = async (reason) => {
        pathingLogger(
          'info',
          `${reason} for waypoint ${targetWaypoint.id}. Advancing.`,
        );
        const advanced = await advanceToNextWaypoint();
        // Go IDLE to re-evaluate the new state, or if advancing fails
        return 'IDLE';
      };

      // --- Step 1: Handle each waypoint type with its specific logic ---
      switch (targetWaypoint.type) {
        case 'Script':
          // Scripts are executed immediately, position is irrelevant.
          return 'EXECUTING_SCRIPT';

        case 'Node':
          // Success condition: Player is at the exact waypoint coordinates.
          if (
            playerPos.x === targetWaypoint.x &&
            playerPos.y === targetWaypoint.y &&
            playerPos.z === targetWaypoint.z
          ) {
            return await handleAdvance('SUCCESS: Reached Node waypoint');
          }
          // If not at the node, fall through to the pathing logic below.
          break;

        case 'Stand':
          // Success condition: Player is exactly 1 tile away (adjacent).
          if (chebyshevDist === 1) {
            return 'PERFORMING_ACTION';
          }
          // If not adjacent, fall through to the pathing logic below.
          break;

        case 'Ladder':
          // Success condition: Player is on the tile or adjacent.
          if (chebyshevDist <= 1) {
            return 'PERFORMING_ACTION';
          }
          // If not close enough, fall through to the pathing logic below.
          break;

        default:
          pathingLogger(
            'warn',
            `Unknown waypoint type "${targetWaypoint.type}". Treating as Node.`,
          );
          if (
            playerPos.x === targetWaypoint.x &&
            playerPos.y === targetWaypoint.y &&
            playerPos.z === targetWaypoint.z
          ) {
            return await handleAdvance(
              `SUCCESS: Reached unknown waypoint type '${targetWaypoint.type}'`,
            );
          }
          break;
      }

      // --- Step 2: If no success condition was met, use pathfinder to move ---
      // This block is only reached if we need to walk towards the target.
      switch (status) {
        case PATH_STATUS_PATH_FOUND:
          if (path.length > 0) {
            // We have a valid path with steps, so let's walk.
            return 'WALKING';
          } else {
            // Anomaly: path is found but empty, and we are NOT at the target.
            // This could be a stale path. Wait for a new path from the pathfinder.
            pathingLogger(
              'warn',
              `Path is empty but not at destination for wpt ${targetWaypoint.id}. Awaiting new path.`,
            );
            return 'EVALUATING_WAYPOINT'; // Re-evaluate next tick
          }

        case PATH_STATUS_WAYPOINT_REACHED:
          // The pathfinder says we've arrived, but our position check above failed.
          // This indicates a sync issue. Trust our position check and advance to avoid getting stuck.
          pathingLogger(
            'warn',
            `Pathfinder reported WAYPOINT_REACHED for wpt ${targetWaypoint.id}, but position mismatch. Advancing.`,
          );
          return await handleAdvance(
            'WARN: Advancing due to state mismatch (REACHED)',
          );

        case PATH_STATUS_NO_PATH_FOUND:
        case PATH_STATUS_NO_VALID_START_OR_END:
        case PATH_STATUS_ERROR:
        case PATH_STATUS_DIFFERENT_FLOOR:
          // The waypoint is unreachable. Log it and advance.
          return await handleAdvance(
            `WARN: Waypoint unreachable (Code: ${status})`,
          );

        case PATH_STATUS_IDLE:
        default:
          // No path information yet. Keep waiting.
          return 'EVALUATING_WAYPOINT';
      }
    },
  },

  WALKING: {
    enter: () => postStoreUpdate('cavebot/setActionPaused', false),
    execute: async () => {
      await handleWalkAction();
      return 'EVALUATING_WAYPOINT';
    },
  },

  PERFORMING_ACTION: {
    enter: () => postStoreUpdate('cavebot/setActionPaused', true),
    execute: async (context) => {
      const { targetWaypoint } = context;
      let actionSucceeded = false;
      const targetCoords = {
        x: targetWaypoint.x,
        y: targetWaypoint.y,
        z: targetWaypoint.z,
      };

      if (targetWaypoint.type === 'Stand')
        actionSucceeded = await handleStandAction(targetWaypoint);
      else if (targetWaypoint.type === 'Ladder')
        actionSucceeded = await handleLadderAction(targetCoords);

      if (actionSucceeded) {
        pathingLogger(
          'info',
          `SUCCESS: Action ${targetWaypoint.type} succeeded. Advancing.`,
        );
        const advanced = await advanceToNextWaypoint();
        return advanced ? 'IDLE' : 'EVALUATING_WAYPOINT';
      } else {
        pathingLogger(
          'error',
          `Action ${targetWaypoint.type} failed. Re-evaluating.`,
        );
        await delay(250);
        return 'EVALUATING_WAYPOINT';
      }
    },
  },

  EXECUTING_SCRIPT: {
    enter: () => postStoreUpdate('cavebot/setActionPaused', true),
    execute: async (context) => {
      await handleScriptAction(context.targetWaypoint);
      return 'IDLE';
    },
  },
};

// --- Data Update and Contextual Logic ---

const updateSABData = () => {
  if (playerPosArray) {
    const newPlayerPosCounter = Atomics.load(
      playerPosArray,
      PLAYER_POS_UPDATE_COUNTER_INDEX,
    );
    if (newPlayerPosCounter > lastPlayerPosCounter) {
      playerMinimapPosition = {
        x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
      };
      lastPlayerPosCounter = newPlayerPosCounter;
    }
  }

  // --- This is the new, safe read logic for the path data ---
  if (pathDataArray) {
    let consistentRead = false;
    let attempts = 0;

    // We might need to loop if a write happens while we're reading.
    // A simple attempt limit prevents any infinite loops in weird edge cases.
    do {
      const counterBeforeRead = Atomics.load(
        pathDataArray,
        PATH_UPDATE_COUNTER_INDEX,
      );

      // Only proceed if there's new data to read.
      if (counterBeforeRead === lastPathDataCounter) {
        return; // No new data, exit.
      }

      // --- Read the entire data block ---
      const pathStartX = Atomics.load(pathDataArray, PATH_START_X_INDEX);
      const pathStartY = Atomics.load(pathDataArray, PATH_START_Y_INDEX);
      const pathStartZ = Atomics.load(pathDataArray, PATH_START_Z_INDEX);
      const tempPathfindingStatus = Atomics.load(
        pathDataArray,
        PATHFINDING_STATUS_INDEX,
      );
      const tempPathChebyshevDistance = Atomics.load(
        pathDataArray,
        PATH_CHEBYSHEV_DISTANCE_INDEX,
      );
      const pathLength = Atomics.load(pathDataArray, PATH_LENGTH_INDEX);
      const tempPath = [];

      // Boundary check to prevent reading out of bounds if pathLength is corrupt
      const safePathLength = Math.min(pathLength, MAX_PATH_WAYPOINTS);
      for (let i = 0; i < safePathLength; i++) {
        const offset = PATH_WAYPOINTS_START_INDEX + i * PATH_WAYPOINT_SIZE;
        tempPath.push({
          x: Atomics.load(pathDataArray, offset + 0),
          y: Atomics.load(pathDataArray, offset + 1),
          z: Atomics.load(pathDataArray, offset + 2),
        });
      }

      // --- Read the counter again ---
      const counterAfterRead = Atomics.load(
        pathDataArray,
        PATH_UPDATE_COUNTER_INDEX,
      );

      // --- The Consistency Check ---
      if (counterBeforeRead === counterAfterRead) {
        // SUCCESS! The data is consistent.
        consistentRead = true;

        // Now, perform the validation against our current player position.
        if (
          !playerMinimapPosition ||
          playerMinimapPosition.x !== pathStartX ||
          playerMinimapPosition.y !== pathStartY ||
          playerMinimapPosition.z !== pathStartZ
        ) {
          // The data is consistent, but stale. We ignore it.
          // This isn't an error, just the pathfinder lagging behind.
        } else {
          // The data is consistent AND valid for our current position.
          // Commit the read data to our worker's state.
          path = tempPath;
          pathfindingStatus = tempPathfindingStatus;
          pathChebyshevDistance = tempPathChebyshevDistance;
        }

        // Mark this update counter as processed, so we don't try to read it again.
        lastPathDataCounter = counterAfterRead;
      } else {
        // A "torn read" occurred. The writer updated the buffer while we were reading.
        // We will loop and try again.
        attempts++;
      }
    } while (!consistentRead && attempts < 3);
  }
};

function findCurrentWaypoint() {
  if (!globalState?.cavebot) return null;
  const { waypointSections, currentSection, wptId } = globalState.cavebot;
  let targetWaypoint = waypointSections[currentSection]?.waypoints.find(
    (wp) => wp.id === wptId,
  );
  if (!targetWaypoint) {
    const firstSectionWithWaypoints = Object.keys(waypointSections).find(
      (id) => waypointSections[id]?.waypoints?.length > 0,
    );
    if (firstSectionWithWaypoints) {
      const firstWaypoint =
        waypointSections[firstSectionWithWaypoints].waypoints[0];
      if (firstWaypoint) {
        postStoreUpdate(
          'cavebot/setCurrentWaypointSection',
          firstSectionWithWaypoints,
        );
        postStoreUpdate('cavebot/setwptId', firstWaypoint.id);
        return firstWaypoint;
      }
    }
    return null;
  }
  return targetWaypoint;
}

// --- Main Operation ---
async function performOperation() {
  const opStart = performance.now();
  try {
    if (
      !isInitialized ||
      !globalState?.cavebot?.enabled ||
      !globalState.global?.windowId
    ) {
      if (fsmState !== 'IDLE') {
        fsmState = 'IDLE';
        fsm.IDLE.enter();
      }
      return;
    }

    updateSABData();
    if (!playerMinimapPosition) return;

    let targetWaypoint = findCurrentWaypoint();
    if (!targetWaypoint) {
      fsmState = 'IDLE';
      lastProcessedWptId = null;
      return;
    }

    // --- Pre-emptive "Seek" Loop ---
    while (targetWaypoint.z !== playerMinimapPosition.z) {
      pathingLogger(
        'info',
        `Waypoint ${targetWaypoint.id} is on a different floor (Z:${targetWaypoint.z}). Skipping.`,
      );
      const advanced = await advanceToNextWaypoint();
      if (!advanced) {
        pathingLogger(
          'error',
          'Failed to advance during fast-skip. Breaking loop.',
        );
        return;
      }
      targetWaypoint = findCurrentWaypoint();
      if (!targetWaypoint) {
        fsmState = 'IDLE';
        return;
      }
    }

    // --- Interruption Check Logic ---
    if (lastProcessedWptId && targetWaypoint.id !== lastProcessedWptId) {
      pathingLogger(
        'info',
        `Target waypoint changed externally to ${targetWaypoint.id}. Resetting state.`,
      );
      fsmState = 'IDLE';
      path = [];
      pathfindingStatus = PATH_STATUS_IDLE;
    }
    lastProcessedWptId = targetWaypoint.id;

    const context = {
      playerPos: playerMinimapPosition,
      path: path,
      chebyshevDist: pathChebyshevDistance,
      targetWaypoint: targetWaypoint,
      status: pathfindingStatus,
    };

    const stateLogic = fsm[fsmState];
    if (stateLogic) {
      const nextState = await stateLogic.execute(context);
      if (nextState !== fsmState) {
        lastFsmState = fsmState;
        fsmState = nextState;
        const newStateLogic = fsm[fsmState];
        if (newStateLogic && newStateLogic.enter) newStateLogic.enter(context);
        pathingLogger(
          'info',
          `[FSM] Transition: ${lastFsmState} -> ${fsmState}`,
        );
      }
    } else {
      logger('error', `Invalid FSM state: ${fsmState}. Resetting to IDLE.`);
      fsmState = 'IDLE';
    }
  } finally {
    const opEnd = performance.now();
    operationCount++;
    totalOperationTime += opEnd - opStart;
  }
}

// --- Main Loop & Worker Lifecycle ---
async function mainLoop() {
  logger('info', '[CavebotWorker] Starting main loop...');
  while (!isShuttingDown) {
    const loopStart = performance.now();
    try {
      await performOperation();
      logPerformanceStats();
    } catch (error) {
      logger('error', '[CavebotWorker] Unhandled error in main loop:', error);
      fsmState = 'IDLE';
      await delay(100);
    }
    const loopEnd = performance.now();
    const elapsedTime = loopEnd - loopStart;
    const delayTime = Math.max(0, MAIN_LOOP_INTERVAL - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  logger('info', '[CavebotWorker] Main loop stopped.');
}

async function initializeWorker() {
  logger('info', 'Cavebot worker starting up...');
  try {
    luaExecutor = new CavebotLuaExecutor({
      logger,
      postStoreUpdate,
      getState: () => globalState,
      advanceToNextWaypoint,
      goToLabel,
      goToSection,
      goToWpt,
    });
    if (!(await luaExecutor.initialize()))
      throw new Error('LuaExecutor failed to initialize.');
    logger('info', 'Cavebot Lua Executor initialized successfully.');
  } catch (e) {
    logger('error', `Could not initialize Cavebot Lua Executor: ${e.message}`);
    luaExecutor = null;
  }
  isInitialized = true;
  logger('info', 'Cavebot worker initialization complete.');
}

parentPort.on('message', (message) => {
  try {
    if (message.type === 'state_diff') {
      if (!globalState) globalState = {};
      Object.assign(globalState, message.payload);
    } else if (message.type === 'shutdown') {
      isShuttingDown = true;
      if (luaExecutor) luaExecutor.destroy();
    } else if (typeof message === 'object' && !message.type) {
      if (!globalState) globalState = message;
      else Object.assign(globalState, message);
      if (!isInitialized) {
        initializeWorker().catch((error) => {
          logger(
            'error',
            '[CavebotWorker] Failed to initialize worker:',
            error,
          );
          process.exit(1);
        });
      }
    }
  } catch (error) {
    logger('error', '[CavebotWorker] Error handling message:', error);
  }
});

parentPort.on('close', () => {
  isShuttingDown = true;
  if (luaExecutor) luaExecutor.destroy();
  process.exit(0);
});

function startWorker() {
  logger('info', '[CavebotWorker] Worker starting up...');
  process.on('SIGTERM', () => {
    isShuttingDown = true;
  });
  process.on('SIGINT', () => {
    isShuttingDown = true;
  });
  mainLoop().catch((error) => {
    logger('error', '[CavebotWorker] Fatal error in main loop:', error);
    process.exit(1);
  });
}

try {
  if (!workerData) throw new Error('[CavebotWorker] Worker data not provided');
  startWorker();
} catch (error) {
  logger('error', '[CavebotWorker] Failed to start worker:', error);
  process.exit(1);
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/entityMonitor-backup.js
//start file
import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import findHealthBars from 'find-health-bars-native';
import findSequences from 'find-sequences-native';
import { getGameCoordinatesFromScreen } from '../utils/gameWorldClickTranslator.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
} from './sharedConstants.js';

// --- Worker Configuration & Setup ---
const { sharedData } = workerData;
const SCAN_INTERVAL_MS = 32;

if (!sharedData) {
  throw new Error('[EntityMonitor] Shared data not provided.');
}

const { imageSAB, syncSAB, playerPosSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const sharedBufferView = Buffer.from(imageSAB);

// --- SharedArrayBuffer Indices ---
const FRAME_COUNTER_INDEX = 0;
const WIDTH_INDEX = 1;
const HEIGHT_INDEX = 2;
const IS_RUNNING_INDEX = 3;

// --- Constellation Configuration ---
const CONSTELLATION_HORIZONTAL_POINTS = 10;
const CONSTELLATION_VERTICAL_POINTS = 8;
const SEQUENCE_LENGTH = 3;
const SEARCH_WINDOW_SIZE = 24;
const QUORUM_THRESHOLD = 0.8;

// --- State ---
let lastProcessedFrameCounter = -1;
let lastSentEntities = null;
let isShuttingDown = false;
let isScanning = false;
let gameWorld = null;
let tileSize = null;

// --- Motion Detection State ---
let isCalibrated = false;
let goldenConstellation = [];
let lastKnownPositions = [];
let lastPlayerPos = null;
const candidateIndices = [5, 15, 25, 35, 45, 55, 65, 75];
const verifierIndices = Array.from(
  { length: CONSTELLATION_HORIZONTAL_POINTS * CONSTELLATION_VERTICAL_POINTS },
  (_, i) => i,
);

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function calibrateConstellation(width, height) {
  console.log('[EntityMonitor] Calibrating motion detection constellation...');
  goldenConstellation = [];
  lastKnownPositions = [];

  const xStep = gameWorld.width / (CONSTELLATION_HORIZONTAL_POINTS + 1);
  const yStep = gameWorld.height / (CONSTELLATION_VERTICAL_POINTS + 1);

  for (let i = 1; i <= CONSTELLATION_VERTICAL_POINTS; i++) {
    for (let j = 1; j <= CONSTELLATION_HORIZONTAL_POINTS; j++) {
      const screenX = Math.round(gameWorld.x + j * xStep);
      const screenY = Math.round(gameWorld.y + i * yStep);

      if (screenX + SEQUENCE_LENGTH > width || screenY >= height) continue;

      const colors = [];
      for (let k = 0; k < SEQUENCE_LENGTH; k++) {
        const offset = (screenY * width + (screenX + k)) * 4;
        const r = sharedBufferView[offset + 2];
        const g = sharedBufferView[offset + 1];
        const b = sharedBufferView[offset + 0];
        colors.push([r, g, b]);
      }

      goldenConstellation.push({
        id: `point_${goldenConstellation.length}`,
        sequence: colors,
      });
      lastKnownPositions.push({ x: screenX, y: screenY });
    }
  }
  isCalibrated = true;
  console.log(
    `[EntityMonitor] Calibration complete. Acquired ${goldenConstellation.length} reference points.`,
  );
}

async function findGridOffset(width, height) {
  if (!isCalibrated) return { dx: 0, dy: 0 };

  for (const index of candidateIndices) {
    if (index >= goldenConstellation.length) continue;

    const candidate = goldenConstellation[index];
    const lastPos = lastKnownPositions[index];

    const searchTask = {
      findCandidate: {
        sequences: { [candidate.id]: { sequence: candidate.sequence } },
        searchArea: {
          x: Math.max(0, lastPos.x - SEARCH_WINDOW_SIZE / 2),
          y: Math.max(0, lastPos.y - SEARCH_WINDOW_SIZE / 2),
          width: SEARCH_WINDOW_SIZE,
          height: SEARCH_WINDOW_SIZE,
        },
        occurrence: 'first',
      },
    };

    const searchResult = await findSequences.findSequencesNativeBatch(
      sharedBufferView,
      searchTask,
    );

    if (searchResult?.findCandidate?.[candidate.id]) {
      const newPos = searchResult.findCandidate[candidate.id];
      const candidateVector = {
        dx: newPos.x - lastPos.x,
        dy: newPos.y - lastPos.y,
      };

      if (candidateVector.dx === 0 && candidateVector.dy === 0) {
        return candidateVector;
      }

      const verifyTask = {
        verifyQuorum: { pixelChecks: {}, searchArea: gameWorld },
      };
      let verifierCount = 0;
      for (const vIndex of verifierIndices) {
        if (vIndex >= goldenConstellation.length) continue;
        const verifier = goldenConstellation[vIndex];
        const verifierLastPos = lastKnownPositions[vIndex];
        const predictedX = verifierLastPos.x + candidateVector.dx;
        const predictedY = verifierLastPos.y + candidateVector.dy;
        const checkId = `v_${vIndex}`;

        const firstPixelColor = verifier.sequence[0];
        const colorHex = `#${firstPixelColor[0].toString(16).padStart(2, '0')}${firstPixelColor[1].toString(16).padStart(2, '0')}${firstPixelColor[2].toString(16).padStart(2, '0')}`;

        if (!verifyTask.verifyQuorum.pixelChecks[colorHex]) {
          verifyTask.verifyQuorum.pixelChecks[colorHex] = [];
        }
        verifyTask.verifyQuorum.pixelChecks[colorHex].push({
          x: predictedX,
          y: predictedY,
          id: checkId,
        });
        verifierCount++;
      }

      const verifyResult = await findSequences.findSequencesNativeBatch(
        sharedBufferView,
        verifyTask,
      );

      let matches = 0;
      if (verifyResult?.verifyQuorum) {
        matches = Object.keys(verifyResult.verifyQuorum).length;
      }

      if (verifierCount > 0 && matches / verifierCount >= QUORUM_THRESHOLD) {
        for (let i = 0; i < lastKnownPositions.length; i++) {
          lastKnownPositions[i].x += candidateVector.dx;
          lastKnownPositions[i].y += candidateVector.dy;
        }
        return candidateVector;
      }
    }
  }

  return { dx: 0, dy: 0 };
}

function deepCompareEntities(a, b) {
  if (!a && !b) return true;
  if (!a || !b || a.length !== b.length) return false;

  for (let i = 0; i < a.length; i++) {
    const entityA = a[i];
    const entityB = b[i];

    if (
      entityA.absoluteCoords.x !== entityB.absoluteCoords.x ||
      entityA.absoluteCoords.y !== entityB.absoluteCoords.y ||
      entityA.gameCoords.x !== entityB.gameCoords.x ||
      entityA.gameCoords.y !== entityB.gameCoords.y ||
      entityA.gameCoords.z !== entityB.gameCoords.z
    ) {
      return false;
    }
  }

  return true;
}

async function mainLoop() {
  console.log('[EntityMonitor] Starting main loop...');

  while (!isShuttingDown) {
    const loopStartTime = performance.now();

    try {
      if (isScanning) {
        await delay(32);
        continue;
      }

      if (
        !gameWorld ||
        gameWorld.width <= 0 ||
        gameWorld.height <= 0 ||
        !playerPosArray ||
        !tileSize ||
        !tileSize.height
      ) {
        await delay(SCAN_INTERVAL_MS);
        continue;
      }

      const newFrameCounter = Atomics.load(syncArray, FRAME_COUNTER_INDEX);

      if (newFrameCounter > lastProcessedFrameCounter) {
        lastProcessedFrameCounter = newFrameCounter;

        if (Atomics.load(syncArray, IS_RUNNING_INDEX) !== 1) {
          await delay(SCAN_INTERVAL_MS);
          continue;
        }

        const width = Atomics.load(syncArray, WIDTH_INDEX);
        const height = Atomics.load(syncArray, HEIGHT_INDEX);

        if (width > 0 && height > 0) {
          isScanning = true;
          try {
            const playerMinimapPosition = {
              x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
              y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
              z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
            };

            const playerMoved =
              !lastPlayerPos ||
              lastPlayerPos.x !== playerMinimapPosition.x ||
              lastPlayerPos.y !== playerMinimapPosition.y ||
              lastPlayerPos.z !== playerMinimapPosition.z;

            if (playerMoved) {
              await delay(100);
              isCalibrated = false;
            }

            if (!isCalibrated) {
              calibrateConstellation(width, height);
              lastPlayerPos = { ...playerMinimapPosition };
            }

            const gridOffset = await findGridOffset(width, height);

            const results = await findHealthBars.findHealthBars(
              sharedBufferView,
              gameWorld,
            );

            let entitiesWithCoords = [];
            if (results && results.length > 0) {
              entitiesWithCoords = results
                .map((r) => {
                  // The physical location of the health bar on screen this frame
                  const screenX = r.x;
                  const screenY = r.y;

                  // The "un-scrolled" logical coordinate to be used for game world translation
                  const correctedX = screenX - gridOffset.dx;
                  const correctedY = screenY - gridOffset.dy;

                  const gameCoords = getGameCoordinatesFromScreen(
                    correctedX,
                    correctedY,
                    playerMinimapPosition,
                    gameWorld,
                    tileSize,
                  );

                  if (!gameCoords) {
                    return null;
                  }

                  // --- Run the perfected static positioning logic on the corrected coordinates ---

                  // **FIX:** Check against the physical `screenY`, not the logical `correctedY`
                  const isOnTopRow =
                    screenY >= gameWorld.y &&
                    screenY < gameWorld.y + tileSize.height;

                  if (isOnTopRow) {
                    const topRowThresholdY =
                      gameWorld.y + tileSize.height * 0.6;
                    // **FIX:** Use the physical `screenY` for this check as well
                    if (screenY < topRowThresholdY) {
                      // Top 60% of top row: NO SHIFT
                    } else {
                      // Bottom 40% of top row: SHIFT
                      gameCoords.y += 1;
                    }
                  } else {
                    // Any other row: SHIFT
                    gameCoords.y += 1;
                  }
                  gameCoords.x = Math.round(gameCoords.x);
                  gameCoords.y = Math.round(gameCoords.y);
                  // --- End of static logic ---

                  gameCoords.z = playerMinimapPosition.z;

                  return {
                    absoluteCoords: { x: screenX, y: screenY }, // Report original screen coords
                    gameCoords: gameCoords, // Use fully corrected game coords
                  };
                })
                .filter(Boolean);

              entitiesWithCoords.sort((a, b) =>
                a.absoluteCoords.x !== b.absoluteCoords.x
                  ? a.absoluteCoords.x - b.absoluteCoords.x
                  : a.absoluteCoords.y - b.absoluteCoords.y,
              );
            }

            if (!deepCompareEntities(entitiesWithCoords, lastSentEntities)) {
              lastSentEntities = entitiesWithCoords;
              parentPort.postMessage({
                type: 'batch-update',
                payload: [
                  {
                    type: 'gameState/setPlayerMinimapPosition',
                    payload: playerMinimapPosition,
                  },
                  {
                    type: 'targeting/setEntities',
                    payload: entitiesWithCoords,
                  },
                ],
              });
            }
          } finally {
            isScanning = false;
          }
        }
      }
    } catch (err) {
      console.error('[EntityMonitor] Error in main loop:', err);
      isScanning = false;
    }

    const loopEndTime = performance.now();
    const elapsedTime = loopEndTime - loopStartTime;
    const delayTime = Math.max(0, SCAN_INTERVAL_MS - elapsedTime);
    if (delayTime > 0) {
      await delay(delayTime);
    }
  }
  console.log('[EntityMonitor] Main loop stopped.');
}

parentPort.on('message', (message) => {
  if (message.type === 'shutdown') {
    isShuttingDown = true;
  } else if (message.type === 'state_diff') {
    if (message.payload.regionCoordinates) {
      gameWorld = message.payload.regionCoordinates.regions?.gameWorld;
      tileSize = message.payload.regionCoordinates.regions?.tileSize;
    }
  } else if (typeof message === 'object' && !message.type && !message.command) {
    if (message.regionCoordinates) {
      gameWorld = message.regionCoordinates.regions?.gameWorld;
      tileSize = message.regionCoordinates.regions?.tileSize;
    }
  }
});

mainLoop().catch((err) => {
  console.error('[EntityMonitor] Fatal error in main loop:', err);
  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/entityMonitor.js
//start file
// entityMonitor.js (Updated)

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import findHealthBars from 'find-health-bars-native';
import { getGameCoordinatesFromScreen } from '../utils/gameWorldClickTranslator.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
} from './sharedConstants.js';

// --- Worker Configuration & Setup ---
const { sharedData } = workerData;
const SCAN_INTERVAL_MS = 32;

if (!sharedData) {
  throw new Error('[EntityMonitor] Shared data not provided.');
}

const { imageSAB, syncSAB, playerPosSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const sharedBufferView = Buffer.from(imageSAB);

// --- SharedArrayBuffer Indices ---
const FRAME_COUNTER_INDEX = 0;
const WIDTH_INDEX = 1;
const HEIGHT_INDEX = 2;
const IS_RUNNING_INDEX = 3;

// --- State ---
let lastProcessedFrameCounter = -1;
let lastSentEntities = null;
let isShuttingDown = false;
let isScanning = false;
let gameWorld = null; // To store the gameWorld region
let tileSize = null;

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function deepCompareEntities(a, b) {
  if (!a && !b) return true;
  if (!a || !b || a.length !== b.length) return false;

  for (let i = 0; i < a.length; i++) {
    const entityA = a[i];
    const entityB = b[i];

    if (
      entityA.absoluteCoords.x !== entityB.absoluteCoords.x ||
      entityA.absoluteCoords.y !== entityB.absoluteCoords.y ||
      entityA.gameCoords.x !== entityB.gameCoords.x ||
      entityA.gameCoords.y !== entityB.gameCoords.y ||
      entityA.gameCoords.z !== entityB.gameCoords.z
    ) {
      return false;
    }
  }

  return true;
}

async function mainLoop() {
  console.log('[EntityMonitor] Starting main loop...');

  while (!isShuttingDown) {
    const loopStartTime = performance.now();

    try {
      if (isScanning) {
        await delay(32);
        continue;
      }

      if (
        !gameWorld ||
        gameWorld.width <= 0 ||
        gameWorld.height <= 0 ||
        !playerPosArray ||
        !tileSize ||
        !tileSize.height
      ) {
        await delay(SCAN_INTERVAL_MS);
        continue;
      }

      const newFrameCounter = Atomics.load(syncArray, FRAME_COUNTER_INDEX);

      if (newFrameCounter > lastProcessedFrameCounter) {
        lastProcessedFrameCounter = newFrameCounter;

        if (Atomics.load(syncArray, IS_RUNNING_INDEX) !== 1) {
          await delay(SCAN_INTERVAL_MS);
          continue;
        }

        const width = Atomics.load(syncArray, WIDTH_INDEX);
        const height = Atomics.load(syncArray, HEIGHT_INDEX);

        if (width > 0 && height > 0) {
          isScanning = true;
          try {
            const results = await findHealthBars.findHealthBars(
              sharedBufferView,
              gameWorld,
            );

            const playerMinimapPosition = {
              x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
              y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
              z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
            };

            let entitiesWithCoords = [];
            if (results && results.length > 0) {
              entitiesWithCoords = results
                .map((r) => {
                  const screenX = r.x;
                  const screenY = r.y;

                  const gameCoords = getGameCoordinatesFromScreen(
                    screenX,
                    screenY,
                    playerMinimapPosition,
                    gameWorld,
                    tileSize,
                  );

                  if (!gameCoords) {
                    return null;
                  }

                  const isOnTopRow =
                    screenY >= gameWorld.y &&
                    screenY < gameWorld.y + tileSize.height;

                  if (isOnTopRow) {
                    const topRowThresholdY =
                      gameWorld.y + tileSize.height * 0.6;

                    if (screenY < topRowThresholdY) {
                      // Entity is on the same tile
                    } else {
                      gameCoords.y += 1; // Entity is on the tile below
                    }
                  } else {
                    gameCoords.y += 1; // Entity is on the tile below
                  }

                  gameCoords.x = Math.round(gameCoords.x);
                  gameCoords.y = Math.round(gameCoords.y);
                  gameCoords.z = playerMinimapPosition.z;

                  return {
                    absoluteCoords: { x: screenX, y: screenY },
                    gameCoords: gameCoords,
                  };
                })
                .filter(Boolean);

              entitiesWithCoords.sort((a, b) =>
                a.absoluteCoords.x !== b.absoluteCoords.x
                  ? a.absoluteCoords.x - b.absoluteCoords.x
                  : a.absoluteCoords.y - b.absoluteCoords.y,
              );
            }

            if (!deepCompareEntities(entitiesWithCoords, lastSentEntities)) {
              lastSentEntities = entitiesWithCoords;
              // --- FIX START: Removed player position update from this worker ---
              // The minimapMonitor is now responsible for this update.
              parentPort.postMessage({
                type: 'batch-update',
                payload: [
                  {
                    type: 'targeting/setEntities',
                    payload: entitiesWithCoords,
                  },
                ],
              });
              // --- FIX END ---
            }
          } finally {
            isScanning = false;
          }
        }
      }
    } catch (err) {
      console.error('[EntityMonitor] Error in main loop:', err);
      isScanning = false;
    }

    const loopEndTime = performance.now();
    const elapsedTime = loopEndTime - loopStartTime;
    const delayTime = Math.max(0, SCAN_INTERVAL_MS - elapsedTime);
    if (delayTime > 0) {
      await delay(delayTime);
    }
  }
  console.log('[EntityMonitor] Main loop stopped.');
}

parentPort.on('message', (message) => {
  if (message.type === 'shutdown') {
    console.log('[EntityMonitor] Received shutdown command.');
    isShuttingDown = true;
  } else if (message.type === 'state_diff') {
    if (message.payload.regionCoordinates) {
      gameWorld = message.payload.regionCoordinates.regions?.gameWorld;
      tileSize = message.payload.regionCoordinates.regions?.tileSize;
    }
  } else if (typeof message === 'object' && !message.type && !message.command) {
    if (message.regionCoordinates) {
      gameWorld = message.regionCoordinates.regions?.gameWorld;
      tileSize = message.regionCoordinates.regions?.tileSize;
    }
  }
});

mainLoop().catch((err) => {
  console.error('[EntityMonitor] Fatal error in main loop:', err);
  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/exposedLuaFunctions.js
//start file
import { getRandomNumber } from '../utils/getRandomNumber.js';

export const wait = async (min_ms, max_ms, refreshCallback = null) => {
  const delay = max_ms === undefined ? min_ms : getRandomNumber(min_ms, max_ms);
  return new Promise((resolve) =>
    setTimeout(() => {
      if (refreshCallback) {
        refreshCallback(); // Call the refresh callback after the delay
      }
      resolve();
    }, delay),
  );
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaApi.js
//start file
import {
  keyPress,
  keyPressMultiple,
  typeArray,
  rotate,
  getIsTyping,
} from '../keyboardControll/keyPress.js';
import mouseController from 'mouse-controller';
import { getAbsoluteGameWorldClickCoordinates } from '../utils/gameWorldClickTranslator.js';
import { getAbsoluteClickCoordinates } from '../utils/minimapClickTranslator.js';
import { wait } from './exposedLuaFunctions.js';
import {
  setActionPaused,
  setenabled as setCavebotEnabled,
} from '../../frontend/redux/slices/cavebotSlice.js';
import { setenabled as setRulesEnabled } from '../../frontend/redux/slices/ruleSlice.js';
import { setenabled as setTargetingEnabled } from '../../frontend/redux/slices/targetingSlice.js';
import { setenabled as setLuaEnabled } from '../../frontend/redux/slices/luaSlice.js';

/**
 * Creates an object with getters for convenient, direct access to state in Lua.
 * This object will be exposed globally in Lua as `__BOT_STATE__`.
 * @param {function} getState - A function that returns the latest full Redux state.
 * @param {'script'|'cavebot'} type - The type of worker, to determine which variables to expose.
 * @returns {object} The state shortcut object.
 */
const createStateShortcutObject = (getState, type) => {
  const shortcuts = {};
  Object.defineProperty(shortcuts, 'hppc', {
    get: () => getState().gameState?.hppc,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'mppc', {
    get: () => getState().gameState?.mppc,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isChatOff', {
    get: () => getState().gameState?.isChatOff,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'monsterNum', {
    get: () =>
      getState().regionCoordinates.regions.battleList?.children?.entries?.list
        ?.length,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'battleList', {
    get: () => ({
      entries:
        getState().regionCoordinates.regions.battleList?.children?.entries
          ?.list || [],
    }),
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'partyNum', {
    get: () => getState().gameState?.partyNum,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isTyping', {
    get: () => getState().gameState?.isTyping,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isOnline', {
    get: () => !!getState().regionCoordinates?.regions?.onlineMarker,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'activeTab', {
    get: () => getState().uiValues?.chatboxTabs?.activeTab || 'unknown',
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'actionItems', {
    get: () => {
      const hotkeyBarChildren =
        getState().regionCoordinates?.regions?.hotkeyBar?.children || {};
      return new Proxy(
        {},
        {
          get(target, prop) {
            const child = hotkeyBarChildren[prop];
            return !!(child && child.x !== undefined && child.y !== undefined);
          },
          has(target, prop) {
            return true;
          },
          ownKeys() {
            return Object.keys(hotkeyBarChildren);
          },
        },
      );
    },
    enumerable: true,
  });
  const gameState = getState().gameState;
  if (gameState && gameState.characterStatus) {
    for (const status in gameState.characterStatus) {
      Object.defineProperty(shortcuts, status, {
        get: () => getState().gameState.characterStatus[status],
        enumerable: true,
      });
    }
  }
  Object.defineProperty(shortcuts, 'pos', {
    get: () => {
      const pos = getState().gameState?.playerMinimapPosition || {};
      return { x: pos.x, y: pos.y, z: pos.z };
    },
    enumerable: true,
  });
  const cavebotState = getState().cavebot;
  if (type === 'cavebot' && cavebotState) {
    Object.defineProperty(shortcuts, 'cavebot', {
      get: () => getState().cavebot?.enabled,
      enumerable: true,
    });
    Object.defineProperty(shortcuts, 'section', {
      get: () =>
        getState().cavebot?.waypointSections[getState().cavebot?.currentSection]
          ?.name,
      enumerable: true,
    });
    Object.defineProperty(shortcuts, 'wpt', {
      get: () => {
        const currentCavebotState = getState().cavebot;
        const currentWaypoints =
          currentCavebotState?.waypointSections[
            currentCavebotState?.currentSection
          ]?.waypoints || [];
        const currentWptIndex = currentWaypoints.findIndex(
          (wp) => wp.id === currentCavebotState?.wptId,
        );
        const currentWpt =
          currentWptIndex !== -1 ? currentWaypoints[currentWptIndex] : null;
        if (currentWpt) {
          return {
            id: currentWptIndex + 1,
            x: currentWpt.x,
            y: currentWpt.y,
            z: currentWpt.z,
            type: currentWpt.type,
            label: currentWpt.label,
            distance: currentCavebotState.wptDistance,
          };
        }
        return null;
      },
      enumerable: true,
    });
  }
  Object.defineProperty(shortcuts, '$healing', {
    get: () => getState().rules?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, '$targeting', {
    get: () => getState().targeting?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, '$cavebot', {
    get: () => getState().cavebot?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, '$scripts', {
    get: () => getState().lua?.enabled,
    enumerable: true,
  });
  return shortcuts;
};

/**
 * Creates a consolidated API (functions and state object) to be exposed to a Lua environment.
 * @param {object} context - The context object from the calling worker.
 * @returns {{api: object, asyncFunctionNames: string[], stateObject: object}}
 */
export const createLuaApi = (context) => {
  const { onAsyncStart, onAsyncEnd } = context;
  const {
    type,
    getState,
    postSystemMessage,
    logger,
    id,
    refreshLuaGlobalState,
  } = context;
  const scriptName = type === 'script' ? `Script ${id}` : 'Cavebot';
  const asyncFunctionNames = [
    'wait',
    'keyPress',
    'keyPressMultiple',
    'type',
    'typeSequence',
    'rotate',
    'leftClick',
    'rightClick',
    'leftClickAbsolute',
    'rightClickAbsolute',
    'mapClick',
    'drag',
    'dragAbsolute',
    'focusTab',
    'login',
  ];
  const getWindowId = () => getState()?.global?.windowId;
  const getDisplay = () => getState()?.global?.display || ':0';
  const baseApi = {
    getDistanceTo: (x, y, z) => {
      const playerPos = getState().gameState?.playerMinimapPosition;
      if (!playerPos) return 9999;
      if (z !== undefined && playerPos.z !== z) return 9999;
      return Math.max(Math.abs(playerPos.x - x), Math.abs(playerPos.y - y));
    },
    isLocation: (range = 0) => {
      const state = getState();
      const playerPos = state.gameState?.playerMinimapPosition;
      const { waypointSections, currentSection, wptId } = state.cavebot;
      if (
        !playerPos ||
        !wptId ||
        !waypointSections ||
        !waypointSections[currentSection]
      )
        return false;
      const targetWpt = waypointSections[currentSection].waypoints.find(
        (wp) => wp.id === wptId,
      );
      if (!targetWpt || playerPos.z !== targetWpt.z) return false;
      return (
        Math.max(
          Math.abs(playerPos.x - targetWpt.x),
          Math.abs(playerPos.y - targetWpt.y),
        ) <= range
      );
    },
    log: (level, ...messages) =>
      logger(
        String(level).toLowerCase(),
        `[Lua/${scriptName}] ${messages.map(String).join(' ')}`,
      ),
    print: (...messages) => {
      const message = messages.map(String).join(' ');
      logger('info', `[Lua/${scriptName}] print: ${message}`);
      if (type === 'cavebot') {
        const scriptId = getState().cavebot.wptId;
        context.postStoreUpdate('cavebot/addWaypointLogEntry', {
          id: scriptId,
          message: message,
        });
      } else {
        context.postStoreUpdate('lua/addLogEntry', {
          id: id,
          message: message,
        });
      }
    },
    alert: () => postSystemMessage({ type: 'play_alert' }),
    wait: (min_ms, max_ms) => wait(min_ms, max_ms, refreshLuaGlobalState),
    keyPress: (key, modifier = null) =>
      keyPress(getDisplay(), key, { modifier }),
    keyPressMultiple: (key, count = 1, modifier = null, delayMs = 50) =>
      keyPressMultiple(getDisplay(), key, {
        count,
        modifier,
        delayMs,
      }),
    type: async (...args) => {
      const display = getDisplay();
      if (args.length === 0) {
        logger(
          'warn',
          `[Lua/${scriptName}] 'type' function called with no arguments.`,
        );
        return false;
      }

      let texts = [];
      let startAndEndWithEnter = true;

      const lastArg = args[args.length - 1];
      if (typeof lastArg === 'boolean') {
        startAndEndWithEnter = lastArg;
        texts = args.slice(0, -1);
      } else {
        texts = args;
      }

      const stringArgs = texts.map(String);

      if (stringArgs.length === 0) {
        logger(
          'warn',
          `[Lua/${scriptName}] 'type' function called without any text to type.`,
        );
        return false;
      }

      try {
        await typeArray(display, stringArgs, startAndEndWithEnter);
        return true;
      } catch (error) {
        logger(
          'error',
          `[Lua/${scriptName}] Error in 'type' function: ${error.message}`,
        );
        throw error;
      }
    },
    typeSequence: async (texts, delayBetween = 100) => {
      for (const text of texts) {
        await typeArray(getDisplay(), [text], true);
        if (delayBetween > 0) {
          await wait(delayBetween);
        }
      }
    },
    rotate: (direction) => rotate(getDisplay(), direction),
    isTyping: () => getIsTyping(),
    leftClick: async (x, y, position = 'bottomRight') => {
      const windowId = String(getWindowId());
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform game left-click: missing region data or player position`,
        );
        return false;
      }
      const clickCoords = getAbsoluteGameWorldClickCoordinates(
        x,
        y,
        playerPos,
        gameWorld,
        tileSize,
        position,
      );
      if (!clickCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform game left-click: invalid coordinates`,
        );
        return false;
      }
      mouseController.leftClick(
        parseInt(windowId),
        clickCoords.x,
        clickCoords.y,
        getDisplay(),
      );
      await wait(100);
      return true;
    },
    leftClickAbsolute: async (x, y) => {
      const windowId = String(getWindowId());
      mouseController.leftClick(parseInt(windowId), x, y, getDisplay());
      await wait(100);
      return true;
    },
    rightClickAbsolute: async (x, y) => {
      const windowId = String(getWindowId());
      mouseController.rightClick(parseInt(windowId), x, y, getDisplay());
      await wait(100);
      return true;
    },
    rightClick: async (x, y, position = 'bottomRight') => {
      const windowId = String(getWindowId());
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform game right-click: missing region data or player position`,
        );
        return false;
      }
      const clickCoords = getAbsoluteGameWorldClickCoordinates(
        x,
        y,
        playerPos,
        gameWorld,
        tileSize,
        position,
      );
      if (!clickCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform game right-click: invalid coordinates`,
        );
        return false;
      }
      mouseController.rightClick(
        parseInt(windowId),
        clickCoords.x,
        clickCoords.y,
        getDisplay(),
      );
      await wait(100);
      return true;
    },
    mapClick: async (x, y, position = 'center') => {
      const windowId = String(getWindowId());
      const state = getState();
      const minimapRegionDef = state.regionCoordinates?.regions?.minimapFull;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!minimapRegionDef || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform minimap click: missing region data or player position`,
        );
        return false;
      }
      const clickCoords = getAbsoluteClickCoordinates(
        x,
        y,
        playerPos,
        minimapRegionDef,
      );
      if (!clickCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform minimap click: invalid coordinates`,
        );
        return false;
      }
      mouseController.leftClick(
        parseInt(windowId),
        clickCoords.x,
        clickCoords.y,
        getDisplay(),
      );
      await wait(100);
      return true;
    },
    drag: async (startX, startY, endX, endY, button = 'left') => {
      const windowId = String(getWindowId());
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform drag: missing region data or player position`,
        );
        return false;
      }
      const startCoords = getAbsoluteGameWorldClickCoordinates(
        startX,
        startY,
        playerPos,
        gameWorld,
        tileSize,
        'bottomRight',
      );
      const endCoords = getAbsoluteGameWorldClickCoordinates(
        endX,
        endY,
        playerPos,
        gameWorld,
        tileSize,
        'bottomRight',
      );
      if (!startCoords || !endCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform drag: invalid coordinates`,
        );
        return false;
      }
      mouseController.mouseMove(
        parseInt(windowId),
        startCoords.x,
        startCoords.y,
        getDisplay(),
      );
      await wait(50);
      if (button === 'right') {
        mouseController.rightMouseDown(
          parseInt(windowId),
          startCoords.x,
          startCoords.y,
        );
      } else {
        mouseController.mouseDown(
          parseInt(windowId),
          startCoords.x,
          startCoords.y,
        );
      }
      await wait(100);
      mouseController.mouseMove(
        parseInt(windowId),
        endCoords.x,
        endCoords.y,
        getDisplay(),
      );
      await wait(100);
      if (button === 'right') {
        mouseController.rightMouseUp(
          parseInt(windowId),
          endCoords.x,
          endCoords.y,
        );
      } else {
        mouseController.mouseUp(
          parseInt(windowId),
          endCoords.x,
          endCoords.y,
          getDisplay(),
        );
      }
      await wait(100);
      return true;
    },
    dragAbsolute: async (startX, startY, endX, endY, button = 'left') => {
      const windowId = String(getWindowId());
      mouseController.mouseMove(
        parseInt(windowId),
        startX,
        startY,
        getDisplay(),
      );
      await wait(50);
      if (button === 'right') {
        mouseController.rightMouseDown(
          parseInt(windowId),
          startX,
          startY,
          getDisplay(),
        );
      } else {
        mouseController.mouseDown(
          parseInt(windowId),
          startX,
          startY,
          getDisplay(),
        );
      }
      await wait(100);
      mouseController.mouseMove(parseInt(windowId), endX, endY, getDisplay());
      await wait(100);
      if (button === 'right') {
        mouseController.rightMouseUp(
          parseInt(windowId),
          endX,
          endY,
          getDisplay(),
        );
      } else {
        mouseController.mouseUp(parseInt(windowId), endX, endY, getDisplay());
      }
      await wait(100);
      return true;
    },
    tileToCoordinate: (tileX, tileY, position = 'bottomRight') => {
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot convert tile to coordinate: missing region data`,
        );
        return null;
      }
      const coords = getAbsoluteGameWorldClickCoordinates(
        tileX,
        tileY,
        playerPos,
        gameWorld,
        tileSize,
        position,
      );
      return coords ? { x: coords.x, y: coords.y } : null;
    },
    coordinateToTile: (screenX, screenY) => {
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot convert coordinate to tile: missing region data`,
        );
        return null;
      }
      const relX = screenX - gameWorld.x;
      const relY = screenY - gameWorld.y;
      const tileX =
        Math.floor(relX / tileSize.width) +
        playerPos.x -
        Math.floor(gameWorld.width / tileSize.width / 2);
      const tileY =
        Math.floor(relY / tileSize.height) +
        playerPos.y -
        Math.floor(gameWorld.height / tileSize.height / 2);
      return { x: tileX, y: tileY };
    },
    focusTab: async (tabName) => {
      const state = getState();
      const tabs = state.uiValues?.chatboxTabs?.tabs;
      if (!tabs || !tabName) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot focus tab: missing tab data or tab name`,
        );
        return false;
      }
      const tab = tabs[tabName];
      if (!tab || !tab.tabPosition) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot focus tab: tab "${tabName}" not found or missing position`,
        );
        return false;
      }
      const windowId = String(getWindowId());
      const { x, y } = tab.tabPosition;
      mouseController.leftClick(parseInt(windowId), x, y, getDisplay());
      await wait(100);
      return true;
    },
    setTargeting: (enabled) => {
      context.postStoreUpdate('targeting/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Targeting ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    setHealing: (enabled) => {
      context.postStoreUpdate('rules/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Healing (rules) ${
          enabled ? 'enabled' : 'disabled'
        }`,
      );
    },
    setCavebot: (enabled) => {
      context.postStoreUpdate('cavebot/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Cavebot ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    setScripts: (enabled) => {
      context.postStoreUpdate('lua/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Scripts ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    login: async (email, password, character) => {
      const windowId = String(getWindowId());
      const display = getDisplay();
      let state = getState();
      if (state.regionCoordinates?.regions?.onlineMarker) {
        logger(
          'info',
          `[Lua/${scriptName}] Player is already online, skipping login`,
        );
        return false;
      }

      const modalsToClose = [
        { name: 'pleaseWaitModal' },
        { name: 'ipChangedModal' },
        { name: 'wrongPasswordModal' },
        { name: 'connectionLostModal' },
        { name: 'connectionFailedModal' },
        { name: 'warningModal' },
        { name: 'notLoggedInAnymoreModal' },
      ];
      let closedAModal;
      do {
        closedAModal = false;
        state = getState();
        const regions = state.regionCoordinates?.regions;
        if (regions) {
          for (const modalInfo of modalsToClose) {
            const modal = regions[modalInfo.name];
            const button =
              modal?.children?.abort ||
              modal?.children?.close ||
              modal?.children?.ok;
            if (button?.x && button?.y) {
              logger('info', `[Lua/${scriptName}] Closing '${modalInfo.name}'`);
              if (
                modalInfo.name === 'ipChangedModal' ||
                modalInfo.name === 'notLoggedInAnymoreModal'
              ) {
                await keyPress(display, 'Escape');
                await wait(200);
                await keyPress(display, 'Escape');
                await wait(200);
              } else {
                mouseController.leftClick(
                  parseInt(windowId),
                  button.x,
                  button.y,
                  display,
                );
                await wait(200);
              }
              closedAModal = true;
              break;
            }
          }
        }
      } while (closedAModal);
      state = getState();
      let selectCharacterModal =
        state.regionCoordinates?.regions?.selectCharacterModal;
      if (selectCharacterModal) {
        logger(
          'info',
          `[Lua/${scriptName}] Already at character selection, skipping login form.`,
        );
      } else {
        logger(
          'info',
          `[Lua/${scriptName}] Starting login process for character: ${character}`,
        );
        const loginModal = state.regionCoordinates?.regions?.loginModal;
        if (!loginModal) {
          logger('warn', `[Lua/${scriptName}] loginModal not found`);
          return false;
        }
        await keyPress(display, 'Escape');
        await wait(100);
        const emailInput = loginModal.children?.emailInput;
        if (!emailInput) {
          logger('warn', `[Lua/${scriptName}] emailInput not found`);
          return false;
        }
        mouseController.leftClick(
          parseInt(windowId),
          emailInput.x,
          emailInput.y,
          display,
        );
        await wait(50);
        await typeArray(display, [email], false);
        await wait(100);
        const passwordInput = loginModal.children?.passwordInput;
        if (!passwordInput) {
          logger('warn', `[Lua/${scriptName}] passwordInput not found`);
          return false;
        }
        mouseController.leftClick(
          parseInt(windowId),
          passwordInput.x,
          passwordInput.y,
          display,
        );
        await wait(50);
        await typeArray(display, [password], false);
        await wait(100);
        await keyPress(display, 'Enter');
        await wait(200);
      }
      let currentState = getState();
      selectCharacterModal =
        currentState.regionCoordinates?.regions?.selectCharacterModal;
      const maxWaitForModal = 10000;
      const modalCheckInterval = 500;
      let modalWaitTime = 0;
      let connectingModalWasSeen = false;
      while (!selectCharacterModal && modalWaitTime < maxWaitForModal) {
        await wait(modalCheckInterval);
        modalWaitTime += modalCheckInterval;
        currentState = getState();
        const regions = currentState.regionCoordinates?.regions;
        selectCharacterModal = regions?.selectCharacterModal;
        const connectingModal = regions?.connectingModal;
        if (connectingModal) {
          connectingModalWasSeen = true;
        }
        if (
          connectingModalWasSeen &&
          !connectingModal &&
          !selectCharacterModal
        ) {
          logger(
            'warn',
            `[Lua/${scriptName}] Connection stalled or failed. Aborting login.`,
          );
          for (let i = 0; i < 3; i++) {
            await keyPress(display, 'Escape');
            await wait(100);
          }
          return false;
        }
      }
      if (!selectCharacterModal) {
        logger(
          'warn',
          `[Lua/${scriptName}] selectCharacterModal not found after login attempt (waited ${modalWaitTime}ms)`,
        );
        return false;
      }
      const characterData = currentState.uiValues?.selectCharacterModal;
      if (!characterData || !characterData.characters) {
        logger('warn', `[Lua/${scriptName}] No character data for selection`);
        return false;
      }
      let characters = characterData.characters;
      let characterNames = Object.keys(characters);
      const targetCharacterLower = character.toLowerCase();
      let targetCharacterFound = characterNames.find((name) =>
        name.toLowerCase().includes(targetCharacterLower),
      );
      if (!targetCharacterFound) {
        await keyPress(display, character[0]);
        await wait(100);
        currentState = getState();
        const updatedCharacterData =
          currentState.uiValues?.selectCharacterModal;
        if (updatedCharacterData && updatedCharacterData.characters) {
          characters = updatedCharacterData.characters;
          characterNames = Object.keys(characters);
          targetCharacterFound = characterNames.find((name) =>
            name.toLowerCase().includes(targetCharacterLower),
          );
        }
      }
      if (!targetCharacterFound) {
        logger(
          'warn',
          `[Lua/${scriptName}] Target character '${character}' not found in list`,
        );
        return false;
      }
      const characterItem = characters[targetCharacterFound];
      if (!characterItem || !characterItem.position) {
        logger(
          'warn',
          `[Lua/${scriptName}] Could not find coordinates for character '${targetCharacterFound}'`,
        );
        return false;
      }

      mouseController.leftClick(
        parseInt(windowId),
        characterItem.position.x,
        characterItem.position.y,
        display,
      );
      await wait(100);
      await keyPress(display, 'Enter');
      const maxWaitTime = 10000;
      const checkInterval = 200;
      let elapsedTime = 0;
      while (elapsedTime < maxWaitTime) {
        await wait(checkInterval);
        elapsedTime += checkInterval;
        const finalState = getState();
        if (!!finalState.regionCoordinates?.regions?.onlineMarker) {
          logger(
            'info',
            `[Lua/${scriptName}] Login successful, player is online`,
          );
          return true;
        }
      }

      logger(
        'warn',
        `[Lua/${scriptName}] Login timeout, player did not come online`,
      );
      return false;
    },
  };
  let navigationApi = {};
  if (type === 'cavebot') {
    navigationApi = {
      skipWaypoint: context.advanceToNextWaypoint,
      goToLabel: context.goToLabel,
      goToSection: context.goToSection,
      goToWpt: context.goToWpt,
      pauseActions: (paused) =>
        context.postStoreUpdate('cavebot/setActionPaused', !!paused),
      setCavebotEnabled: (enabled) =>
        context.postStoreUpdate('cavebot/setenabled', !!enabled),
    };
  } else {
    navigationApi = {
      skipWaypoint: () => {
        const state = getState();
        const { waypointSections, currentSection, wptId } = state.cavebot;
        const waypoints = waypointSections[currentSection]?.waypoints || [];
        const currentIndex = waypoints.findIndex((wp) => wp.id === wptId);
        if (currentIndex === -1) return;
        const nextIndex = (currentIndex + 1) % waypoints.length;
        if (waypoints[nextIndex])
          context.postStoreUpdate('cavebot/setwptId', waypoints[nextIndex].id);
      },
      goToLabel: (label) => {
        const state = getState();
        const targetWpt = state.cavebot.waypointSections[
          state.cavebot.currentSection
        ]?.waypoints.find((wp) => wp.label === label);
        if (targetWpt)
          context.postStoreUpdate('cavebot/setwptId', targetWpt.id);
      },
      goToSection: (sectionName) => {
        const state = getState();
        const foundEntry = Object.entries(state.cavebot.waypointSections).find(
          ([, s]) => s.name === sectionName,
        );
        if (foundEntry) {
          const [targetSectionId, targetSection] = foundEntry;
          if (targetSection.waypoints?.length > 0) {
            context.postStoreUpdate(
              'cavebot/setCurrentWaypointSection',
              targetSectionId,
            );
            context.postStoreUpdate(
              'cavebot/setwptId',
              targetSection.waypoints[0].id,
            );
          }
        }
      },
      goToWpt: (index) => {
        const arrayIndex = parseInt(index, 10) - 1;
        if (isNaN(arrayIndex) || arrayIndex < 0) return;
        const state = getState();
        const waypoints =
          state.cavebot.waypointSections[state.cavebot.currentSection]
            ?.waypoints || [];
        if (arrayIndex < waypoints.length)
          context.postStoreUpdate('cavebot/setwptId', waypoints[arrayIndex].id);
      },
      pauseActions: (paused) =>
        context.postStoreUpdate('cavebot/setActionPaused', !!paused),
    };
  }
  const api = { ...baseApi, ...navigationApi };
  const stateObject = createStateShortcutObject(getState, type);
  const asyncApiFunctionSet = new Set(asyncFunctionNames);
  const apiProxy = new Proxy(api, {
    get(target, prop, receiver) {
      const originalMember = target[prop];
      if (
        typeof originalMember === 'function' &&
        asyncApiFunctionSet.has(prop)
      ) {
        return async (...args) => {
          if (onAsyncStart) {
            onAsyncStart();
          }
          try {
            return await originalMember.apply(target, args);
          } finally {
            if (onAsyncEnd) {
              onAsyncEnd();
            }
          }
        };
      }
      return Reflect.get(target, prop, receiver);
    },
  });
  return { api: apiProxy, asyncFunctionNames, stateObject };
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaScriptProcessor.js
//start file
/**
 * @fileoverview Centralized processor for preparing Lua scripts for execution.
 * This module contains utility functions for manipulating Lua script code before
 * it is run by the wasmoon engine.
 */
/**
 * Replaces convenient '$' prefixed variables with their valid, secret internal counterparts.
 * This uses a regular expression to safely replace `$var` with `__BOT_STATE__.var`
 * to avoid conflicts with user-defined variables.
 *
 * @param {string} code - The raw Lua code from the user.
 * @returns {string} The processed code with valid Lua syntax.
 */
const replaceShortcutVariables = (code) => {
  // This regex finds a literal '$' followed by a valid Lua identifier
  // (starts with a letter or underscore, followed by letters, numbers, or underscores).
  const regex = /\$([a-zA-Z_][a-zA-Z0-9_]*)/g;
  // The replacement string '__BOT_STATE__.$1' uses the captured group ($1)
  // to construct the valid Lua code, e.g., '$hp' becomes '__BOT_STATE__.hp'.
  return code.replace(regex, '__BOT_STATE__.$1');
};

/**
 * Preprocesses a raw Lua script string to handle custom syntax.
 * This now runs as a two-step process:
 * 1. Replaces '$' shortcut variables (e.g., `$hp`) with their valid form (`__BOT_STATE__.hp`).
 * 2. Appends `:await()` to specified async function calls for wasmoon compatibility.
 *
 * @param {string} scriptCode - The raw Lua script to preprocess.
 * @param {string[]} asyncFunctionNames - A list of function names that are asynchronous and return Promises.
 * @returns {string} The fully processed script with valid syntax, ready for execution.
 */
export function preprocessLuaScript(scriptCode, asyncFunctionNames) {
  // Step 1: Replace $ variables
  let processedCode = replaceShortcutVariables(scriptCode);

  if (!asyncFunctionNames || asyncFunctionNames.length === 0) {
    return processedCode;
  }

  // Build regex for async functions
  const funcNamePattern = asyncFunctionNames.join('|');

  // This regex matches function calls that don't already have :await()
  const regex = new RegExp(
    `\\b(${funcNamePattern})\\s*\\((?:[^()]*|\\([^)]*\\))*\\)(?!:await\\(\\))`,
    'g',
  );

  processedCode = processedCode.replace(regex, (match) => {
    return `${match}:await()`;
  });

  return processedCode;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaScriptWorker.js
//start file
// luaScriptWorker.js  (drop-in replacement)

import { parentPort, workerData, threadId } from 'worker_threads';
import { LuaFactory } from 'wasmoon';
import { createLogger } from '../utils/logger.js';
import { createLuaApi } from './luaApi.js';
import { preprocessLuaScript } from './luaScriptProcessor.js';

const log = createLogger();
let lua;
let currentState = {};
let scriptConfig = {};
let loopInterval = null;
let asyncFunctionNames = [];
let keepAliveInterval = null;

// --- State machine to prevent shutdown during init ---
let workerState = 'pending'; // 'pending' | 'initializing' | 'running'
let shutdownRequested = false;

// --- Active async operation counter ---
let activeAsyncOperations = 0;
const onAsyncStart = () => activeAsyncOperations++;
const onAsyncEnd = () => activeAsyncOperations--;

// NEW: lazy pull handle
const getFreshState = () =>
  new Promise((res) => {
    const onSnap = (msg) => {
      if (msg.type === 'state_snapshot') {
        parentPort.off('message', onSnap);
        res(msg.payload);
      }
    };
    parentPort.on('message', onSnap);
    parentPort.postMessage({ type: 'request_state_snapshot' });
  });

const postStoreUpdate = (type, payload) => {
  parentPort.postMessage({ storeUpdate: true, type, payload });
};

const keepAlive = () => {
  if (keepAliveInterval) return;
  keepAliveInterval = setInterval(() => {}, 60 * 60 * 1000);
};

const cleanupAndExit = async () => {
  log(
    'info',
    `[Lua Script Worker ${scriptConfig.id}] Cleaning up and exiting.`,
  );
  stopScriptLoop();
  if (keepAliveInterval) clearInterval(keepAliveInterval);

  const maxWait = 5000;
  const start = Date.now();
  while (activeAsyncOperations > 0 && Date.now() - start < maxWait) {
    log(
      'info',
      `[Lua Script Worker ${scriptConfig.id}] Waiting for ${activeAsyncOperations} async ops…`,
    );
    await new Promise((r) => setTimeout(r, 100));
  }

  if (lua) {
    try {
      lua.global.close();
    } catch (e) {
      log(
        'error',
        `[Lua Script Worker ${scriptConfig.id}] close error: ${e.message}`,
      );
    }
  }
  process.exit(0);
};

const initializeLuaVM = async () => {
  log('info', `[Lua Script Worker ${scriptConfig.id}] Initializing Lua VM…`);
  try {
    const factory = new LuaFactory();
    lua = await factory.createEngine();
    log('info', `[Lua Script Worker ${scriptConfig.id}] Lua VM ready.`);
  } catch (error) {
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] VM init failed:`,
      error,
    );
    throw error;
  }
};

const _syncApiToLua = () => {
  if (!lua) return;
  const {
    api,
    asyncFunctionNames: newNames,
    stateObject,
  } = createLuaApi({
    type: 'script',
    getState: () => currentState,
    postSystemMessage: (m) => parentPort.postMessage(m),
    logger: log,
    id: scriptConfig.id,
    postStoreUpdate,
    refreshLuaGlobalState: _syncApiToLua,
    onAsyncStart,
    onAsyncEnd,
    getFreshState, // <-- expose lazy pull
  });
  asyncFunctionNames = newNames;
  for (const fn in api) lua.global.set(fn, api[fn]);
  lua.global.set('__BOT_STATE__', stateObject);
};

const refreshLuaGlobalState = () => {
  _syncApiToLua();
  log(
    'debug',
    `[Lua Script Worker ${scriptConfig.id}] Lua global state refreshed.`,
  );
};

const executeOneShot = async () => {
  log(
    'info',
    `[Lua Script Worker ${scriptConfig.id}] Executing one-shot script.`,
  );
  if (!lua || !scriptConfig.code?.trim()) {
    postStoreUpdate('lua/addLogEntry', {
      id: scriptConfig.id,
      message: '[ERROR] No script code provided or Lua VM not ready.',
    });
    return;
  }
  try {
    _syncApiToLua();
    const processedCode = preprocessLuaScript(
      scriptConfig.code,
      asyncFunctionNames,
    );
    console.log('About to execute Lua code:', processedCode);
    await lua.doString(processedCode);
    console.log('Lua code execution completed');
  } catch (error) {
    const msg = error.message || String(error);
    console.error('Lua execution error:', msg, error.stack);
    log('error', `[Lua Script Worker ${scriptConfig.id}] loop error:`, msg);
    postStoreUpdate('lua/addLogEntry', {
      id: scriptConfig.id,
      message: `[ERROR] ${msg}`,
    });
  }
};

const executeScriptLoop = async () => {
  if (!lua) return stopScriptLoop();
  if (!scriptConfig.code?.trim()) {
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] Script empty; skipping.`,
    );
  } else {
    try {
      _syncApiToLua();
      await lua.doString(
        preprocessLuaScript(scriptConfig.code, asyncFunctionNames),
      );
    } catch (error) {
      const msg = error.message || String(error);
      log('error', `[Lua Script Worker ${scriptConfig.id}] loop error:`, msg);
      postStoreUpdate('lua/addLogEntry', {
        id: scriptConfig.id,
        message: `[ERROR] ${msg}`,
      });
    }
  }
  const min = scriptConfig.loopMin || 100;
  const max = scriptConfig.loopMax || 200;
  const delay = Math.floor(Math.random() * (max - min + 1)) + min;
  loopInterval = setTimeout(executeScriptLoop, delay);
};

const startScriptLoop = () => {
  if (loopInterval) clearTimeout(loopInterval);
  log('info', `[Lua Script Worker ${scriptConfig.id}] Starting script loop.`);
  executeScriptLoop();
};

const stopScriptLoop = () => {
  if (loopInterval) {
    log('info', `[Lua Script Worker ${scriptConfig.id}] Stopping script loop.`);
    clearTimeout(loopInterval);
    loopInterval = null;
  }
};

/* ------------ message router ------------ */
parentPort.on('message', async (message) => {
  if (message.type === 'shutdown') {
    shutdownRequested = true;
    if (workerState === 'running') await cleanupAndExit();
    return;
  }

  if (message.type === 'init') {
    workerState = 'initializing';
    scriptConfig = message.script;
    log('info', `[Lua Script Worker ${scriptConfig.id}] Init`, scriptConfig);

    await initializeLuaVM();
    if (shutdownRequested) {
      await cleanupAndExit();
      return;
    }

    workerState = 'running';
    _syncApiToLua();

    if (scriptConfig.type === 'oneshot') {
      await executeOneShot();
    } else {
      startScriptLoop();
      keepAlive();
    }
    return;
  }

  if (message.type === 'update') {
    scriptConfig = message.script;
    return;
  }

  if (message.type === 'state_diff') {
    Object.assign(currentState, message.payload);
    if (workerState === 'running') refreshLuaGlobalState();
  } else if (message.type === undefined) {
    // initial full state
    currentState = message;
    if (workerState === 'running') refreshLuaGlobalState();
  }
});

parentPort.on('close', async () => {
  log('info', `[Lua Script Worker ${scriptConfig.id}] Parent port closed.`);
  await cleanupAndExit();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/config.js
//start file
import { PALETTE_DATA } from '../../constants/palette.js';

// --- Worker Timing ---
export const MAIN_LOOP_INTERVAL = 32;
export const MAX_FRAME_FALLBEHIND = 15;
// --- Performance Logging ---
export const PERFORMANCE_LOGGING_ENABLED = false; // Set to false to disable logging
export const PERFORMANCE_LOG_INTERVAL_MS = 10000; // Log stats every 10 seconds

// --- SharedArrayBuffer (SAB) Indices ---
export const FRAME_COUNTER_INDEX = 0;
// ... (rest of the file is unchanged)
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

// --- Image Buffer Constants ---
export const HEADER_SIZE = 8;
export const BYTES_PER_PIXEL = 4;

// --- Minimap Specifics ---
export const MINIMAP_WIDTH = 106;
export const MINIMAP_HEIGHT = 109;

/**
 * A pre-computed map for fast lookups of a color's 8-bit palette index.
 * Key: An integer representing an RGB color (e.g., (r << 16) | (g << 8) | b).
 * Value: The 8-bit index from the palette.
 */
export const colorToIndexMap = new Map();
PALETTE_DATA.forEach((color, index) => {
  const intKey = (color.r << 16) | (color.g << 8) | color.b;
  colorToIndexMap.set(intKey, index);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/core.js
//start file
import { parentPort, workerData } from 'worker_threads';
import {
  MinimapMatcher,
  setMinimapResourcesPath,
} from '../../utils/minimapMatcher.js';
import * as config from './config.js';
import { rectsIntersect, extractBGRA } from './helpers.js';
import { processMinimapData } from './processing.js';
import { PerformanceTracker } from './performanceTracker.js';

// --- Worker State ---
let currentState = null;
let isShuttingDown = false;
let isInitialized = false;
let lastProcessedFrameCounter = -1;
let lastKnownMinimapFull = null;
let lastKnownMinimapFloor = null;
let minimapMatcher = null;

// --- Performance Tracking State ---
const perfTracker = new PerformanceTracker();
let lastPerfReportTime = Date.now();

// --- Shared Buffer Setup ---
if (!workerData.sharedData)
  throw new Error('[MinimapCore] Shared data not provided.');
const { imageSAB, syncSAB } = workerData.sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

async function initialize() {
  console.log('[MinimapCore] Initializing...');
  setMinimapResourcesPath(workerData.paths.minimapResources);
  minimapMatcher = new MinimapMatcher();
  await minimapMatcher.loadMapData();
  isInitialized = true;
  console.log('[MinimapCore] Initialized successfully.');
}

async function performOperation() {
  if (!isInitialized || !currentState?.regionCoordinates?.regions) {
    return;
  }

  const newFrameCounter = Atomics.load(syncArray, config.FRAME_COUNTER_INDEX);
  if (
    newFrameCounter <= lastProcessedFrameCounter ||
    Atomics.load(syncArray, config.IS_RUNNING_INDEX) === 0
  ) {
    return;
  }

  const { minimapFull, minimapFloorIndicatorColumn } =
    currentState.regionCoordinates.regions;
  const screenWidth = Atomics.load(syncArray, config.WIDTH_INDEX);
  if (!minimapFull || !minimapFloorIndicatorColumn || screenWidth <= 0) return;

  let needsProcessing = false;
  const dirtyRegionCount = Atomics.load(
    syncArray,
    config.DIRTY_REGION_COUNT_INDEX,
  );
  for (let i = 0; i < dirtyRegionCount; i++) {
    const offset = config.DIRTY_REGIONS_START_INDEX + i * 4;
    const dirtyRect = {
      x: Atomics.load(syncArray, offset + 0),
      y: Atomics.load(syncArray, offset + 1),
      width: Atomics.load(syncArray, offset + 2),
      height: Atomics.load(syncArray, offset + 3),
    };
    if (
      rectsIntersect(minimapFull, dirtyRect) ||
      rectsIntersect(minimapFloorIndicatorColumn, dirtyRect)
    ) {
      needsProcessing = true;
      break;
    }
  }

  // --- Robust Frame-Based Fallback Logic ---
  const framesBehind = newFrameCounter - lastProcessedFrameCounter;
  const isFallbackTriggered = framesBehind > config.MAX_FRAME_FALLBEHIND;

  if (needsProcessing || isFallbackTriggered) {
    // Update the counter to prevent reprocessing the same frame.
    lastProcessedFrameCounter = newFrameCounter;

    const minimapData = extractBGRA(sharedBufferView, screenWidth, minimapFull);
    const floorIndicatorData = extractBGRA(
      sharedBufferView,
      screenWidth,
      minimapFloorIndicatorColumn,
    );

    if (minimapData && floorIndicatorData) {
      const duration = await processMinimapData(
        minimapData,
        floorIndicatorData,
        minimapMatcher,
        workerData,
      );
      if (typeof duration === 'number') {
        perfTracker.addMeasurement(duration);
      }
    }
  }
}

/**
 * Checks if it's time to log performance stats and does so if needed.
 */
function logPerformanceReport() {
  if (!config.PERFORMANCE_LOGGING_ENABLED) return;

  const now = Date.now();
  if (now - lastPerfReportTime >= config.PERFORMANCE_LOG_INTERVAL_MS) {
    console.log(perfTracker.getReport());
    perfTracker.reset(); // Reset for the next interval
    lastPerfReportTime = now;
  }
}

async function mainLoop() {
  while (!isShuttingDown) {
    const loopStart = Date.now();
    try {
      await performOperation();
      logPerformanceReport(); // Call the report logger every loop
    } catch (error) {
      console.error('[MinimapCore] Error in main loop:', error);
    }
    const elapsedTime = Date.now() - loopStart;
    const delayTime = Math.max(0, config.MAIN_LOOP_INTERVAL - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  console.log('[MinimapCore] Main loop stopped.');
}

function handleMessage(message) {
  if (message.type === 'shutdown') {
    console.log('[MinimapCore] Received shutdown command.');
    isShuttingDown = true;
  } else if (message.type === 'state_diff') {
    if (!currentState) currentState = {};
    Object.assign(currentState, message.payload);
  } else if (typeof message === 'object' && !message.type) {
    currentState = message;
    if (!isInitialized) {
      initialize().catch((err) => {
        console.error('[MinimapCore] Initialization failed:', err);
        process.exit(1);
      });
    }
  }
}

export function start() {
  console.log('[MinimapCore] Worker starting up.');
  parentPort.on('message', handleMessage);
  mainLoop();
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/helpers.js
//start file
import { HEADER_SIZE, BYTES_PER_PIXEL } from './config.js';

/**
 * Checks if two rectangle objects intersect.
 * @returns {boolean} True if the rectangles overlap.
 */
export function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

/**
 * Extracts a rectangular region of raw BGRA pixel data from a larger buffer.
 * @param {Buffer} sourceBuffer - The full screen capture buffer.
 * @param {number} sourceWidth - The width of the full screen capture.
 * @param {object} rect - The {x, y, width, height} of the region to extract.
 * @returns {Buffer|null} A new Buffer containing the extracted region, or null on error.
 */
export function extractBGRA(sourceBuffer, sourceWidth, rect) {
  if (!rect || rect.width <= 0 || rect.height <= 0) {
    return null;
  }

  const targetSize = rect.width * rect.height * BYTES_PER_PIXEL;
  const targetBuffer = Buffer.alloc(targetSize);

  for (let y = 0; y < rect.height; y++) {
    const sourceY = rect.y + y;
    const sourceRowStart =
      HEADER_SIZE + (sourceY * sourceWidth + rect.x) * BYTES_PER_PIXEL;
    const targetRowStart = y * rect.width * BYTES_PER_PIXEL;

    if (
      sourceRowStart < 0 ||
      sourceRowStart + rect.width * BYTES_PER_PIXEL > sourceBuffer.length
    ) {
      console.error('[MinimapHelpers] Buffer copy out of bounds.');
      return null;
    }

    sourceBuffer.copy(
      targetBuffer,
      targetRowStart,
      sourceRowStart,
      sourceRowStart + rect.width * BYTES_PER_PIXEL,
    );
  }

  return targetBuffer;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  /**
   * Resets all statistics to their initial state.
   */
  reset() {
    this.times = [];
    this.minTime = Infinity;
    this.maxTime = 0;
    this.totalTime = 0;
  }

  /**
   * Adds a new duration measurement to the tracker.
   * @param {number} duration - The time in milliseconds for an operation.
   */
  addMeasurement(duration) {
    this.times.push(duration);
    this.totalTime += duration;
    if (duration < this.minTime) this.minTime = duration;
    if (duration > this.maxTime) this.maxTime = duration;
  }

  /**
   * Calculates the median from the collected times.
   * @returns {number} The median value.
   */
  _calculateMedian() {
    const sorted = [...this.times].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    }
    return sorted[mid];
  }

  /**
   * Generates a formatted string of the current performance statistics.
   * @returns {string|null} A report string or null if no data is available.
   */
  getReport() {
    const iterations = this.times.length;
    if (iterations === 0) {
      return '[MinimapPerformance] No successful operations in the last period.';
    }

    const avg = this.totalTime / iterations;
    const median = this._calculateMedian();

    const report = [
      '[MinimapPerformance] Stats:',
      `${iterations} iterations |`,
      `Avg: ${avg.toFixed(2)}ms |`,
      `Median: ${median.toFixed(2)}ms |`,
      `Min: ${this.minTime.toFixed(2)}ms |`,
      `Max: ${this.maxTime.toFixed(2)}ms`,
    ].join(' ');

    return report;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/processing.js
//start file
// minimap/processing.js (Updated)

import { parentPort } from 'worker_threads';
import { performance } from 'perf_hooks';
import findSequences from 'find-sequences-native';
import { floorLevelIndicators } from '../../constants/index.js';
import {
  MINIMAP_WIDTH,
  MINIMAP_HEIGHT,
  HEADER_SIZE,
  colorToIndexMap,
} from './config.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
} from '../sharedConstants.js';

let lastWrittenPosition = null;

/**
 * Analyzes minimap and floor indicator data to determine player position.
 * @returns {Promise<number|null>} The processing duration in ms if successful, otherwise null.
 */
export async function processMinimapData(
  minimapBuffer,
  floorIndicatorBuffer,
  minimapMatcher,
  workerData,
) {
  const startTime = performance.now();
  const { playerPosSAB } = workerData;
  const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;

  try {
    const floorIndicatorSearchBuffer = Buffer.alloc(
      HEADER_SIZE + floorIndicatorBuffer.length,
    );
    floorIndicatorSearchBuffer.writeUInt32LE(2, 0);
    floorIndicatorSearchBuffer.writeUInt32LE(63, 4);
    floorIndicatorBuffer.copy(floorIndicatorSearchBuffer, HEADER_SIZE);

    const searchResults = await findSequences.findSequencesNativeBatch(
      floorIndicatorSearchBuffer,
      {
        floor: {
          sequences: floorLevelIndicators,
          searchArea: { x: 0, y: 0, width: 2, height: 63 },
          occurrence: 'first',
        },
      },
    );

    const foundFloor = searchResults.floor || {};
    const floorKey = Object.keys(foundFloor).reduce(
      (lowest, key) =>
        foundFloor[key] !== null && foundFloor[key].y < lowest.y
          ? { key, y: foundFloor[key].y }
          : lowest,
      { key: null, y: Infinity },
    ).key;
    const detectedZ = floorKey !== null ? parseInt(floorKey, 10) : null;

    if (detectedZ === null) return null;

    const minimapIndexData = new Uint8Array(MINIMAP_WIDTH * MINIMAP_HEIGHT);
    for (let i = 0; i < minimapIndexData.length; i++) {
      const p = i * 4;
      const key =
        (minimapBuffer[p + 2] << 16) |
        (minimapBuffer[p + 1] << 8) |
        minimapBuffer[p];
      minimapIndexData[i] = colorToIndexMap.get(key) ?? 0;
    }

    const result = await minimapMatcher.findPosition(
      minimapIndexData,
      MINIMAP_WIDTH,
      MINIMAP_HEIGHT,
      detectedZ,
    );

    if (result?.position) {
      const newPos = result.position;

      if (
        !lastWrittenPosition ||
        newPos.x !== lastWrittenPosition.x ||
        newPos.y !== lastWrittenPosition.y ||
        newPos.z !== lastWrittenPosition.z
      ) {
        // --- FIX START: Directly update Redux from minimapMonitor ---
        // Post a message to the main thread to update the global Redux store.
        parentPort.postMessage({
          type: 'batch-update',
          payload: [
            {
              type: 'gameState/setPlayerMinimapPosition',
              payload: newPos,
            },
          ],
        });
        // --- FIX END ---

        // Update SharedArrayBuffer for other workers (like entityMonitor) to consume.
        if (playerPosArray) {
          Atomics.store(playerPosArray, PLAYER_X_INDEX, newPos.x);
          Atomics.store(playerPosArray, PLAYER_Y_INDEX, newPos.y);
          Atomics.store(playerPosArray, PLAYER_Z_INDEX, newPos.z);
          Atomics.add(playerPosArray, PLAYER_POS_UPDATE_COUNTER_INDEX, 1);
          Atomics.notify(playerPosArray, PLAYER_POS_UPDATE_COUNTER_INDEX);
        }

        lastWrittenPosition = newPos;
      }

      return performance.now() - startTime;
    }
  } catch (err) {
    console.error(`[MinimapProcessing] Error: ${err.message}`);
  }

  return null;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimapMonitor.js
//start file
/**
 * @file minimap-monitor.js
 * @summary A dedicated worker for analyzing minimap data to determine player position.
 * @description This file is the entry point for the minimap worker. It delegates
 * all logic to the modules in the /minimap sub-directory.
 */

import { start } from './minimap/core.js';

try {
  start();
} catch (error) {
  console.error('[MinimapMonitor] Failed to start worker core:', error);
  process.exit(1);
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/config.js
//start file
import { regionParsers } from './parsers.js';
import regionDefinitions from '../../constants/regionDefinitions.js';

export const MAIN_LOOP_INTERVAL = 20;
export const PERFORMANCE_LOGGING_ENABLED = true;
export const PERFORMANCE_LOG_INTERVAL_MS = 10000;

export const FRAME_COUNTER_INDEX = 0;
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

export const OCR_REGION_CONFIGS = {
  skillsWidget: {
    colors: regionDefinitions.skillsWidget?.ocrColors,
    parser: regionParsers.skillsWidget,
    storeAction: 'uiValues/setSkillsWidget',
  },
  chatboxMain: {
    colors: regionDefinitions.chatboxMain?.ocrColors,
    parser: regionParsers.chatboxMain,
    storeAction: 'uiValues/setChatboxMain',
  },
  chatboxSecondary: {
    colors: regionDefinitions.chatboxSecondary?.ocrColors,
    parser: regionParsers.chatboxSecondary,
    storeAction: 'uiValues/setChatboxSecondary',
  },
  chatBoxTabRow: {
    colors: regionDefinitions.chatBoxTabRow?.ocrColors,
    parser: regionParsers.chatBoxTabRow,
    storeAction: 'uiValues/setChatTabs',
  },
  selectCharacterModal: {
    colors: regionDefinitions.selectCharacterModal?.ocrColors,
    parser: regionParsers.selectCharacterModal,
    storeAction: 'uiValues/setSelectCharacterModal',
  },
  vipWidget: {
    colors: regionDefinitions.vipWidget?.ocrColors,
    parser: regionParsers.vipWidget,
    storeAction: 'uiValues/setVipWidget',
  },
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/core.js
//start file
import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import * as config from './config.js';
import { PerformanceTracker } from './performanceTracker.js';
import {
  rectsIntersect,
  processBattleList,
  processOcrRegions,
} from './processing.js';

let currentState = null;
let isShuttingDown = false;
let lastProcessedFrameCounter = -1;
let initializedRegions = new Set();

const perfTracker = new PerformanceTracker();
let lastPerfReportTime = Date.now();

const { sharedData } = workerData;
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function logPerformanceReport() {
  if (!config.PERFORMANCE_LOGGING_ENABLED) return;
  const now = Date.now();
  if (now - lastPerfReportTime >= config.PERFORMANCE_LOG_INTERVAL_MS) {
    console.log(perfTracker.getReport());
    perfTracker.reset();
    lastPerfReportTime = now;
  }
}

async function performOperation() {
  const opStart = performance.now();
  let processedRegionCount = 0;

  try {
    if (!currentState) return;

    const newFrameCounter = Atomics.load(syncArray, config.FRAME_COUNTER_INDEX);
    if (
      newFrameCounter <= lastProcessedFrameCounter ||
      Atomics.load(syncArray, config.IS_RUNNING_INDEX) !== 1
    ) {
      return;
    }

    const width = Atomics.load(syncArray, config.WIDTH_INDEX);
    const height = Atomics.load(syncArray, config.HEIGHT_INDEX);
    const { regions } = currentState.regionCoordinates;
    if (Object.keys(regions).length === 0 || width <= 0 || height <= 0) return;

    lastProcessedFrameCounter = newFrameCounter;

    const dirtyRegionCount = Atomics.load(
      syncArray,
      config.DIRTY_REGION_COUNT_INDEX,
    );
    const dirtyRects = [];
    for (let i = 0; i < dirtyRegionCount; i++) {
      const offset = config.DIRTY_REGIONS_START_INDEX + i * 4;
      dirtyRects.push({
        x: Atomics.load(syncArray, offset + 0),
        y: Atomics.load(syncArray, offset + 1),
        width: Atomics.load(syncArray, offset + 2),
        height: Atomics.load(syncArray, offset + 3),
      });
    }

    const shouldProcessRegion = (regionName) => {
      if (!regions[regionName]) return false;
      if (!initializedRegions.has(regionName)) return true;
      for (const dirtyRect of dirtyRects) {
        if (rectsIntersect(regions[regionName], dirtyRect)) return true;
      }
      return false;
    };

    const processingTasks = [];
    const regionsToProcess = new Set();

    if (shouldProcessRegion('battleList')) {
      processingTasks.push(processBattleList(sharedBufferView, regions));
      initializedRegions.add('battleList');
    }

    for (const regionKey of Object.keys(config.OCR_REGION_CONFIGS)) {
      if (shouldProcessRegion(regionKey)) {
        regionsToProcess.add(regionKey);
        initializedRegions.add(regionKey);
      }
    }

    if (regionsToProcess.size > 0) {
      processingTasks.push(
        processOcrRegions(sharedBufferView, regions, regionsToProcess),
      );
    }

    if (processingTasks.length > 0) {
      await Promise.all(processingTasks);
      processedRegionCount =
        regionsToProcess.size +
        (processingTasks.length > regionsToProcess.size ? 1 : 0);
    }
  } catch (error) {
    console.error('[OcrCore] Error in operation:', error);
  } finally {
    if (processedRegionCount > 0) {
      const opDuration = performance.now() - opStart;
      perfTracker.addMeasurement(opDuration, processedRegionCount);
    }
  }
}

async function mainLoop() {
  console.log('[OcrCore] Starting main loop...');
  while (!isShuttingDown) {
    const loopStart = performance.now();
    try {
      await performOperation();
      logPerformanceReport();
    } catch (error) {
      console.error('[OcrCore] Error in main loop:', error);
    }
    const elapsedTime = performance.now() - loopStart;
    const delayTime = Math.max(0, config.MAIN_LOOP_INTERVAL - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  console.log('[OcrCore] Main loop stopped.');
}

function handleMessage(message) {
  try {
    if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      const regionsChanged =
        message.payload.regionCoordinates &&
        currentState.regionCoordinates !== message.payload.regionCoordinates;
      Object.assign(currentState, message.payload);
      if (regionsChanged) {
        console.log(
          '[OcrCore] Region definitions changed, forcing re-initialization.',
        );
        initializedRegions.clear();
      }
    } else if (message.type === 'shutdown') {
      console.log('[OcrCore] Received shutdown command.');
      isShuttingDown = true;
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
      console.log('[OcrCore] Received initial state update.');
      initializedRegions.clear();
    }
  } catch (error) {
    console.error('[OcrCore] Error handling message:', error);
  }
}

export async function start() {
  console.log('[OcrCore] Worker starting up...');
  if (!workerData?.sharedData) {
    throw new Error('[OcrCore] Shared data not provided');
  }
  parentPort.on('message', handleMessage);

  mainLoop().catch((error) => {
    console.error('[OcrCore] Fatal error in main loop:', error);
    process.exit(1);
  });
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/parsers.js
//start file
/**
 * @file parsers.js
 * @summary The single source of truth for parsing all OCR data.
 * @description This module contains powerful parsers that transform raw OCR text
 * into the final, structured objects ready for the Redux state.
 */

// Note: Most of these functions are moved directly from the original uiValuesSlice.js

function parseSkillsWidget(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0) return null;
  const result = {};
  const skills = {};
  const combat = {};
  const validData = ocrData.filter(
    (item) =>
      item.text &&
      item.text.trim() &&
      !item.text.match(/^[-\s]*$/) &&
      item.text !== 'alue',
  );
  const rows = new Map();
  validData.forEach((item) => {
    let rowKey = Array.from(rows.keys()).find(
      (key) => Math.abs(item.y - key) <= 5,
    );
    if (rowKey === undefined) rowKey = item.y;
    if (!rows.has(rowKey)) rows.set(rowKey, []);
    rows.get(rowKey).push(item);
  });
  Array.from(rows.values()).forEach((row) => {
    row.sort((a, b) => a.x - b.x);
    for (let i = 0; i < row.length - 1; i++) {
      const label = row[i].text.trim().toLowerCase();
      const value = row[i + 1]?.text?.trim();
      if (!value) continue;
      switch (label) {
        case 'level':
          result.level = parseInt(value) || null;
          break;
        case 'experience':
          result.experience = parseInt(value.replace(/,/g, '')) || null;
          break;
        case 'xp gain rate':
          result.xpGainRate = parseFloat(value.replace('%', '')) || null;
          break;
        case 'hit points':
          result.hitPoints = parseInt(value) || null;
          break;
        case 'mana':
          result.mana = parseInt(value) || null;
          break;
        case 'soul points':
          result.soulPoints = parseInt(value) || null;
          break;
        case 'capacity':
          result.capacity = parseInt(value) || null;
          break;
        case 'speed':
          result.speed = parseInt(value) || null;
          break;
        case 'food':
          result.food = value;
          break;
        case 'stamina':
          result.stamina = value;
          break;
        case 'offline training':
          result.offlineTraining = value;
          break;
        case 'magic':
          skills.magic = parseInt(value) || null;
          break;
        case 'fist':
          skills.fist = parseInt(value) || null;
          break;
        case 'club':
          skills.club = parseInt(value) || null;
          break;
        case 'sword':
          skills.sword = parseInt(value) || null;
          break;
        case 'axe':
          skills.axe = parseInt(value) || null;
          break;
        case 'distance':
          skills.distance = parseInt(value) || null;
          break;
        case 'shielding':
          skills.shielding = parseInt(value) || null;
          break;
        case 'fishing':
          skills.fishing = parseInt(value) || null;
          break;
        case 'damage/healing':
          combat.damageHealing = parseInt(value) || null;
          break;
        case 'attack':
          if (value.endsWith('V'))
            combat.attack = parseInt(value.replace('V', '')) || null;
          break;
        case 'defence':
          if (value.endsWith('V'))
            combat.defence = parseInt(value.replace('V', '')) || null;
          break;
        case 'armor':
          if (value.endsWith('V'))
            combat.armor = parseInt(value.replace('V', '')) || null;
          break;
        case 'mantra':
          if (value.endsWith('V'))
            combat.mantra = parseInt(value.replace('V', '')) || null;
          break;
        case 'mitigation':
          if (value.includes('%'))
            combat.mitigation = parseFloat(value.replace(/[+%]/g, '')) || null;
          break;
      }
    }
  });
  return { ...result, skills, combat };
}

function parseChatData(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0) return [];
  return ocrData.filter((item) => item && typeof item === 'object');
}

function parseChatBoxTabRow(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { activeTab: null, tabs: {} };
  const tabs = {};
  let activeTab = null;
  ocrData.forEach((item) => {
    const tabName = item.text.trim();
    if (!tabName) return;
    tabs[tabName] = {
      tabName,
      tabPosition: { x: item.click.x, y: item.click.y },
      originalPosition: { x: item.x, y: item.y },
    };
    if (
      item.color &&
      item.color.r === 223 &&
      item.color.g === 223 &&
      item.color.b === 223
    ) {
      activeTab = tabName;
    }
  });
  return { activeTab, tabs };
}

function parseSelectCharacterModal(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { selectedCharacter: null, characters: {}, accountStatus: null };
  const characters = {};
  let selectedCharacter = null;
  let accountStatus = null;
  ocrData.forEach((item) => {
    const text = item.text.trim();
    if (!text) return;
    if (text.includes('Account Status:')) {
      const nextItem = ocrData.find(
        (next) => next.y > item.y && Math.abs(next.x - item.x) < 50,
      );
      if (nextItem) accountStatus = nextItem.text.trim();
      return;
    }
    if (text === 'Free Account' || text === 'Premium Account') {
      if (!accountStatus) accountStatus = text;
      return;
    }
    characters[text] = {
      name: text,
      position: { x: item.click.x, y: item.click.y },
      originalPosition: { x: item.x, y: item.y },
      color: item.color,
    };
    if (
      item.color &&
      item.color.r === 244 &&
      item.color.g === 244 &&
      item.color.b === 244
    ) {
      selectedCharacter = text;
    }
  });
  return { selectedCharacter, characters, accountStatus };
}

function parseVipWidget(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { online: [], offline: [] };
  const online = [];
  const offline = [];
  ocrData.forEach((item) => {
    if (!item?.text) return;
    const isOnline =
      item.color &&
      item.color.r === 96 &&
      item.color.g === 248 &&
      item.color.b === 96;
    if (isOnline) online.push(item.text);
    else offline.push(item.text);
  });
  online.sort((a, b) => a.localeCompare(b));
  offline.sort((a, b) => a.localeCompare(b));
  return { online, offline };
}

export const regionParsers = {
  skillsWidget: parseSkillsWidget,
  chatboxMain: parseChatData,
  chatboxSecondary: parseChatData,
  chatBoxTabRow: parseChatBoxTabRow,
  selectCharacterModal: parseSelectCharacterModal,
  vipWidget: parseVipWidget,
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report OCR performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  reset() {
    this.operationTimes = [];
    this.totalOperationTime = 0;
    this.regionsProcessedCounts = [];
    this.totalRegionsProcessed = 0;
  }

  /**
   * Adds a new measurement from a single performOperation cycle.
   * @param {number} duration - The time in milliseconds for the operation.
   * @param {number} regionCount - The number of regions processed in the operation.
   */
  addMeasurement(duration, regionCount) {
    this.operationTimes.push(duration);
    this.totalOperationTime += duration;
    this.regionsProcessedCounts.push(regionCount);
    this.totalRegionsProcessed += regionCount;
  }

  getReport() {
    const operationCount = this.operationTimes.length;
    if (operationCount === 0) {
      return '[OcrPerformance] No OCR operations in the last period.';
    }

    const avgOpTime = this.totalOperationTime / operationCount;
    const maxOpTime = Math.max(...this.operationTimes);
    const avgRegions = this.totalRegionsProcessed / operationCount;

    const report = [
      '[OcrPerformance] Stats:',
      `${operationCount} ops |`,
      `Avg Time: ${avgOpTime.toFixed(2)}ms |`,
      `Max Time: ${maxOpTime.toFixed(2)}ms |`,
      `Avg Regions/Op: ${avgRegions.toFixed(1)}`,
    ].join(' ');

    return report;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/processing.js
//start file
import { parentPort } from 'worker_threads';
import pkg from 'font-ocr';
import { OCR_REGION_CONFIGS } from './config.js';
import regionDefinitions from '../../constants/regionDefinitions.js';

const { recognizeText } = pkg;

/**
 * Checks if two rectangle objects intersect.
 * @returns {boolean} True if the rectangles overlap.
 */
export function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

/**
 * Processes the battle list, which has special logic for handling many small sub-regions.
 * It performs OCR and dispatches the final array of monster names.
 * @param {Buffer} buffer - The shared screen buffer.
 * @param {object} regions - The map of all known UI regions.
 */
export async function processBattleList(buffer, regions) {
  const battleListEntries = regions.battleList?.children?.entries?.list;
  if (!Array.isArray(battleListEntries) || battleListEntries.length === 0) {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'uiValues/setBattleListEntries',
      payload: [],
    });
    return;
  }

  try {
    const validNameRegions = battleListEntries
      .filter((e) => e?.name && typeof e.name.x === 'number')
      .map((e) => e.name);
    if (validNameRegions.length === 0) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'uiValues/setBattleListEntries',
        payload: [],
      });
      return;
    }

    // Create a "super region" that encompasses all monster names for a single, efficient OCR call.
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    for (const region of validNameRegions) {
      minX = Math.min(minX, region.x);
      minY = Math.min(minY, region.y);
      maxX = Math.max(maxX, region.x + region.width);
      maxY = Math.max(maxY, region.y + region.height);
    }
    const superRegion = {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY,
    };
    const monsterNameColors = regionDefinitions.battleList?.ocrColors || [
      [240, 240, 240],
    ];

    const ocrResults =
      recognizeText(buffer, superRegion, monsterNameColors) || [];

    // Map the OCR results back to the original battle list entries by their y-coordinate.
    const monsterNames = battleListEntries.map((entry) => {
      if (!entry?.name) return '';
      // Find the OCR line that is vertically closest to the entry's name region.
      const foundText = ocrResults.find(
        (ocrLine) => Math.abs(ocrLine.y - entry.name.y) <= 3,
      );
      return foundText ? foundText.text.trim() : '';
    });

    parentPort.postMessage({
      storeUpdate: true,
      type: 'uiValues/setBattleListEntries',
      payload: monsterNames,
    });
  } catch (ocrError) {
    console.error(
      '[OcrProcessing] OCR failed for battleList entries:',
      ocrError,
    );
  }
}

/**
 * Processes a set of standard OCR regions, running them through their specific parsers.
 * @param {Buffer} buffer - The shared screen buffer.
 * @param {object} regions - The map of all known UI regions.
 * @param {Set<string>} regionKeys - A set of region names to process.
 */
export async function processOcrRegions(buffer, regions, regionKeys) {
  const ocrRawUpdates = {};
  const processingPromises = [];

  for (const regionKey of regionKeys) {
    const config = OCR_REGION_CONFIGS[regionKey];
    const region = regions[regionKey];
    if (!region || !config) continue;

    const processRegion = async () => {
      try {
        // 1. Get raw OCR text data from the native library.
        const rawData = recognizeText(buffer, region, config.colors) || [];
        ocrRawUpdates[regionKey] = rawData; // Keep raw data for debugging if needed.

        // 2. If a parser exists, use it to transform the raw data.
        if (config.parser) {
          const parsedData = config.parser(rawData);

          // 3. If the parser returns a valid result, dispatch the specific, clean action.
          if (parsedData) {
            parentPort.postMessage({
              storeUpdate: true,
              type: config.storeAction,
              payload: parsedData,
            });
          }
        }
      } catch (ocrError) {
        console.error(`[OcrProcessing] OCR failed for ${regionKey}:`, ocrError);
      }
    };
    processingPromises.push(processRegion());
  }

  await Promise.all(processingPromises);

  // This can still be useful for a generic "raw ocr" view in a debug tool.
  if (Object.keys(ocrRawUpdates).length > 0) {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'ocr/setOcrRegionsText',
      payload: ocrRawUpdates,
    });
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocrWorker.js
//start file
/**
 * @file ocrWorker.js
 * @summary A dedicated worker for OCR text recognition on UI regions.
 * @description This file is the entry point for the OCR worker. It delegates
 * all logic to the modules in the /ocr sub-directory for maintainability.
 */

import { workerData } from 'worker_threads';
import { start } from './ocr/core.js';
import { IS_RUNNING_INDEX } from './ocr/config.js';

start().catch((err) => {
  console.error(
    '[OcrWorker] A fatal, unhandled error occurred during startup:',
    err,
  );

  try {
    const { sharedData } = workerData;
    if (sharedData?.syncSAB) {
      const syncArray = new Int32Array(sharedData.syncSAB);
      Atomics.store(syncArray, IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, IS_RUNNING_INDEX);
      console.log(
        '[OcrWorker] Successfully signaled shutdown to other workers.',
      );
    } else {
      console.error(
        '[OcrWorker] Could not signal shutdown: sharedData or syncSAB not available.',
      );
    }
  } catch (e) {
    console.error(
      '[OcrWorker] An error occurred while trying to signal shutdown:',
      e,
    );
  }

  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/config.js
//start file
import path from 'path';

// --- Performance Logging ---
export const PERFORMANCE_LOGGING_ENABLED = true;
export const PERFORMANCE_LOG_INTERVAL_MS = 10000;

// --- File Paths ---
export const PREPROCESSED_BASE_DIR = path.join(
  process.cwd(),
  'resources',
  'preprocessed_minimaps',
);

// --- Logic Constants ---
// Maps a waypoint type to the type of special avoidance area it should respect.
export const WAYPOINT_AVOIDANCE_MAP = {
  Node: 'cavebot',
  Stand: 'cavebot',
  Ladder: 'cavebot',
  Script: 'cavebot',
  Lure: 'targeting',
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/core.js
//start file
// pathfinder/core.js (Always Active Version)

import { parentPort, workerData } from 'worker_threads';
import Pathfinder from 'pathfinder-native';
import { createLogger } from '../../utils/logger.js';
import * as config from './config.js';
import { loadAllMapData } from './dataLoader.js';
import { runPathfindingLogic } from './logic.js';
import { PerformanceTracker } from './performanceTracker.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
} from '../sharedConstants.js';

const logger = createLogger({ info: true, error: true, debug: false });

// --- Worker State ---
let state = null;
let pathfinderInstance = null;
let lastPlayerPosCounter = -1;

const logicContext = {
  lastPlayerPosKey: null,
  lastTargetWptId: null,
  lastJsonForType: new Map(),
};

// --- Shared Buffer Setup ---
const { playerPosSAB, pathDataSAB } = workerData;
const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const pathDataArray = pathDataSAB ? new Int32Array(pathDataSAB) : null;

// --- Performance Tracking ---
const perfTracker = new PerformanceTracker();
let lastPerfReportTime = Date.now();

// --- Redux Update Throttling ---
const REDUX_UPDATE_INTERVAL_MS = 150;
let lastReduxUpdateTime = 0;
let reduxUpdateTimeout = null;
let pendingReduxUpdatePayload = null;

function postThrottledUpdate() {
  if (pendingReduxUpdatePayload) {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/setPathfindingFeedback',
      payload: pendingReduxUpdatePayload,
    });
    lastReduxUpdateTime = Date.now();
    pendingReduxUpdatePayload = null;
  }
  if (reduxUpdateTimeout) {
    clearTimeout(reduxUpdateTimeout);
    reduxUpdateTimeout = null;
  }
}

function throttleReduxUpdate(payload) {
  pendingReduxUpdatePayload = payload;
  const now = Date.now();
  const timeSinceLastUpdate = now - lastReduxUpdateTime;
  if (timeSinceLastUpdate >= REDUX_UPDATE_INTERVAL_MS) {
    postThrottledUpdate();
  } else if (!reduxUpdateTimeout) {
    reduxUpdateTimeout = setTimeout(
      postThrottledUpdate,
      REDUX_UPDATE_INTERVAL_MS - timeSinceLastUpdate,
    );
  }
}

function logPerformanceReport() {
  if (!config.PERFORMANCE_LOGGING_ENABLED) return;
  const now = Date.now();
  if (now - lastPerfReportTime >= config.PERFORMANCE_LOG_INTERVAL_MS) {
    logger('info', perfTracker.getReport());
    perfTracker.reset();
    lastPerfReportTime = now;
  }
}

function handleMessage(message) {
  try {
    if (message.type === 'state_diff') {
      state = { ...state, ...message.payload };
    } else if (message.type === undefined) {
      state = message;
    } else if (message.type === 'shutdown') {
      if (reduxUpdateTimeout) clearTimeout(reduxUpdateTimeout);
      return;
    } else {
      return;
    }

    let playerMinimapPosition = null;
    if (playerPosArray) {
      const newPlayerPosCounter = Atomics.load(
        playerPosArray,
        PLAYER_POS_UPDATE_COUNTER_INDEX,
      );
      if (newPlayerPosCounter > lastPlayerPosCounter) {
        playerMinimapPosition = {
          x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
          y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
          z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
        };
        lastPlayerPosCounter = newPlayerPosCounter;
        if (!state) state = {};
        if (!state.gameState) state.gameState = {};
        state.gameState.playerMinimapPosition = playerMinimapPosition;
      } else if (state?.gameState?.playerMinimapPosition) {
        playerMinimapPosition = state.gameState.playerMinimapPosition;
      }
    } else if (state?.gameState?.playerMinimapPosition) {
      playerMinimapPosition = state.gameState.playerMinimapPosition;
    }

    // --- FIX: Remove the 'cavebot.enabled' check ---
    // The pathfinder should always run if it has a position.
    // The logic inside runPathfindingLogic will check if there's a valid target waypoint.
    if (playerMinimapPosition) {
      const duration = runPathfindingLogic({
        ...logicContext,
        state: {
          ...state,
          gameState: { ...state.gameState, playerMinimapPosition },
        },
        pathfinderInstance,
        logger,
        pathDataArray,
        throttleReduxUpdate,
      });

      if (typeof duration === 'number') {
        perfTracker.addMeasurement(duration);
      }
    }
    // --- END FIX ---

    logPerformanceReport();
  } catch (error) {
    logger(
      'error',
      '[PathfinderCore] Unhandled error in message handler:',
      error,
    );
  }
}

export async function start() {
  logger('info', 'Pathfinder worker starting up...');
  try {
    pathfinderInstance = new Pathfinder.Pathfinder();
    logger('info', 'Native Pathfinder addon loaded successfully.');
    loadAllMapData(pathfinderInstance, logger);
  } catch (err) {
    logger(
      'error',
      `Pathfinder worker fatal error on startup: ${err.message}`,
      err,
    );
    if (parentPort) {
      parentPort.postMessage({
        fatalError: err.message || 'Unknown fatal error in worker',
      });
    }
    process.exit(1);
  }
  parentPort.on('message', handleMessage);
  parentPort.on('close', () => {
    logger('info', 'Parent port closed. Stopping pathfinder worker.');
    process.exit(0);
  });
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/dataLoader.js
//start file
import fs from 'fs';
import path from 'path';
import { PREPROCESSED_BASE_DIR } from './config.js';

/**
 * Reads all preprocessed map data from disk and loads it into the pathfinder instance.
 * @param {object} pathfinderInstance - The native Pathfinder addon instance.
 * @param {function} logger - The logger utility.
 */
export function loadAllMapData(pathfinderInstance, logger) {
  if (pathfinderInstance.isLoaded) return;

  logger('info', 'Loading pathfinding data for all Z-levels...');
  const mapDataForAddon = {};
  try {
    const zLevelDirs = fs
      .readdirSync(PREPROCESSED_BASE_DIR, { withFileTypes: true })
      .filter((d) => d.isDirectory() && d.name.startsWith('z'))
      .map((d) => d.name);

    for (const zDir of zLevelDirs) {
      const zLevel = parseInt(zDir.substring(1), 10);
      const zLevelPath = path.join(PREPROCESSED_BASE_DIR, zDir);
      try {
        const metadata = JSON.parse(
          fs.readFileSync(path.join(zLevelPath, 'walkable.json'), 'utf8'),
        );
        const grid = fs.readFileSync(path.join(zLevelPath, 'walkable.bin'));
        mapDataForAddon[zLevel] = { ...metadata, grid };
      } catch (e) {
        if (e.code !== 'ENOENT') {
          logger(
            'warn',
            `Could not load pathfinding data for Z=${zLevel}: ${e.message}`,
          );
        }
      }
    }

    pathfinderInstance.loadMapData(mapDataForAddon);

    if (pathfinderInstance.isLoaded) {
      logger(
        'info',
        'Pathfinding data successfully loaded into native module.',
      );
    } else {
      throw new Error(
        'Failed to load data into native module after reading files.',
      );
    }
  } catch (e) {
    logger('error', `Critical error during map data loading: ${e.message}`);
    throw e; // Re-throw to be caught by the worker's main error handler
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/logic.js
//start file
import { WAYPOINT_AVOIDANCE_MAP } from './config.js';
import {
  // Import all existing constants
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_WAYPOINTS_START_INDEX,
  PATH_WAYPOINT_SIZE,
  MAX_PATH_WAYPOINTS,
  PATH_CHEBYSHEV_DISTANCE_INDEX,
  PATH_START_X_INDEX,
  PATH_START_Y_INDEX,
  PATH_START_Z_INDEX,

  // Import the new constants from the updated sharedConstants.js
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
  PATH_STATUS_PATH_FOUND,
  PATH_STATUS_WAYPOINT_REACHED,
  PATH_STATUS_NO_PATH_FOUND,
  PATH_STATUS_DIFFERENT_FLOOR,
  PATH_STATUS_ERROR,
  PATH_STATUS_NO_VALID_START_OR_END,
} from '../sharedConstants.js';

// This helps prevent redundant writes to the SAB if the result is identical.
let lastWrittenPathSignature = '';

export function runPathfindingLogic(context) {
  const {
    state,
    pathfinderInstance,
    lastJsonForType,
    logger,
    pathDataArray,
    throttleReduxUpdate,
  } = context;

  try {
    if (!state?.cavebot?.wptId || !state?.gameState?.playerMinimapPosition) {
      return null;
    }

    const { x, y, z } = state.gameState.playerMinimapPosition;

    if (
      typeof x !== 'number' ||
      typeof y !== 'number' ||
      typeof z !== 'number'
    ) {
      logger(
        'error',
        `Pathfinder received invalid player position: {x: ${x}, y: ${y}, z: ${z}}`,
      );
      return null;
    }

    const { waypointSections, currentSection, wptId } = state.cavebot;
    const currentWaypoints = waypointSections[currentSection]?.waypoints || [];
    const targetWaypoint = currentWaypoints.find((wp) => wp.id === wptId);
    if (!targetWaypoint) return null;

    // --- Handle Special Areas (Unchanged) ---
    const requiredAvoidanceType = WAYPOINT_AVOIDANCE_MAP[targetWaypoint.type];
    if (requiredAvoidanceType) {
      const permanentAreas = (state.cavebot?.specialAreas || []).filter(
        (area) => area.enabled && area.type === requiredAvoidanceType,
      );
      const currentJson = JSON.stringify(permanentAreas);
      if (currentJson !== lastJsonForType.get(requiredAvoidanceType)) {
        const areasForNative = permanentAreas.map((area) => ({
          x: area.x,
          y: area.y,
          z: area.z,
          avoidance: area.avoidance,
          width: area.sizeX,
          height: area.sizeY,
        }));
        pathfinderInstance.updateSpecialAreas(areasForNative, z);
        lastJsonForType.set(requiredAvoidanceType, currentJson);
      }
    }

    // --- Handle Different Floor Case ---
    if (z !== targetWaypoint.z) {
      // Only update if this is a new target, to avoid spamming updates.
      if (context.lastTargetWptId !== targetWaypoint.id) {
        throttleReduxUpdate({
          pathWaypoints: [],
          wptDistance: null,
          pathfindingStatus: 'DIFFERENT_FLOOR',
        });
        // Write the definitive status to the SAB
        if (pathDataArray) {
          Atomics.store(
            pathDataArray,
            PATHFINDING_STATUS_INDEX,
            PATH_STATUS_DIFFERENT_FLOOR,
          );
          Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0); // Ensure path is empty
          Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1); // Notify worker
        }
        context.lastTargetWptId = targetWaypoint.id;
      }
      return null;
    }

    // --- Prevent Recalculation if Nothing Changed (Unchanged) ---
    const currentPosKey = `${x},${y},${z}`;
    if (
      context.lastPlayerPosKey === currentPosKey &&
      context.lastTargetWptId === targetWaypoint.id
    ) {
      return null;
    }
    context.lastPlayerPosKey = currentPosKey;
    context.lastTargetWptId = targetWaypoint.id;

    // --- Perform Pathfinding ---
    const result = pathfinderInstance.findPathSync(
      { x, y, z },
      { x: targetWaypoint.x, y: targetWaypoint.y, z: targetWaypoint.z },
      { waypointType: targetWaypoint.type },
    );

    const path = result.path || [];
    const statusString = result.reason;

    // --- Convert Status String to Integer Code ---
    let statusCode = PATH_STATUS_IDLE;
    switch (statusString) {
      case 'PATH_FOUND':
        statusCode = PATH_STATUS_PATH_FOUND;
        break;
      case 'WAYPOINT_REACHED':
        statusCode = PATH_STATUS_WAYPOINT_REACHED;
        break;
      case 'NO_PATH_FOUND':
        statusCode = PATH_STATUS_NO_PATH_FOUND;
        break;
      case 'NO_VALID_START':
      case 'NO_VALID_END':
        statusCode = PATH_STATUS_NO_VALID_START_OR_END;
        break;
      default:
        statusCode = PATH_STATUS_ERROR; // Should not happen
    }

    // --- Write Results to Shared Array Buffer ---
    const pathSignature = `${statusCode}:${path.map((p) => `${p.x},${p.y}`).join(';')}`;
    if (pathSignature !== lastWrittenPathSignature) {
      if (pathDataArray) {
        const pathLength = Math.min(path.length, MAX_PATH_WAYPOINTS);
        const chebyshevDistance = Math.max(
          Math.abs(x - targetWaypoint.x),
          Math.abs(y - targetWaypoint.y),
        );

        // Store all path metadata in the SAB
        Atomics.store(pathDataArray, PATH_LENGTH_INDEX, pathLength);
        Atomics.store(
          pathDataArray,
          PATH_CHEBYSHEV_DISTANCE_INDEX,
          chebyshevDistance,
        );
        Atomics.store(pathDataArray, PATH_START_X_INDEX, x);
        Atomics.store(pathDataArray, PATH_START_Y_INDEX, y);
        Atomics.store(pathDataArray, PATH_START_Z_INDEX, z);

        // ** THE CRUCIAL CHANGE: Store the definitive status code **
        Atomics.store(pathDataArray, PATHFINDING_STATUS_INDEX, statusCode);

        // Store the waypoints
        for (let i = 0; i < pathLength; i++) {
          const waypoint = path[i];
          const offset = PATH_WAYPOINTS_START_INDEX + i * PATH_WAYPOINT_SIZE;
          Atomics.store(pathDataArray, offset + 0, waypoint.x);
          Atomics.store(pathDataArray, offset + 1, waypoint.y);
          Atomics.store(pathDataArray, offset + 2, waypoint.z);
        }

        // Increment update counter to notify consumers
        Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
      }
      lastWrittenPathSignature = pathSignature;
    }

    // --- Throttle Redux Update for UI (Unchanged) ---
    const distance =
      statusString === 'NO_PATH_FOUND'
        ? null
        : path.length > 0
          ? path.length
          : statusString === 'WAYPOINT_REACHED'
            ? 0
            : null;
    throttleReduxUpdate({
      pathWaypoints: path,
      wptDistance: distance,
      routeSearchMs: result.performance.totalTimeMs,
      pathfindingStatus: statusString,
    });

    return result.performance.totalTimeMs;
  } catch (error) {
    logger('error', `Pathfinding error: ${error.message}`);
    throttleReduxUpdate({
      pathWaypoints: [],
      wptDistance: null,
      pathfindingStatus: 'ERROR',
    });
    // On error, notify the worker so it can handle it gracefully
    if (pathDataArray) {
      Atomics.store(pathDataArray, PATHFINDING_STATUS_INDEX, PATH_STATUS_ERROR);
      Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0);
      Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
    }
    return null;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  /**
   * Resets all statistics to their initial state.
   */
  reset() {
    this.times = [];
    this.minTime = Infinity;
    this.maxTime = 0;
    this.totalTime = 0;
  }

  /**
   * Adds a new duration measurement to the tracker.
   * @param {number} duration - The time in milliseconds for an operation.
   */
  addMeasurement(duration) {
    this.times.push(duration);
    this.totalTime += duration;
    if (duration < this.minTime) this.minTime = duration;
    if (duration > this.maxTime) this.maxTime = duration;
  }

  /**
   * Calculates the median from the collected times.
   * @returns {number} The median value.
   */
  _calculateMedian() {
    const sorted = [...this.times].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    }
    return sorted[mid];
  }

  /**
   * Generates a formatted string of the current performance statistics.
   * @returns {string|null} A report string or null if no data is available.
   */
  getReport() {
    const iterations = this.times.length;
    if (iterations === 0) {
      return '[PathfinderPerformance] No successful pathfinding operations in the last period.';
    }

    const avg = this.totalTime / iterations;
    const median = this._calculateMedian();

    const report = [
      '[PathfinderPerformance] Stats:',
      `${iterations} paths found |`,
      `Avg: ${avg.toFixed(2)}ms |`,
      `Median: ${median.toFixed(2)}ms |`,
      `Min: ${this.minTime.toFixed(2)}ms |`,
      `Max: ${this.maxTime.toFixed(2)}ms`,
    ].join(' ');

    return report;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinderWorker.js
//start file
/**
 * @file pathfinderWorker.js
 * @summary A dedicated worker for all pathfinding calculations.
 * @description This file is the entry point for the pathfinder worker. It delegates
 * all logic to the modules in the /pathfinder sub-directory for maintainability.
 */

import { start } from './pathfinder/core.js';

start().catch((err) => {
  // This catch is for errors during the initial `start` execution itself,
  // though most errors within the worker are handled by the core module.
  console.error('[PathfinderWorker] Failed to start worker core:', err);
  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/regionMonitor.js
//start file
// @regionMonitor.js
import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import regionDefinitions from '../constants/regionDefinitions.js';
import { setAllRegions } from '../../frontend/redux/slices/regionCoordinatesSlice.js';
import findSequences from 'find-sequences-native';

// --- Worker Configuration & Setup ---
const { sharedData } = workerData;
const FULL_SCAN_INTERVAL_MS = 250; // How often to perform full scans
const MIN_LOOP_DELAY_MS = 200; // Minimum delay between loop iterations
const PERFORMANCE_LOG_INTERVAL = 10000; // Log performance stats every 10 seconds

if (!sharedData) throw new Error('[RegionMonitor] Shared data not provided.');
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

// --- Correct SharedArrayBuffer Indices ---
const FRAME_COUNTER_INDEX = 0;
const WIDTH_INDEX = 1;
const HEIGHT_INDEX = 2;
const IS_RUNNING_INDEX = 3;
const WINDOW_ID_INDEX = 4;

// --- State variables for full scan model ---
let lastProcessedFrameCounter = -1;
let lastKnownRegions = {};
let lastWidth = 0;
let lastHeight = 0;
let lastScanTime = 0;
let nextScanTime = 0; // When the next scan should start
let currentState = null;
let isShuttingDown = false;
let isScanning = false; // Flag to prevent overlapping scans

// --- Performance tracking ---
let scanCount = 0;
let totalScanTime = 0;
let lastPerfReport = Date.now();

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// --- Performance monitoring ---
function logPerformanceStats() {
  const now = Date.now();
  const timeSinceLastReport = now - lastPerfReport;
  if (timeSinceLastReport >= PERFORMANCE_LOG_INTERVAL) {
    const avgScanTime =
      scanCount > 0 ? (totalScanTime / scanCount).toFixed(2) : 0;
    const scansPerSecond = ((scanCount / timeSinceLastReport) * 1000).toFixed(
      1,
    );
    console.log(
      `[RegionMonitor] Performance: ${scansPerSecond} scans/sec, ` +
        `avg: ${avgScanTime}ms, total scans: ${scanCount}`,
    );
    // Reset counters
    scanCount = 0;
    totalScanTime = 0;
    lastPerfReport = now;
  }
}

// ========================================================================
// --- findRegionsRecursive (Optimized with early returns) ---
// ========================================================================
async function findRegionsRecursive(
  buffer,
  definitions,
  searchArea,
  baseOffset,
  parentResult,
  metadata,
) {
  const discoveryTasks = {};
  const boundingBoxDefs = {};
  const fixedDefs = {};
  const defEntries = Object.entries(definitions);
  // Early return if no definitions
  if (defEntries.length === 0) return;
  // Step 1: Generate discovery tasks
  for (const [name, def] of defEntries) {
    const type = def.type;
    switch (type) {
      case 'single':
        discoveryTasks[name] = {
          sequences: { [name]: def },
          searchArea,
          occurrence: 'first',
        };
        break;
      case 'boundingBox':
        const startTaskKey = `${name}_start`;
        discoveryTasks[startTaskKey] = {
          sequences: { [startTaskKey]: def.start },
          searchArea,
          occurrence: 'first',
        };
        boundingBoxDefs[name] = def;
        break;
      case 'fixed':
        fixedDefs[name] = def;
        break;
    }
  }
  // Process fixed regions
  for (const [name, def] of Object.entries(fixedDefs)) {
    parentResult[name] = {
      x: baseOffset.x + def.x,
      y: baseOffset.y + def.y,
      width: def.width,
      height: def.height,
    };
  }
  if (!Object.keys(discoveryTasks).length) return;
  // Step 2: Run discovery search
  const discoveryResults = await findSequences.findSequencesNativeBatch(
    buffer,
    discoveryTasks,
  );
  const endpointTasks = {};
  const foundStarts = {};
  const childInvocations = [];
  // Step 3: Process 'single' results
  for (const [name, def] of defEntries) {
    if (def.type === 'single' && discoveryResults[name]?.[name]) {
      const result = discoveryResults[name][name];
      const region = {
        x: result.x,
        y: result.y,
        width: def.width,
        height: def.height,
        rawPos: {
          x: result.x - (def.offset?.x || 0),
          y: result.y - (def.offset?.y || 0),
        },
      };
      parentResult[name] = region;
      if (def.children) {
        parentResult[name].children = {};
        childInvocations.push(() =>
          findRegionsRecursive(
            buffer,
            def.children,
            {
              x: region.x,
              y: region.y,
              width: region.width,
              height: region.height,
            },
            { x: region.x, y: region.y },
            parentResult[name].children,
            metadata,
          ),
        );
      }
    }
  }
  // Step 4: Process bounding boxes
  for (const [name, def] of Object.entries(boundingBoxDefs)) {
    const startResult = discoveryResults[`${name}_start`]?.[`${name}_start`];
    if (!startResult) continue;
    foundStarts[name] = startResult;
    const maxW = def.maxRight === 'fullWidth' ? metadata.width : def.maxRight;
    const maxH = def.maxDown === 'fullHeight' ? metadata.height : def.maxDown;
    const endSearchArea = {
      x: startResult.x,
      y: startResult.y,
      width: Math.min(maxW, searchArea.x + searchArea.width - startResult.x),
      height: Math.min(maxH, searchArea.y + searchArea.height - startResult.y),
    };
    if (endSearchArea.width > 0 && endSearchArea.height > 0) {
      endpointTasks[`${name}_end`] = {
        sequences: { [`${name}_end`]: def.end },
        searchArea: endSearchArea,
        occurrence: 'first',
      };
    }
  }
  // Step 5: Run endpoint search
  let endpointResults = {};
  if (Object.keys(endpointTasks).length > 0) {
    endpointResults = await findSequences.findSequencesNativeBatch(
      buffer,
      endpointTasks,
    );
  }
  // Step 6: Assemble bounding boxes
  for (const [name, startPos] of Object.entries(foundStarts)) {
    const def = boundingBoxDefs[name];
    const endPos = endpointResults[`${name}_end`]?.[`${name}_end`];
    const absStartPos = { x: startPos.x, y: startPos.y };
    const rawStartPos = {
      x: absStartPos.x - (def.start.offset?.x || 0),
      y: absStartPos.y - (def.start.offset?.y || 0),
    };
    if (!endPos) {
      parentResult[name] = {
        ...absStartPos,
        width: 0,
        height: 0,
        startFound: true,
        endFound: false,
        rawStartPos,
      };
      continue;
    }
    const rectWidth = endPos.x - startPos.x + 1;
    const rectHeight = endPos.y - startPos.y + 1;
    const region = {
      ...absStartPos,
      width: rectWidth > 0 ? rectWidth : 0,
      height: rectHeight > 0 ? rectHeight : 0,
      startFound: true,
      endFound: true,
      rawStartPos,
      rawEndPos: {
        x: endPos.x - (def.end.offset?.x || 0),
        y: endPos.y - (def.end.offset?.y || 0),
      },
    };
    parentResult[name] = region;
    if (def.children) {
      parentResult[name].children = {};
      childInvocations.push(() =>
        findRegionsRecursive(
          buffer,
          def.children,
          {
            x: region.x,
            y: region.y,
            width: region.width,
            height: region.height,
          },
          { x: region.x, y: region.y },
          parentResult[name].children,
          metadata,
        ),
      );
    }
  }
  // Step 7: Parallelize child processing
  if (childInvocations.length > 0) {
    await Promise.all(childInvocations.map((invoke) => invoke()));
  }
}

// ========================================================================
// --- BattleList & TileSize Helpers (Optimized) ---
// ========================================================================
const BATTLE_LIST_ENTRY_HEIGHT = 20;
const BATTLE_LIST_ENTRY_VERTICAL_PITCH = 22;

function generateBattleListTasks(entriesRegion) {
  const maxEntries = Math.floor(
    (entriesRegion.height +
      (BATTLE_LIST_ENTRY_VERTICAL_PITCH - BATTLE_LIST_ENTRY_HEIGHT)) /
      BATTLE_LIST_ENTRY_VERTICAL_PITCH,
  );
  if (maxEntries <= 0) return null;
  const pixelChecks = {
    '#FF0000': [],
    '#FF8080': [],
    '#000000': [],
  };
  for (let i = 0; i < maxEntries; i++) {
    const entryBaseY = entriesRegion.y + i * BATTLE_LIST_ENTRY_VERTICAL_PITCH;
    const entryBaseX = entriesRegion.x;
    pixelChecks['#FF0000'].push({
      x: entryBaseX,
      y: entryBaseY,
      id: `entry_${i}_isTargeted_red`,
    });
    pixelChecks['#FF8080'].push({
      x: entryBaseX,
      y: entryBaseY,
      id: `entry_${i}_isTargeted_hovered`,
    });
    pixelChecks['#000000'].push({
      x: entryBaseX,
      y: entryBaseY,
      id: `entry_${i}_isAttacking_0_0`,
    });
    pixelChecks['#000000'].push({
      x: entryBaseX + 1,
      y: entryBaseY + 1,
      id: `entry_${i}_isAttacking_1_1`,
    });
    pixelChecks['#000000'].push({
      x: entryBaseX + 22,
      y: entryBaseY + 15,
      id: `entry_${i}_isValid`,
    });
  }
  return { searchArea: entriesRegion, pixelChecks };
}

function processBattleListResults(checkResults, entriesRegion) {
  const maxEntries = Math.floor(
    (entriesRegion.height +
      (BATTLE_LIST_ENTRY_VERTICAL_PITCH - BATTLE_LIST_ENTRY_HEIGHT)) /
      BATTLE_LIST_ENTRY_VERTICAL_PITCH,
  );
  const entryList = [];
  if (!checkResults || maxEntries <= 0) {
    entriesRegion.list = [];
    return;
  }
  for (let i = 0; i < maxEntries; i++) {
    if (checkResults[`entry_${i}_isValid`]) {
      const entryBaseY = entriesRegion.y + i * BATTLE_LIST_ENTRY_VERTICAL_PITCH;
      const entryBaseX = entriesRegion.x;
      entryList.push({
        isValid: true,
        isTargeted:
          !!checkResults[`entry_${i}_isTargeted_red`] ||
          !!checkResults[`entry_${i}_isTargeted_hovered`],
        isAttacking:
          !!checkResults[`entry_${i}_isAttacking_0_0`] ||
          !!checkResults[`entry_${i}_isAttacking_1_1`],
        name: { x: entryBaseX + 22, y: entryBaseY + 2, width: 131, height: 12 },
        healthBarFull: {
          x: entryBaseX + 22,
          y: entryBaseY + 15,
          width: 132,
          height: 5,
        },
        healthBarFill: {
          x: entryBaseX + 23,
          y: entryBaseY + 16,
          width: 130,
          height: 3,
        },
      });
    }
  }
  entriesRegion.list = entryList;
}

// --- Process special regions after a scan ---
async function processSpecialRegions(buffer, regions, metadata) {
  // Process dynamic content like the battle list if its container was found.
  if (regions.battleList?.children?.entries?.endFound) {
    const battleListTask = generateBattleListTasks(
      regions.battleList.children.entries,
    );
    if (battleListTask) {
      const batchTask = { battleListChecks: battleListTask };
      const results = await findSequences.findSequencesNativeBatch(
        buffer,
        batchTask,
      );
      processBattleListResults(
        results.battleListChecks,
        regions.battleList.children.entries,
      );
    }
  }
  // Calculate tile size if the game world was found.
  if (regions.gameWorld?.endFound) {
    const { gameWorld } = regions;
    regions.tileSize = {
      width: Math.round(gameWorld.width / 15),
      height: Math.round(gameWorld.height / 11),
    };
  }
}

// ========================================================================
// --- Scanning Function (performFullScan only) ---
// ========================================================================
async function performFullScan(buffer, metadata) {
  const scanStart = performance.now();
  const foundRegions = {};
  await findRegionsRecursive(
    buffer,
    regionDefinitions,
    { x: 0, y: 0, width: metadata.width, height: metadata.height },
    { x: 0, y: 0 },
    foundRegions,
    metadata,
  );
  await processSpecialRegions(buffer, foundRegions, metadata);
  const scanEnd = performance.now();
  const scanTime = scanEnd - scanStart;
  // Update performance stats
  scanCount++;
  totalScanTime += scanTime;
  // Log slow scans
  if (scanTime > 100) {
    console.log(`[RegionMonitor] Slow full scan: ${scanTime.toFixed(2)}ms`);
  }
  return foundRegions;
}

// ========================================================================
// --- Main Loop (Optimized for non-overlapping scans) ---
// ========================================================================
async function mainLoop() {
  console.log(
    '[RegionMonitor] Starting main loop with non-overlapping scans...',
  );

  // Initialize next scan time
  nextScanTime = performance.now() + FULL_SCAN_INTERVAL_MS;

  while (!isShuttingDown) {
    const loopStartTime = performance.now();

    try {
      // Skip if a scan is already in progress
      if (isScanning) {
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      const newFrameCounter = Atomics.load(syncArray, FRAME_COUNTER_INDEX);

      // Process new frames
      if (newFrameCounter > lastProcessedFrameCounter) {
        lastProcessedFrameCounter = newFrameCounter;

        // Check if capture is running
        if (Atomics.load(syncArray, IS_RUNNING_INDEX) !== 1) {
          if (Object.keys(lastKnownRegions).length > 0) {
            console.log('[RegionMonitor] Capture stopped. Clearing regions.');
            lastKnownRegions = {};
            parentPort.postMessage({
              storeUpdate: true,
              type: setAllRegions.type,
              payload: {},
            });
          }
          await delay(MIN_LOOP_DELAY_MS);
          continue;
        }

        const width = Atomics.load(syncArray, WIDTH_INDEX);
        const height = Atomics.load(syncArray, HEIGHT_INDEX);
        if (width <= 0 || height <= 0) {
          await delay(MIN_LOOP_DELAY_MS);
          continue;
        }

        const metadata = { width, height, frameCounter: newFrameCounter };
        const now = performance.now();

        // Check if we need to scan (time-based or dimension change)
        const needsScan =
          now >= nextScanTime ||
          Object.keys(lastKnownRegions).length === 0 ||
          width !== lastWidth ||
          height !== lastHeight;

        if (needsScan) {
          // Set scanning flag to prevent overlapping scans
          isScanning = true;

          try {
            const newRegions = await performFullScan(
              sharedBufferView,
              metadata,
            );

            // Update state after successful scan
            lastScanTime = now;
            lastWidth = width;
            lastHeight = height;
            lastKnownRegions = newRegions;

            // Schedule next scan
            nextScanTime = lastScanTime + FULL_SCAN_INTERVAL_MS;

            // Send update to parent
            parentPort.postMessage({
              storeUpdate: true,
              type: setAllRegions.type,
              payload: newRegions,
            });
          } catch (err) {
            console.error('[RegionMonitor] Error during scan:', err);
            // Reset state on error
            lastKnownRegions = {};
            lastProcessedFrameCounter = -1;
            // Schedule next scan after error
            nextScanTime = performance.now() + FULL_SCAN_INTERVAL_MS;
          } finally {
            // Always clear scanning flag
            isScanning = false;
          }
        }
      }

      // Log performance stats periodically
      logPerformanceStats();
    } catch (err) {
      console.error('[RegionMonitor] Error in main loop:', err);
      // Reset state on error
      lastKnownRegions = {};
      lastProcessedFrameCounter = -1;
      // Schedule next scan after error
      nextScanTime = performance.now() + FULL_SCAN_INTERVAL_MS;
    }

    // Calculate delay until next iteration
    const loopEndTime = performance.now();
    const elapsedTime = loopEndTime - loopStartTime;
    const timeUntilNextScan = nextScanTime - loopEndTime;

    // Wait until next scan is due or minimum delay
    const delayTime = Math.max(
      MIN_LOOP_DELAY_MS,
      Math.min(FULL_SCAN_INTERVAL_MS, timeUntilNextScan),
    );

    if (delayTime > 0) {
      await delay(delayTime);
    }
  }

  console.log('[RegionMonitor] Main loop stopped.');
}

// ========================================================================
// --- Message Handler (Updated for new WorkerManager) ---
// ========================================================================
parentPort.on('message', (message) => {
  try {
    if (message.type === 'state_diff') {
      // Handle state updates from WorkerManager
      if (!currentState) {
        currentState = {};
      }
      // Apply state diff
      Object.assign(currentState, message.payload);
      // Handle specific state changes that affect region monitoring
      if (message.payload.global) {
        const globalState = message.payload.global;
        // If window changed, force a full scan
        if (
          globalState.windowId !== undefined &&
          currentState.global?.windowId !== globalState.windowId
        ) {
          console.log('[RegionMonitor] Window changed, forcing full scan.');
          // Reset scan time to trigger immediate scan
          nextScanTime = 0;
        }
      }
    } else if (message.type === 'shutdown') {
      console.log('[RegionMonitor] Received shutdown command.');
      isShuttingDown = true;
    } else if (
      typeof message === 'object' &&
      !message.type &&
      !message.command
    ) {
      // Handle full state updates (initial state)
      currentState = message;
      console.log('[RegionMonitor] Received initial state update.');
    }
  } catch (err) {
    console.error('[RegionMonitor] Error handling message:', err);
  }
});

// ========================================================================
// --- Worker Startup ---
// ========================================================================
async function startWorker() {
  console.log(
    '[RegionMonitor] Worker starting up with non-overlapping scans...',
  );

  // Handle graceful shutdown
  process.on('SIGTERM', () => {
    console.log('[RegionMonitor] Received SIGTERM, shutting down...');
    isShuttingDown = true;
  });

  process.on('SIGINT', () => {
    console.log('[RegionMonitor] Received SIGINT, shutting down...');
    isShuttingDown = true;
  });

  mainLoop().catch((err) => {
    console.error('[RegionMonitor] Fatal error in main loop:', err);
    process.exit(1);
  });
}

startWorker();

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/CooldownManager.js
//start file
import { performance as perf } from 'perf_hooks';

// Configuration Section
const CONFIG = {
  ENABLE_COOLDOWN_LOGGING: false,
  DEBOUNCE_DURATION: 50,
  HISTORY_LENGTH: 3,
  MAX_COOLDOWN_DURATIONS: {
    attack: 2000,
    healing: 1000,
    support: 500,
  },
};

const COOLDOWN_DURATIONS = {
  healing: 1000,
  attack: 1950,
  support: 500,
};

export class CooldownManager {
  constructor() {
    this.cooldowns = {
      healing: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
      attack: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
      support: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
    };
  }

  forceDeactivate(type) {
    const cooldown = this.cooldowns[type];
    const now = perf.now();

    cooldown.active = false;
    cooldown.startTime = 0;
    cooldown.debounceEndTime = now + CONFIG.DEBOUNCE_DURATION;
    cooldown.history = [];

    if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
      console.log(`${type} cooldown force-deactivated by UI state`);
    }
  }

  updateCooldown(type, isActive) {
    const now = perf.now();
    const cooldown = this.cooldowns[type];

    // Update state history
    cooldown.history.push(isActive);
    if (cooldown.history.length > CONFIG.HISTORY_LENGTH) {
      cooldown.history.shift();
    }

    // Determine consistent state
    const activeCount = cooldown.history.filter((state) => state).length;
    const consistentActive = activeCount >= Math.ceil(CONFIG.HISTORY_LENGTH / 2);

    // Activation logic
    if (consistentActive && !cooldown.active && now >= cooldown.debounceEndTime) {
      cooldown.active = true;
      cooldown.startTime = now;
      cooldown.debounceEndTime = now + COOLDOWN_DURATIONS[type] - CONFIG.DEBOUNCE_DURATION;

      if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
        console.log(`${type} cooldown activated`);
      }
    }

    // Deactivation logic
    if (!consistentActive && cooldown.active && now >= cooldown.debounceEndTime) {
      const elapsedTime = now - cooldown.startTime;
      const maxDuration = CONFIG.MAX_COOLDOWN_DURATIONS[type];

      if (elapsedTime >= COOLDOWN_DURATIONS[type] || elapsedTime >= maxDuration) {
        cooldown.active = false;
        cooldown.debounceEndTime = now + CONFIG.DEBOUNCE_DURATION;

        if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
          console.log(`${type} cooldown naturally deactivated after ${elapsedTime.toFixed(1)}ms`);
        }
      }
    }

    return cooldown.active;
  }

  getCooldownState(type) {
    const cooldown = this.cooldowns[type];
    if (cooldown.active) {
      const elapsedTime = perf.now() - cooldown.startTime;
      const maxDuration = CONFIG.MAX_COOLDOWN_DURATIONS[type];

      // Force expiration if beyond maximum allowed duration
      if (elapsedTime >= maxDuration) {
        cooldown.active = false;
        cooldown.debounceEndTime = perf.now() + CONFIG.DEBOUNCE_DURATION;

        if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
          console.log(`${type} cooldown forced expiration after ${elapsedTime.toFixed(2)}ms`);
        }
      }
    }
    return cooldown.active;
  }

  getStats() {
    if (!CONFIG.ENABLE_COOLDOWN_LOGGING) return null;

    const stats = {};
    const now = perf.now();

    for (const [type, data] of Object.entries(this.cooldowns)) {
      const currentDuration = data.active ? now - data.startTime : 0;
      stats[type] = {
        isActive: data.active,
        currentActiveDuration: currentDuration,
        debounceEndTime: data.debounceEndTime,
        history: [...data.history],
      };
    }

    return stats;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/constants.js
//start file
export const OPTIONS = {
  globalDelay: 0,
  categoryDelays: {
    Healing: 200,
    Potion: 975,
    Support: 475,
    Attack: 1975,
    Equip: 250,
    Others: 50,
  },
  cooldownStateMapping: {
    Healing: 'healingCd',
    Support: 'supportCd',
    Attack: 'attackCd',
  },
  logsEnabled: false,
};

export const PARTY_MEMBER_STATUS = {
  active: {
    sequence: [
      [192, 192, 192],
      [192, 192, 192],
    ],
    direction: 'horizontal',
  },
  activeHover: {
    sequence: [
      [247, 247, 247],
      [247, 247, 247],
    ],
    direction: 'horizontal',
  },
  // inactive: {
  //   sequence: [
  //     [128, 128, 128],
  //     [128, 128, 128],
  //   ],
  //   direction: 'horizontal',
  // },
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/ruleFilterUtils.js
//start file
import parseMathCondition from '../../utils/parseMathCondition.js';
import areCharStatusConditionsMet from '../../utils/areStatusConditionsMet.js';
import { OPTIONS } from './constants.js';

let lastRuleExecutionTimes = {};
let lastCategoriesExecutionTimes = {};

export const filterEnabledRules = (rules) => rules.filter((rule) => rule.enabled);

export const filterRulesNotOnDelay = (rules) =>
  rules.filter(
    (rule) =>
      Date.now() - (lastRuleExecutionTimes[rule.id] || 0) >= (rule.delay || 0) &&
      Date.now() -
        Math.max(
          ...rules
            .filter((r) => r.category === rule.category)
            .map((r) => lastRuleExecutionTimes[r.id] || 0),
        ) >=
        OPTIONS.categoryDelays[rule.category],
  );

export const filterRulesByActiveCooldowns = (rules, directGameState) =>
  rules.filter((rule) => {
    const cooldownStateKey = OPTIONS.cooldownStateMapping[rule.category];
    return !cooldownStateKey || !directGameState[cooldownStateKey];
  });

export const filterRulesByConditions = (rules, directGameState) =>
  rules.filter((rule) => {
    return (
      parseMathCondition(
        rule.hpTriggerCondition,
        parseInt(rule.hpTriggerPercentage, 10),
        directGameState.hppc,
      ) &&
      parseMathCondition(
        rule.manaTriggerCondition,
        parseInt(rule.manaTriggerPercentage, 10),
        directGameState.mppc,
      ) &&
      areCharStatusConditionsMet(rule, directGameState) &&
      parseMathCondition(
        rule.monsterNumCondition,
        parseInt(rule.monsterNum, 10),
        directGameState.monsterNum,
      )
    );
  });

export const getAllValidRules = (rules, directGameState) => {
  const enabledRules = filterEnabledRules(rules);
  const rulesWithoutActiveCooldowns = filterRulesByActiveCooldowns(enabledRules, directGameState);
  const rulesNotOnDelay = filterRulesNotOnDelay(rulesWithoutActiveCooldowns);
  return filterRulesByConditions(rulesNotOnDelay, directGameState).sort(
    (a, b) => b.priority - a.priority,
  );
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/ruleProcessor.js
//start file
import parseMathCondition from '../../utils/parseMathCondition.js';
import areCharStatusConditionsMet from '../../utils/areStatusConditionsMet.js';
import {
  keyPress,
  keyPressMultiple,
  getIsTyping,
} from '../../keyboardControll/keyPress.js';
import { createLogger } from '../../utils/logger.js';

const log = createLogger({ info: true, error: true, warn: true });

import useItemOnCoordinates from '../../mouseControll/useItemOnCoordinates.js';
import { getRandomNumber } from '../../utils/getRandomNumber.js';
import { OPTIONS } from './constants.js';

class RuleProcessor {
  constructor() {
    this.lastSuccessfulRuleActionTime = {}; // PRIMARY FOR DELAY on non-ManaSync rules
    this.lastCategoryExecutionTime = {};
    this.lastPartyHealActionTime = 0;
    this.lastAttackCooldownState = false;
    this.attackCooldownStartTime = null;
    this.lastKeypressTime = 0;
    this.effectiveCooldownEndTime = 0;

    // ManaSync specific state
    this.manaSyncWatchList = new Map();
    this.executedManaSyncThisCooldown = new Set();
    this.forcedManaSyncExecutedThisCooldown = new Set();

    this.pendingActionConfirmations = new Map(); // For item disappearance check

    // Attack CD Exclusivity state
    this.actionTakenThisAttackCooldown = false;
    this.healFriendRuneExecutionsThisAttackCooldown = 0;

    // Constants
    this.KEYPRESS_COOLDOWN_MS = 50;
    this.PARTY_HEAL_MIN_INTERVAL_MS = 50;
    this.MANASYNC_FORCED_EXECUTION_DELAY_MS = 740;
    this.MANASYNC_FORCED_EXECUTION_WINDOW_MS = 100;
    this.MANA_SYNC_WATCH_DURATION_MS = 800;
    this.ACTION_CONFIRMATION_TIMEOUT_MS = 300;

    this.RULE_PREFIX = {
      USER: 'userRule',
      ACTION_BAR: 'actionBarItem',
      MANA_SYNC: 'manaSync',
      PARTY_HEAL: 'healFriend',
      ROTATION: 'rotationRule',
      EQUIP: 'equipRule',
    };
    this.PARTY_HEAL_RUNE_ITEMS = new Set([
      'ultimateHealingRune',
      'intenseHealingRune',
    ]);
  }

  async processRules(activePreset, gameState, globalConfig) {
    const now = Date.now();

    if (getIsTyping()) {
      return;
    }

    if (!globalConfig.isOnline) {
      return;
    }

    if (!gameState.rulesEnabled) {
      return;
    }

    // --- ManaSync Processing ---
    const attackCdChanged = this._handleAttackCooldownTransitions(
      now,
      gameState,
      activePreset,
      globalConfig,
    );
    let manaSyncRuleExecutedImmediately = attackCdChanged.executed;

    let manaSyncRuleExecutedFromWatch = false;
    if (
      !manaSyncRuleExecutedImmediately &&
      gameState.attackCd &&
      this.manaSyncWatchList.size > 0 &&
      !this.actionTakenThisAttackCooldown
    ) {
      manaSyncRuleExecutedFromWatch = this._processManaSyncWatch(
        now,
        gameState,
        activePreset,
        globalConfig,
      );
    }

    let manaSyncRuleForcedExecution = false;
    if (
      gameState.attackCd &&
      !this.actionTakenThisAttackCooldown &&
      !manaSyncRuleExecutedImmediately &&
      !manaSyncRuleExecutedFromWatch
    ) {
      manaSyncRuleForcedExecution = this._processForcedManaSyncExecution(
        now,
        gameState,
        activePreset,
        globalConfig,
      );
    }

    // --- Action Confirmation Processing ---
    this._processActionConfirmations(now, gameState);

    let ruleActionTriggeredThisCycle =
      manaSyncRuleExecutedImmediately ||
      manaSyncRuleExecutedFromWatch ||
      manaSyncRuleForcedExecution;

    // --- Standard Rule Processing (User, Equip, ActionBar, PartyHeal non-rune) ---
    if (!ruleActionTriggeredThisCycle) {
      const nonManaSyncPreset = activePreset.filter(
        (r) => !r.id.startsWith(this.RULE_PREFIX.MANA_SYNC),
      );
      const eligibleRules = this._filterEligibleRules(
        now,
        nonManaSyncPreset,
        gameState,
      );

      if (eligibleRules.length > 0) {
        const ruleToExecute = eligibleRules[0];
        const nonManaSyncActionSuccess = this._attemptExecutionAndHandleOutcome(
          now,
          ruleToExecute,
          gameState,
          globalConfig,
        );

        if (nonManaSyncActionSuccess) {
          ruleActionTriggeredThisCycle = true;
        }
      }
    }
  }

  // --- Filtering Logic ---
  _filterEligibleRules(now, rules, gameState) {
    let eligibleRules = rules.filter((rule) => rule.enabled);

    eligibleRules = this._filterRulesByActiveCooldowns(
      eligibleRules,
      gameState,
    );

    eligibleRules = this._filterRulesNotOnDelay(now, eligibleRules);

    eligibleRules = this._filterRulesByWalkingState(eligibleRules, gameState);

    eligibleRules = eligibleRules.filter((rule) => {
      /* PartyHeal Interval Filter */
      if (rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        const timeSinceLastHeal = now - this.lastPartyHealActionTime;
        return timeSinceLastHeal >= this.PARTY_HEAL_MIN_INTERVAL_MS;
      }
      return true;
    });

    eligibleRules = eligibleRules.filter((rule) => {
      /* HealFriend Rune Exclusivity */
      if (
        rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem)
      ) {
        if (gameState.attackCd) {
          if (this.actionTakenThisAttackCooldown) {
            return false;
          }
          if (this.healFriendRuneExecutionsThisAttackCooldown >= 2) {
            return false;
          }
        }
      }
      return true;
    });

    eligibleRules = this._filterRulesByBasicConditions(
      eligibleRules,
      gameState,
    );

    eligibleRules = this._filterRulesByItemAvailability(
      eligibleRules,
      gameState,
    );

    eligibleRules = eligibleRules.filter((rule) => {
      /* Equip Rule Specifics */
      if (rule.id.startsWith(this.RULE_PREFIX.EQUIP)) {
        if (
          typeof rule.actionItem !== 'string' ||
          rule.actionItem.trim() === '' ||
          !rule.targetSlot
        )
          return false;
        if (typeof rule.equipOnlyIfSlotIsEmpty !== 'boolean') return false;

        const currentItemInSlot = gameState.equippedItems?.[rule.targetSlot];
        const itemToBeEquippedName =
          rule.itemToBeEquippedName || rule.actionItem;

        if (rule.equipOnlyIfSlotIsEmpty) {
          let expectedEmptyItemKey;
          // {{change 1}}
          if (rule.targetSlot === 'amulet') {
            expectedEmptyItemKey = 'Empty';
          } else if (rule.targetSlot === 'ring') {
            expectedEmptyItemKey = 'Empty';
          } else if (rule.targetSlot === 'boots') {
            expectedEmptyItemKey = 'Empty';
          } else {
            return false;
          }
          if (currentItemInSlot !== expectedEmptyItemKey) {
            return false;
          }
        }
        // Avoid re-equipping if the item is already in the slot
        if (currentItemInSlot === itemToBeEquippedName) {
          return false;
        }
        return true;
      }
      return true;
    });

    eligibleRules = eligibleRules.filter((rule) => {
      /* PartyHeal Final Condition */
      if (rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        return this._shouldHealFriend(rule, gameState);
      }
      return true;
    });

    eligibleRules.sort((a, b) => (b.priority || 0) - (a.priority || 0));
    return eligibleRules;
  }

  _filterRulesNotOnDelay(now, rules) {
    return rules.filter((rule) => {
      const ruleId = rule.id;
      const ruleDelay = rule.delay ?? 0;
      const category = rule.category;

      // INDIVIDUAL DELAY
      const timeSinceLastSuccessfulTrigger =
        now - (this.lastSuccessfulRuleActionTime[ruleId] || 0);
      if (timeSinceLastSuccessfulTrigger < ruleDelay) {
        return false;
      }

      // CATEGORY DELAY
      if (rule.id.startsWith(this.RULE_PREFIX.USER) && category) {
        const categoryDelay = OPTIONS.categoryDelays?.[category] ?? 0;
        if (categoryDelay > 0) {
          const timeSinceCategoryLastTrigger =
            now - (this.lastCategoryExecutionTime[category] || 0);
          if (timeSinceCategoryLastTrigger < categoryDelay) {
            return false;
          }
        }
      }
      return true;
    });
  }

  _filterRulesByActiveCooldowns(rules, gameState) {
    return rules.filter((rule) => {
      if (rule.id.startsWith(this.RULE_PREFIX.USER)) {
        const cooldownStateKey = rule.category
          ? OPTIONS.cooldownStateMapping?.[rule.category]
          : null;
        return !cooldownStateKey || !gameState[cooldownStateKey];
      }
      return true;
    });
  }

  _filterRulesByWalkingState(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.USER) ||
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR)
      ) {
        return !rule.isWalking || (rule.isWalking && gameState.isWalking);
      }
      return true;
    });
  }

  _filterRulesByBasicConditions(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.USER) ||
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR) ||
        rule.id.startsWith(this.RULE_PREFIX.EQUIP)
      ) {
        const hpMet = parseMathCondition(
          rule.hpTriggerCondition,
          parseInt(rule.hpTriggerPercentage, 10),
          gameState.hppc,
        );
        const manaMet = parseMathCondition(
          rule.manaTriggerCondition,
          parseInt(rule.manaTriggerPercentage, 10),
          gameState.mppc,
        );
        let monsterMet = true;
        if (rule.monsterNumCondition != null && rule.monsterNum != null) {
          monsterMet = parseMathCondition(
            rule.monsterNumCondition,
            parseInt(rule.monsterNum, 10),
            gameState.monsterNum,
          );
        }
        const statusMet = areCharStatusConditionsMet(rule, gameState);
        return hpMet && manaMet && statusMet && monsterMet;
      }
      return true;
    });
  }

  _filterRulesByItemAvailability(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR) ||
        rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) ||
        rule.id.startsWith(this.RULE_PREFIX.EQUIP)
      ) {
        const requiredItemToClick = rule.actionItem;
        if (
          typeof requiredItemToClick !== 'string' ||
          requiredItemToClick.trim() === ''
        ) {
          return false;
        }

        const isCreateRuneAction =
          requiredItemToClick.includes('create') &&
          requiredItemToClick.includes('Rune');

        if (isCreateRuneAction) {
          if (!gameState.activeActionItems?.['blankRune']) {
            return false;
          }
        }

        if (!gameState.activeActionItems?.[requiredItemToClick]) {
          return false;
        }
        return true;
      }
      return true;
    });
  }

  // --- ManaSync Logic ---
  _handleAttackCooldownTransitions(now, gameState, activePreset, globalConfig) {
    const attackCdIsCurrentlyActive = gameState.attackCd;
    const attackCdJustStarted =
      attackCdIsCurrentlyActive && !this.lastAttackCooldownState;
    const attackCdJustEnded =
      !attackCdIsCurrentlyActive && this.lastAttackCooldownState;
    let executedManaSyncNow = false;

    if (attackCdJustEnded) {
      this.manaSyncWatchList.clear();
      this.executedManaSyncThisCooldown.clear();
      this.forcedManaSyncExecutedThisCooldown.clear();
      this.attackCooldownStartTime = null;
    }

    if (attackCdJustStarted) {
      this.attackCooldownStartTime = now;
      this.manaSyncWatchList.clear();
      this.executedManaSyncThisCooldown.clear();
      this.forcedManaSyncExecutedThisCooldown.clear();
      this.actionTakenThisAttackCooldown = false;
      this.healFriendRuneExecutionsThisAttackCooldown = 0;

      const manaSyncRules = activePreset
        .filter((r) => r.enabled && r.id.startsWith(this.RULE_PREFIX.MANA_SYNC))
        .sort((a, b) => (b.priority || 0) - (a.priority || 0));

      for (const rule of manaSyncRules) {
        if (executedManaSyncNow || this.actionTakenThisAttackCooldown) break;
        const conditionsMet = this._checkManaSyncConditions(rule, gameState);
        const itemIsActive = !!gameState.activeActionItems?.[rule.actionItem];
        if (conditionsMet.all) {
          if (!rule.actionItem) {
            console.warn(`[RuleProc] ManaSync ${rule.id} no actionItem.`);
            continue;
          }
          if (itemIsActive) {
            if (
              !this._hasHigherPriorityEligibleHealFriend(
                gameState,
                activePreset,
                rule.priority || 0,
                now,
              )
            ) {
              const keypressSent = this._tryExecuteAction(
                now,
                rule,
                gameState,
                globalConfig,
                'manaSyncNormal',
              );
              if (keypressSent) {
                this.executedManaSyncThisCooldown.add(rule.id);
                this.actionTakenThisAttackCooldown = true;
                executedManaSyncNow = true;
              }
            }
          } else {
            this.manaSyncWatchList.set(rule.id, {
              startTime: now,
              checkedConditions: conditionsMet,
            });
          }
        }
      }
    }
    this.lastAttackCooldownState = attackCdIsCurrentlyActive;
    return {
      changed: attackCdJustStarted || attackCdJustEnded,
      executed: executedManaSyncNow,
    };
  }

  _processManaSyncWatch(now, gameState, activePreset, globalConfig) {
    if (this.manaSyncWatchList.size === 0 || this.actionTakenThisAttackCooldown)
      return false;
    let executedFromWatch = false;
    const rulesToRemoveFromWatch = [];
    const sortedWatchKeys = Array.from(this.manaSyncWatchList.keys())
      .sort
      /* by prio */
      ();

    for (const ruleId of sortedWatchKeys) {
      if (executedFromWatch || this.actionTakenThisAttackCooldown) break;
      const watchData = this.manaSyncWatchList.get(ruleId);
      const rule = activePreset.find((r) => r.id === ruleId);
      if (
        !rule ||
        !rule.actionItem ||
        this.executedManaSyncThisCooldown.has(ruleId) ||
        now - watchData.startTime > this.MANA_SYNC_WATCH_DURATION_MS
      ) {
        rulesToRemoveFromWatch.push(ruleId);
        continue;
      }
      const itemIsNowActive = !!gameState.activeActionItems?.[rule.actionItem];
      if (itemIsNowActive) {
        const conditionsStillMet = this._checkManaSyncConditions(
          rule,
          gameState,
        );
        if (conditionsStillMet.all) {
          if (
            !this._hasHigherPriorityEligibleHealFriend(
              gameState,
              activePreset,
              rule.priority || 0,
              now,
            )
          ) {
            const keypressSent = this._tryExecuteAction(
              now,
              rule,
              gameState,
              globalConfig,
              'manaSyncNormal',
            );
            if (keypressSent) {
              this.executedManaSyncThisCooldown.add(ruleId);
              this.actionTakenThisAttackCooldown = true;
              executedFromWatch = true;
            }
          }
        }
        rulesToRemoveFromWatch.push(ruleId);
      }
    }
    rulesToRemoveFromWatch.forEach((id) => this.manaSyncWatchList.delete(id));
    return executedFromWatch;
  }

  _processForcedManaSyncExecution(now, gameState, activePreset, globalConfig) {
    if (
      !gameState.attackCd ||
      !this.attackCooldownStartTime ||
      this.actionTakenThisAttackCooldown
    )
      return false;
    const timeSinceCdStart = now - this.attackCooldownStartTime;
    const isInForcedWindow =
      timeSinceCdStart >= this.MANASYNC_FORCED_EXECUTION_DELAY_MS &&
      timeSinceCdStart <=
        this.MANASYNC_FORCED_EXECUTION_DELAY_MS +
          this.MANASYNC_FORCED_EXECUTION_WINDOW_MS;
    if (!isInForcedWindow) return false;

    const manaSyncRules = activePreset
      .filter((r) => r.enabled && r.id.startsWith(this.RULE_PREFIX.MANA_SYNC))
      .sort((a, b) => (b.priority || 0) - (a.priority || 0));
    for (const rule of manaSyncRules) {
      if (this.actionTakenThisAttackCooldown) break;
      if (
        this.executedManaSyncThisCooldown.has(rule.id) ||
        this.forcedManaSyncExecutedThisCooldown.has(rule.id)
      )
        continue;
      const conditionsMet = this._checkManaSyncConditions(rule, gameState);
      if (conditionsMet.all) {
        if (
          !this._hasHigherPriorityEligibleHealFriend(
            gameState,
            activePreset,
            rule.priority || 0,
            now,
          )
        ) {
          const keypressSent = this._tryExecuteAction(
            now,
            rule,
            gameState,
            globalConfig,
            'manaSyncForced',
          );
          if (keypressSent) {
            this.forcedManaSyncExecutedThisCooldown.add(rule.id);
            this.actionTakenThisAttackCooldown = true;
            return true;
          }
        }
      }
    }
    return false;
  }

  _checkManaSyncConditions(rule, gameState) {
    const hpMet = parseMathCondition(
      rule.hpTriggerCondition ?? '>=',
      parseInt(rule.hpTriggerPercentage ?? 0, 10),
      gameState.hppc,
    );
    const manaMet = parseMathCondition(
      rule.manaTriggerCondition ?? '<=',
      parseInt(rule.manaTriggerPercentage ?? 100, 10),
      gameState.mppc,
    );
    const statusMet = areCharStatusConditionsMet(rule, gameState);
    return { hpMet, manaMet, statusMet, all: hpMet && manaMet && statusMet };
  }

  _hasHigherPriorityEligibleHealFriend(
    gameState,
    activePreset,
    manaSyncPriority,
    now,
  ) {
    if (this.actionTakenThisAttackCooldown) return false;
    const competingHealFriends = activePreset.filter(
      (r) =>
        r.enabled &&
        r.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        r.requireAttackCooldown === true &&
        (r.priority || 0) > manaSyncPriority,
    );
    if (competingHealFriends.length === 0) return false;
    for (const healRule of competingHealFriends) {
      if (
        this.PARTY_HEAL_RUNE_ITEMS.has(healRule.actionItem) &&
        this.healFriendRuneExecutionsThisAttackCooldown >= 2
      )
        continue;
      const healRuleDelay = healRule.delay ?? 0;
      const timeSinceHealRuleLastTrigger =
        now - (this.lastSuccessfulRuleActionTime[healRule.id] || 0);
      if (timeSinceHealRuleLastTrigger < healRuleDelay) continue;
      if (this._shouldHealFriend(healRule, gameState) && healRule.actionItem)
        return true;
    }
    return false;
  }

  // --- Action Execution and Confirmation ---
  _processActionConfirmations(now, gameState) {
    if (this.pendingActionConfirmations.size === 0) return;
    const ruleIdsToRemove = [];
    for (const [ruleId, data] of this.pendingActionConfirmations) {
      if (
        !gameState.activeActionItems?.[data.actionItem] ||
        now - data.attemptTimestamp > this.ACTION_CONFIRMATION_TIMEOUT_MS
      ) {
        ruleIdsToRemove.push(ruleId);
      }
    }
    ruleIdsToRemove.forEach((id) => this.pendingActionConfirmations.delete(id));
  }

  _attemptExecutionAndHandleOutcome(
    now,
    ruleToExecute,
    gameState,
    globalConfig,
  ) {
    const ruleId = ruleToExecute.id;

    if (this.pendingActionConfirmations.has(ruleId)) {
      return false;
    }

    const actionSuccess = this._tryExecuteAction(
      now,
      ruleToExecute,
      gameState,
      globalConfig,
      'standard',
    );

    if (actionSuccess) {
      this.lastSuccessfulRuleActionTime[ruleId] = now;

      if (ruleToExecute.category && ruleId.startsWith(this.RULE_PREFIX.USER)) {
        this.lastCategoryExecutionTime[ruleToExecute.category] = now;
      }
      if (ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        this.lastPartyHealActionTime = now;
        if (
          this.PARTY_HEAL_RUNE_ITEMS.has(ruleToExecute.actionItem) &&
          gameState.attackCd
        ) {
          this.actionTakenThisAttackCooldown = true;
          this.healFriendRuneExecutionsThisAttackCooldown++;
        }
      }
      if (
        typeof ruleToExecute.actionItem === 'string' &&
        ruleToExecute.actionItem.length > 0
      ) {
        this.pendingActionConfirmations.set(ruleId, {
          attemptTimestamp: now,
          actionItem: ruleToExecute.actionItem,
        });
      }
      return true;
    }
    return false;
  }

  _tryExecuteAction(now, rule, gameState, globalConfig, executionType) {
    const ruleId = rule.id;
    const isManaSync = executionType.startsWith('manaSync');
    const isPriorityRuleForCooldown =
      isManaSync ||
      (ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem) &&
        gameState.attackCd);

    if (!isPriorityRuleForCooldown && now < this.effectiveCooldownEndTime) {
      return false;
    }

    if (!rule.key) {
      console.warn(`[RuleProc] Cannot execute ${ruleId}: Missing 'key'.`);
      return false;
    }

    let actionSent = false;
    try {
      if (
        ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem)
      ) {
        const targetMember = this._findPartyHealTarget(rule, gameState);
        if (targetMember?.uhCoordinates) {
          useItemOnCoordinates(
            globalConfig.windowId,
            globalConfig.display,
            targetMember.uhCoordinates.x + getRandomNumber(0, 130),
            targetMember.uhCoordinates.y + getRandomNumber(0, 11),
            rule.key,
          );
          actionSent = true;
        } else {
          console.warn(
            `[RuleProc] PartyHeal Rune ${ruleId}: No valid target found.`,
          );
        }
      } else {
        keyPress(globalConfig.display, rule.key);
        actionSent = true;
      }

      if (actionSent) {
        this.lastKeypressTime = now;
        this.effectiveCooldownEndTime =
          now + (isPriorityRuleForCooldown ? 25 : this.KEYPRESS_COOLDOWN_MS);
      }
      return actionSent;
    } catch (error) {
      console.error(
        `[RuleProcessor] Error during action execution for ${ruleId} (Type: ${executionType}):`,
        error,
      );
      return false;
    }
  }

  // --- Party Heal Specific Logic ---
  _shouldHealFriend(rule, gameState) {
    if (!gameState?.partyMembers || rule.friendHpTriggerPercentage == null)
      return false;
    if (rule.requireAttackCooldown && !gameState.attackCd) return false;
    const hpTriggerPercentage = parseInt(rule.friendHpTriggerPercentage, 10);
    const partyPositionIndex = parseInt(rule.partyPosition, 10);
    if (
      isNaN(partyPositionIndex) ||
      partyPositionIndex < 0 ||
      isNaN(hpTriggerPercentage)
    )
      return false;
    if (partyPositionIndex === 0) {
      return gameState.partyMembers.some(
        (m) =>
          m.isActive &&
          m.hppc != null &&
          m.hppc > 0 &&
          m.hppc <= hpTriggerPercentage,
      );
    } else {
      const targetMember = gameState.partyMembers?.[partyPositionIndex - 1];
      return (
        !!targetMember &&
        targetMember.isActive &&
        targetMember.hppc != null &&
        targetMember.hppc > 0 &&
        targetMember.hppc <= hpTriggerPercentage
      );
    }
  }

  _findPartyHealTarget(rule, gameState) {
    const hpTriggerPercentage = parseInt(rule.friendHpTriggerPercentage, 10);
    const partyPositionIndex = parseInt(rule.partyPosition, 10);
    if (
      isNaN(partyPositionIndex) ||
      partyPositionIndex < 0 ||
      isNaN(hpTriggerPercentage)
    )
      return null;
    if (partyPositionIndex === 0) {
      const potentialTargets = gameState.partyMembers
        .filter(
          (m) =>
            m.isActive &&
            m.hppc != null &&
            m.hppc > 0 &&
            m.hppc <= hpTriggerPercentage,
        )
        .sort((a, b) => a.hppc - b.hppc);
      return potentialTargets[0] || null;
    } else {
      const targetMember = gameState.partyMembers?.[partyPositionIndex - 1];
      if (
        targetMember &&
        targetMember.isActive &&
        targetMember.hppc != null &&
        targetMember.hppc > 0 &&
        targetMember.hppc <= hpTriggerPercentage
      ) {
        return targetMember;
      }
      return null;
    }
  }
}

export default RuleProcessor;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor.js
//start file
/**
 * @file screenMonitor.js
 * @summary A dedicated worker for processing game state data from pre-identified screen regions.
 */

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import { resourceBars } from '../constants/index.js';
import { setBattleListEntries } from '../../frontend/redux/slices/battleListSlice.js';
import calculatePercentages from '../screenMonitor/calcs/calculatePercentages.js';
import RuleProcessor from './screenMonitor/ruleProcessor.js';
import { CooldownManager } from './screenMonitor/CooldownManager.js';

// --- Worker Configuration ---
const { sharedData } = workerData;
const SCAN_INTERVAL_MS = 50;
const PERFORMANCE_LOG_INTERVAL = 10000; // Log performance every 10 seconds

// --- Shared Buffer Setup ---
if (!sharedData) throw new Error('[ScreenMonitor] Shared data not provided.');
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

// --- Correct SharedArrayBuffer Indices ---
const FRAME_COUNTER_INDEX = 0;
const WIDTH_INDEX = 1;
const HEIGHT_INDEX = 2;
const IS_RUNNING_INDEX = 3;
const DIRTY_REGION_COUNT_INDEX = 5;
const DIRTY_REGIONS_START_INDEX = 6;

// --- State Variables ---
let currentState = null;
let lastProcessedFrameCounter = -1;
let isShuttingDown = false;
let isInitialized = false;

const cooldownManager = new CooldownManager();
const ruleProcessorInstance = new RuleProcessor();
const initializedRegions = new Set();

// --- Performance Tracking ---
let operationCount = 0;
let calculationCount = 0;
let totalOperationTime = 0;
let totalCalculationTime = 0;
let lastPerfReport = Date.now();

// --- Cached State ---
let lastCalculatedState = {
  hppc: null,
  mppc: null,
  healingCd: { onCooldown: false, remaining: 0 },
  supportCd: { onCooldown: false, remaining: 0 },
  attackCd: { onCooldown: false, remaining: 0 },
  characterStatus: {},
  partyMembers: [],
  isWalking: false,
  activeActionItems: {},
  equippedItems: {},
  battleList: [],
  lastMovementTimestamp: 0,
  lastKnownPlayerMinimapPosition: null,
  monsterNum: 0,
};

// --- Reusable objects to reduce GC pressure ---
const reusableGameStateUpdate = {
  storeUpdate: true,
  type: 'gameState/updateGameStateFromMonitorData',
  payload: {},
};

const reusableBattleListUpdate = {
  storeUpdate: true,
  type: setBattleListEntries.type,
  payload: [],
};

// --- Utilities ---
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

// --- Performance Monitoring ---
function logPerformanceStats() {
  const now = Date.now();
  const timeSinceLastReport = now - lastPerfReport;

  if (timeSinceLastReport >= PERFORMANCE_LOG_INTERVAL) {
    const avgOpTime =
      operationCount > 0 ? (totalOperationTime / operationCount).toFixed(2) : 0;
    const avgCalcTime =
      calculationCount > 0
        ? (totalCalculationTime / calculationCount).toFixed(2)
        : 0;
    const opsPerSecond = (
      (operationCount / timeSinceLastReport) *
      1000
    ).toFixed(1);
    const calcsPerSecond = (
      (calculationCount / timeSinceLastReport) *
      1000
    ).toFixed(1);

    console.log(
      `[ScreenMonitor] Performance: ${opsPerSecond} ops/sec (avg: ${avgOpTime}ms), ` +
        `${calcsPerSecond} calcs/sec (avg: ${avgCalcTime}ms)`,
    );

    // Reset counters
    operationCount = 0;
    calculationCount = 0;
    totalOperationTime = 0;
    totalCalculationTime = 0;
    lastPerfReport = now;
  }
}

// --- Worker Initialization ---
function initializeWorker() {
  console.log('[ScreenMonitor] Initializing worker...');
  isInitialized = true;
}

// --- Rule Processing ---
function runRules(ruleInput) {
  if (!currentState?.rules?.enabled) return;

  const currentPreset =
    currentState?.rules?.presets?.[currentState?.rules?.activePresetIndex];
  if (!currentPreset) return;

  try {
    ruleProcessorInstance.processRules(currentPreset, ruleInput, {
      ...currentState.global,
      isOnline: currentState?.regionCoordinates?.regions?.onlineMarker ?? false,
    });
  } catch (error) {
    console.error('[ScreenMonitor] Rule processing error:', error);
  }
}

// --- Calculation Functions ---
function calculateHealthBar(bufferToUse, metadata, regions) {
  if (!regions.healthBar) return lastCalculatedState.hppc;

  const calcStart = performance.now();
  const result = calculatePercentages(
    bufferToUse,
    metadata,
    regions.healthBar,
    resourceBars.healthBar,
    94,
  );
  const calcEnd = performance.now();

  calculationCount++;
  totalCalculationTime += calcEnd - calcStart;

  return result;
}

function calculateManaBar(bufferToUse, metadata, regions) {
  if (!regions.manaBar) return lastCalculatedState.mppc;

  const calcStart = performance.now();
  const result = calculatePercentages(
    bufferToUse,
    metadata,
    regions.manaBar,
    resourceBars.manaBar,
    94,
  );
  const calcEnd = performance.now();

  calculationCount++;
  totalCalculationTime += calcEnd - calcStart;

  return result;
}

function calculateCooldowns(regions) {
  const activeCooldowns = regions.cooldowns?.children || {};

  const healingCd = cooldownManager.updateCooldown(
    'healing',
    !!activeCooldowns.healing,
  );
  const supportCd = cooldownManager.updateCooldown(
    'support',
    !!activeCooldowns.support,
  );
  const attackCd = cooldownManager.updateCooldown(
    'attack',
    !!activeCooldowns.attack,
  );

  // Handle inactive states
  if (activeCooldowns.attackInactive) cooldownManager.forceDeactivate('attack');
  if (activeCooldowns.healingInactive)
    cooldownManager.forceDeactivate('healing');
  if (activeCooldowns.supportInactive)
    cooldownManager.forceDeactivate('support');

  return { healingCd, supportCd, attackCd };
}

function calculateCharacterStatus(regions) {
  const characterStatus = {};
  if (regions.statusBar?.children) {
    Object.keys(regions.statusBar.children).forEach((key) => {
      characterStatus[key] = !!regions.statusBar.children[key].x;
    });
  }
  return characterStatus;
}

function calculateEquippedItems(regions) {
  const getEquippedItem = (slotRegion) => {
    if (!slotRegion?.children) return 'Unknown';
    const foundItems = Object.keys(slotRegion.children);
    if (foundItems.length === 0) return 'Empty';
    const actualItem = foundItems.find((item) => !item.includes('empty'));
    return actualItem || 'Empty';
  };

  return {
    amulet: getEquippedItem(regions.amuletSlot),
    ring: getEquippedItem(regions.ringSlot),
    boots: getEquippedItem(regions.bootsSlot),
  };
}

function calculateActiveActionItems(regions) {
  return regions.hotkeyBar?.children
    ? Object.fromEntries(
        Object.entries(regions.hotkeyBar.children).map(([key, child]) => [
          key,
          child,
        ]),
      )
    : {};
}

function calculateBattleList(bufferToUse, metadata, regions) {
  const battleListEntries = regions.battleList?.children?.entries?.list || [];
  const uiBattleListNames = currentState.uiValues?.battleListEntries || [];

  return battleListEntries.map((entry, index) => {
    const calcStart = performance.now();
    const health = calculatePercentages(
      bufferToUse,
      metadata,
      entry.healthBarFill,
      resourceBars.partyEntryHpBar,
      entry.healthBarFill.width,
    );
    const calcEnd = performance.now();

    calculationCount++;
    totalCalculationTime += calcEnd - calcStart;

    return {
      name: uiBattleListNames[index] || '',
      health: health >= 0 ? health : 0,
      isTargeted: entry.isTargeted,
      isAttacking: entry.isAttacking,
      region: entry.healthBarFull,
    };
  });
}

function calculateWalkingState() {
  if (!currentState?.gameState?.playerMinimapPosition) {
    return lastCalculatedState.isWalking;
  }

  const currentPos = currentState.gameState.playerMinimapPosition;
  const lastPos = lastCalculatedState.lastKnownPlayerMinimapPosition;

  const hasPositionChanged =
    !lastPos ||
    currentPos.x !== lastPos.x ||
    currentPos.y !== lastPos.y ||
    currentPos.z !== lastPos.z;

  if (hasPositionChanged) {
    lastCalculatedState.lastMovementTimestamp = performance.now();
    lastCalculatedState.lastKnownPlayerMinimapPosition = { ...currentPos };
  }

  const isWalking =
    hasPositionChanged ||
    performance.now() - (lastCalculatedState.lastMovementTimestamp || 0) < 750;

  return isWalking;
}

// --- Main Processing Function ---
async function processGameState() {
  if (!isInitialized || !currentState?.regionCoordinates?.regions) {
    return;
  }

  const opStart = performance.now();

  try {
    const newFrameCounter = Atomics.load(syncArray, FRAME_COUNTER_INDEX);

    if (newFrameCounter <= lastProcessedFrameCounter) {
      return; // No new frame to process
    }

    if (Atomics.load(syncArray, IS_RUNNING_INDEX) === 0) {
      return; // Capture not running
    }

    const width = Atomics.load(syncArray, WIDTH_INDEX);
    const height = Atomics.load(syncArray, HEIGHT_INDEX);
    const { regions } = currentState.regionCoordinates;

    if (Object.keys(regions).length === 0 || width <= 0 || height <= 0) {
      return; // No regions or invalid dimensions
    }

    lastProcessedFrameCounter = newFrameCounter;
    const metadata = { width, height, frameCounter: newFrameCounter };
    const bufferToUse = sharedBufferView;

    // Get dirty regions
    const dirtyRegionCount = Atomics.load(syncArray, DIRTY_REGION_COUNT_INDEX);
    const dirtyRects = [];

    for (let i = 0; i < Math.min(dirtyRegionCount, 64); i++) {
      // Limit to max 64 regions
      const offset = DIRTY_REGIONS_START_INDEX + i * 4;
      const rect = {
        x: Atomics.load(syncArray, offset + 0),
        y: Atomics.load(syncArray, offset + 1),
        width: Atomics.load(syncArray, offset + 2),
        height: Atomics.load(syncArray, offset + 3),
      };

      if (rect.width > 0 && rect.height > 0) {
        dirtyRects.push(rect);
      }
    }

    // Determine what needs calculation
    const shouldCalculate = (regionName) => {
      if (!regions[regionName]) return false;
      if (!initializedRegions.has(regionName)) return true;

      for (const dirtyRect of dirtyRects) {
        if (rectsIntersect(regions[regionName], dirtyRect)) return true;
      }
      return false;
    };

    let hasUpdates = false;

    // Perform calculations only when needed
    if (shouldCalculate('healthBar')) {
      lastCalculatedState.hppc = calculateHealthBar(
        bufferToUse,
        metadata,
        regions,
      );
      initializedRegions.add('healthBar');
      hasUpdates = true;
    }

    if (shouldCalculate('manaBar')) {
      lastCalculatedState.mppc = calculateManaBar(
        bufferToUse,
        metadata,
        regions,
      );
      initializedRegions.add('manaBar');
      hasUpdates = true;
    }

    if (shouldCalculate('cooldowns')) {
      const cooldowns = calculateCooldowns(regions);
      Object.assign(lastCalculatedState, cooldowns);
      initializedRegions.add('cooldowns');
      hasUpdates = true;
    }

    if (shouldCalculate('statusBar')) {
      lastCalculatedState.characterStatus = calculateCharacterStatus(regions);
      initializedRegions.add('statusBar');
      hasUpdates = true;
    }

    const equipmentRegions = ['amuletSlot', 'ringSlot', 'bootsSlot'];
    if (equipmentRegions.some(shouldCalculate)) {
      lastCalculatedState.equippedItems = calculateEquippedItems(regions);
      equipmentRegions.forEach((name) => initializedRegions.add(name));
      hasUpdates = true;
    }

    if (shouldCalculate('hotkeyBar')) {
      lastCalculatedState.activeActionItems =
        calculateActiveActionItems(regions);
      initializedRegions.add('hotkeyBar');
      hasUpdates = true;
    }

    if (shouldCalculate('battleList')) {
      lastCalculatedState.battleList = calculateBattleList(
        bufferToUse,
        metadata,
        regions,
      );
      initializedRegions.add('battleList');
      hasUpdates = true;
    }

    // Always calculate walking state and monster count (non-pixel based)
    lastCalculatedState.isWalking = calculateWalkingState();
    lastCalculatedState.monsterNum =
      regions.battleList?.children?.entries?.list?.length || 0;

    // Send updates if we have changes
    if (hasUpdates || !initializedRegions.size) {
      // Update reusable game state object
      reusableGameStateUpdate.payload = {
        hppc: lastCalculatedState.hppc,
        mppc: lastCalculatedState.mppc,
        monsterNum: lastCalculatedState.monsterNum,
        partyMembers: lastCalculatedState.partyMembers,
        healingCd: lastCalculatedState.healingCd,
        supportCd: lastCalculatedState.supportCd,
        attackCd: lastCalculatedState.attackCd,
        characterStatus: lastCalculatedState.characterStatus,
        isWalking: lastCalculatedState.isWalking,
        activeActionItems: lastCalculatedState.activeActionItems,
        equippedItems: lastCalculatedState.equippedItems,
      };

      parentPort.postMessage(reusableGameStateUpdate);

      // Update battle list
      reusableBattleListUpdate.payload = lastCalculatedState.battleList;
      parentPort.postMessage(reusableBattleListUpdate);
    }

    // Run rules if enabled
    if (currentState?.rules?.enabled && currentState.gameState) {
      const ruleInput = {
        ...currentState.gameState,
        ...lastCalculatedState,
        rulesEnabled: true,
      };
      runRules(ruleInput);
    }
  } catch (error) {
    console.error('[ScreenMonitor] Error in processGameState:', error);
  } finally {
    const opEnd = performance.now();
    const opTime = opEnd - opStart;

    // Update performance stats
    operationCount++;
    totalOperationTime += opTime;

    // Log slow operations
    if (opTime > 25) {
      console.log(`[ScreenMonitor] Slow operation: ${opTime.toFixed(2)}ms`);
    }
  }
}

// --- Main Loop ---
async function mainLoop() {
  console.log('[ScreenMonitor] Starting main loop...');

  while (!isShuttingDown) {
    const loopStart = performance.now();

    try {
      await processGameState();
      logPerformanceStats();
    } catch (error) {
      console.error('[ScreenMonitor] Error in main loop:', error);
      // Wait longer on error to avoid tight error loops
      await delay(Math.max(SCAN_INTERVAL_MS * 2, 100));
      continue;
    }

    const loopEnd = performance.now();
    const elapsedTime = loopEnd - loopStart;
    const delayTime = Math.max(0, SCAN_INTERVAL_MS - elapsedTime);

    if (delayTime > 0) {
      await delay(delayTime);
    }
  }

  console.log('[ScreenMonitor] Main loop stopped.');
}

// --- Message Handler ---
parentPort.on('message', (message) => {
  try {
    if (message.type === 'state_diff') {
      // Handle state updates from WorkerManager
      if (!currentState) {
        currentState = {};
      }

      // Apply state diff
      Object.assign(currentState, message.payload);

      // Handle specific state changes
      if (message.payload.global) {
        const globalState = message.payload.global;

        // If window changed, reset initialized regions
        if (
          globalState.windowId !== undefined &&
          currentState.global?.windowId !== globalState.windowId
        ) {
          console.log(
            '[ScreenMonitor] Window changed, resetting calculations.',
          );
          initializedRegions.clear();
          lastProcessedFrameCounter = -1;
        }
      }

      // If regions changed, reset initialized regions
      if (message.payload.regionCoordinates) {
        // console.log('[ScreenMonitor] Regions updated, resetting calculations.');
        initializedRegions.clear();
        lastProcessedFrameCounter = -1;
      }
    } else if (message.type === 'shutdown') {
      console.log('[ScreenMonitor] Received shutdown command.');
      isShuttingDown = true;
    } else if (typeof message === 'object' && !message.type) {
      // Handle full state updates (initial state from WorkerManager)
      currentState = message;
      console.log('[ScreenMonitor] Received initial state update.');

      if (!isInitialized) {
        initializeWorker();
      }
    } else {
      console.log(
        '[ScreenMonitor] Received message:',
        message.type || 'unknown',
      );
    }
  } catch (error) {
    console.error('[ScreenMonitor] Error handling message:', error);
  }
});

// --- Worker Startup ---
async function startWorker() {
  console.log(
    '[ScreenMonitor] Worker starting up in hybrid calculation mode...',
  );

  // Handle graceful shutdown signals
  process.on('SIGTERM', () => {
    console.log('[ScreenMonitor] Received SIGTERM, shutting down...');
    isShuttingDown = true;
  });

  process.on('SIGINT', () => {
    console.log('[ScreenMonitor] Received SIGINT, shutting down...');
    isShuttingDown = true;
  });

  // Start the main loop
  mainLoop().catch((error) => {
    console.error('[ScreenMonitor] Fatal error in main loop:', error);
    process.exit(1);
  });
}

startWorker();

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/sharedConstants.js
//start file
// --- SharedArrayBuffer (SAB) Indices for Player Position ---
// This section is unchanged.
export const PLAYER_X_INDEX = 0;
export const PLAYER_Y_INDEX = 1;
export const PLAYER_Z_INDEX = 2;
export const PLAYER_POS_UPDATE_COUNTER_INDEX = 3;
export const PLAYER_POS_SAB_SIZE = 4; // x, y, z, counter

// --- SharedArrayBuffer (SAB) Indices for Pathfinder Data ---
export const PATH_LENGTH_INDEX = 0;
export const PATH_CHEBYSHEV_DISTANCE_INDEX = 1; // Chebyshev distance from start to target
export const PATH_START_X_INDEX = 2;
export const PATH_START_Y_INDEX = 3;
export const PATH_START_Z_INDEX = 4;

// NEW: Added a dedicated index for the pathfinder's status result.
export const PATHFINDING_STATUS_INDEX = 5;

// SHIFTED: The update counter is shifted to make room for the new status index.
export const PATH_UPDATE_COUNTER_INDEX = 6;

// SHIFTED: The start of the waypoint data is shifted accordingly.
export const PATH_WAYPOINTS_START_INDEX = 7;

// --- Path Data Configuration ---
export const MAX_PATH_WAYPOINTS = 1000;
export const PATH_WAYPOINT_SIZE = 3; // Each waypoint is x, y, z

// The size calculation automatically adjusts to the new layout.
export const PATH_DATA_SAB_SIZE =
  PATH_WAYPOINTS_START_INDEX + MAX_PATH_WAYPOINTS * PATH_WAYPOINT_SIZE;

// --- NEW: Definitive Status Codes for Pathfinder Communication ---
// These codes are written by the pathfinder and read by the cavebot worker.
export const PATH_STATUS_IDLE = 0; // Initial state, no calculation done yet.
export const PATH_STATUS_PATH_FOUND = 1; // A valid path was found.
export const PATH_STATUS_WAYPOINT_REACHED = 2; // The start point is the destination.
export const PATH_STATUS_NO_PATH_FOUND = 3; // The destination is unreachable.
export const PATH_STATUS_DIFFERENT_FLOOR = 4; // Start and end are on different z-levels.
export const PATH_STATUS_ERROR = 5; // An unexpected error occurred during pathfinding.
export const PATH_STATUS_NO_VALID_START_OR_END = 6; // Start or end point is in an unwalkable area with no nearby valid points.

//endFile

