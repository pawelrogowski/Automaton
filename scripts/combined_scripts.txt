// /home/feiron/Dokumenty/Automaton/nativeModules/findSequences/src/findSequences.cc
//start file
// findSequences.cc â€“ With new high-performance Unified Search Worker
#include <napi.h>
#include <vector>
#include <string>
#include <set>
#include <cstdint>
#include <thread>
#include <cmath>
#include <algorithm>
#include <unordered_map>
#include <atomic>

#include <immintrin.h>

// ---------- Constants ----------
const uint32_t ANY_COLOR_HASH = 0xFFFFFFFF;

// ---------- Structures ----------
struct SearchArea {
    uint32_t x = 0, y = 0, width = 0, height = 0;
    bool active = false;
};

struct PixelCheck {
    uint32_t x, y;
    std::string id;
};

struct SequenceDefinition {
    std::string name;
    std::vector<uint32_t> sequenceHashes;
    std::string direction = "horizontal";
    int offsetX = 0, offsetY = 0;
    std::string variant = "primary";
};

struct FirstCandidate {
    int x = 0, y = 0;
    size_t pixelIndex = static_cast<size_t>(-1);
};

struct FoundCoords {
    int x, y;
    bool operator<(const FoundCoords& o) const {
        return y != o.y ? y < o.y : x < o.x;
    }
};

using FirstCandidateMap = std::unordered_map<std::string, std::pair<FirstCandidate, FirstCandidate>>;
using AllCandidateMap   = std::unordered_map<std::string, std::pair<std::set<FoundCoords>, std::set<FoundCoords>>>;
using PixelCheckResultMap = std::unordered_map<std::string, bool>;

// NEW: A map of a row (y-coordinate) to the checks on that row.
// The inner map is color -> vector of checks for that color.
using RowBasedPixelChecks = std::unordered_map<uint32_t, std::unordered_map<uint32_t, std::vector<PixelCheck>>>;

struct SearchTask {
    std::string taskName;
    std::unordered_map<uint32_t, std::vector<SequenceDefinition>> firstColorLookup;
    std::unordered_map<uint32_t, std::vector<PixelCheck>> pixelChecks;
    std::vector<std::string> targetNames;
    SearchArea searchArea;
    std::string occurrenceMode = "first";
};

struct WorkerData {
    const uint8_t* bgraData;
    uint32_t bufferWidth, bufferHeight, stride;
    size_t bgraDataLength;
    const std::vector<SearchTask>& tasks;
    FirstCandidateMap* localFirstResults;
    AllCandidateMap* localAllResults;
    PixelCheckResultMap* localPixelCheckResults; // MODIFIED: Now per-thread
    std::atomic<uint32_t>* next_row;
    const RowBasedPixelChecks* rowBasedChecks; // NEW: Pointer to pre-processed checks
};

// ---------- Parsing utilities (Unchanged) ----------
// ... (HexToUint32, ParseColorSequence, ParseTargetSequences are identical)
uint32_t HexToUint32(const std::string& hex) {
    if (hex.length() > 1 && hex[0] == '#') {
        return std::stoul(hex.substr(1), nullptr, 16);
    }
    return 0;
}

bool ParseColorSequence(Napi::Env env, const Napi::Array& jsSeq, std::vector<uint32_t>& out) {
    out.clear();
    uint32_t len = jsSeq.Length();
    out.reserve(len);
    for (uint32_t i = 0; i < len; ++i) {
        Napi::Value v = jsSeq.Get(i);
        if (v.IsString() && v.As<Napi::String>().Utf8Value() == "any") {
            out.push_back(ANY_COLOR_HASH);
            continue;
        }
        if (!v.IsArray()) return false;
        Napi::Array arr = v.As<Napi::Array>();
        if (arr.Length() != 3) return false;
        uint32_t r = arr.Get(0u).As<Napi::Number>().Uint32Value();
        uint32_t g = arr.Get(1u).As<Napi::Number>().Uint32Value();
        uint32_t b = arr.Get(2u).As<Napi::Number>().Uint32Value();
        out.push_back((r << 16) | (g << 8) | b);
    }
    return true;
}

bool ParseTargetSequences(Napi::Env env,
                          const Napi::Object& jsSequences,
                          std::unordered_map<uint32_t, std::vector<SequenceDefinition>>& firstColorLookup,
                          std::vector<std::string>& targetNames) {
    firstColorLookup.clear();
    targetNames.clear();
    Napi::Array names = jsSequences.GetPropertyNames();
    uint32_t n = names.Length();
    targetNames.reserve(n);
    for (uint32_t i = 0; i < n; ++i) {
        Napi::Value keyVal = names.Get(i);
        if (!keyVal.IsString()) continue;
        std::string name = keyVal.As<Napi::String>().Utf8Value();
        targetNames.emplace_back(name);
        Napi::Object cfg = jsSequences.Get(keyVal).As<Napi::Object>();
        SequenceDefinition def;
        def.name = name;
        def.direction = cfg.Has("direction") ? cfg.Get("direction").As<Napi::String>().Utf8Value() : "horizontal";
        if (cfg.Has("offset")) {
            Napi::Object off = cfg.Get("offset").As<Napi::Object>();
            def.offsetX = off.Has("x") ? off.Get("x").As<Napi::Number>().Int32Value() : 0;
            def.offsetY = off.Has("y") ? off.Get("y").As<Napi::Number>().Int32Value() : 0;
        }
        if (cfg.Has("sequence")) {
            def.variant = "primary";
            if (!ParseColorSequence(env, cfg.Get("sequence").As<Napi::Array>(), def.sequenceHashes)) return false;
            if (!def.sequenceHashes.empty() && def.sequenceHashes[0] != ANY_COLOR_HASH)
                firstColorLookup[def.sequenceHashes[0]].push_back(def);
        }
        if (cfg.Has("backupSequence")) {
            SequenceDefinition back = def;
            back.variant = "backup";
            if (!ParseColorSequence(env, cfg.Get("backupSequence").As<Napi::Array>(), back.sequenceHashes)) return false;
            if (!back.sequenceHashes.empty() && back.sequenceHashes[0] != ANY_COLOR_HASH)
                firstColorLookup[back.sequenceHashes[0]].push_back(back);
        }
    }
    return true;
}


// ---------- Verification Function (Unchanged) ----------
void VerifyAndRecordMatch(const WorkerData& data, const SequenceDefinition& seqDef, const SearchTask& task, uint32_t x, uint32_t y) {
    // ... (This function is identical to the original)
    const size_t seqLen = seqDef.sequenceHashes.size();
    if (seqLen == 0) return;
    bool match = true;

    if (seqDef.direction == "horizontal") {
        if (x + seqLen > data.bufferWidth) return;
        for (size_t j = 1; j < seqLen; ++j) {
            uint32_t expectedColor = seqDef.sequenceHashes[j];
            if (expectedColor == ANY_COLOR_HASH) continue;
            size_t nextPixelOffset = (y * data.stride) + ((x + j) * 4);
            if (nextPixelOffset + 2 >= data.bgraDataLength) { match = false; break; }
            uint32_t actualColor = (static_cast<uint32_t>(data.bgraData[nextPixelOffset + 2]) << 16) | (static_cast<uint32_t>(data.bgraData[nextPixelOffset + 1]) << 8) | (static_cast<uint32_t>(data.bgraData[nextPixelOffset]));
            if (actualColor != expectedColor) { match = false; break; }
        }
    } else { // Vertical
        if (y + seqLen > data.bufferHeight) return;
        for (size_t j = 1; j < seqLen; ++j) {
            uint32_t expectedColor = seqDef.sequenceHashes[j];
            if (expectedColor == ANY_COLOR_HASH) continue;
            size_t nextPixelOffset = ((y + j) * data.stride) + (x * 4);
            if (nextPixelOffset + 2 >= data.bgraDataLength) { match = false; break; }
            uint32_t actualColor = (static_cast<uint32_t>(data.bgraData[nextPixelOffset + 2]) << 16) | (static_cast<uint32_t>(data.bgraData[nextPixelOffset + 1]) << 8) | (static_cast<uint32_t>(data.bgraData[nextPixelOffset]));
            if (actualColor != expectedColor) { match = false; break; }
        }
    }

    if (match) {
        size_t currentPixelIndex = y * data.bufferWidth + x;
        int foundX = static_cast<int>(x) + seqDef.offsetX;
        int foundY = static_cast<int>(y) + seqDef.offsetY;
        if (task.occurrenceMode == "first") {
            auto& candidatePair = (*data.localFirstResults)[seqDef.name];
            if (seqDef.variant == "primary") {
                if (candidatePair.first.pixelIndex == static_cast<size_t>(-1) || currentPixelIndex < candidatePair.first.pixelIndex) {
                    candidatePair.first = {foundX, foundY, currentPixelIndex};
                }
            } else {
                if (candidatePair.first.pixelIndex == static_cast<size_t>(-1)) {
                    if (candidatePair.second.pixelIndex == static_cast<size_t>(-1) || currentPixelIndex < candidatePair.second.pixelIndex) {
                        candidatePair.second = {foundX, foundY, currentPixelIndex};
                    }
                }
            }
        } else {
            auto& candidatePair = (*data.localAllResults)[seqDef.name];
            if (seqDef.variant == "primary") candidatePair.first.insert({foundX, foundY});
            else candidatePair.second.insert({foundX, foundY});
        }
    }
}

// REMOVED: FindSequencesWorker is now part of UnifiedSearchWorker
// void FindSequencesWorker(const WorkerData& d) { ... }

// NEW: The unified worker that handles both pixel and sequence checks in one pass.
void UnifiedSearchWorker(const WorkerData& d) {
    const uint32_t chunk = 16;
    while (true) {
        uint32_t startY = d.next_row->fetch_add(chunk);
        if (startY >= d.bufferHeight) break;
        uint32_t endY = std::min(startY + chunk, d.bufferHeight);

        for (uint32_t y = startY; y < endY; ++y) {
            // --- 1. Perform Pixel Checks for this row ---
            auto row_it = d.rowBasedChecks->find(y);
            if (row_it != d.rowBasedChecks->end()) {
                for (const auto& [colorHash, checks] : row_it->second) {
                    for (const auto& check : checks) {
                        // Bounds already checked during pre-processing
                        size_t offset = (check.y * d.stride) + (check.x * 4);
                        uint32_t actualColor = (static_cast<uint32_t>(d.bgraData[offset + 2]) << 16) |
                                               (static_cast<uint32_t>(d.bgraData[offset + 1]) << 8) |
                                               (static_cast<uint32_t>(d.bgraData[offset]));
                        if (actualColor == colorHash) {
                            (*d.localPixelCheckResults)[check.id] = true;
                        }
                    }
                }
            }

            // --- 2. Perform Sequence Searches for this row ---
            const uint8_t* row = d.bgraData + y * d.stride;
            for (const SearchTask& task : d.tasks) {
                if (task.firstColorLookup.empty()) continue;

                // Check if the current row is within the task's vertical search area
                if (y < task.searchArea.y || y >= (task.searchArea.y + task.searchArea.height)) continue;

                uint32_t startX = task.searchArea.x;
                uint32_t endX   = task.searchArea.x + task.searchArea.width;

                // AVX2 accelerated part
                uint32_t x = startX;
                for (; x + 8 <= endX; x += 8) {
                    __m256i chunkVec = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(row + x * 4));
                    for (const auto& [color, seqs] : task.firstColorLookup) {
                        uint32_t r = (color >> 16) & 0xFF;
                        uint32_t g = (color >> 8)  & 0xFF;
                        uint32_t b =  color        & 0xFF;
                        uint32_t target_bgra = (0xFF << 24) | (r << 16) | (g << 8) | b;
                        __m256i target = _mm256_set1_epi32(target_bgra);
                        __m256i cmp    = _mm256_cmpeq_epi32(chunkVec, target);
                        int mask       = _mm256_movemask_ps(_mm256_castsi256_ps(cmp));
                        if (mask) {
                            for (int j = 0; j < 8; ++j) {
                                if (mask & (1 << j)) {
                                    for (const SequenceDefinition& seq : seqs) {
                                        VerifyAndRecordMatch(d, seq, task, x + j, y);
                                    }
                                }
                            }
                        }
                    }
                }
                // Remainder part
                for (; x < endX; ++x) {
                    const uint8_t* pixel = row + x * 4;
                    uint32_t r = pixel[2], g = pixel[1], b = pixel[0];
                    uint32_t currentColorHash = (r << 16) | (g << 8) | b;
                    auto it = task.firstColorLookup.find(currentColorHash);
                    if (it != task.firstColorLookup.end()) {
                        for (const SequenceDefinition& seq : it->second) {
                            VerifyAndRecordMatch(d, seq, task, x, y);
                        }
                    }
                }
            }
        }
    }
}


// ---------- Async Worker Class ----------
class SearchWorker : public Napi::AsyncWorker {
public:
    SearchWorker(Napi::Promise::Deferred deferred, const Napi::Buffer<uint8_t>& imageBuffer, const Napi::Object& jsSearchTasks, bool isBatch)
        : Napi::AsyncWorker(deferred.Env()), deferred(deferred), isBatchCall(isBatch) {
        // ... (Constructor parsing logic is identical to the original)
        bufferRef = Napi::ObjectReference::New(imageBuffer, 1);

        uint8_t* bufferData = imageBuffer.Data();
        if (imageBuffer.Length() < 8) {
            Napi::Error::New(Env(), "Buffer too small for header").ThrowAsJavaScriptException();
            return;
        }
        bufferWidth = *reinterpret_cast<uint32_t*>(bufferData);
        bufferHeight = *reinterpret_cast<uint32_t*>(bufferData + 4);
        bgraData = bufferData + 8;
        bgraDataLength = static_cast<size_t>(bufferWidth) * bufferHeight * 4;
        stride = bufferWidth * 4;

        if (imageBuffer.Length() < bgraDataLength + 8) {
            Napi::Error::New(Env(), "Buffer length does not match dimensions in header").ThrowAsJavaScriptException();
            return;
        }

        Napi::Array names = jsSearchTasks.GetPropertyNames();
        uint32_t n = names.Length();
        tasks.reserve(n);
        for (uint32_t i = 0; i < n; ++i) {
            Napi::Value keyVal = names.Get(i);
            if (!keyVal.IsString()) continue;
            std::string taskName = keyVal.As<Napi::String>().Utf8Value();
            Napi::Object cfg = jsSearchTasks.Get(keyVal).As<Napi::Object>();
            SearchTask task;
            task.taskName = taskName;

            // Parse sequence searches
            if (cfg.Has("sequences")) {
                if (!ParseTargetSequences(Env(), cfg.Get("sequences").As<Napi::Object>(), task.firstColorLookup, task.targetNames)) {
                    Napi::Error::New(Env(), "Failed to parse target sequences for task: " + taskName).ThrowAsJavaScriptException();
                    return;
                }
                task.occurrenceMode = cfg.Get("occurrence").As<Napi::String>().Utf8Value();
            }

            // Parse pixel checks
            if (cfg.Has("pixelChecks")) {
                Napi::Object checksObj = cfg.Get("pixelChecks").As<Napi::Object>();
                Napi::Array colorKeys = checksObj.GetPropertyNames();
                for (uint32_t j = 0; j < colorKeys.Length(); ++j) {
                    std::string colorHex = colorKeys.Get(j).As<Napi::String>().Utf8Value();
                    uint32_t colorHash = HexToUint32(colorHex);
                    uint32_t r = (colorHash >> 16) & 0xFF;
                    uint32_t g = (colorHash >> 8) & 0xFF;
                    uint32_t b = colorHash & 0xFF;
                    colorHash = (r << 16) | (g << 8) | b; // Ensure RGB order

                    Napi::Array points = checksObj.Get(colorKeys.Get(j)).As<Napi::Array>();
                    std::vector<PixelCheck> checkList;
                    checkList.reserve(points.Length());
                    for (uint32_t k = 0; k < points.Length(); ++k) {
                        Napi::Object point = points.Get(k).As<Napi::Object>();
                        checkList.push_back({
                            point.Get("x").As<Napi::Number>().Uint32Value(),
                            point.Get("y").As<Napi::Number>().Uint32Value(),
                            point.Get("id").As<Napi::String>().Utf8Value()
                        });
                    }
                    task.pixelChecks[colorHash] = checkList;
                }
            }

            Napi::Object areaObj = cfg.Get("searchArea").As<Napi::Object>();
            task.searchArea.x = areaObj.Get("x").As<Napi::Number>().Uint32Value();
            task.searchArea.y = areaObj.Get("y").As<Napi::Number>().Uint32Value();
            task.searchArea.width = areaObj.Get("width").As<Napi::Number>().Uint32Value();
            task.searchArea.height = areaObj.Get("height").As<Napi::Number>().Uint32Value();
            task.searchArea.active = true;
            tasks.emplace_back(std::move(task));
        }
    }

    ~SearchWorker() {}

protected:
    // REMOVED: This is now integrated into the unified worker.
    // void PerformPixelChecks() { ... }

    void Execute() override {
        // --- Pre-process pixel checks for fast row-based lookup ---
        RowBasedPixelChecks rowBasedChecks;
        std::unordered_map<std::string, std::string> pixelCheckIdToTaskName;

        for (const auto& task : tasks) {
            if (task.pixelChecks.empty()) continue;
            for (const auto& [colorHash, checks] : task.pixelChecks) {
                for (const auto& check : checks) {
                    if (check.x >= bufferWidth || check.y >= bufferHeight) continue;
                    // Store the check in the row-based map
                    rowBasedChecks[check.y][colorHash].push_back(check);
                    // Map the check ID back to its task name for result aggregation
                    pixelCheckIdToTaskName[check.id] = task.taskName;
                }
            }
        }

        // --- Perform unified search using threading ---
        unsigned numThreads = std::min((unsigned)std::thread::hardware_concurrency(), bufferHeight);
        if (!numThreads) numThreads = 1;

        std::vector<FirstCandidateMap> threadFirstResults(numThreads);
        std::vector<AllCandidateMap> threadAllResults(numThreads);
        std::vector<PixelCheckResultMap> threadPixelCheckResults(numThreads); // NEW: Per-thread results

        std::set<std::string> uniqueNames;
        for (const auto& t : tasks) uniqueNames.insert(t.targetNames.begin(), t.targetNames.end());
        for (unsigned i = 0; i < numThreads; ++i) {
            threadFirstResults[i].reserve(uniqueNames.size());
            threadAllResults[i].reserve(uniqueNames.size());
        }

        std::atomic<uint32_t> nextRow(0);
        std::vector<std::thread> threads;
        for (unsigned i = 0; i < numThreads; ++i) {
            threads.emplace_back(UnifiedSearchWorker, WorkerData{
                bgraData, bufferWidth, bufferHeight, stride, bgraDataLength,
                tasks, &threadFirstResults[i], &threadAllResults[i],
                &threadPixelCheckResults[i], // NEW
                &nextRow, &rowBasedChecks    // NEW
            });
        }
        for (auto& t : threads) t.join();

        // --- Merge results from all threads ---
        // Merge sequence results (unchanged)
        for (const auto& localMap : threadFirstResults) {
            for (const auto& [name, pair] : localMap) {
                if (mergedFirstResults.find(name) == mergedFirstResults.end()) {
                    mergedFirstResults[name] = pair;
                    continue;
                }
                auto& best = mergedFirstResults.at(name);
                if (pair.first.pixelIndex != static_cast<size_t>(-1) && (best.first.pixelIndex == static_cast<size_t>(-1) || pair.first.pixelIndex < best.first.pixelIndex)) best.first = pair.first;
                if (best.first.pixelIndex == static_cast<size_t>(-1) && pair.second.pixelIndex != static_cast<size_t>(-1) && (best.second.pixelIndex == static_cast<size_t>(-1) || pair.second.pixelIndex < best.second.pixelIndex)) best.second = pair.second;
            }
        }
        for (const auto& localMap : threadAllResults) {
            for (const auto& [name, pair] : localMap) {
                mergedAllResults[name].first.insert(pair.first.begin(), pair.first.end());
                mergedAllResults[name].second.insert(pair.second.begin(), pair.second.end());
            }
        }

        // MODIFIED: Merge pixel check results
        for (const auto& localMap : threadPixelCheckResults) {
            for (const auto& [id, found] : localMap) {
                if (found) {
                    auto it = pixelCheckIdToTaskName.find(id);
                    if (it != pixelCheckIdToTaskName.end()) {
                        const std::string& taskName = it->second;
                        mergedPixelCheckResults[taskName][id] = true;
                    }
                }
            }
        }
    }

    void OnOK() override {
        // ... (This function is identical to the original)
        Napi::Env env = Env();
        Napi::HandleScope scope(env);

        Napi::Object finalResults = Napi::Object::New(env);
        for (const SearchTask& task : tasks) {
            Napi::Object taskResult = Napi::Object::New(env);

            // Add sequence search results
            if (!task.firstColorLookup.empty()) {
                if (task.occurrenceMode == "first") {
                    for (const std::string& name : task.targetNames) {
                        auto it = mergedFirstResults.find(name);
                        if (it == mergedFirstResults.end()) {
                            taskResult.Set(name, env.Null());
                            continue;
                        }
                        const auto& pair = it->second;
                        if (pair.first.pixelIndex != static_cast<size_t>(-1)) {
                            Napi::Object c = Napi::Object::New(env); c.Set("x", pair.first.x); c.Set("y", pair.first.y);
                            taskResult.Set(name, c);
                        } else if (pair.second.pixelIndex != static_cast<size_t>(-1)) {
                            Napi::Object c = Napi::Object::New(env); c.Set("x", pair.second.x); c.Set("y", pair.second.y);
                            taskResult.Set(name, c);
                        } else {
                            taskResult.Set(name, env.Null());
                        }
                    }
                } else { // "all"
                    for (const std::string& name : task.targetNames) {
                        auto it = mergedAllResults.find(name);
                        if (it == mergedAllResults.end()) {
                            taskResult.Set(name, Napi::Array::New(env, 0));
                            continue;
                        }
                        const auto& [pri, bak] = it->second;
                        const auto& resultSet = !pri.empty() ? pri : bak;
                        Napi::Array arr = Napi::Array::New(env, resultSet.size());
                        size_t idx = 0;
                        for (const FoundCoords& fc : resultSet) {
                            Napi::Object c = Napi::Object::New(env); c.Set("x", fc.x); c.Set("y", fc.y);
                            arr[idx++] = c;
                        }
                        taskResult.Set(name, arr);
                    }
                }
            }

            // Add pixel check results
            auto pixelCheckIt = mergedPixelCheckResults.find(task.taskName);
            if (pixelCheckIt != mergedPixelCheckResults.end()) {
                for (const auto& [id, found] : pixelCheckIt->second) {
                    if (found) {
                        taskResult.Set(id, Napi::Boolean::New(env, true));
                    }
                }
            }

            finalResults.Set(task.taskName, taskResult);
        }

        bufferRef.Unref();

        if (isBatchCall) {
            deferred.Resolve(finalResults);
        } else {
            if (finalResults.Has("defaultTask")) {
                deferred.Resolve(finalResults.Get("defaultTask"));
            } else {
                deferred.Resolve(env.Null());
            }
        }
    }

    void OnError(const Napi::Error& e) override {
        bufferRef.Unref();
        deferred.Reject(e.Value());
    }

private:
    Napi::ObjectReference bufferRef;
    uint8_t* bgraData;
    uint32_t bufferWidth, bufferHeight, stride;
    size_t bgraDataLength;
    std::vector<SearchTask> tasks;
    bool isBatchCall;
    Napi::Promise::Deferred deferred;
    FirstCandidateMap mergedFirstResults;
    AllCandidateMap mergedAllResults;
    std::unordered_map<std::string, PixelCheckResultMap> mergedPixelCheckResults;
};


// ---------- Public Async Wrappers & Module Registration (Unchanged) ----------
// ... (FindSequencesAsyncBatch, FindSequencesAsync, and Init are identical)
Napi::Value FindSequencesAsyncBatch(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2 || !info[0].IsBuffer() || !info[1].IsObject()) {
        Napi::TypeError::New(env, "Expected (Buffer, Object searchTasks)").ThrowAsJavaScriptException();
        return env.Null();
    }

    auto deferred = Napi::Promise::Deferred::New(env);
    auto worker = new SearchWorker(deferred, info[0].As<Napi::Buffer<uint8_t>>(), info[1].As<Napi::Object>(), true);
    worker->Queue();
    return deferred.Promise();
}

Napi::Value FindSequencesAsync(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2 || !info[0].IsBuffer() || !info[1].IsObject()) {
        Napi::TypeError::New(env, "Expected (Buffer, Object sequences, [Object searchArea], [String occurrence])").ThrowAsJavaScriptException();
        return env.Null();
    }

    Napi::Object searchTasks = Napi::Object::New(env);
    Napi::Object singleTask = Napi::Object::New(env);
    singleTask.Set("sequences", info[1]);
    singleTask.Set("occurrence", (info.Length() > 3 && !info[3].IsNull()) ? info[3] : Napi::String::New(env, "first"));
    Napi::Object searchArea = Napi::Object::New(env);
    if (info.Length() > 2 && info[2].IsObject()) {
        searchArea = info[2].As<Napi::Object>();
    } else {
        uint8_t* bufferData = info[0].As<Napi::Buffer<uint8_t>>().Data();
        uint32_t w = *reinterpret_cast<uint32_t*>(bufferData);
        uint32_t h = *reinterpret_cast<uint32_t*>(bufferData + 4);
        searchArea.Set("x", 0); searchArea.Set("y", 0);
        searchArea.Set("width", w); searchArea.Set("height", h);
    }
    singleTask.Set("searchArea", searchArea);
    searchTasks.Set("defaultTask", singleTask);

    auto deferred = Napi::Promise::Deferred::New(env);
    auto worker = new SearchWorker(deferred, info[0].As<Napi::Buffer<uint8_t>>(), searchTasks, false);
    worker->Queue();
    return deferred.Promise();
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
    exports.Set("findSequencesNative", Napi::Function::New(env, FindSequencesAsync));
    exports.Set("findSequencesNativeBatch", Napi::Function::New(env, FindSequencesAsyncBatch));
    return exports;
}

NODE_API_MODULE(findSequences, Init)
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/findSequences/wrapper.js
//start file
const findSequencesNative = require('./build/Release/findSequences.node');
module.exports = findSequencesNative;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/findTarget/src/findTarget.cc
//start file
// findTarget.cc â€“ Repurposed to find a single, potentially obstructed target mark.
#include <napi.h>
#include <vector>
#include <thread>
#include <atomic>
#include <cstdint>
#include <mutex>
#include <algorithm>
#include <cmath>
#include <queue>
#include <immintrin.h>

const uint32_t TARGET_BORDER_COLOR = 0xFF0000;
// Minimum number of pixels a cluster must have to be considered part of the border
const size_t MIN_CLUSTER_SIZE = 5;

struct Point {
    uint32_t x, y;
};

struct WorkerData {
    const uint8_t* bgraData;
    uint32_t width, height, stride;
    uint32_t searchX, searchY, searchW, searchH;
    std::atomic<uint32_t>* nextRow;
    std::vector<Point>* results;
    std::mutex* resultsMutex;
};

void TargetWorker(WorkerData data) {
    const uint32_t rowChunkSize = 32; // Larger chunks can be better for simple tasks
    const __m256i bgr_mask = _mm256_set1_epi32(0x00FFFFFF);
    const __m256i target_color_v = _mm256_set1_epi32(TARGET_BORDER_COLOR);

    std::vector<Point> local_results;

    while (true) {
        uint32_t startY = data.nextRow->fetch_add(rowChunkSize);
        if (startY >= data.searchY + data.searchH) break;

        uint32_t endY = std::min(startY + rowChunkSize, data.searchY + data.searchH);

        for (uint32_t y = startY; y < endY; ++y) {
            const uint8_t* row = data.bgraData + (y * data.stride);
            const uint32_t endX = data.searchX + data.searchW;

            for (uint32_t x = data.searchX; x + 8 <= endX; x += 8) {
                __m256i chunk = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(row + x * 4));
                chunk = _mm256_and_si256(chunk, bgr_mask); // Ignore alpha channel

                __m256i cmp = _mm256_cmpeq_epi32(chunk, target_color_v);
                int mask = _mm256_movemask_ps(_mm256_castsi256_ps(cmp));

                if (mask != 0) {
                    for (int j = 0; j < 8; ++j) {
                        if (mask & (1 << j)) {
                            local_results.push_back({x + j, y});
                        }
                    }
                }
            }
            // Handle remaining pixels that don't fit in an 8-pixel chunk
            for (uint32_t x = (data.searchX + data.searchW) & ~7; x < endX; ++x) {
                 const uint8_t* p = row + x * 4;
                 uint32_t pixelColor = (static_cast<uint32_t>(p[2]) << 16) | (static_cast<uint32_t>(p[1]) << 8) | p[0];
                 if (pixelColor == TARGET_BORDER_COLOR) {
                     local_results.push_back({x, y});
                 }
            }
        }
    }

    if (!local_results.empty()) {
        std::lock_guard<std::mutex> lock(*data.resultsMutex);
        data.results->insert(data.results->end(), local_results.begin(), local_results.end());
    }
}


Napi::Value FindTarget(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();

    if (info.Length() < 2 || !info[0].IsBuffer() || !info[1].IsObject()) {
        Napi::TypeError::New(env, "Expected (Buffer, Object searchArea)").ThrowAsJavaScriptException();
        return env.Null();
    }

    Napi::Buffer<uint8_t> buffer = info[0].As<Napi::Buffer<uint8_t>>();
    const uint8_t* bufferData = buffer.Data();
    size_t bufferLength = buffer.Length();

    if (bufferLength < 8) return env.Null();
    uint32_t width  = *reinterpret_cast<const uint32_t*>(bufferData);
    uint32_t height = *reinterpret_cast<const uint32_t*>(bufferData + 4);
    const uint8_t* bgraData = bufferData + 8;
    uint32_t stride = width * 4;
    if (bufferLength - 8 < width * height * 4) return env.Null();

    Napi::Object area = info[1].As<Napi::Object>();
    uint32_t searchX = area.Get("x").As<Napi::Number>().Uint32Value();
    uint32_t searchY = area.Get("y").As<Napi::Number>().Uint32Value();
    uint32_t searchW = area.Get("width").As<Napi::Number>().Uint32Value();
    uint32_t searchH = area.Get("height").As<Napi::Number>().Uint32Value();

    // === STAGE 1: GATHER PIXELS ===
    std::vector<Point> candidatePoints;
    std::mutex resultsMutex;
    std::atomic<uint32_t> nextRow(searchY);

    unsigned numThreads = std::thread::hardware_concurrency();
    if (!numThreads) numThreads = 4;

    std::vector<std::thread> threads;
    for (unsigned i = 0; i < numThreads; ++i) {
        threads.emplace_back(TargetWorker, WorkerData{
            bgraData, width, height, stride,
            searchX, searchY, searchW, searchH,
            &nextRow, &candidatePoints, &resultsMutex
        });
    }
    for (auto& t : threads) t.join();

    if (candidatePoints.empty()) {
        return env.Null();
    }

    // === STAGE 2: CLUSTER & INFER BOUNDING BOX ===
    std::vector<std::vector<Point>> clusters;
    std::vector<bool> visited(width * height, false);

    for (const auto& start_point : candidatePoints) {
        uint32_t start_idx = start_point.y * width + start_point.x;
        if (visited[start_idx]) continue;

        std::vector<Point> current_cluster;
        std::queue<Point> q;

        q.push(start_point);
        visited[start_idx] = true;

        while (!q.empty()) {
            Point p = q.front();
            q.pop();
            current_cluster.push_back(p);

            // Check 8 neighbors (Moore neighborhood)
            for (int dy = -1; dy <= 1; ++dy) {
                for (int dx = -1; dx <= 1; ++dx) {
                    if (dx == 0 && dy == 0) continue;
                    uint32_t nx = p.x + dx;
                    uint32_t ny = p.y + dy;

                    if (nx >= searchX && nx < searchX + searchW && ny >= searchY && ny < searchY + searchH) {
                        uint32_t neighbor_idx = ny * width + nx;
                        if (!visited[neighbor_idx]) {
                           const uint8_t* np = bgraData + ny * stride + nx * 4;
                           uint32_t neighborColor = (static_cast<uint32_t>(np[2]) << 16) | (static_cast<uint32_t>(np[1]) << 8) | np[0];
                           if (neighborColor == TARGET_BORDER_COLOR) {
                               visited[neighbor_idx] = true;
                               q.push({nx, ny});
                           }
                        }
                    }
                }
            }
        }
        if (current_cluster.size() >= MIN_CLUSTER_SIZE) {
            clusters.push_back(current_cluster);
        }
    }

    if (clusters.empty()) {
        return env.Null();
    }

    // === Combine all valid clusters into a single bounding box ===
    uint32_t minX = width, minY = height, maxX = 0, maxY = 0;

    for (const auto& cluster : clusters) {
        for (const auto& p : cluster) {
            minX = std::min(minX, p.x);
            minY = std::min(minY, p.y);
            maxX = std::max(maxX, p.x);
            maxY = std::max(maxY, p.y);
        }
    }

    // Add the 3px border thickness to the max coordinates to get the full creature rect
    // The border is outside the creature, so the creature rect is inside minX+3, minY+3
    uint32_t creatureX = minX + 3;
    uint32_t creatureY = minY + 3;
    uint32_t creatureW = (maxX - 3) - creatureX + 1;
    uint32_t creatureH = (maxY - 3) - creatureY + 1;

    Napi::Object result = Napi::Object::New(env);
    result.Set("x", creatureX);
    result.Set("y", creatureY);
    result.Set("width", creatureW);
    result.Set("height", creatureH);

    return result;
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
    exports.Set("findTarget", Napi::Function::New(env, FindTarget));
    return exports;
}

NODE_API_MODULE(findTarget, Init)
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/findTarget/wrapper.js
//start file
const findTargetNative = require('./build/Release/findTarget.node');
module.exports = findTargetNative;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/focus_watcher/src/focus_watcher.cc
//start file
#include <napi.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <unistd.h>
#include <thread>
#include <atomic>
#include <mutex>
#include <iostream>

// --- Global State ---
std::thread g_watcher_thread;
std::atomic<bool> g_is_watcher_running(false);
std::atomic<Window> g_target_window_id(0);
std::mutex g_thread_management_mutex;

// The aggressive "force focus" logic from your original keypress addon
void force_actual_focus(Display* display, Window target_window) {
    // 1. The Polite Request to activate the window
    Atom net_active_window = XInternAtom(display, "_NET_ACTIVE_WINDOW", False);
    XEvent event;
    memset(&event, 0, sizeof(event));

    event.xclient.type = ClientMessage;
    event.xclient.window = target_window;
    event.xclient.message_type = net_active_window;
    event.xclient.format = 32;
    event.xclient.data.l[0] = 1; // 1 for "normal" applications
    event.xclient.data.l[1] = CurrentTime;
    event.xclient.data.l[2] = 0; // The currently active window (if known)

    XSendEvent(display, XDefaultRootWindow(display), False, SubstructureRedirectMask | SubstructureNotifyMask, &event);

    // 2. The Forceful Command to set the input focus
    XSetInputFocus(display, target_window, RevertToParent, CurrentTime);

    // We must flush the request to the server
    XFlush(display);
}

// The background thread's main loop
void force_focus_loop() {
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        std::cerr << "FocusWatcher [Thread]: Cannot open display. Thread exiting." << std::endl;
        g_is_watcher_running = false;
        return;
    }

    Atom net_wm_state = XInternAtom(display, "_NET_WM_STATE", False);
    Atom net_wm_state_focused = XInternAtom(display, "_NET_WM_STATE_FOCUSED", False);

    std::cout << "FocusWatcher [Thread]: Aggressive focus watcher thread started." << std::endl;

    while (g_is_watcher_running) {
        Window current_target = g_target_window_id.load();
        if (current_target == 0) {
            usleep(100000); // No target, sleep longer
            continue;
        }

        // Check if the property is already set. If not, we fight back.
        bool is_focused_prop_present = false;
        Atom* prop_data = NULL;
        Atom actual_type;
        int actual_format;
        unsigned long nitems, bytes_after;

        int status = XGetWindowProperty(display, current_target, net_wm_state, 0, 1024, False, XA_ATOM,
                                        &actual_type, &actual_format, &nitems, &bytes_after, (unsigned char**)&prop_data);

        if (status == Success && prop_data) {
            for (unsigned long i = 0; i < nitems; i++) {
                if (prop_data[i] == net_wm_state_focused) {
                    is_focused_prop_present = true;
                    break;
                }
            }
            XFree(prop_data);
        }

        // If the compositor has removed our focus, we take it back forcefully.
        if (!is_focused_prop_present) {
            // std::cout << "FocusWatcher [Thread]: Focus lost. Re-asserting control..." << std::endl;
            force_actual_focus(display, current_target);
        }

        usleep(100000); // Check every 100ms. Adjust if needed.
    }

    XCloseDisplay(display);
    std::cout << "FocusWatcher [Thread]: Watcher thread stopped." << std::endl;
}

// --- N-API Bindings (no changes needed here) ---

Napi::Value UpdateWatcher(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    std::lock_guard<std::mutex> lock(g_thread_management_mutex);
    if (info.Length() < 1 || !info[0].IsNumber()) {
        Napi::TypeError::New(env, "Window ID (Number) is required.").ThrowAsJavaScriptException();
        return env.Null();
    }
    uint64_t new_window_id = info[0].As<Napi::Number>().Int64Value();
    g_target_window_id.store((Window)new_window_id);
    if (new_window_id != 0 && !g_is_watcher_running) {
        g_is_watcher_running = true;
        std::thread(force_focus_loop).detach();
    } else if (new_window_id == 0 && g_is_watcher_running) {
        g_is_watcher_running = false;
    }
    return env.Undefined();
}

void StopWatcher(const Napi::CallbackInfo& info) {
    std::lock_guard<std::mutex> lock(g_thread_management_mutex);
    if (g_is_watcher_running) {
        g_target_window_id.store(0);
        g_is_watcher_running = false;
    }
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
    if (!XInitThreads()) {
        std::cerr << "FATAL: XInitThreads() failed." << std::endl;
    }
    exports.Set("update", Napi::Function::New(env, UpdateWatcher));
    exports.Set("stop", Napi::Function::New(env, StopWatcher));
    return exports;
}

NODE_API_MODULE(focus_watcher, Init);
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/focus_watcher/wrapper.js
//start file
const focusWatcher = require('./build/Release/focus_watcher.node');
module.exports = focusWatcher;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/fontOcr/src/fontOcr.cc
//start file
// fontOcr.cc â€” AVX2-accelerated color prescan + trigger-map matching (BGRA input).
// - Keeps your working findText path
// - Fixes recognizeText by reverting to trigger-map logic but accelerates the hot-pixel scan with AVX2
// - Uses packed 32-bit loads and avoids per-pixel tuple loops for color checks

#include <napi.h>
#include <vector>
#include <string>
#include <cstdint>
#include <algorithm>
#include <tuple>
#include <cmath>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <map>
#include <queue>
#include <cctype>
#include <sstream>
#include <unordered_set>
#include <set>
#include <immintrin.h>

#include "ocr_structs.h"
#include "font_atlas_data.h"

// --- Global State ---
static std::vector<CharTemplate> fontAtlas;
static std::map<Point, std::vector<const CharTemplate*>> triggerMap;   // Point is from ocr_structs.h
static std::map<char, const CharTemplate*> charToTemplateMap;

// --- Helper: pack RGB -> 0xAARRGGBB (A=0xFF) matching BGRA byte order in memory ---
static inline uint32_t PackBGRA(uint8_t r, uint8_t g, uint8_t b) {
    return (0xFFu << 24) | (uint32_t(r) << 16) | (uint32_t(g) << 8) | uint32_t(b);
}

// --- Fast color set built from valid font colors (in packed ARGB/BGRA) ---
struct ColorSet {
    std::unordered_set<uint32_t> S;
    std::vector<__m256i> v; // AVX2 broadcast constants for prescan

    void build(const std::vector<std::tuple<uint8_t,uint8_t,uint8_t>>& colors) {
        S.clear(); v.clear();
        S.reserve(colors.size()*2);
        v.reserve(colors.size());
        for (auto &t : colors) {
            uint8_t r = std::get<0>(t), g = std::get<1>(t), b = std::get<2>(t);
            uint32_t packed = PackBGRA(r,g,b);
            S.insert(packed);
            v.push_back(_mm256_set1_epi32((int)packed));
        }
    }
    inline bool has(uint32_t packed) const {
        return S.find(packed) != S.end();
    }
};

// --- Helper Functions ---
inline bool is_valid_font_color_tuple(uint8_t r, uint8_t g, uint8_t b,
    const std::vector<std::tuple<uint8_t,uint8_t,uint8_t>>& valid_colors)
{
    for (const auto& color : valid_colors)
        if (std::get<0>(color)==r && std::get<1>(color)==g && std::get<2>(color)==b) return true;
    return false;
}

// Tight/fast final match: compare glyph "on" pixels to a reference font color, and ensure bg pixels are NOT any valid font color.
static inline bool FinalMatchTestFast(
    const uint8_t* __restrict screen_data,
    uint32_t screen_width,
    uint32_t match_x, uint32_t match_y,
    const CharTemplate& tpl,
    uint32_t ref_packed,                      // packed BGRA 0xAARRGGBB
    const ColorSet& validPacked               // set of packed BGRA valid colors
){
    // Foreground: must equal ref_packed
    for (const auto& off : tpl.font_pixel_offsets) {
        size_t idx = ((size_t)(match_y + off.second) * screen_width + (match_x + off.first)) * 4u;
        uint32_t pix = *reinterpret_cast<const uint32_t*>(screen_data + idx);
        if (pix != ref_packed) return false;
    }
    // Background guard: must NOT be any valid font color
    for (const auto& off : tpl.bg_pixel_offsets) {
        size_t idx = ((size_t)(match_y + off.second) * screen_width + (match_x + off.first)) * 4u;
        uint32_t pix = *reinterpret_cast<const uint32_t*>(screen_data + idx);
        if (validPacked.has(pix)) return false;
    }
    return true;
}

// --- Pre-computation ---
static void PrecomputeMaps() {
    if (!triggerMap.empty()) return;
    for (const auto& tpl : fontAtlas) {
        for (const auto& offset : tpl.font_pixel_offsets) {
            triggerMap[{offset.first, offset.second}].push_back(&tpl);
        }
        charToTemplateMap[tpl.character] = &tpl;
    }
}

// --- Structs from your code ---
struct TextContext {
    std::string text;
    uint32_t x;
    uint32_t y;
    uint32_t clickX;
    uint32_t clickY;
    uint8_t colorR;
    uint8_t colorG;
    uint8_t colorB;
};

// Forward decls
Napi::Value RecognizeText(const Napi::CallbackInfo& info);
Napi::Value FindText(const Napi::CallbackInfo& info);

// =====================================================================================
// AVX2-accelerated RecognizeText implementation (fixes earlier non-working version)
// - AVX2 prescan to locate candidate pixels with any valid font color
// - Trigger-map verification against templates using fast packed 32-bit compares
// =====================================================================================

static std::vector<FoundChar> RecognizeText_PrescanAVX2(
    const uint8_t* __restrict screen_data, uint32_t screen_width, uint32_t screen_height,
    uint32_t roi_x, uint32_t roi_y, uint32_t roi_w, uint32_t roi_h,
    const std::vector<std::tuple<uint8_t,uint8_t,uint8_t>>& valid_colors,
    const std::string& allowed_chars)
{
    // Build quick filter for allowed chars
    auto allowed = [&](char c)->bool {
        return allowed_chars.empty() || (allowed_chars.find(c) != std::string::npos);
    };

    // Build packed valid color set + AVX constants
    ColorSet colorSet;
    colorSet.build(valid_colors);

    std::vector<FoundChar> final_chars;
    if (roi_w == 0 || roi_h == 0 || colorSet.v.empty()) return final_chars;

    // We keep a "consumed" mask to avoid re-detecting pixels within an accepted glyph region.
    std::vector<uint8_t> consumed(roi_w * roi_h, 0);

    const size_t strideBytes = (size_t)screen_width * 4u;

    // Scan each row in ROI: AVX2 compare 8 pixels (8 * 4 bytes = 32B) per load
    for (uint32_t dy = 0; dy < roi_h; ++dy) {
        const uint32_t y = roi_y + dy;
        const uint8_t* rowPtr = screen_data + (size_t)y * strideBytes + (size_t)roi_x * 4u;

        uint32_t dx = 0;

        // Vector body (process 8 pixels at a time)
        for (; dx + 8 <= roi_w; dx += 8) {
            __m256i chunk = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(rowPtr + (size_t)dx * 4u));

            // Compare against all valid colors, OR masks together
            __m256i acc = _mm256_setzero_si256();
            for (const __m256i& colVec : colorSet.v) {
                __m256i m = _mm256_cmpeq_epi32(chunk, colVec);
                acc = _mm256_or_si256(acc, m);
            }

            int bitmask = _mm256_movemask_ps(_mm256_castsi256_ps(acc)); // one bit per 32-bit lane
            while (bitmask) {
                int lane = __builtin_ctz((unsigned)bitmask);
                bitmask &= bitmask - 1;

                uint32_t x = roi_x + dx + (uint32_t)lane;
                uint32_t local_x = dx + (uint32_t)lane;
                if (consumed[dy * roi_w + local_x]) continue;

                // Reference color for this hot pixel (we use it for foreground equality)
                uint32_t refPacked = *reinterpret_cast<const uint32_t*>(
                    screen_data + (size_t)y * strideBytes + (size_t)x * 4u);

                // Try all trigger offsets; compute potential top-left and test templates
                std::vector<FoundChar> candidates;
                for (const auto& kv : triggerMap) {
                    const Point& off = kv.first;
                    int potential_cx = int(local_x) - off.first;
                    int potential_cy = int(dy) - off.second;
                    if (potential_cx < 0 || potential_cy < 0) continue;

                    // Bounds check inside ROI (glyph must fully fit)
                    for (const CharTemplate* tplPtr : kv.second) {
                        const CharTemplate& tpl = *tplPtr;
                        if (!allowed(tpl.character)) continue;

                        if ((uint32_t)potential_cx + tpl.width  > roi_w) continue;
                        if ((uint32_t)potential_cy + tpl.height > roi_h) continue;

                        // Absolute coords of top-left (match origin)
                        uint32_t mx = roi_x + (uint32_t)potential_cx;
                        uint32_t my = roi_y + (uint32_t)potential_cy;

                        if (FinalMatchTestFast(screen_data, screen_width, mx, my, tpl, refPacked, colorSet)) {
                            candidates.emplace_back(tpl.character,
                                                    (uint32_t)mx, (uint32_t)my,
                                                    tpl.width, tpl.height, tpl.offset,
                                                    (uint8_t)((refPacked >> 16) & 0xFF),
                                                    (uint8_t)((refPacked >> 8) & 0xFF),
                                                    (uint8_t)(refPacked & 0xFF));
                        }
                    }
                }

                if (!candidates.empty()) {
                    // Prefer the largest area (as in your original)
                    auto best_it = std::max_element(
                        candidates.begin(), candidates.end(),
                        [](const FoundChar& a, const FoundChar& b) {
                            return (a.width * a.height) < (b.width * b.height);
                        }
                    );
                    const FoundChar& best = *best_it;
                    final_chars.push_back(best);

                    // Mark consumed region in local ROI space
                    uint32_t lx = best.x - roi_x, ly = best.y - roi_y;
                    for (uint32_t yy = 0; yy < best.height; ++yy) {
                        uint32_t base = (ly + yy) * roi_w + lx;
                        for (uint32_t xx = 0; xx < best.width; ++xx) {
                            consumed[base + xx] = 1;
                        }
                    }
                }
            }
        }

        // Tail scalar loop
        for (; dx < roi_w; ++dx) {
            if (consumed[dy * roi_w + dx]) continue;

            const uint8_t* pixPtr = rowPtr + (size_t)dx * 4u;
            uint32_t packed = *reinterpret_cast<const uint32_t*>(pixPtr);
            if (!colorSet.has(packed)) continue;

            uint32_t x = roi_x + dx;
            uint32_t refPacked = packed;

            std::vector<FoundChar> candidates;
            for (const auto& kv : triggerMap) {
                const Point& off = kv.first;
                int potential_cx = int(dx) - off.first;
                int potential_cy = int(dy) - off.second;
                if (potential_cx < 0 || potential_cy < 0) continue;

                for (const CharTemplate* tplPtr : kv.second) {
                    const CharTemplate& tpl = *tplPtr;
                    if (!allowed(tpl.character)) continue;
                    if ((uint32_t)potential_cx + tpl.width  > roi_w) continue;
                    if ((uint32_t)potential_cy + tpl.height > roi_h) continue;

                    uint32_t mx = roi_x + (uint32_t)potential_cx;
                    uint32_t my = roi_y + (uint32_t)potential_cy;

                    if (FinalMatchTestFast(screen_data, screen_width, mx, my, tpl, refPacked, colorSet)) {
                        candidates.emplace_back(tpl.character,
                                                (uint32_t)mx, (uint32_t)my,
                                                tpl.width, tpl.height, tpl.offset,
                                                (uint8_t)((refPacked >> 16) & 0xFF),
                                                (uint8_t)((refPacked >> 8) & 0xFF),
                                                (uint8_t)(refPacked & 0xFF));
                    }
                }
            }

            if (!candidates.empty()) {
                const FoundChar& best = *std::max_element(
                    candidates.begin(), candidates.end(),
                    [](const FoundChar& a, const FoundChar& b) {
                        return (a.width * a.height) < (b.width * b.height);
                    }
                );
                final_chars.push_back(best);
                uint32_t lx = best.x - roi_x, ly = best.y - roi_y;
                for (uint32_t yy = 0; yy < best.height; ++yy) {
                    uint32_t base = (ly + yy) * roi_w + lx;
                    for (uint32_t xx = 0; xx < best.width; ++xx) {
                        consumed[base + xx] = 1;
                    }
                }
            }
        }
    }

    return final_chars;
}

// --- Public NAPI: RecognizeText ---
Napi::Value RecognizeText(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();

    if (info.Length() < 4 || !info[0].IsBuffer() || !info[1].IsObject() || !info[2].IsArray() || !info[3].IsString()) {
        Napi::TypeError::New(env, "Usage: recognizeText(screenBuffer, roi, validColors, allowedChars)").ThrowAsJavaScriptException();
        return env.Null();
    }

    Napi::Buffer<uint8_t> screenBuffer = info[0].As<Napi::Buffer<uint8_t>>();
    Napi::Object roi = info[1].As<Napi::Object>();
    Napi::Array jsColors = info[2].As<Napi::Array>();
    std::string allowed_chars = info[3].As<Napi::String>().Utf8Value();

    if (screenBuffer.Length() < 8) {
        Napi::TypeError::New(env, "screenBuffer too small").ThrowAsJavaScriptException();
        return env.Null();
    }

    const uint32_t screen_width  = *reinterpret_cast<uint32_t*>(screenBuffer.Data());
    const uint32_t screen_height = *reinterpret_cast<uint32_t*>(screenBuffer.Data() + 4);
    const uint8_t* screen_data   = screenBuffer.Data() + 8;

    const uint32_t roi_x = roi.Get("x").As<Napi::Number>().Uint32Value();
    const uint32_t roi_y = roi.Get("y").As<Napi::Number>().Uint32Value();
    const uint32_t roi_w = roi.Get("width").As<Napi::Number>().Uint32Value();
    const uint32_t roi_h = roi.Get("height").As<Napi::Number>().Uint32Value();

    // Validate ROI against screen dimensions
    if (roi_x >= screen_width || roi_y >= screen_height) {
        return Napi::Array::New(env, 0);
    }
    uint32_t safe_w = std::min(roi_w, screen_width  - roi_x);
    uint32_t safe_h = std::min(roi_h, screen_height - roi_y);

    std::vector<std::tuple<uint8_t,uint8_t,uint8_t>> valid_colors;
    valid_colors.reserve(jsColors.Length());
    for (uint32_t i = 0; i < jsColors.Length(); ++i) {
        Napi::Array t = jsColors.Get(i).As<Napi::Array>();
        uint8_t r = (uint8_t)t.Get(0u).As<Napi::Number>().Uint32Value();
        uint8_t g = (uint8_t)t.Get(1u).As<Napi::Number>().Uint32Value();
        uint8_t b = (uint8_t)t.Get(2u).As<Napi::Number>().Uint32Value();
        valid_colors.emplace_back(r,g,b);
    }

    std::vector<FoundChar> final_chars = RecognizeText_PrescanAVX2(
        screen_data, screen_width, screen_height,
        roi_x, roi_y, safe_w, safe_h,
        valid_colors, allowed_chars
    );

    // --- Group into contexts (unchanged logic, minor tidying) ---
    std::vector<TextContext> final_contexts;
    if (!final_chars.empty()) {
        std::sort(final_chars.begin(), final_chars.end(), [](const FoundChar& a, const FoundChar& b) {
            uint32_t a_line_y = a.y - a.offset;
            uint32_t b_line_y = b.y - b.offset;
            if (std::abs(int(a_line_y) - int(b_line_y)) > 2) return a_line_y < b_line_y;
            return a.x < b.x;
        });

        const int32_t LINE_Y_TOLERANCE    = 1;
        const int32_t SPACE_THRESHOLD     = 6;
        const int32_t CONTEXT_GAP_THRESH  = 15;

        TextContext cur{};
        const FoundChar* start_char = &final_chars.front();

        auto flush_context = [&](const FoundChar* from, const FoundChar* to) {
            TextContext ctx{};
            std::string s; s.reserve((to - from + 1) + 8);
            uint32_t right = 0, max_h = 0;

            for (const FoundChar* ch = from; ch <= to; ++ch) {
                if (ch > from) {
                    int gap = int(ch->x) - int((ch-1)->x + (ch-1)->width);
                    if (gap >= SPACE_THRESHOLD) s.push_back(' ');
                }
                s.push_back(ch->character);
                right = ch->x + ch->width;
                if (ch->height > max_h) max_h = ch->height;
            }
            ctx.text   = std::move(s);
            ctx.x      = from->x;
            ctx.y      = from->y - from->offset;
            ctx.clickX = ctx.x + (right - ctx.x) / 2;
            ctx.clickY = ctx.y + max_h / 2;
            ctx.colorR = start_char->r; ctx.colorG = start_char->g; ctx.colorB = start_char->b;

            return ctx;
        };

        for (size_t i = 1; i < final_chars.size(); ++i) {
            const auto& prev = final_chars[i-1];
            const auto& curr = final_chars[i];
            uint32_t prev_line_y = prev.y - prev.offset;
            uint32_t curr_line_y = curr.y - curr.offset;
            int32_t y_gap = std::abs(int(curr_line_y) - int(prev_line_y));
            int32_t x_gap = int(curr.x) - int(prev.x + prev.width);

            if (y_gap > LINE_Y_TOLERANCE || x_gap >= CONTEXT_GAP_THRESH) {
                final_contexts.push_back(flush_context(start_char, &prev));
                start_char = &curr;
            }
        }
        final_contexts.push_back(flush_context(start_char, &final_chars.back()));
    }

    Napi::Array resultArray = Napi::Array::New(env, final_contexts.size());
    for (size_t i = 0; i < final_contexts.size(); ++i) {
        const auto& c = final_contexts[i];
        Napi::Object ctx = Napi::Object::New(env);
        ctx.Set("x", Napi::Number::New(env, c.x));
        ctx.Set("y", Napi::Number::New(env, c.y));
        ctx.Set("text", Napi::String::New(env, c.text));

        Napi::Object click = Napi::Object::New(env);
        click.Set("x", Napi::Number::New(env, c.clickX));
        click.Set("y", Napi::Number::New(env, c.clickY));
        ctx.Set("click", click);

        Napi::Object color = Napi::Object::New(env);
        color.Set("r", Napi::Number::New(env, c.colorR));
        color.Set("g", Napi::Number::New(env, c.colorG));
        color.Set("b", Napi::Number::New(env, c.colorB));
        ctx.Set("color", color);

        resultArray.Set(i, ctx);
    }
    return resultArray;
}

// =====================================================================================
// Existing findText path (kept from your working version; tiny cleanups only)
// =====================================================================================

struct FoundWord {
    std::string text;
    uint32_t x;
    uint32_t y;
    uint8_t r, g, b;
};

static inline bool FinalMatchTest_Tuple(
    const uint8_t* screen_data, uint32_t screen_width,
    uint32_t match_x, uint32_t match_y,
    const CharTemplate& tpl,
    uint8_t ref_r, uint8_t ref_g, uint8_t ref_b,
    const std::vector<std::tuple<uint8_t,uint8_t,uint8_t>>& valid_colors)
{
    for (const auto& offset : tpl.font_pixel_offsets) {
        const size_t idx = ((match_y + offset.second) * screen_width + (match_x + offset.first)) * 4u;
        if (screen_data[idx + 2] != ref_r || screen_data[idx + 1] != ref_g || screen_data[idx + 0] != ref_b) return false;
    }
    for (const auto& offset : tpl.bg_pixel_offsets) {
        const size_t idx = ((match_y + offset.second) * screen_width + (match_x + offset.first)) * 4u;
        if (is_valid_font_color_tuple(screen_data[idx + 2], screen_data[idx + 1], screen_data[idx + 0], valid_colors)) return false;
    }
    return true;
}

bool MatchWord_Dynamic(const std::string& word,
                       uint32_t first_char_x, uint32_t first_char_y,
                       const uint8_t* screen_data, uint32_t screen_width,
                       uint8_t r, uint8_t g, uint8_t b,
                       const std::vector<std::tuple<uint8_t, uint8_t, uint8_t>>& valid_colors)
{
    const CharTemplate* prev_tpl = charToTemplateMap.at(word[0]);

    if (!FinalMatchTest_Tuple(screen_data, screen_width, first_char_x, first_char_y, *prev_tpl, r, g, b, valid_colors)) {
        return false;
    }

    uint32_t baseline_y = first_char_y - prev_tpl->offset;
    uint32_t current_x_base = first_char_x + prev_tpl->width;
    const int SPACE_WIDTH = 4;
    const int MAX_CHAR_GAP = 3;

    for (size_t i = 1; i < word.length(); ++i) {
        char c = word[i];
        if (c == ' ') { current_x_base += SPACE_WIDTH; prev_tpl = nullptr; continue; }

        auto it = charToTemplateMap.find(c);
        if (it == charToTemplateMap.end()) return false;
        const CharTemplate* tpl = it->second;

        uint32_t char_y = baseline_y + tpl->offset;
        bool found_next_char = false;

        for (int gap = 0; gap <= MAX_CHAR_GAP; ++gap) {
            uint32_t next_char_x = current_x_base + gap;
            if (FinalMatchTest_Tuple(screen_data, screen_width, next_char_x, char_y, *tpl, r, g, b, valid_colors)) {
                current_x_base = next_char_x + tpl->width;
                found_next_char = true;
                break;
            }
        }
        if (!found_next_char) return false;
    }
    return true;
}

Napi::Value FindText(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();

    if (info.Length() < 4 || !info[0].IsBuffer() || !info[1].IsObject() || !info[2].IsArray() || !info[3].IsArray()) {
        Napi::TypeError::New(env, "Usage: findText(screenBuffer, roi, validColors, wordsToFind)").ThrowAsJavaScriptException();
        return env.Null();
    }

    Napi::Buffer<uint8_t> screenBuffer = info[0].As<Napi::Buffer<uint8_t>>();
    Napi::Object roi = info[1].As<Napi::Object>();
    Napi::Array jsColors = info[2].As<Napi::Array>();
    Napi::Array jsWords = info[3].As<Napi::Array>();

    const uint32_t screen_width = *reinterpret_cast<uint32_t*>(screenBuffer.Data());
    const uint8_t* screen_data = screenBuffer.Data() + 8;
    const uint32_t roi_x = roi.Get("x").As<Napi::Number>().Uint32Value();
    const uint32_t roi_y = roi.Get("y").As<Napi::Number>().Uint32Value();
    const uint32_t roi_w = roi.Get("width").As<Napi::Number>().Uint32Value();
    const uint32_t roi_h = roi.Get("height").As<Napi::Number>().Uint32Value();

    std::vector<std::tuple<uint8_t,uint8_t,uint8_t>> valid_colors;
    valid_colors.reserve(jsColors.Length());
    for (uint32_t i = 0; i < jsColors.Length(); ++i) {
        Napi::Array t = jsColors.Get(i).As<Napi::Array>();
        valid_colors.emplace_back(
            (uint8_t)t.Get(0u).As<Napi::Number>().Uint32Value(),
            (uint8_t)t.Get(1u).As<Napi::Number>().Uint32Value(),
            (uint8_t)t.Get(2u).As<Napi::Number>().Uint32Value()
        );
    }

    std::vector<std::string> words_to_find;
    words_to_find.reserve(jsWords.Length());
    for (uint32_t i = 0; i < jsWords.Length(); ++i) {
        words_to_find.push_back(jsWords.Get(i).As<Napi::String>().Utf8Value());
    }

    // Sort by length desc to bias toward longer matches first
    std::sort(words_to_find.begin(), words_to_find.end(),
              [](const std::string& a, const std::string& b){ return a.length() > b.length(); });

    std::vector<__m256i> avx_valid_colors;
    avx_valid_colors.reserve(valid_colors.size());
    for (const auto& c : valid_colors) {
        avx_valid_colors.push_back(_mm256_set1_epi32((int)PackBGRA(std::get<0>(c), std::get<1>(c), std::get<2>(c))));
    }

    std::vector<FoundWord> final_words;
    std::map<std::pair<uint32_t,uint32_t>, bool> found_coords;

    const uint32_t CELL_SIZE = 16;
    std::set<std::pair<uint32_t,uint32_t>> hot_cells;

    // Pass 1: AVX2 prescan to mark hot cells
    for (uint32_t y = 0; y < roi_h; ++y) {
        const uint8_t* row_ptr = screen_data + ((roi_y + y) * screen_width + roi_x) * 4u;
        for (uint32_t x = 0; x + 8 <= roi_w; x += 8) {
            __m256i chunk = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(row_ptr + (size_t)x * 4u));
            __m256i acc = _mm256_setzero_si256();
            for (const auto& col : avx_valid_colors)
                acc = _mm256_or_si256(acc, _mm256_cmpeq_epi32(chunk, col));
            if (_mm256_testz_si256(acc, acc) == 0) {
                hot_cells.insert({x / CELL_SIZE, y / CELL_SIZE});
            }
        }
    }

    // Pass 2: targeted scan of hot cells (scalar verification for words)
    for (const auto& cell : hot_cells) {
        uint32_t sx = cell.first * CELL_SIZE;
        uint32_t sy = cell.second * CELL_SIZE;
        uint32_t ex = std::min(sx + CELL_SIZE, roi_w);
        uint32_t ey = std::min(sy + CELL_SIZE, roi_h);

        for (uint32_t y = sy; y < ey; ++y) {
            for (uint32_t x = sx; x < ex; ++x) {
                const size_t idx = ((roi_y + y) * screen_width + (roi_x + x)) * 4u;
                uint8_t b = screen_data[idx + 0];
                uint8_t g = screen_data[idx + 1];
                uint8_t r = screen_data[idx + 2];
                if (!is_valid_font_color_tuple(r,g,b, valid_colors)) continue;

                for (const auto& word : words_to_find) {
                    if (word.empty()) continue;
                    const CharTemplate* first_tpl = charToTemplateMap.at(word[0]);
                    for (const auto& off : first_tpl->font_pixel_offsets) {
                        int pcx = int(x) - off.first;
                        int pcy = int(y) - off.second;
                        if (pcx < 0 || pcy < 0) continue;

                        uint32_t wx = roi_x + (uint32_t)pcx;
                        uint32_t wy = roi_y + (uint32_t)pcy;
                        if (found_coords.count({wx, wy})) continue;

                        if (MatchWord_Dynamic(word, wx, wy, screen_data, screen_width, r, g, b, valid_colors)) {
                            uint32_t baseline_y = wy - first_tpl->offset;
                            final_words.push_back({word, wx, baseline_y, r, g, b});
                            found_coords[{wx, wy}] = true;
                        }
                    }
                }
            }
        }
    }

    Napi::Array resultArray = Napi::Array::New(env, final_words.size());
    for (size_t i = 0; i < final_words.size(); ++i) {
        const auto& w = final_words[i];
        Napi::Object o = Napi::Object::New(env);
        o.Set("text", Napi::String::New(env, w.text));
        o.Set("x", Napi::Number::New(env, w.x));
        o.Set("y", Napi::Number::New(env, w.y));
        Napi::Object color = Napi::Object::New(env);
        color.Set("r", Napi::Number::New(env, w.r));
        color.Set("g", Napi::Number::New(env, w.g));
        color.Set("b", Napi::Number::New(env, w.b));
        o.Set("color", color);
        resultArray.Set(i, o);
    }
    return resultArray;
}

// --- Module Initialization ---
Napi::Object Init(Napi::Env env, Napi::Object exports) {
    HardcodedInitializeFontAtlas(fontAtlas);
    PrecomputeMaps();

    exports.Set("recognizeText", Napi::Function::New(env, RecognizeText));
    exports.Set("findText", Napi::Function::New(env, FindText));
    return exports;
}

NODE_API_MODULE(fontocr, Init)

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/fontOcr/src/font_atlas_data.h
//start file
// font_atlas_data.h
// Generated by generate-font-data.js on 2025-07-12T22:39:26.683Z
// DO NOT EDIT THIS FILE MANUALLY

#pragma once
#include "ocr_structs.h" // Include the full struct definitions

inline void HardcodedInitializeFontAtlas(std::vector<CharTemplate>& fontAtlas) {
    if (!fontAtlas.empty()) return;
    fontAtlas.reserve(93);

    {
        CharTemplate tpl;
        tpl.character = '0';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '1';
        tpl.width = 4;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {0,1}, {1,1}, {2,1}, {1,2}, {2,2}, {1,3}, {2,3}, {1,4}, {2,4}, {1,5}, {2,5}, {1,6}, {2,6}, {0,7}, {1,7}, {2,7}, {3,7}};
        tpl.bg_pixel_offsets = {{0,0}, {3,0}, {3,1}, {0,2}, {3,2}, {0,3}, {3,3}, {0,4}, {3,4}, {0,5}, {3,5}, {0,6}, {3,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '2';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {4,2}, {5,2}, {3,3}, {4,3}, {2,4}, {3,4}, {1,5}, {2,5}, {0,6}, {1,6}, {0,7}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {0,2}, {1,2}, {2,2}, {3,2}, {0,3}, {1,3}, {2,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {3,5}, {4,5}, {5,5}, {2,6}, {3,6}, {4,6}, {5,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '3';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {4,2}, {5,2}, {2,3}, {3,3}, {4,3}, {4,4}, {5,4}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {0,2}, {1,2}, {2,2}, {3,2}, {0,3}, {1,3}, {5,3}, {0,4}, {1,4}, {2,4}, {3,4}, {0,5}, {1,5}, {2,5}, {3,5}, {2,6}, {3,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '4';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{4,0}, {3,1}, {4,1}, {2,2}, {3,2}, {4,2}, {1,3}, {3,3}, {4,3}, {0,4}, {3,4}, {4,4}, {0,5}, {1,5}, {2,5}, {3,5}, {4,5}, {5,5}, {3,6}, {4,6}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {5,0}, {0,1}, {1,1}, {2,1}, {5,1}, {0,2}, {1,2}, {5,2}, {0,3}, {2,3}, {5,3}, {1,4}, {2,4}, {5,4}, {0,6}, {1,6}, {2,6}, {5,6}, {0,7}, {1,7}, {2,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '5';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {1,1}, {2,1}, {1,2}, {2,2}, {1,3}, {2,3}, {3,3}, {4,3}, {4,4}, {5,4}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {0,1}, {3,1}, {4,1}, {5,1}, {0,2}, {3,2}, {4,2}, {5,2}, {0,3}, {5,3}, {0,4}, {1,4}, {2,4}, {3,4}, {0,5}, {1,5}, {2,5}, {3,5}, {2,6}, {3,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '6';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{2,0}, {3,0}, {4,0}, {1,1}, {2,1}, {0,2}, {1,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {5,0}, {0,1}, {3,1}, {4,1}, {5,1}, {2,2}, {3,2}, {4,2}, {5,2}, {5,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '7';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {4,1}, {5,1}, {3,2}, {4,2}, {3,3}, {4,3}, {2,4}, {3,4}, {2,5}, {3,5}, {1,6}, {2,6}, {1,7}, {2,7}};
        tpl.bg_pixel_offsets = {{0,1}, {1,1}, {2,1}, {3,1}, {0,2}, {1,2}, {2,2}, {5,2}, {0,3}, {1,3}, {2,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {3,6}, {4,6}, {5,6}, {0,7}, {3,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '8';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {1,3}, {2,3}, {3,3}, {4,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {0,3}, {5,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '9';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {1,4}, {2,4}, {3,4}, {4,4}, {5,4}, {4,5}, {5,5}, {3,6}, {4,6}, {1,7}, {2,7}, {3,7}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {0,4}, {0,5}, {1,5}, {2,5}, {3,5}, {0,6}, {1,6}, {2,6}, {5,6}, {0,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'A';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{2,0}, {3,0}, {4,0}, {2,1}, {3,1}, {4,1}, {1,2}, {2,2}, {4,2}, {5,2}, {1,3}, {2,3}, {4,3}, {5,3}, {1,4}, {2,4}, {4,4}, {5,4}, {0,5}, {1,5}, {2,5}, {3,5}, {4,5}, {5,5}, {6,5}, {0,6}, {1,6}, {5,6}, {6,6}, {0,7}, {1,7}, {5,7}, {6,7}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {5,0}, {6,0}, {0,1}, {1,1}, {5,1}, {6,1}, {0,2}, {3,2}, {6,2}, {0,3}, {3,3}, {6,3}, {0,4}, {3,4}, {6,4}, {2,6}, {3,6}, {4,6}, {2,7}, {3,7}, {4,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'B';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {5,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'C';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {5,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {4,1}, {2,2}, {3,2}, {4,2}, {5,2}, {2,3}, {3,3}, {4,3}, {5,3}, {2,4}, {3,4}, {4,4}, {5,4}, {2,5}, {3,5}, {4,5}, {5,5}, {2,6}, {3,6}, {4,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'D';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {5,2}, {6,2}, {0,3}, {1,3}, {5,3}, {6,3}, {0,4}, {1,4}, {5,4}, {6,4}, {0,5}, {1,5}, {5,5}, {6,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{5,0}, {6,0}, {2,1}, {3,1}, {6,1}, {2,2}, {3,2}, {4,2}, {2,3}, {3,3}, {4,3}, {2,4}, {3,4}, {4,4}, {2,5}, {3,5}, {4,5}, {2,6}, {3,6}, {6,6}, {5,7}, {6,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'E';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {5,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{2,1}, {3,1}, {4,1}, {5,1}, {2,2}, {3,2}, {4,2}, {5,2}, {2,4}, {3,4}, {4,4}, {5,4}, {2,5}, {3,5}, {4,5}, {5,5}, {2,6}, {3,6}, {4,6}, {5,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'F';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {5,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}};
        tpl.bg_pixel_offsets = {{2,1}, {3,1}, {4,1}, {5,1}, {2,2}, {3,2}, {4,2}, {5,2}, {2,4}, {3,4}, {4,4}, {5,4}, {2,5}, {3,5}, {4,5}, {5,5}, {2,6}, {3,6}, {4,6}, {5,6}, {2,7}, {3,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'G';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {0,1}, {1,1}, {6,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {4,4}, {5,4}, {6,4}, {0,5}, {1,5}, {5,5}, {6,5}, {0,6}, {1,6}, {5,6}, {6,6}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}, {6,7}};
        tpl.bg_pixel_offsets = {{0,0}, {6,0}, {2,1}, {3,1}, {4,1}, {5,1}, {2,2}, {3,2}, {4,2}, {5,2}, {6,2}, {2,3}, {3,3}, {4,3}, {5,3}, {6,3}, {2,4}, {3,4}, {2,5}, {3,5}, {4,5}, {2,6}, {3,6}, {4,6}, {0,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'H';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {5,0}, {6,0}, {0,1}, {1,1}, {5,1}, {6,1}, {0,2}, {1,2}, {5,2}, {6,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {5,3}, {6,3}, {0,4}, {1,4}, {5,4}, {6,4}, {0,5}, {1,5}, {5,5}, {6,5}, {0,6}, {1,6}, {5,6}, {6,6}, {0,7}, {1,7}, {5,7}, {6,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {2,1}, {3,1}, {4,1}, {2,2}, {3,2}, {4,2}, {2,4}, {3,4}, {4,4}, {2,5}, {3,5}, {4,5}, {2,6}, {3,6}, {4,6}, {2,7}, {3,7}, {4,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'I';
        tpl.width = 4;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {1,1}, {2,1}, {1,2}, {2,2}, {1,3}, {2,3}, {1,4}, {2,4}, {1,5}, {2,5}, {1,6}, {2,6}, {0,7}, {1,7}, {2,7}, {3,7}};
        tpl.bg_pixel_offsets = {{0,1}, {3,1}, {0,2}, {3,2}, {0,3}, {3,3}, {0,4}, {3,4}, {0,5}, {3,5}, {0,6}, {3,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'J';
        tpl.width = 5;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {3,1}, {4,1}, {3,2}, {4,2}, {3,3}, {4,3}, {3,4}, {4,4}, {3,5}, {4,5}, {3,6}, {4,6}, {0,7}, {1,7}, {2,7}, {3,7}};
        tpl.bg_pixel_offsets = {{0,0}, {0,1}, {1,1}, {2,1}, {0,2}, {1,2}, {2,2}, {0,3}, {1,3}, {2,3}, {0,4}, {1,4}, {2,4}, {0,5}, {1,5}, {2,5}, {0,6}, {1,6}, {2,6}, {4,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'K';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {0,1}, {1,1}, {3,1}, {4,1}, {0,2}, {1,2}, {2,2}, {3,2}, {0,3}, {1,3}, {2,3}, {0,4}, {1,4}, {2,4}, {0,5}, {1,5}, {2,5}, {3,5}, {0,6}, {1,6}, {3,6}, {4,6}, {0,7}, {1,7}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {2,1}, {5,1}, {4,2}, {5,2}, {3,3}, {4,3}, {5,3}, {3,4}, {4,4}, {5,4}, {4,5}, {5,5}, {2,6}, {5,6}, {2,7}, {3,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'L';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {5,0}, {2,1}, {3,1}, {4,1}, {5,1}, {2,2}, {3,2}, {4,2}, {5,2}, {2,3}, {3,3}, {4,3}, {5,3}, {2,4}, {3,4}, {4,4}, {5,4}, {2,5}, {3,5}, {4,5}, {5,5}, {2,6}, {3,6}, {4,6}, {5,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'M';
        tpl.width = 8;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {7,0}, {0,1}, {1,1}, {2,1}, {6,1}, {7,1}, {0,2}, {1,2}, {2,2}, {3,2}, {5,2}, {6,2}, {7,2}, {0,3}, {2,3}, {3,3}, {4,3}, {6,3}, {7,3}, {0,4}, {3,4}, {6,4}, {7,4}, {0,5}, {6,5}, {7,5}, {0,6}, {6,6}, {7,6}, {0,7}, {6,7}, {7,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {5,0}, {6,0}, {3,1}, {4,1}, {5,1}, {4,2}, {1,3}, {5,3}, {1,4}, {2,4}, {4,4}, {5,4}, {1,5}, {2,5}, {3,5}, {4,5}, {5,5}, {1,6}, {2,6}, {3,6}, {4,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'N';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {6,0}, {0,1}, {1,1}, {6,1}, {0,2}, {1,2}, {2,2}, {6,2}, {0,3}, {2,3}, {3,3}, {6,3}, {0,4}, {3,4}, {4,4}, {6,4}, {0,5}, {4,5}, {5,5}, {6,5}, {0,6}, {5,6}, {6,6}, {0,7}, {6,7}};
        tpl.bg_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {2,1}, {3,1}, {4,1}, {5,1}, {3,2}, {4,2}, {5,2}, {1,3}, {4,3}, {5,3}, {1,4}, {2,4}, {5,4}, {1,5}, {2,5}, {3,5}, {1,6}, {2,6}, {3,6}, {4,6}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'O';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {0,1}, {1,1}, {5,1}, {6,1}, {0,2}, {1,2}, {5,2}, {6,2}, {0,3}, {1,3}, {5,3}, {6,3}, {0,4}, {1,4}, {5,4}, {6,4}, {0,5}, {1,5}, {5,5}, {6,5}, {0,6}, {1,6}, {5,6}, {6,6}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{0,0}, {6,0}, {2,1}, {3,1}, {4,1}, {2,2}, {3,2}, {4,2}, {2,3}, {3,3}, {4,3}, {2,4}, {3,4}, {4,4}, {2,5}, {3,5}, {4,5}, {2,6}, {3,6}, {4,6}, {0,7}, {6,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'P';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {2,4}, {3,4}, {4,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}};
        tpl.bg_pixel_offsets = {{5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {5,4}, {2,5}, {3,5}, {4,5}, {5,5}, {2,6}, {3,6}, {4,6}, {5,6}, {2,7}, {3,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'Q';
        tpl.width = 7;
        tpl.height = 10;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {0,1}, {1,1}, {5,1}, {6,1}, {0,2}, {1,2}, {5,2}, {6,2}, {0,3}, {1,3}, {5,3}, {6,3}, {0,4}, {1,4}, {5,4}, {6,4}, {0,5}, {1,5}, {5,5}, {6,5}, {0,6}, {1,6}, {5,6}, {6,6}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}, {3,8}, {4,8}, {4,9}, {5,9}, {6,9}};
        tpl.bg_pixel_offsets = {{0,0}, {6,0}, {2,1}, {3,1}, {4,1}, {2,2}, {3,2}, {4,2}, {2,3}, {3,3}, {4,3}, {2,4}, {3,4}, {4,4}, {2,5}, {3,5}, {4,5}, {2,6}, {3,6}, {4,6}, {0,7}, {6,7}, {0,8}, {1,8}, {2,8}, {5,8}, {6,8}, {0,9}, {1,9}, {2,9}, {3,9}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'R';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {2,4}, {3,4}, {4,4}, {0,5}, {1,5}, {3,5}, {4,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {5,7}, {6,7}};
        tpl.bg_pixel_offsets = {{5,0}, {6,0}, {2,1}, {3,1}, {6,1}, {2,2}, {3,2}, {6,2}, {2,3}, {3,3}, {6,3}, {5,4}, {6,4}, {2,5}, {5,5}, {6,5}, {2,6}, {3,6}, {6,6}, {2,7}, {3,7}, {4,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'S';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {5,1}, {0,2}, {1,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {1,4}, {2,4}, {3,4}, {4,4}, {5,4}, {4,5}, {5,5}, {0,6}, {4,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {4,1}, {2,2}, {3,2}, {4,2}, {5,2}, {5,3}, {0,4}, {0,5}, {1,5}, {2,5}, {3,5}, {1,6}, {2,6}, {3,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'T';
        tpl.width = 8;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {6,0}, {7,0}, {3,1}, {4,1}, {3,2}, {4,2}, {3,3}, {4,3}, {3,4}, {4,4}, {3,5}, {4,5}, {3,6}, {4,6}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,1}, {1,1}, {2,1}, {5,1}, {6,1}, {7,1}, {0,2}, {1,2}, {2,2}, {5,2}, {6,2}, {7,2}, {0,3}, {1,3}, {2,3}, {5,3}, {6,3}, {7,3}, {0,4}, {1,4}, {2,4}, {5,4}, {6,4}, {7,4}, {0,5}, {1,5}, {2,5}, {5,5}, {6,5}, {7,5}, {0,6}, {1,6}, {2,6}, {5,6}, {6,6}, {7,6}, {0,7}, {1,7}, {2,7}, {5,7}, {6,7}, {7,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'U';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {5,0}, {6,0}, {0,1}, {1,1}, {5,1}, {6,1}, {0,2}, {1,2}, {5,2}, {6,2}, {0,3}, {1,3}, {5,3}, {6,3}, {0,4}, {1,4}, {5,4}, {6,4}, {0,5}, {1,5}, {5,5}, {6,5}, {0,6}, {1,6}, {5,6}, {6,6}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {2,1}, {3,1}, {4,1}, {2,2}, {3,2}, {4,2}, {2,3}, {3,3}, {4,3}, {2,4}, {3,4}, {4,4}, {2,5}, {3,5}, {4,5}, {2,6}, {3,6}, {4,6}, {0,7}, {6,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'V';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {1,3}, {2,3}, {3,3}, {4,3}, {1,4}, {2,4}, {3,4}, {4,4}, {1,5}, {2,5}, {3,5}, {4,5}, {2,6}, {3,6}, {2,7}, {3,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {2,1}, {3,1}, {2,2}, {3,2}, {0,3}, {5,3}, {0,4}, {5,4}, {0,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'W';
        tpl.width = 10;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {8,0}, {9,0}, {0,1}, {1,1}, {4,1}, {5,1}, {8,1}, {9,1}, {0,2}, {1,2}, {4,2}, {5,2}, {8,2}, {9,2}, {1,3}, {2,3}, {4,3}, {5,3}, {7,3}, {8,3}, {1,4}, {2,4}, {3,4}, {4,4}, {5,4}, {6,4}, {7,4}, {8,4}, {1,5}, {2,5}, {3,5}, {6,5}, {7,5}, {8,5}, {2,6}, {3,6}, {6,6}, {7,6}, {2,7}, {3,7}, {6,7}, {7,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {6,0}, {7,0}, {2,1}, {3,1}, {6,1}, {7,1}, {2,2}, {3,2}, {6,2}, {7,2}, {0,3}, {3,3}, {6,3}, {9,3}, {0,4}, {9,4}, {0,5}, {4,5}, {5,5}, {9,5}, {0,6}, {1,6}, {4,6}, {5,6}, {8,6}, {9,6}, {0,7}, {1,7}, {4,7}, {5,7}, {8,7}, {9,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'X';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {1,2}, {2,2}, {3,2}, {4,2}, {2,3}, {3,3}, {2,4}, {3,4}, {1,5}, {2,5}, {3,5}, {4,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {2,1}, {3,1}, {0,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {5,5}, {2,6}, {3,6}, {2,7}, {3,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'Y';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {1,2}, {2,2}, {3,2}, {4,2}, {1,3}, {2,3}, {3,3}, {4,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {2,1}, {3,1}, {0,2}, {5,2}, {0,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'Z';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {4,1}, {5,1}, {3,2}, {4,2}, {5,2}, {2,3}, {3,3}, {4,3}, {1,4}, {2,4}, {3,4}, {0,5}, {1,5}, {2,5}, {0,6}, {1,6}, {0,7}, {1,7}, {2,7}, {3,7}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{0,1}, {1,1}, {2,1}, {3,1}, {0,2}, {1,2}, {2,2}, {0,3}, {1,3}, {5,3}, {0,4}, {4,4}, {5,4}, {3,5}, {4,5}, {5,5}, {2,6}, {3,6}, {4,6}, {5,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'a';
        tpl.width = 6;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {4,1}, {5,1}, {1,2}, {2,2}, {3,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {1,5}, {2,5}, {3,5}, {4,5}, {5,5}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {0,1}, {1,1}, {2,1}, {3,1}, {0,2}, {2,3}, {3,3}, {2,4}, {3,4}, {0,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '&';
        tpl.width = 8;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {0,1}, {1,1}, {3,1}, {4,1}, {0,2}, {1,2}, {3,2}, {4,2}, {1,3}, {2,3}, {3,3}, {6,3}, {7,3}, {0,4}, {1,4}, {3,4}, {4,4}, {6,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {5,6}, {6,6}, {1,7}, {2,7}, {3,7}, {4,7}, {6,7}, {7,7}};
        tpl.bg_pixel_offsets = {{0,0}, {4,0}, {5,0}, {6,0}, {7,0}, {2,1}, {5,1}, {6,1}, {7,1}, {2,2}, {5,2}, {6,2}, {7,2}, {0,3}, {4,3}, {5,3}, {2,4}, {5,4}, {7,4}, {2,5}, {3,5}, {6,5}, {7,5}, {2,6}, {3,6}, {4,6}, {7,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '\'';
        tpl.width = 2;
        tpl.height = 3;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}};
        tpl.bg_pixel_offsets = {};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '*';
        tpl.width = 5;
        tpl.height = 5;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{2,0}, {0,1}, {2,1}, {4,1}, {1,2}, {2,2}, {3,2}, {0,3}, {2,3}, {4,3}, {2,4}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {3,0}, {4,0}, {1,1}, {3,1}, {0,2}, {4,2}, {1,3}, {3,3}, {0,4}, {1,4}, {3,4}, {4,4}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '@';
        tpl.width = 9;
        tpl.height = 9;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{2,0}, {3,0}, {4,0}, {5,0}, {6,0}, {7,0}, {1,1}, {8,1}, {0,2}, {3,2}, {4,2}, {5,2}, {6,2}, {8,2}, {0,3}, {2,3}, {3,3}, {5,3}, {6,3}, {8,3}, {0,4}, {3,4}, {5,4}, {6,4}, {8,4}, {0,5}, {2,5}, {3,5}, {5,5}, {6,5}, {8,5}, {0,6}, {3,6}, {4,6}, {5,6}, {6,6}, {7,6}, {1,7}, {2,8}, {3,8}, {4,8}, {5,8}, {6,8}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {8,0}, {0,1}, {2,1}, {3,1}, {4,1}, {5,1}, {6,1}, {7,1}, {1,2}, {2,2}, {7,2}, {1,3}, {4,3}, {7,3}, {1,4}, {2,4}, {4,4}, {7,4}, {1,5}, {4,5}, {7,5}, {1,6}, {2,6}, {8,6}, {0,7}, {2,7}, {3,7}, {4,7}, {5,7}, {6,7}, {7,7}, {8,7}, {0,8}, {1,8}, {7,8}, {8,8}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'b';
        tpl.width = 6;
        tpl.height = 9;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {4,7}, {5,7}, {0,8}, {1,8}, {2,8}, {3,8}, {4,8}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {5,0}, {2,1}, {3,1}, {4,1}, {5,1}, {2,2}, {3,2}, {4,2}, {5,2}, {5,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}, {5,8}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '\\';
        tpl.width = 6;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {1,2}, {2,2}, {1,3}, {2,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {3,7}, {4,7}, {3,8}, {4,8}, {4,9}, {5,9}, {4,10}, {5,10}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {5,0}, {2,1}, {3,1}, {4,1}, {5,1}, {0,2}, {3,2}, {4,2}, {5,2}, {0,3}, {3,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {2,7}, {5,7}, {0,8}, {1,8}, {2,8}, {5,8}, {0,9}, {1,9}, {2,9}, {3,9}, {0,10}, {1,10}, {2,10}, {3,10}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '`';
        tpl.width = 3;
        tpl.height = 2;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {1,1}, {2,1}};
        tpl.bg_pixel_offsets = {{2,0}, {0,1}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '}';
        tpl.width = 6;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {3,5}, {4,5}, {5,5}, {2,6}, {3,6}, {2,7}, {3,7}, {2,8}, {3,8}, {2,9}, {3,9}, {0,10}, {1,10}, {2,10}};
        tpl.bg_pixel_offsets = {{3,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {2,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {4,7}, {5,7}, {0,8}, {1,8}, {4,8}, {5,8}, {0,9}, {1,9}, {4,9}, {5,9}, {3,10}, {4,10}, {5,10}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '{';
        tpl.width = 6;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{3,0}, {4,0}, {5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {0,5}, {1,5}, {2,5}, {2,6}, {3,6}, {2,7}, {3,7}, {2,8}, {3,8}, {2,9}, {3,9}, {3,10}, {4,10}, {5,10}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {3,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {4,7}, {5,7}, {0,8}, {1,8}, {4,8}, {5,8}, {0,9}, {1,9}, {4,9}, {5,9}, {0,10}, {1,10}, {2,10}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = ']';
        tpl.width = 4;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}, {2,8}, {3,8}, {2,9}, {3,9}, {0,10}, {1,10}, {2,10}, {3,10}};
        tpl.bg_pixel_offsets = {{0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {0,8}, {1,8}, {0,9}, {1,9}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '[';
        tpl.width = 4;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {0,8}, {1,8}, {0,9}, {1,9}, {0,10}, {1,10}, {2,10}, {3,10}};
        tpl.bg_pixel_offsets = {{2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}, {2,8}, {3,8}, {2,9}, {3,9}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'c';
        tpl.width = 5;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {1,5}, {2,5}, {3,5}, {4,5}};
        tpl.bg_pixel_offsets = {{0,0}, {2,1}, {3,1}, {4,1}, {2,2}, {3,2}, {4,2}, {2,3}, {3,3}, {4,3}, {2,4}, {3,4}, {4,4}, {0,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '^';
        tpl.width = 8;
        tpl.height = 4;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{3,0}, {4,0}, {2,1}, {3,1}, {4,1}, {5,1}, {1,2}, {2,2}, {5,2}, {6,2}, {0,3}, {1,3}, {6,3}, {7,3}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {5,0}, {6,0}, {7,0}, {0,1}, {1,1}, {6,1}, {7,1}, {0,2}, {3,2}, {4,2}, {7,2}, {2,3}, {3,3}, {4,3}, {5,3}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = ':';
        tpl.width = 2;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,4}, {1,4}, {0,5}, {1,5}};
        tpl.bg_pixel_offsets = {{0,2}, {1,2}, {0,3}, {1,3}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = ',';
        tpl.width = 2;
        tpl.height = 4;
        tpl.offset = 7;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}};
        tpl.bg_pixel_offsets = {{1,3}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'd';
        tpl.width = 6;
        tpl.height = 9;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{4,0}, {5,0}, {4,1}, {5,1}, {4,2}, {5,2}, {1,3}, {2,3}, {3,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {4,7}, {5,7}, {1,8}, {2,8}, {3,8}, {4,8}, {5,8}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {0,1}, {1,1}, {2,1}, {3,1}, {0,2}, {1,2}, {2,2}, {3,2}, {0,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}, {0,8}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '$';
        tpl.width = 6;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{3,0}, {3,1}, {1,2}, {2,2}, {3,2}, {4,2}, {0,3}, {1,3}, {3,3}, {5,3}, {0,4}, {1,4}, {3,4}, {1,5}, {2,5}, {3,5}, {4,5}, {2,6}, {4,6}, {5,6}, {0,7}, {2,7}, {4,7}, {5,7}, {1,8}, {2,8}, {3,8}, {4,8}, {2,9}, {2,10}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {4,0}, {5,0}, {0,1}, {1,1}, {2,1}, {4,1}, {5,1}, {0,2}, {5,2}, {2,3}, {4,3}, {2,4}, {4,4}, {5,4}, {0,5}, {5,5}, {0,6}, {1,6}, {3,6}, {1,7}, {3,7}, {0,8}, {5,8}, {0,9}, {1,9}, {3,9}, {4,9}, {5,9}, {0,10}, {1,10}, {3,10}, {4,10}, {5,10}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'e';
        tpl.width = 6;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {2,2}, {3,2}, {4,2}, {5,2}, {0,3}, {1,3}, {0,4}, {1,4}, {5,4}, {1,5}, {2,5}, {3,5}, {4,5}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {2,3}, {3,3}, {4,3}, {5,3}, {2,4}, {3,4}, {4,4}, {0,5}, {5,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '=';
        tpl.width = 7;
        tpl.height = 4;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {6,0}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {5,3}, {6,3}};
        tpl.bg_pixel_offsets = {{0,1}, {1,1}, {2,1}, {3,1}, {4,1}, {5,1}, {6,1}, {0,2}, {1,2}, {2,2}, {3,2}, {4,2}, {5,2}, {6,2}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '!';
        tpl.width = 2;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,7}, {1,7}};
        tpl.bg_pixel_offsets = {{0,6}, {1,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'f';
        tpl.width = 5;
        tpl.height = 9;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{2,0}, {3,0}, {4,0}, {1,1}, {2,1}, {1,2}, {2,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {1,4}, {2,4}, {1,5}, {2,5}, {1,6}, {2,6}, {1,7}, {2,7}, {1,8}, {2,8}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {0,1}, {3,1}, {4,1}, {0,2}, {3,2}, {4,2}, {0,4}, {3,4}, {4,4}, {0,5}, {3,5}, {4,5}, {0,6}, {3,6}, {4,6}, {0,7}, {3,7}, {4,7}, {0,8}, {3,8}, {4,8}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'g';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {1,5}, {2,5}, {3,5}, {4,5}, {5,5}, {4,6}, {5,6}, {1,7}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {0,5}, {0,6}, {1,6}, {2,6}, {3,6}, {0,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '>';
        tpl.width = 7;
        tpl.height = 7;
        tpl.offset = 2;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,1}, {3,1}, {4,2}, {5,2}, {6,3}, {4,4}, {5,4}, {2,5}, {3,5}, {0,6}, {1,6}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {5,0}, {6,0}, {0,1}, {1,1}, {4,1}, {5,1}, {6,1}, {0,2}, {1,2}, {2,2}, {3,2}, {6,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {5,3}, {0,4}, {1,4}, {2,4}, {3,4}, {6,4}, {0,5}, {1,5}, {4,5}, {5,5}, {6,5}, {2,6}, {3,6}, {4,6}, {5,6}, {6,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'h';
        tpl.width = 6;
        tpl.height = 9;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {1,7}, {4,7}, {5,7}, {0,8}, {1,8}, {4,8}, {5,8}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {5,0}, {2,1}, {3,1}, {4,1}, {5,1}, {2,2}, {3,2}, {4,2}, {5,2}, {5,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}, {2,8}, {3,8}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '#';
        tpl.width = 7;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{3,0}, {5,0}, {3,1}, {5,1}, {1,2}, {2,2}, {3,2}, {4,2}, {5,2}, {6,2}, {2,3}, {4,3}, {2,4}, {4,4}, {0,5}, {1,5}, {2,5}, {3,5}, {4,5}, {5,5}, {1,6}, {3,6}, {1,7}, {3,7}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {4,0}, {6,0}, {0,1}, {1,1}, {2,1}, {4,1}, {6,1}, {0,2}, {0,3}, {1,3}, {3,3}, {5,3}, {6,3}, {0,4}, {1,4}, {3,4}, {5,4}, {6,4}, {6,5}, {0,6}, {2,6}, {4,6}, {5,6}, {6,6}, {0,7}, {2,7}, {4,7}, {5,7}, {6,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '-';
        tpl.width = 4;
        tpl.height = 1;
        tpl.offset = 5;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}};
        tpl.bg_pixel_offsets = {};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'i';
        tpl.width = 2;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}};
        tpl.bg_pixel_offsets = {{0,1}, {1,1}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'j';
        tpl.width = 4;
        tpl.height = 10;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{2,0}, {3,0}, {1,2}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}, {2,8}, {3,8}, {0,9}, {1,9}, {2,9}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {2,1}, {3,1}, {0,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {0,8}, {1,8}, {3,9}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'k';
        tpl.width = 6;
        tpl.height = 9;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {3,4}, {4,4}, {0,5}, {1,5}, {2,5}, {3,5}, {0,6}, {1,6}, {2,6}, {3,6}, {0,7}, {1,7}, {3,7}, {4,7}, {0,8}, {1,8}, {4,8}, {5,8}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {4,0}, {5,0}, {2,1}, {3,1}, {4,1}, {5,1}, {2,2}, {3,2}, {4,2}, {5,2}, {2,3}, {3,3}, {2,4}, {5,4}, {4,5}, {5,5}, {4,6}, {5,6}, {2,7}, {5,7}, {2,8}, {3,8}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'l';
        tpl.width = 2;
        tpl.height = 9;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {0,8}, {1,8}};
        tpl.bg_pixel_offsets = {};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '<';
        tpl.width = 7;
        tpl.height = 7;
        tpl.offset = 2;
        tpl.font_pixel_offsets = {{5,0}, {6,0}, {3,1}, {4,1}, {1,2}, {2,2}, {0,3}, {1,4}, {2,4}, {3,5}, {4,5}, {5,6}, {6,6}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {2,1}, {5,1}, {6,1}, {0,2}, {3,2}, {4,2}, {5,2}, {6,2}, {1,3}, {2,3}, {3,3}, {4,3}, {5,3}, {6,3}, {0,4}, {3,4}, {4,4}, {5,4}, {6,4}, {0,5}, {1,5}, {2,5}, {5,5}, {6,5}, {0,6}, {1,6}, {2,6}, {3,6}, {4,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'm';
        tpl.width = 10;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {6,0}, {7,0}, {8,0}, {0,1}, {1,1}, {4,1}, {5,1}, {8,1}, {9,1}, {0,2}, {1,2}, {4,2}, {5,2}, {8,2}, {9,2}, {0,3}, {1,3}, {4,3}, {5,3}, {8,3}, {9,3}, {0,4}, {1,4}, {4,4}, {5,4}, {8,4}, {9,4}, {0,5}, {1,5}, {4,5}, {5,5}, {8,5}, {9,5}};
        tpl.bg_pixel_offsets = {{5,0}, {9,0}, {2,1}, {3,1}, {6,1}, {7,1}, {2,2}, {3,2}, {6,2}, {7,2}, {2,3}, {3,3}, {6,3}, {7,3}, {2,4}, {3,4}, {6,4}, {7,4}, {2,5}, {3,5}, {6,5}, {7,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'n';
        tpl.width = 6;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}};
        tpl.bg_pixel_offsets = {{5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {2,5}, {3,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'o';
        tpl.width = 6;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {1,5}, {2,5}, {3,5}, {4,5}};
        tpl.bg_pixel_offsets = {{0,0}, {5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {0,5}, {5,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'p';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {2,5}, {3,5}, {4,5}, {0,6}, {1,6}, {0,7}, {1,7}};
        tpl.bg_pixel_offsets = {{5,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {5,5}, {2,6}, {3,6}, {4,6}, {5,6}, {2,7}, {3,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = ')';
        tpl.width = 4;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {1,1}, {2,1}, {1,2}, {2,2}, {2,3}, {3,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}, {1,8}, {2,8}, {1,9}, {2,9}, {0,10}, {1,10}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {0,1}, {3,1}, {0,2}, {3,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {0,8}, {3,8}, {0,9}, {3,9}, {2,10}, {3,10}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '(';
        tpl.width = 4;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{2,0}, {3,0}, {1,1}, {2,1}, {1,2}, {2,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {1,8}, {2,8}, {1,9}, {2,9}, {2,10}, {3,10}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {0,1}, {3,1}, {0,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {2,7}, {3,7}, {0,8}, {3,8}, {0,9}, {3,9}, {0,10}, {1,10}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '%';
        tpl.width = 12;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {7,0}, {0,1}, {1,1}, {3,1}, {4,1}, {7,1}, {0,2}, {1,2}, {3,2}, {4,2}, {6,2}, {0,3}, {1,3}, {3,3}, {4,3}, {6,3}, {8,3}, {9,3}, {10,3}, {1,4}, {2,4}, {3,4}, {5,4}, {7,4}, {8,4}, {10,4}, {11,4}, {5,5}, {7,5}, {8,5}, {10,5}, {11,5}, {4,6}, {7,6}, {8,6}, {10,6}, {11,6}, {4,7}, {8,7}, {9,7}, {10,7}};
        tpl.bg_pixel_offsets = {{0,0}, {4,0}, {5,0}, {6,0}, {8,0}, {9,0}, {10,0}, {11,0}, {2,1}, {5,1}, {6,1}, {8,1}, {9,1}, {10,1}, {11,1}, {2,2}, {5,2}, {7,2}, {8,2}, {9,2}, {10,2}, {11,2}, {2,3}, {5,3}, {7,3}, {11,3}, {0,4}, {4,4}, {6,4}, {9,4}, {0,5}, {1,5}, {2,5}, {3,5}, {4,5}, {6,5}, {9,5}, {0,6}, {1,6}, {2,6}, {3,6}, {5,6}, {6,6}, {9,6}, {0,7}, {1,7}, {2,7}, {3,7}, {5,7}, {6,7}, {7,7}, {11,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '.';
        tpl.width = 2;
        tpl.height = 2;
        tpl.offset = 7;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}};
        tpl.bg_pixel_offsets = {};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '|';
        tpl.width = 2;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}, {1,7}, {0,8}, {1,8}, {0,9}, {1,9}, {0,10}, {1,10}};
        tpl.bg_pixel_offsets = {};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '+';
        tpl.width = 7;
        tpl.height = 7;
        tpl.offset = 2;
        tpl.font_pixel_offsets = {{3,0}, {3,1}, {3,2}, {0,3}, {1,3}, {2,3}, {3,3}, {4,3}, {5,3}, {6,3}, {3,4}, {3,5}, {3,6}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {4,0}, {5,0}, {6,0}, {0,1}, {1,1}, {2,1}, {4,1}, {5,1}, {6,1}, {0,2}, {1,2}, {2,2}, {4,2}, {5,2}, {6,2}, {0,4}, {1,4}, {2,4}, {4,4}, {5,4}, {6,4}, {0,5}, {1,5}, {2,5}, {4,5}, {5,5}, {6,5}, {0,6}, {1,6}, {2,6}, {4,6}, {5,6}, {6,6}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'q';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {1,5}, {2,5}, {3,5}, {4,5}, {5,5}, {4,6}, {5,6}, {4,7}, {5,7}};
        tpl.bg_pixel_offsets = {{0,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {0,5}, {0,6}, {1,6}, {2,6}, {3,6}, {0,7}, {1,7}, {2,7}, {3,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '?';
        tpl.width = 5;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {0,1}, {3,1}, {4,1}, {3,2}, {4,2}, {2,3}, {3,3}, {1,4}, {2,4}, {1,5}, {2,5}, {1,7}, {2,7}};
        tpl.bg_pixel_offsets = {{0,0}, {4,0}, {1,1}, {2,1}, {0,2}, {1,2}, {2,2}, {0,3}, {1,3}, {4,3}, {0,4}, {3,4}, {4,4}, {0,5}, {3,5}, {4,5}, {0,6}, {1,6}, {2,6}, {3,6}, {4,6}, {0,7}, {3,7}, {4,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '"';
        tpl.width = 5;
        tpl.height = 3;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {3,0}, {4,0}, {0,1}, {1,1}, {3,1}, {4,1}, {0,2}, {1,2}, {3,2}, {4,2}};
        tpl.bg_pixel_offsets = {{2,0}, {2,1}, {2,2}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'r';
        tpl.width = 5;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {3,0}, {4,0}, {0,1}, {1,1}, {2,1}, {3,1}, {4,1}, {0,2}, {1,2}, {0,3}, {1,3}, {0,4}, {1,4}, {0,5}, {1,5}};
        tpl.bg_pixel_offsets = {{2,0}, {2,2}, {3,2}, {4,2}, {2,3}, {3,3}, {4,3}, {2,4}, {3,4}, {4,4}, {2,5}, {3,5}, {4,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 's';
        tpl.width = 5;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {3,0}, {4,0}, {0,1}, {1,1}, {0,2}, {1,2}, {2,2}, {3,2}, {1,3}, {2,3}, {3,3}, {4,3}, {3,4}, {4,4}, {0,5}, {1,5}, {2,5}, {3,5}};
        tpl.bg_pixel_offsets = {{0,0}, {2,1}, {3,1}, {4,1}, {4,2}, {0,3}, {0,4}, {1,4}, {2,4}, {4,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = ';';
        tpl.width = 2;
        tpl.height = 8;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {0,1}, {1,1}, {0,4}, {1,4}, {0,5}, {1,5}, {0,6}, {1,6}, {0,7}};
        tpl.bg_pixel_offsets = {{0,2}, {1,2}, {0,3}, {1,3}, {1,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '/';
        tpl.width = 6;
        tpl.height = 11;
        tpl.offset = 0;
        tpl.font_pixel_offsets = {{4,0}, {5,0}, {4,1}, {5,1}, {3,2}, {4,2}, {3,3}, {4,3}, {2,4}, {3,4}, {2,5}, {3,5}, {2,6}, {3,6}, {1,7}, {2,7}, {1,8}, {2,8}, {0,9}, {1,9}, {0,10}, {1,10}};
        tpl.bg_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {0,1}, {1,1}, {2,1}, {3,1}, {0,2}, {1,2}, {2,2}, {5,2}, {0,3}, {1,3}, {2,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {1,6}, {4,6}, {5,6}, {0,7}, {3,7}, {4,7}, {5,7}, {0,8}, {3,8}, {4,8}, {5,8}, {2,9}, {3,9}, {4,9}, {5,9}, {2,10}, {3,10}, {4,10}, {5,10}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 't';
        tpl.width = 5;
        tpl.height = 8;
        tpl.offset = 1;
        tpl.font_pixel_offsets = {{1,0}, {2,0}, {1,1}, {2,1}, {0,2}, {1,2}, {2,2}, {3,2}, {4,2}, {1,3}, {2,3}, {1,4}, {2,4}, {1,5}, {2,5}, {1,6}, {2,6}, {2,7}, {3,7}, {4,7}};
        tpl.bg_pixel_offsets = {{0,0}, {3,0}, {4,0}, {0,1}, {3,1}, {4,1}, {0,3}, {3,3}, {4,3}, {0,4}, {3,4}, {4,4}, {0,5}, {3,5}, {4,5}, {0,6}, {3,6}, {4,6}, {0,7}, {1,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'u';
        tpl.width = 6;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {0,3}, {1,3}, {4,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {1,5}, {2,5}, {3,5}, {4,5}, {5,5}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {2,1}, {3,1}, {2,2}, {3,2}, {2,3}, {3,3}, {2,4}, {3,4}, {0,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = '_';
        tpl.width = 8;
        tpl.height = 1;
        tpl.offset = 10;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {5,0}, {6,0}, {7,0}};
        tpl.bg_pixel_offsets = {};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'v';
        tpl.width = 6;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {0,2}, {1,2}, {4,2}, {5,2}, {1,3}, {2,3}, {3,3}, {4,3}, {1,4}, {2,4}, {3,4}, {4,4}, {2,5}, {3,5}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {2,1}, {3,1}, {2,2}, {3,2}, {0,3}, {5,3}, {0,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'w';
        tpl.width = 8;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {3,0}, {4,0}, {6,0}, {7,0}, {0,1}, {1,1}, {3,1}, {4,1}, {6,1}, {7,1}, {0,2}, {1,2}, {3,2}, {4,2}, {6,2}, {7,2}, {0,3}, {1,3}, {3,3}, {4,3}, {6,3}, {7,3}, {1,4}, {2,4}, {5,4}, {6,4}, {1,5}, {2,5}, {5,5}, {6,5}};
        tpl.bg_pixel_offsets = {{2,0}, {5,0}, {2,1}, {5,1}, {2,2}, {5,2}, {2,3}, {5,3}, {0,4}, {3,4}, {4,4}, {7,4}, {0,5}, {3,5}, {4,5}, {7,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'x';
        tpl.width = 6;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {1,2}, {2,2}, {3,2}, {4,2}, {1,3}, {2,3}, {3,3}, {4,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {2,1}, {3,1}, {0,2}, {5,2}, {0,3}, {5,3}, {2,4}, {3,4}, {2,5}, {3,5}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'y';
        tpl.width = 6;
        tpl.height = 8;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {4,0}, {5,0}, {0,1}, {1,1}, {4,1}, {5,1}, {1,2}, {2,2}, {3,2}, {4,2}, {1,3}, {2,3}, {3,3}, {4,3}, {2,4}, {3,4}, {2,5}, {3,5}, {1,6}, {2,6}, {1,7}, {2,7}};
        tpl.bg_pixel_offsets = {{2,0}, {3,0}, {2,1}, {3,1}, {0,2}, {5,2}, {0,3}, {5,3}, {0,4}, {1,4}, {4,4}, {5,4}, {0,5}, {1,5}, {4,5}, {5,5}, {0,6}, {3,6}, {4,6}, {5,6}, {0,7}, {3,7}, {4,7}, {5,7}};
        fontAtlas.push_back(std::move(tpl));
    }
    {
        CharTemplate tpl;
        tpl.character = 'z';
        tpl.width = 5;
        tpl.height = 6;
        tpl.offset = 3;
        tpl.font_pixel_offsets = {{0,0}, {1,0}, {2,0}, {3,0}, {4,0}, {3,1}, {4,1}, {2,2}, {3,2}, {1,3}, {2,3}, {0,4}, {1,4}, {0,5}, {1,5}, {2,5}, {3,5}, {4,5}};
        tpl.bg_pixel_offsets = {{0,1}, {1,1}, {2,1}, {0,2}, {1,2}, {4,2}, {0,3}, {3,3}, {4,3}, {2,4}, {3,4}, {4,4}};
        fontAtlas.push_back(std::move(tpl));
    }
}

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/fontOcr/src/ocr_structs.h
//start file
#pragma once

#include <vector>
#include <string>
#include <cstdint>
#include <utility>

// A clean struct for coordinates, with a comparison operator for use in maps.
struct Point {
    uint8_t first;  // x
    uint8_t second; // y

    bool operator<(const Point& other) const {
        if (first != other.first) {
            return first < other.first;
        }
        return second < other.second;
    }
};

// Template for a single character.
struct CharTemplate {
    char character;
    uint32_t width;
    uint32_t height;
    uint32_t offset;
    std::vector<Point> font_pixel_offsets;
    std::vector<Point> bg_pixel_offsets;
};

// Represents a character found on screen by recognizeText.
struct FoundChar {
    char character;
    uint32_t x;
    uint32_t y;
    uint32_t width;
    uint32_t height;
    uint32_t offset;
    uint8_t r, g, b;
    FoundChar(char c, uint32_t _x, uint32_t _y, uint32_t w, uint32_t h, uint32_t o, uint8_t _r, uint8_t _g, uint8_t _b)
        : character(c), x(_x), y(_y), width(w), height(h), offset(o), r(_r), g(_g), b(_b) {}
};
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/fontOcr/wrapper.js
//start file
// wrapper.js

// Load the native addon's exports object, which is { recognizeText: [Function] }
const addon = require('./build/Release/fontOcr.node');

// Export the entire addon object directly.
module.exports = addon;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/keypress/src/keypress.cc
//start file
#include <napi.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#include <X11/XKBlib.h>
#include <X11/Xatom.h>
#include <X11/extensions/XTest.h>
#include <string>
#include <map>
#include <vector>
#include <unordered_map>
#include <unistd.h>
#include <cctype>
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <thread>
#include <chrono>
#include <random>
#include <cmath>
#include <memory>

std::map<std::string, KeySym> specialKeys = {
   {"f1", XK_F1}, {"f2", XK_F2}, {"f3", XK_F3}, {"f4", XK_F4},
   {"f5", XK_F5}, {"f6", XK_F6}, {"f7", XK_F7}, {"f8", XK_F8},
   {"f9", XK_F9}, {"f10", XK_F10}, {"f11", XK_F11}, {"f12", XK_F12},
   {"enter", XK_Return}, {"return", XK_Return}, {"tab", XK_Tab},
   {"space", XK_space}, {"backspace", XK_BackSpace}, {"delete", XK_Delete},
   {"escape", XK_Escape}, {"esc", XK_Escape}, {"=", XK_equal},
   {"-", XK_minus}, {".", XK_period}, {"/", XK_slash},
   {"\\", XK_backslash}, {";", XK_semicolon}, {"'", XK_apostrophe},
   {"[", XK_bracketleft}, {"]", XK_bracketright}, {"`", XK_grave},
   {"left", XK_Left}, {"right", XK_Right}, {"up", XK_Up},
   {"down", XK_Down}, {"home", XK_Home}, {"end", XK_End},
   {"pgup", XK_Page_Up}, {"pgdn", XK_Page_Down}, {"menu", XK_Menu},
};

std::map<std::string, unsigned int> modifierKeys = {
    {"shift", ShiftMask}, {"control", ControlMask}, {"ctrl", ControlMask},
    {"alt", Mod1Mask}, {"super", Mod4Mask}, {"meta", Mod4Mask},
};

std::map<char, KeySym> directionKeys = {
    {'n', XK_Up}, {'s', XK_Down}, {'e', XK_Right}, {'w', XK_Left}
};

class HumanTimingGenerator {
private:
    std::mt19937 rng;
    std::normal_distribution<double> normal_dist;
    std::uniform_real_distribution<double> uniform_dist;

public:
    HumanTimingGenerator() : rng(std::random_device{}()), normal_dist(0.0, 1.0), uniform_dist(0.0, 1.0) {}

    int get_pro_gamer_delay(int base_ms, int max_variation_ms) {
        double rand_val = uniform_dist(rng);
        double variation;

        if (rand_val < 0.8) {
            variation = normal_dist(rng) * max_variation_ms;
        } else {
            variation = (uniform_dist(rng) - 0.5) * 2.0 * max_variation_ms;
        }

        int result = static_cast<int>(base_ms + variation);
        return std::max(1, std::min(result, base_ms + max_variation_ms));
    }

    bool should_add_micro_delay() {
        return uniform_dist(rng) < 0.02;
    }

    int get_micro_delay() {
        return get_pro_gamer_delay(10, 5);
    }
};

HumanTimingGenerator timing_generator;

class BehaviorProfile {
private:
    int typing_speed_preference;
    int error_rate;
    int correction_speed;

public:
    BehaviorProfile() {
        typing_speed_preference = rand() % 3;
        error_rate = rand() % 2;
        correction_speed = rand() % 3;
    }

    int get_base_delay() const {
        switch (typing_speed_preference) {
            case 0: return 35;
            case 1: return 25;
            case 2: return 15;
            default: return 25;
        }
    }

    int get_delay_variation() const {
        switch (typing_speed_preference) {
            case 0: return 15;
            case 1: return 10;
            case 2: return 5;
            default: return 10;
        }
    }

    bool should_make_error() const {
        return (rand() % 100) < error_rate;
    }

    int get_correction_delay() const {
        switch (correction_speed) {
            case 0: return 80;
            case 1: return 50;
            case 2: return 30;
            default: return 50;
        }
    }
};

class SessionManager {
private:
    static int session_counter;
    static std::unordered_map<int, std::shared_ptr<BehaviorProfile>> session_profiles;

public:
    static std::shared_ptr<BehaviorProfile> get_current_profile() {
        if (session_profiles.find(session_counter) == session_profiles.end()) {
            session_profiles[session_counter] = std::make_shared<BehaviorProfile>();
        }
        return session_profiles[session_counter];
    }

    static void new_session() {
        session_counter++;
        if (session_profiles.size() > 20) {
            session_profiles.clear();
        }
    }

    static int get_session_id() {
        return session_counter;
    }
};

int SessionManager::session_counter = 0;
std::unordered_map<int, std::shared_ptr<BehaviorProfile>> SessionManager::session_profiles;

class TypingMistakeSimulator {
private:
    std::unordered_map<char, std::vector<char>> nearby_keys;

public:
    TypingMistakeSimulator() {
        nearby_keys = {
            {'q', {'w', 'a'}},
            {'w', {'q', 'e', 'a', 's'}},
            {'e', {'w', 'r', 's', 'd'}},
            {'r', {'e', 't', 'd', 'f'}},
            {'t', {'r', 'y', 'f', 'g'}},
            {'y', {'t', 'u', 'g', 'h'}},
            {'u', {'y', 'i', 'h', 'j'}},
            {'i', {'u', 'o', 'j', 'k'}},
            {'o', {'i', 'p', 'k', 'l'}},
            {'p', {'o', '[', 'l', ';'}},
            {'a', {'q', 'w', 's', 'z'}},
            {'s', {'q', 'w', 'e', 'a', 'd', 'x', 'z'}},
            {'d', {'w', 'e', 'r', 's', 'f', 'c', 'x'}},
            {'f', {'e', 'r', 't', 'd', 'g', 'v', 'c'}},
            {'g', {'r', 't', 'y', 'f', 'h', 'b', 'v'}},
            {'h', {'t', 'y', 'u', 'g', 'j', 'n', 'b'}},
            {'j', {'y', 'u', 'i', 'h', 'k', 'm', 'n'}},
            {'k', {'u', 'i', 'o', 'j', 'l', ',', 'm'}},
            {'l', {'i', 'o', 'p', 'k', ';', '.', ','}},
            {'z', {'a', 's', 'x'}},
            {'x', {'a', 's', 'd', 'z', 'c'}},
            {'c', {'s', 'd', 'f', 'x', 'v'}},
            {'v', {'d', 'f', 'g', 'c', 'b'}},
            {'b', {'f', 'g', 'h', 'v', 'n'}},
            {'n', {'g', 'h', 'j', 'b', 'm'}},
            {'m', {'h', 'j', 'k', 'n', ','}}
        };
    }

    char get_nearby_key(char c) const {
        c = tolower(c);
        auto it = nearby_keys.find(c);
        if (it != nearby_keys.end() && !it->second.empty()) {
            return it->second[rand() % it->second.size()];
        }
        return c;
    }
};

TypingMistakeSimulator mistake_simulator;

bool initialize_xtest(Display* display) {
    int event_base, error_base, major, minor;
    return XTestQueryExtension(display, &event_base, &error_base, &major, &minor);
}

void send_xtest_key(Display* display, KeyCode keycode, bool press, unsigned int modifiers) {
    if (modifiers != 0) {
        if (modifiers & ShiftMask) {
            KeyCode shift_keycode = XKeysymToKeycode(display, XK_Shift_L);
            if (shift_keycode != 0) {
                XTestFakeKeyEvent(display, shift_keycode, True, CurrentTime);
                XFlush(display);
            }
        }
        if (modifiers & ControlMask) {
            KeyCode ctrl_keycode = XKeysymToKeycode(display, XK_Control_L);
            if (ctrl_keycode != 0) {
                XTestFakeKeyEvent(display, ctrl_keycode, True, CurrentTime);
                XFlush(display);
            }
        }
        if (modifiers & Mod1Mask) {
            KeyCode alt_keycode = XKeysymToKeycode(display, XK_Alt_L);
            if (alt_keycode != 0) {
                XTestFakeKeyEvent(display, alt_keycode, True, CurrentTime);
                XFlush(display);
            }
        }
        if (modifiers & Mod4Mask) {
            KeyCode super_keycode = XKeysymToKeycode(display, XK_Super_L);
            if (super_keycode != 0) {
                XTestFakeKeyEvent(display, super_keycode, True, CurrentTime);
                XFlush(display);
            }
        }
        usleep(5000);
    }

    XTestFakeKeyEvent(display, keycode, press, CurrentTime);
    XFlush(display);

    if (!press && modifiers != 0) {
        usleep(5000);
        if (modifiers & ShiftMask) {
            KeyCode shift_keycode = XKeysymToKeycode(display, XK_Shift_L);
            if (shift_keycode != 0) {
                XTestFakeKeyEvent(display, shift_keycode, False, CurrentTime);
                XFlush(display);
            }
        }
        if (modifiers & ControlMask) {
            KeyCode ctrl_keycode = XKeysymToKeycode(display, XK_Control_L);
            if (ctrl_keycode != 0) {
                XTestFakeKeyEvent(display, ctrl_keycode, False, CurrentTime);
                XFlush(display);
            }
        }
        if (modifiers & Mod1Mask) {
            KeyCode alt_keycode = XKeysymToKeycode(display, XK_Alt_L);
            if (alt_keycode != 0) {
                XTestFakeKeyEvent(display, alt_keycode, False, CurrentTime);
                XFlush(display);
            }
        }
        if (modifiers & Mod4Mask) {
            KeyCode super_keycode = XKeysymToKeycode(display, XK_Super_L);
            if (super_keycode != 0) {
                XTestFakeKeyEvent(display, super_keycode, False, CurrentTime);
                XFlush(display);
            }
        }
    }
}

class SendKeyWorker : public Napi::AsyncWorker {
public:
    SendKeyWorker(Napi::Env env, Napi::Promise::Deferred deferred, std::string key, std::string modifier, std::string display_name)
        : Napi::AsyncWorker(env), deferred(deferred), key(key), modifier(modifier), display_name(display_name) {}

protected:
    void Execute() override {
        Display *display = XOpenDisplay(display_name.empty() ? NULL : display_name.c_str());
        if (!display) {
            SetError("Cannot open display: " + display_name);
            return;
        }

        if (!initialize_xtest(display)) {
            XCloseDisplay(display);
            SetError("XTest extension not available");
            return;
        }

        auto behavior_profile = SessionManager::get_current_profile();

        unsigned int modifiers_state = 0;
        if (!modifier.empty()) {
            std::transform(modifier.begin(), modifier.end(), modifier.begin(), ::tolower);
            if (modifierKeys.count(modifier)) {
                modifiers_state = modifierKeys[modifier];
            } else {
                XCloseDisplay(display);
                SetError("Invalid modifier: " + modifier);
                return;
            }
        }

        std::transform(key.begin(), key.end(), key.begin(), ::tolower);
        KeySym keysym = (specialKeys.count(key)) ? specialKeys[key] : XStringToKeysym(key.c_str());
        if (keysym == NoSymbol) {
            XCloseDisplay(display);
            SetError("Invalid key: " + key);
            return;
        }

        KeyCode keycode = XKeysymToKeycode(display, keysym);
        if (keycode == 0) {
            XCloseDisplay(display);
            SetError("Could not get keycode for key: " + key);
            return;
        }

        int base_delay = behavior_profile->get_base_delay();
        int delay_variation = behavior_profile->get_delay_variation();
        int press_delay = timing_generator.get_pro_gamer_delay(base_delay, delay_variation);
        int release_delay = timing_generator.get_pro_gamer_delay(base_delay - 5, delay_variation - 2);

        if (timing_generator.should_add_micro_delay()) {
            usleep(timing_generator.get_micro_delay() * 1000);
        }

        send_xtest_key(display, keycode, true, modifiers_state);
        XFlush(display);
        usleep(press_delay * 1000);

        send_xtest_key(display, keycode, false, modifiers_state);
        XFlush(display);
        usleep(release_delay * 1000);

        XCloseDisplay(display);
    }

    void OnOK() override {
        deferred.Resolve(Env().Undefined());
    }

    void OnError(const Napi::Error& e) override {
        deferred.Reject(Napi::Error::New(Env(), e.Message()).Value());
    }

private:
    Napi::Promise::Deferred deferred;
    std::string key;
    std::string modifier;
    std::string display_name;
};

class TypeStringWorker : public Napi::AsyncWorker {
public:
    TypeStringWorker(Napi::Env env, Napi::Promise::Deferred deferred,
                     std::string str, bool start_and_end_with_enter,
                     std::string display_name)
        : Napi::AsyncWorker(env), deferred_(deferred), str_(str),
          start_and_end_with_enter_(start_and_end_with_enter), display_name_(display_name) {}

protected:
    void Execute() override {
        Display *display = XOpenDisplay(display_name_.empty() ? NULL : display_name_.c_str());
        if (!display) {
            SetError("Cannot open display: " + display_name_);
            return;
        }

        if (!initialize_xtest(display)) {
            XCloseDisplay(display);
            SetError("XTest extension not available");
            return;
        }

        auto behavior_profile = SessionManager::get_current_profile();

        auto send_enter_key = [&](Display* d) {
            KeySym ks = XK_Return;
            KeyCode kc = XKeysymToKeycode(d, ks);
            if (kc != 0) {
                send_xtest_key(d, kc, true, 0);
                XFlush(d);
                usleep(timing_generator.get_pro_gamer_delay(25, 10) * 1000);
                send_xtest_key(d, kc, false, 0);
                XFlush(d);
                usleep(50 * 1000);
            }
        };

        if (start_and_end_with_enter_) {
            send_enter_key(display);
            usleep(timing_generator.get_pro_gamer_delay(40, 15) * 1000);
        }

        for (size_t i = 0; i < str_.length(); i++) {
            char c = str_[i];

            if (timing_generator.should_add_micro_delay()) {
                usleep(timing_generator.get_micro_delay() * 1000);
            }

            KeySym keysym = NoSymbol;
            unsigned int required_modifier = 0;

            if (c == ' ') {
                keysym = XK_space;
            } else if (isalpha(c)) {
                if (isupper(c)) {
                    keysym = XK_a + (tolower(c) - 'a');
                    required_modifier = ShiftMask;
                } else {
                    keysym = XK_a + (c - 'a');
                }
            } else if (isdigit(c)) {
                keysym = XK_0 + (c - '0');
            } else {
                switch (c) {
                    case '!': keysym = XK_1; required_modifier = ShiftMask; break;
                    case '@': keysym = XK_2; required_modifier = ShiftMask; break;
                    case '#': keysym = XK_3; required_modifier = ShiftMask; break;
                    case '$': keysym = XK_4; required_modifier = ShiftMask; break;
                    case '%': keysym = XK_5; required_modifier = ShiftMask; break;
                    case '^': keysym = XK_6; required_modifier = ShiftMask; break;
                    case '&': keysym = XK_7; required_modifier = ShiftMask; break;
                    case '*': keysym = XK_8; required_modifier = ShiftMask; break;
                    case '(': keysym = XK_9; required_modifier = ShiftMask; break;
                    case ')': keysym = XK_0; required_modifier = ShiftMask; break;
                    case '-': keysym = XK_minus; break;
                    case '_': keysym = XK_minus; required_modifier = ShiftMask; break;
                    case '=': keysym = XK_equal; break;
                    case '+': keysym = XK_equal; required_modifier = ShiftMask; break;
                    case '[': keysym = XK_bracketleft; break;
                    case ']': keysym = XK_bracketright; break;
                    case '{': keysym = XK_bracketleft; required_modifier = ShiftMask; break;
                    case '}': keysym = XK_bracketright; required_modifier = ShiftMask; break;
                    case ';': keysym = XK_semicolon; break;
                    case ':': keysym = XK_semicolon; required_modifier = ShiftMask; break;
                    case '\'': keysym = XK_apostrophe; break;
                    case '"': keysym = XK_apostrophe; required_modifier = ShiftMask; break;
                    case ',': keysym = XK_comma; break;
                    case '<': keysym = XK_comma; required_modifier = ShiftMask; break;
                    case '.': keysym = XK_period; break;
                    case '>': keysym = XK_period; required_modifier = ShiftMask; break;
                    case '/': keysym = XK_slash; break;
                    case '?': keysym = XK_slash; required_modifier = ShiftMask; break;
                    case '\\': keysym = XK_backslash; break;
                    case '|': keysym = XK_backslash; required_modifier = ShiftMask; break;
                    case '`': keysym = XK_grave; break;
                    case '~': keysym = XK_grave; required_modifier = ShiftMask; break;
                    default:
                        keysym = XStringToKeysym(std::string(1, c).c_str());
                        if (keysym == NoSymbol) {
                            keysym = XStringToKeysym(std::string(1, tolower(c)).c_str());
                            if (isupper(c)) {
                                required_modifier = ShiftMask;
                            }
                        }
                        break;
                }
            }

            if (keysym == NoSymbol) continue;

            KeyCode keycode = XKeysymToKeycode(display, keysym);
            if (keycode == 0) continue;

            int press_delay = timing_generator.get_pro_gamer_delay(15, 8);
            int release_delay = timing_generator.get_pro_gamer_delay(12, 5);

            send_xtest_key(display, keycode, true, required_modifier);
            XFlush(display);
            usleep(press_delay * 1000);

            send_xtest_key(display, keycode, false, required_modifier);
            XFlush(display);
            usleep(release_delay * 1000);
        }

        if (start_and_end_with_enter_) {
            usleep(timing_generator.get_pro_gamer_delay(50, 20) * 1000);
            send_enter_key(display);
        }

        XSync(display, False);
        usleep(100 * 1000);
        XCloseDisplay(display);
    }

    void OnOK() override {
        deferred_.Resolve(Napi::Boolean::New(Env(), true));
    }

    void OnError(const Napi::Error& e) override {
        deferred_.Reject(Napi::Error::New(Env(), e.Message()).Value());
    }

private:
    Napi::Promise::Deferred deferred_;
    std::string str_;
    bool start_and_end_with_enter_;
    std::string display_name_;
};

class TypeStringArrayWorker : public Napi::AsyncWorker {
public:
    TypeStringArrayWorker(Napi::Env env, Napi::Promise::Deferred deferred,
                         std::vector<std::string> strings, bool start_and_end_with_enter,
                         std::string display_name)
        : Napi::AsyncWorker(env), deferred_(deferred), strings_(strings),
          start_and_end_with_enter_(start_and_end_with_enter), display_name_(display_name) {}

protected:
    void Execute() override {
        Display *display = XOpenDisplay(display_name_.empty() ? NULL : display_name_.c_str());
        if (!display) {
            SetError("Cannot open display: " + display_name_);
            return;
        }

        if (!initialize_xtest(display)) {
            XCloseDisplay(display);
            SetError("XTest extension not available");
            return;
        }

        // REMOVED: Unused variables to fix compiler warning
        // auto behavior_profile = SessionManager::get_current_profile();
        // int base_delay = behavior_profile->get_base_delay();
        // int delay_variation = behavior_profile->get_delay_variation();

        auto send_enter_key = [&](Display* d) {
            KeySym ks = XK_Return;
            KeyCode kc = XKeysymToKeycode(d, ks);
            if (kc != 0) {
                send_xtest_key(d, kc, true, 0);
                XFlush(d);
                usleep(timing_generator.get_pro_gamer_delay(25, 10) * 1000);
                send_xtest_key(d, kc, false, 0);
                XFlush(d);
                usleep(50 * 1000);
            }
        };

        for (size_t str_idx = 0; str_idx < strings_.size(); str_idx++) {
            const std::string& str = strings_[str_idx];

            if (start_and_end_with_enter_) {
                send_enter_key(display);
                usleep(timing_generator.get_pro_gamer_delay(40, 15) * 1000);
            }

            for (size_t i = 0; i < str.length(); i++) {
                char c = str[i];

                if (timing_generator.should_add_micro_delay()) {
                    usleep(timing_generator.get_micro_delay() * 1000);
                }

                KeySym keysym = NoSymbol;
                unsigned int required_modifier = 0;

                if (c == ' ') {
                    keysym = XK_space;
                } else if (isalpha(c)) {
                    if (isupper(c)) {
                        keysym = XK_a + (tolower(c) - 'a');
                        required_modifier = ShiftMask;
                    } else {
                        keysym = XK_a + (c - 'a');
                    }
                } else if (isdigit(c)) {
                    keysym = XK_0 + (c - '0');
                } else {
                    switch (c) {
                        case '!': keysym = XK_1; required_modifier = ShiftMask; break;
                        case '@': keysym = XK_2; required_modifier = ShiftMask; break;
                        case '#': keysym = XK_3; required_modifier = ShiftMask; break;
                        case '$': keysym = XK_4; required_modifier = ShiftMask; break;
                        case '%': keysym = XK_5; required_modifier = ShiftMask; break;
                        case '^': keysym = XK_6; required_modifier = ShiftMask; break;
                        case '&': keysym = XK_7; required_modifier = ShiftMask; break;
                        case '*': keysym = XK_8; required_modifier = ShiftMask; break;
                        case '(': keysym = XK_9; required_modifier = ShiftMask; break;
                        case ')': keysym = XK_0; required_modifier = ShiftMask; break;
                        case '-': keysym = XK_minus; break;
                        case '_': keysym = XK_minus; required_modifier = ShiftMask; break;
                        case '=': keysym = XK_equal; break;
                        case '+': keysym = XK_equal; required_modifier = ShiftMask; break;
                        case '[': keysym = XK_bracketleft; break;
                        case ']': keysym = XK_bracketright; break;
                        case '{': keysym = XK_bracketleft; required_modifier = ShiftMask; break;
                        case '}': keysym = XK_bracketright; required_modifier = ShiftMask; break;
                        case ';': keysym = XK_semicolon; break;
                        case ':': keysym = XK_semicolon; required_modifier = ShiftMask; break;
                        case '\'': keysym = XK_apostrophe; break;
                        case '"': keysym = XK_apostrophe; required_modifier = ShiftMask; break;
                        case ',': keysym = XK_comma; break;
                        case '<': keysym = XK_comma; required_modifier = ShiftMask; break;
                        case '.': keysym = XK_period; break;
                        case '>': keysym = XK_period; required_modifier = ShiftMask; break;
                        case '/': keysym = XK_slash; break;
                        case '?': keysym = XK_slash; required_modifier = ShiftMask; break;
                        case '\\': keysym = XK_backslash; break;
                        case '|': keysym = XK_backslash; required_modifier = ShiftMask; break;
                        case '`': keysym = XK_grave; break;
                        case '~': keysym = XK_grave; required_modifier = ShiftMask; break;
                        default:
                            keysym = XStringToKeysym(std::string(1, c).c_str());
                            if (keysym == NoSymbol) {
                                keysym = XStringToKeysym(std::string(1, tolower(c)).c_str());
                                if (isupper(c)) {
                                    required_modifier = ShiftMask;
                                }
                            }
                            break;
                    }
                }

                if (keysym == NoSymbol) continue;

                KeyCode keycode = XKeysymToKeycode(display, keysym);
                if (keycode == 0) continue;

                int press_delay = timing_generator.get_pro_gamer_delay(15, 8);
                int release_delay = timing_generator.get_pro_gamer_delay(12, 5);

                send_xtest_key(display, keycode, true, required_modifier);
                XFlush(display);
                usleep(press_delay * 1000);

                send_xtest_key(display, keycode, false, required_modifier);
                XFlush(display);
                usleep(release_delay * 1000);
            }

            if (start_and_end_with_enter_) {
                usleep(timing_generator.get_pro_gamer_delay(50, 20) * 1000);
                send_enter_key(display);
            }

            if (str_idx < strings_.size() - 1) {
                usleep(timing_generator.get_pro_gamer_delay(200, 50) * 1000);
            }
        }

        XSync(display, False);
        usleep(100 * 1000);
        XCloseDisplay(display);
    }

    void OnOK() override {
        deferred_.Resolve(Napi::Boolean::New(Env(), true));
    }

    void OnError(const Napi::Error& e) override {
        deferred_.Reject(Napi::Error::New(Env(), e.Message()).Value());
    }

private:
    Napi::Promise::Deferred deferred_;
    std::vector<std::string> strings_;
    bool start_and_end_with_enter_;
    std::string display_name_;
};

class RotateWorker : public Napi::AsyncWorker {
public:
    RotateWorker(Napi::Env env, Napi::Promise::Deferred deferred, char direction, std::string display_name)
        : Napi::AsyncWorker(env), deferred(deferred), direction(direction), display_name(display_name) {}

protected:
    void Execute() override {
        Display *display = XOpenDisplay(display_name.empty() ? NULL : display_name.c_str());
        if (!display) {
            SetError("Cannot open display: " + display_name);
            return;
        }

        if (!initialize_xtest(display)) {
            XCloseDisplay(display);
            SetError("XTest extension not available");
            return;
        }

        auto behavior_profile = SessionManager::get_current_profile();

        std::vector<KeySym> key_sequence;
        key_sequence.push_back(XK_Down);
        bool go_left = (rand() % 2 == 0);
        key_sequence.push_back(go_left ? XK_Left : XK_Right);
        key_sequence.push_back(go_left ? XK_Right : XK_Left);
        key_sequence.push_back(XK_Up);
        key_sequence.push_back(XK_Down);

        if (direction != '\0') {
            auto it = directionKeys.find(direction);
            if (it != directionKeys.end()) {
                key_sequence.back() = it->second;
            }
        }

        KeyCode ctrl_keycode = XKeysymToKeycode(display, XK_Control_L);
        if (ctrl_keycode == 0) {
            XCloseDisplay(display);
            SetError("Could not find keycode for Control_L key.");
            return;
        }

        send_xtest_key(display, ctrl_keycode, true, 0);
        XFlush(display);
        usleep(timing_generator.get_pro_gamer_delay(10, 5) * 1000);

        for (size_t i = 0; i < key_sequence.size(); i++) {
            KeySym keysym = key_sequence[i];
            KeyCode keycode = XKeysymToKeycode(display, keysym);
            if (keycode == 0) continue;

            int press_delay, release_delay;

            if (i == 0) {
                press_delay = timing_generator.get_pro_gamer_delay(25, 12);
                release_delay = timing_generator.get_pro_gamer_delay(20, 10);
            } else if (i == key_sequence.size() - 1) {
                press_delay = timing_generator.get_pro_gamer_delay(20, 10);
                release_delay = timing_generator.get_pro_gamer_delay(15, 8);
            } else {
                press_delay = timing_generator.get_pro_gamer_delay(22, 11);
                release_delay = timing_generator.get_pro_gamer_delay(18, 9);
            }

            if (timing_generator.should_add_micro_delay()) {
                usleep(timing_generator.get_micro_delay() * 1000);
            }

            send_xtest_key(display, keycode, true, ControlMask);
            XFlush(display);
            usleep(press_delay * 1000);

            send_xtest_key(display, keycode, false, ControlMask);
            XFlush(display);
            usleep(release_delay * 1000);
        }

        usleep(timing_generator.get_pro_gamer_delay(15, 8) * 1000);
        send_xtest_key(display, ctrl_keycode, false, 0);
        XFlush(display);

        XCloseDisplay(display);
    }

    void OnOK() override {
        deferred.Resolve(Env().Undefined());
    }

    void OnError(const Napi::Error& e) override {
        deferred.Reject(Napi::Error::New(Env(), e.Message()).Value());
    }

private:
    Napi::Promise::Deferred deferred;
    char direction;
    std::string display_name;
};

class KeyDownWorker : public Napi::AsyncWorker {
public:
    KeyDownWorker(Napi::Env env, Napi::Promise::Deferred deferred, std::string key, std::string modifier, std::string display_name)
        : Napi::AsyncWorker(env), deferred(deferred), key(key), modifier(modifier), display_name(display_name) {}

protected:
    void Execute() override {
        Display *display = XOpenDisplay(display_name.empty() ? NULL : display_name.c_str());
        if (!display) {
            SetError("Cannot open display: " + display_name);
            return;
        }

        if (!initialize_xtest(display)) {
            XCloseDisplay(display);
            SetError("XTest extension not available");
            return;
        }

        auto behavior_profile = SessionManager::get_current_profile();

        unsigned int modifiers_state = 0;
        if (!modifier.empty()) {
            std::transform(modifier.begin(), modifier.end(), modifier.begin(), ::tolower);
            if (modifierKeys.count(modifier)) {
                modifiers_state = modifierKeys[modifier];
            } else {
                XCloseDisplay(display);
                SetError("Invalid modifier: " + modifier);
                return;
            }
        }

        std::transform(key.begin(), key.end(), key.begin(), ::tolower);
        KeySym keysym = (specialKeys.count(key)) ? specialKeys[key] : XStringToKeysym(key.c_str());
        if (keysym == NoSymbol) {
            XCloseDisplay(display);
            SetError("Invalid key: " + key);
            return;
        }

        KeyCode keycode = XKeysymToKeycode(display, keysym);
        if (keycode == 0) {
            XCloseDisplay(display);
            SetError("Could not get keycode for key: " + key);
            return;
        }

        if (timing_generator.should_add_micro_delay()) {
            usleep(timing_generator.get_micro_delay() * 1000);
        }

        send_xtest_key(display, keycode, true, modifiers_state);
        XFlush(display);

        XCloseDisplay(display);
    }

    void OnOK() override {
        deferred.Resolve(Env().Undefined());
    }

    void OnError(const Napi::Error& e) override {
        deferred.Reject(Napi::Error::New(Env(), e.Message()).Value());
    }

private:
    Napi::Promise::Deferred deferred;
    std::string key;
    std::string modifier;
    std::string display_name;
};

class KeyUpWorker : public Napi::AsyncWorker {
public:
    KeyUpWorker(Napi::Env env, Napi::Promise::Deferred deferred, std::string key, std::string modifier, std::string display_name)
        : Napi::AsyncWorker(env), deferred(deferred), key(key), modifier(modifier), display_name(display_name) {}

protected:
    void Execute() override {
        Display *display = XOpenDisplay(display_name.empty() ? NULL : display_name.c_str());
        if (!display) {
            SetError("Cannot open display: " + display_name);
            return;
        }

        if (!initialize_xtest(display)) {
            XCloseDisplay(display);
            SetError("XTest extension not available");
            return;
        }

        auto behavior_profile = SessionManager::get_current_profile();

        unsigned int modifiers_state = 0;
        if (!modifier.empty()) {
            std::transform(modifier.begin(), modifier.end(), modifier.begin(), ::tolower);
            if (modifierKeys.count(modifier)) {
                modifiers_state = modifierKeys[modifier];
            } else {
                XCloseDisplay(display);
                SetError("Invalid modifier: " + modifier);
                return;
            }
        }

        std::transform(key.begin(), key.end(), key.begin(), ::tolower);
        KeySym keysym = (specialKeys.count(key)) ? specialKeys[key] : XStringToKeysym(key.c_str());
        if (keysym == NoSymbol) {
            XCloseDisplay(display);
            SetError("Invalid key: " + key);
            return;
        }

        KeyCode keycode = XKeysymToKeycode(display, keysym);
        if (keycode == 0) {
            XCloseDisplay(display);
            SetError("Could not get keycode for key: " + key);
            return;
        }

        if (timing_generator.should_add_micro_delay()) {
            usleep(timing_generator.get_micro_delay() * 1000);
        }

        send_xtest_key(display, keycode, false, modifiers_state);
        XFlush(display);

        XCloseDisplay(display);
    }

    void OnOK() override {
        deferred.Resolve(Env().Undefined());
    }

    void OnError(const Napi::Error& e) override {
        deferred.Reject(Napi::Error::New(Env(), e.Message()).Value());
    }

private:
    Napi::Promise::Deferred deferred;
    std::string key;
    std::string modifier;
    std::string display_name;
};

Napi::Value SendKeyAsync(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    auto deferred = Napi::Promise::Deferred::New(env);
    if (info.Length() < 2 || !info[0].IsString() || !info[1].IsString()) {
        deferred.Reject(Napi::TypeError::New(env, "sendKey(key, display, [modifier]) requires key and display.").Value());
        return deferred.Promise();
    }
    std::string key = info[0].As<Napi::String>().Utf8Value();
    std::string display_name = info[1].As<Napi::String>().Utf8Value();
    std::string modifier = "";
    if (info.Length() > 2 && info[2].IsString()) {
        modifier = info[2].As<Napi::String>().Utf8Value();
    }
    SendKeyWorker* worker = new SendKeyWorker(env, deferred, key, modifier, display_name);
    worker->Queue();
    return deferred.Promise();
}

Napi::Value TypeStringAsync(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    auto deferred = Napi::Promise::Deferred::New(env);
    if (info.Length() < 2 || !info[0].IsString() || !info[1].IsString()) {
        deferred.Reject(Napi::TypeError::New(env, "type(text, display, [startAndEndWithEnter]) requires text and display.").Value());
        return deferred.Promise();
    }
    std::string str = info[0].As<Napi::String>().Utf8Value();
    std::string display_name = info[1].As<Napi::String>().Utf8Value();
    bool start_and_end_with_enter = false;
    if (info.Length() > 2 && info[2].IsBoolean()) {
        start_and_end_with_enter = info[2].As<Napi::Boolean>().Value();
    }
    TypeStringWorker* worker = new TypeStringWorker(env, deferred, str, start_and_end_with_enter, display_name);
    worker->Queue();
    return deferred.Promise();
}

Napi::Value TypeStringArrayAsync(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    auto deferred = Napi::Promise::Deferred::New(env);

    if (info.Length() < 2) {
        deferred.Reject(Napi::TypeError::New(env, "typeArray(strings, display, [startAndEndWithEnter]) requires strings array and display.").Value());
        return deferred.Promise();
    }

    std::vector<std::string> strings;

    if (info[0].IsArray()) {
        Napi::Array arr = info[0].As<Napi::Array>();
        uint32_t len = arr.Length();
        for (uint32_t i = 0; i < len; i++) {
            Napi::Value val = arr[i];
            if (val.IsString()) {
                strings.push_back(val.As<Napi::String>().Utf8Value());
            }
        }
    } else if (info[0].IsString()) {
        strings.push_back(info[0].As<Napi::String>().Utf8Value());
    } else {
        deferred.Reject(Napi::TypeError::New(env, "First argument must be string or array of strings").Value());
        return deferred.Promise();
    }

    std::string display_name = info[1].As<Napi::String>().Utf8Value();
    bool start_and_end_with_enter = true;
    if (info.Length() > 2 && info[2].IsBoolean()) {
        start_and_end_with_enter = info[2].As<Napi::Boolean>().Value();
    }

    TypeStringArrayWorker* worker = new TypeStringArrayWorker(env, deferred, strings, start_and_end_with_enter, display_name);
    worker->Queue();
    return deferred.Promise();
}
Napi::Value RotateAsync(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    auto deferred = Napi::Promise::Deferred::New(env);
    if (info.Length() < 1 || !info[0].IsString()) {
        deferred.Reject(Napi::TypeError::New(env, "rotate(display, [direction]) requires display.").Value());
        return deferred.Promise();
    }
    std::string display_name = info[0].As<Napi::String>().Utf8Value();
    char direction_char = '\0';
    if (info.Length() > 1 && info[1].IsString()) {
        std::string direction_str = info[1].As<Napi::String>().Utf8Value();
        if (direction_str.length() == 1) {
            char c = tolower(direction_str[0]);
            if (directionKeys.count(c)) {
                direction_char = c;
            }
        }
    }
    RotateWorker* worker = new RotateWorker(env, deferred, direction_char, display_name);
    worker->Queue();
    return deferred.Promise();
}

Napi::Value KeyDownAsync(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    auto deferred = Napi::Promise::Deferred::New(env);
    if (info.Length() < 2 || !info[0].IsString() || !info[1].IsString()) {
        deferred.Reject(Napi::TypeError::New(env, "keyDown(key, display, [modifier]) requires key and display.").Value());
        return deferred.Promise();
    }
    std::string key = info[0].As<Napi::String>().Utf8Value();
    std::string display_name = info[1].As<Napi::String>().Utf8Value();
    std::string modifier = "";
    if (info.Length() > 2 && info[2].IsString()) {
        modifier = info[2].As<Napi::String>().Utf8Value();
    }
    KeyDownWorker* worker = new KeyDownWorker(env, deferred, key, modifier, display_name);
    worker->Queue();
    return deferred.Promise();
}

Napi::Value KeyUpAsync(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    auto deferred = Napi::Promise::Deferred::New(env);
    if (info.Length() < 2 || !info[0].IsString() || !info[1].IsString()) {
        deferred.Reject(Napi::TypeError::New(env, "keyUp(key, display, [modifier]) requires key and display.").Value());
        return deferred.Promise();
    }
    std::string key = info[0].As<Napi::String>().Utf8Value();
    std::string display_name = info[1].As<Napi::String>().Utf8Value();
    std::string modifier = "";
    if (info.Length() > 2 && info[2].IsString()) {
        modifier = info[2].As<Napi::String>().Utf8Value();
    }
    KeyUpWorker* worker = new KeyUpWorker(env, deferred, key, modifier, display_name);
    worker->Queue();
    return deferred.Promise();
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
    if (!XInitThreads()) {
      std::cerr << "keypress-native: Warning - XInitThreads() failed." << std::endl;
    }

    std::random_device rd;
    std::seed_seq seq{rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd()};
    timing_generator = HumanTimingGenerator();

    SessionManager::new_session();

    srand(time(NULL));

    exports.Set("sendKey", Napi::Function::New(env, SendKeyAsync));
    exports.Set("rotate", Napi::Function::New(env, RotateAsync));
    exports.Set("type", Napi::Function::New(env, TypeStringAsync));
    exports.Set("typeArray", Napi::Function::New(env, TypeStringArrayAsync));
    exports.Set("keyDown", Napi::Function::New(env, KeyDownAsync));
    exports.Set("keyUp", Napi::Function::New(env, KeyUpAsync));

    return exports;
}

NODE_API_MODULE(keypress, Init)
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/keypress/wrapper.js
//start file
const keypressNative = require('./build/Release/keypress.node');
module.exports = keypressNative;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/minimapMatcher/src/minimapMatcher.cc
//start file
// minimapMatcher.cc (MODIFIED FOR 4-BIT PACKING)

#include "minimapMatcher.h"
#include "positionFinderWorker.h"
#include <iostream>

// --- Helper to convert Napi::Value to std::vector<uint8_t> ---
std::vector<uint8_t> NapiBufferToVector(const Napi::Buffer<uint8_t>& buffer) {
    return std::vector<uint8_t>(buffer.Data(), buffer.Data() + buffer.Length());
}

// --- Static member initialization ---
Napi::FunctionReference MinimapMatcher::constructor;

// --- MinimapMatcher Implementation ---

Napi::Object MinimapMatcher::Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "MinimapMatcher", {
        InstanceAccessor("isLoaded", &MinimapMatcher::IsLoadedGetter, &MinimapMatcher::IsLoadedSetter),
        InstanceAccessor("palette", &MinimapMatcher::PaletteGetter, &MinimapMatcher::PaletteSetter),
        InstanceAccessor("landmarkData", &MinimapMatcher::LandmarkDataGetter, &MinimapMatcher::LandmarkDataSetter),
        InstanceMethod("findPosition", &MinimapMatcher::FindPosition),
        InstanceMethod("cancelSearch", &MinimapMatcher::CancelSearch)
    });

    constructor = Napi::Persistent(func);
    exports.Set("MinimapMatcher", func);
    return exports;
}

MinimapMatcher::MinimapMatcher(const Napi::CallbackInfo& info) : Napi::ObjectWrap<MinimapMatcher>(info) {
    Napi::Object constants = info[0].As<Napi::Object>();
    LANDMARK_SIZE = constants.Get("LANDMARK_SIZE").As<Napi::Number>().Int32Value();
    // This will now receive 25 from JavaScript
    LANDMARK_PATTERN_BYTES = constants.Get("LANDMARK_PATTERN_BYTES").As<Napi::Number>().Int32Value();

    Napi::Array excludedColorsArray = constants.Get("EXCLUDED_COLORS_RGB").As<Napi::Array>();
    for (uint32_t i = 0; i < excludedColorsArray.Length(); ++i) {
        EXCLUDED_COLORS_RGB.push_back(Napi::Persistent(excludedColorsArray.Get(i).As<Napi::Object>()));
    }

    this->liveNoiseIndices = {0, 14};
    this->isLoaded = false;
    this->activeWorker = nullptr;
}

// --- Accessors (No Changes) ---
void MinimapMatcher::IsLoadedSetter(const Napi::CallbackInfo& info, const Napi::Value& value) { this->isLoaded = value.As<Napi::Boolean>().Value(); }
Napi::Value MinimapMatcher::IsLoadedGetter(const Napi::CallbackInfo& info) { return Napi::Boolean::New(info.Env(), this->isLoaded); }
void MinimapMatcher::PaletteSetter(const Napi::CallbackInfo& info, const Napi::Value& value) { this->palette = Napi::Persistent(value.As<Napi::Array>()); }
Napi::Value MinimapMatcher::PaletteGetter(const Napi::CallbackInfo& info) { return this->palette.Value(); }
Napi::Value MinimapMatcher::LandmarkDataGetter(const Napi::CallbackInfo& info) { return Napi::String::New(info.Env(), "Landmark data is stored natively."); }

// --- LandmarkDataSetter (No Changes) ---
// This function is already generic enough. It reads a buffer of LANDMARK_PATTERN_BYTES
// and uses it as a key, so it works perfectly with the new 25-byte patterns.
void MinimapMatcher::LandmarkDataSetter(const Napi::CallbackInfo& info, const Napi::Value& value) {
    Napi::Object obj = value.As<Napi::Object>();
    Napi::Array keys = obj.GetPropertyNames();
    this->landmarkData.clear();
    for (uint32_t i = 0; i < keys.Length(); ++i) {
        Napi::Value key_value = keys.Get(i);
        std::string key_str = key_value.As<Napi::String>().Utf8Value();
        int z_level = std::stoi(key_str);
        Napi::Array landmarksArray = obj.Get(key_value).As<Napi::Array>();

        LandmarkMap nativeLandmarkMap;
        for (uint32_t j = 0; j < landmarksArray.Length(); ++j) {
            Napi::Object lm_js = landmarksArray.Get(j).As<Napi::Object>();
            Napi::Buffer<uint8_t> pattern_buffer = lm_js.Get("pattern").As<Napi::Buffer<uint8_t>>();

            LandmarkPattern pattern_key(
                reinterpret_cast<const char*>(pattern_buffer.Data()),
                pattern_buffer.Length()
            );

            NativeLandmark nativeLm;
            nativeLm.x = lm_js.Get("x").As<Napi::Number>().Int32Value();
            nativeLm.y = lm_js.Get("y").As<Napi::Number>().Int32Value();

            nativeLandmarkMap[pattern_key] = nativeLm;
        }
        this->landmarkData[z_level] = std::move(nativeLandmarkMap);
    }
}

// --- FindPosition & CancelSearch (No Changes) ---
Napi::Value MinimapMatcher::FindPosition(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (this->activeWorker != nullptr) {
        this->activeWorker->Cancel();
    }
    Napi::Buffer<uint8_t> unpackedMinimapBuffer = info[0].As<Napi::Buffer<uint8_t>>();
    int minimapWidth = info[1].As<Napi::Number>().Int32Value();
    int minimapHeight = info[2].As<Napi::Number>().Int32Value();
    int targetZ = info[3].As<Napi::Number>().Int32Value();
    if (!this->isLoaded) {
         Napi::Promise::Deferred deferred = Napi::Promise::Deferred::New(env);
         deferred.Reject(Napi::Error::New(env, "Matcher not loaded").Value());
         return deferred.Promise();
    }
    std::vector<uint8_t> unpackedMinimapVec = NapiBufferToVector(unpackedMinimapBuffer);
    PositionFinderWorker* worker = new PositionFinderWorker(env, this, unpackedMinimapVec, minimapWidth, minimapHeight, targetZ);
    worker->Queue();
    return worker->GetPromise();
}

Napi::Value MinimapMatcher::CancelSearch(const Napi::CallbackInfo& info) {
    if (this->activeWorker != nullptr) {
        this->activeWorker->Cancel();
    }
    return info.Env().Undefined();
}

// --- PositionFinderWorker Implementation ---

PositionFinderWorker::PositionFinderWorker(
    Napi::Env env,
    MinimapMatcher* matcher,
    const std::vector<uint8_t>& unpackedMinimap,
    int minimapWidth,
    int minimapHeight,
    int targetZ
) : Napi::AsyncWorker(env),
    matcherInstance(matcher),
    unpackedMinimap(unpackedMinimap),
    minimapWidth(minimapWidth),
    minimapHeight(minimapHeight),
    targetZ(targetZ),
    deferred(Napi::Promise::Deferred::New(env)) {
    this->matcherInstance->activeWorker = this;
}

PositionFinderWorker::~PositionFinderWorker() {
    if (this->matcherInstance->activeWorker == this) {
        this->matcherInstance->activeWorker = nullptr;
    }
}

void PositionFinderWorker::Cancel() { this->wasCancelled = true; }
Napi::Promise PositionFinderWorker::GetPromise() { return deferred.Promise(); }
void PositionFinderWorker::OnError(const Napi::Error& e) {
    Napi::HandleScope scope(Env());
    deferred.Reject(e.Value());
}

// --- THE CORE CHANGE IS IN THIS METHOD ---
void PositionFinderWorker::Execute() {
    auto start_time = std::chrono::high_resolution_clock::now();

    auto z_it = this->matcherInstance->landmarkData.find(targetZ);
    if (z_it == this->matcherInstance->landmarkData.end() || z_it->second.empty()) {
        this->searchMethod = "fallback_no_landmarks";
        auto end_time = std::chrono::high_resolution_clock::now();
        this->durationMs = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time).count() / 1000.0;
        return;
    }

    const auto& landmarkMapForZ = z_it->second;
    this->searchMethod = "v2.1";
    int halfLandmark = this->matcherInstance->LANDMARK_SIZE / 2;
    const int patternPixelCount = this->matcherInstance->LANDMARK_SIZE * this->matcherInstance->LANDMARK_SIZE; // 49

    // Pre-allocate the string for our packed probe pattern (25 bytes).
    MinimapMatcher::LandmarkPattern probePattern(this->matcherInstance->LANDMARK_PATTERN_BYTES, '\0');
    char* probePatternData = probePattern.data();

    for (int y = halfLandmark; y < minimapHeight - halfLandmark; ++y) {
        if (this->wasCancelled) { return; }
        for (int x = halfLandmark; x < minimapWidth - halfLandmark; ++x) {
            bool isClean = true;

            // --- NEW: Pack the live 7x7 minimap area into the 25-byte probePattern ---
            for (int i = 0; i < patternPixelCount; ++i) {
                int my = i / this->matcherInstance->LANDMARK_SIZE;
                int mx = i % this->matcherInstance->LANDMARK_SIZE;

                uint8_t liveIndex = unpackedMinimap[(y - halfLandmark + my) * minimapWidth + (x - halfLandmark + mx)];

                if (this->matcherInstance->liveNoiseIndices.count(liveIndex)) {
                    isClean = false;
                    break;
                }

                // Pack two 4-bit palette indices into one byte
                int byteIndex = i / 2;
                if (i % 2 == 0) {
                    // First pixel goes into the high 4 bits
                    probePatternData[byteIndex] = static_cast<char>(liveIndex << 4);
                } else {
                    // Second pixel goes into the low 4 bits
                    probePatternData[byteIndex] |= static_cast<char>(liveIndex);
                }
            }

            if (isClean) {
                // This is now a lookup using the 25-byte packed key
                auto lm_it = landmarkMapForZ.find(probePattern);
                if (lm_it != landmarkMapForZ.end()) {
                    const NativeLandmark& foundLandmark = lm_it->second;

                    this->resultPosition.found = true;
                    int mapViewX = foundLandmark.x - x;
                    int mapViewY = foundLandmark.y - y;
                    this->resultPosition.x = mapViewX + (minimapWidth / 2);
                    this->resultPosition.y = mapViewY + (minimapHeight / 2);
                    this->resultPosition.z = targetZ;
                    this->resultPosition.mapViewX = mapViewX;
                    this->resultPosition.mapViewY = mapViewY;

                    auto end_time = std::chrono::high_resolution_clock::now();
                    this->durationMs = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time).count() / 1000.0;
                    return; // Position found, exit immediately.
                }
            }
        }
    }

    this->searchMethod = "fallback_no_match";
    auto end_time = std::chrono::high_resolution_clock::now();
    this->durationMs = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time).count() / 1000.0;
}

// --- OnOK (No Changes) ---
void PositionFinderWorker::OnOK() {
    Napi::Env env = Env();
    Napi::HandleScope scope(env);
    if (this->wasCancelled) {
        deferred.Reject(Napi::Error::New(env, "Search cancelled").Value());
        return;
    }
    Napi::Object performance = Napi::Object::New(env);
    performance.Set("totalTimeMs", Napi::Number::New(env, this->durationMs));
    performance.Set("method", Napi::String::New(env, this->searchMethod));
    Napi::Object result = Napi::Object::New(env);
    result.Set("performance", performance);
    if (this->resultPosition.found) {
        Napi::Object position = Napi::Object::New(env);
        position.Set("x", Napi::Number::New(env, this->resultPosition.x));
        position.Set("y", Napi::Number::New(env, this->resultPosition.y));
        position.Set("z", Napi::Number::New(env, this->resultPosition.z));
        result.Set("position", position);
        result.Set("mapViewX", Napi::Number::New(env, this->resultPosition.mapViewX));
        result.Set("mapViewY", Napi::Number::New(env, this->resultPosition.mapViewY));
    } else {
        result.Set("position", env.Null());
    }
    deferred.Resolve(result);
}

// --- Module Registration (No Changes) ---
Napi::Object Init(Napi::Env env, Napi::Object exports) {
    MinimapMatcher::Init(env, exports);
    return exports;
}

NODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/minimapMatcher/src/minimapMatcher.h
//start file
// minimapMatcher.h

#ifndef MINIMAP_MATCHER_H
#define MINIMAP_MATCHER_H

#include <napi.h>
#include <vector>
#include <string>        // <--- ADDED
#include <set>
#include <map>
#include <unordered_map> // <--- ADDED
#include <atomic>

// --- Forward Declarations ---
// We tell the compiler these classes exist without defining them yet.
class PositionFinderWorker;

// --- Native Data Structures ---
struct NativeLandmark {
    int x;
    int y;
};

// --- The Main MinimapMatcher Class Declaration ---
class MinimapMatcher : public Napi::ObjectWrap<MinimapMatcher> {
public:
    // --- Static Methods ---
    static Napi::Object Init(Napi::Env env, Napi::Object exports);
    static Napi::FunctionReference constructor;

    // --- Constructor ---
    MinimapMatcher(const Napi::CallbackInfo& info);

    // --- Public Members (for worker access) ---
    int LANDMARK_SIZE;
    int LANDMARK_PATTERN_BYTES;
    std::set<int> liveNoiseIndices;

    // --- NEW: Type aliases for clarity and easy modification ---
    using LandmarkPattern = std::string;
    using LandmarkMap = std::unordered_map<LandmarkPattern, NativeLandmark>;

    // --- CHANGED: Use the new, faster unordered_map ---
    std::map<int, LandmarkMap> landmarkData;

    PositionFinderWorker* activeWorker; // Pointer to an incomplete type is allowed

private:
    // --- Instance Methods ---
    Napi::Value FindPosition(const Napi::CallbackInfo& info);
    Napi::Value CancelSearch(const Napi::CallbackInfo& info);

    // --- Accessors ---
    void IsLoadedSetter(const Napi::CallbackInfo& info, const Napi::Value& value);
    Napi::Value IsLoadedGetter(const Napi::CallbackInfo& info);
    void PaletteSetter(const Napi::CallbackInfo& info, const Napi::Value& value);
    Napi::Value PaletteGetter(const Napi::CallbackInfo& info);
    void LandmarkDataSetter(const Napi::CallbackInfo& info, const Napi::Value& value);
    Napi::Value LandmarkDataGetter(const Napi::CallbackInfo& info);

    // --- Private Members ---
    bool isLoaded;
    Napi::Reference<Napi::Array> palette;
    std::vector<Napi::Reference<Napi::Object>> EXCLUDED_COLORS_RGB;
};

#endif 
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/minimapMatcher/src/positionFinderWorker.h
//start file

#ifndef POSITION_FINDER_WORKER_H
#define POSITION_FINDER_WORKER_H

#include <napi.h>
#include <chrono>
#include "minimapMatcher.h"

// --- Native Data Structures for results ---
struct NativePosition {
    bool found = false;
    int x = 0;
    int y = 0;
    int z = 0;
    int mapViewX = 0;
    int mapViewY = 0;
};

// --- The Asynchronous Worker Declaration ---
class PositionFinderWorker : public Napi::AsyncWorker {
public:
    PositionFinderWorker(
        Napi::Env env,
        MinimapMatcher* matcher,
        const std::vector<uint8_t>& unpackedMinimap,
        int minimapWidth,
        int minimapHeight,
        int targetZ
    );

    ~PositionFinderWorker();

    void Execute() override;
    void OnOK() override;
    void OnError(const Napi::Error& e) override;
    Napi::Promise GetPromise();
    void Cancel();

private:
    MinimapMatcher* matcherInstance; // Now we have the full type info

    // Input Data
    std::vector<uint8_t> unpackedMinimap;
    int minimapWidth;
    int minimapHeight;
    int targetZ;

    // Cancellation Flag
    std::atomic<bool> wasCancelled{false};

    // Result Data
    NativePosition resultPosition;
    std::string searchMethod;
    double durationMs;

    Napi::Promise::Deferred deferred;
};

#endif // POSITION_FINDER_WORKER_H
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/minimapMatcher/wrapper.js
//start file
const minimapMatcher = require('./build/Release/minimapMatcher.node');
module.exports = minimapMatcher;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/mouseController/src/mouse-controller.cc
//start file
#include <napi.h>
#include <X11/Xlib.h>
#include <string>
#include <memory>
#include <stdexcept>
#include <algorithm>
#include <unistd.h>

// RAII wrapper for the X11 Display connection
struct DisplayDeleter {
    void operator()(Display* disp) {
        if (disp) XCloseDisplay(disp);
    }
};
using DisplayPtr = std::unique_ptr<Display, DisplayDeleter>;

/**
 * @brief The core logic for sending a synthetic mouse click.
 */
void DoSyntheticClick(const Napi::CallbackInfo& info, unsigned int button, const std::string& display_name) {
    Napi::Env env = info.Env();

    // --- Argument Validation ---
    if (info.Length() < 4 || !info[0].IsNumber() || !info[1].IsNumber() || !info[2].IsNumber() || !info[3].IsString()) {
        Napi::TypeError::New(env, "Requires at least 4 arguments: (windowId, x, y, display)").ThrowAsJavaScriptException();
        return;
    }

    // --- Connect to X Server ---
    DisplayPtr display(XOpenDisplay(display_name.empty() ? nullptr : display_name.c_str()));
    if (!display) {
        Napi::Error::New(env, "Failed to connect to X server on display: " + display_name).ThrowAsJavaScriptException();
        return;
    }

    // --- Parse Required Arguments ---
    const Window target_window = info[0].As<Napi::Number>().Int64Value();
    const int x = info[1].As<Napi::Number>().Int32Value();
    const int y = info[2].As<Napi::Number>().Int32Value();

    // --- Parse Optional Modifier Keys ---
    unsigned int modifier_mask = 0;
    for (size_t i = 3; i < info.Length(); ++i) {
        if (info[i].IsString()) {
            std::string mod = info[i].As<Napi::String>().Utf8Value();
            std::transform(mod.begin(), mod.end(), mod.begin(), ::tolower);
            if (mod == "ctrl")       modifier_mask |= ControlMask;
            else if (mod == "shift") modifier_mask |= ShiftMask;
            else if (mod == "alt")   modifier_mask |= Mod1Mask;
        }
    }

    // --- Get window position relative to root ---
    Window root = XDefaultRootWindow(display.get());
    int win_x, win_y;
    Window child;
    if (!XTranslateCoordinates(display.get(), target_window, root, 0, 0, &win_x, &win_y, &child)) {
        Napi::Error::New(env, "Failed to get window coordinates").ThrowAsJavaScriptException();
        return;
    }

    // --- Create the Synthetic Event ---
    XEvent event;
    memset(&event, 0, sizeof(event));

    event.xbutton.display     = display.get();
    event.xbutton.window      = target_window;
    event.xbutton.root        = root;
    event.xbutton.subwindow   = None;
    event.xbutton.time        = CurrentTime;
    event.xbutton.x           = x;
    event.xbutton.y           = y;
    event.xbutton.x_root      = win_x + x;
    event.xbutton.y_root      = win_y + y;
    event.xbutton.same_screen = True;
    event.xbutton.button      = button;
    event.xbutton.state       = modifier_mask;

    // --- Send ButtonPress ---
    event.type = ButtonPress;
    XSendEvent(display.get(), target_window, True, ButtonPressMask, &event);
    XFlush(display.get());
    usleep(30000);

    // --- Send ButtonRelease ---
    event.type = ButtonRelease;
    event.xbutton.state = modifier_mask;
    XSendEvent(display.get(), target_window, True, ButtonReleaseMask, &event);
    XFlush(display.get());
}

/**
 * @brief The core logic for sending a synthetic mouse button press or release.
 */
void DoSyntheticMouseEvent(const Napi::CallbackInfo& info, unsigned int button, bool is_press, const std::string& display_name) {
    Napi::Env env = info.Env();

    // --- Argument Validation ---
    if (info.Length() < 4 || !info[0].IsNumber() || !info[1].IsNumber() || !info[2].IsNumber() || !info[3].IsString()) {
        Napi::TypeError::New(env, "Requires at least 4 arguments: (windowId, x, y, display)").ThrowAsJavaScriptException();
        return;
    }

    // --- Connect to X Server ---
    DisplayPtr display(XOpenDisplay(display_name.empty() ? nullptr : display_name.c_str()));
    if (!display) {
        Napi::Error::New(env, "Failed to connect to X server on display: " + display_name).ThrowAsJavaScriptException();
        return;
    }

    // --- Parse Required Arguments ---
    const Window target_window = info[0].As<Napi::Number>().Int64Value();
    const int x = info[1].As<Napi::Number>().Int32Value();
    const int y = info[2].As<Napi::Number>().Int32Value();

    // --- Get window position relative to root ---
    Window root = XDefaultRootWindow(display.get());
    int win_x, win_y;
    Window child;
    if (!XTranslateCoordinates(display.get(), target_window, root, 0, 0, &win_x, &win_y, &child)) {
        Napi::Error::New(env, "Failed to get window coordinates").ThrowAsJavaScriptException();
        return;
    }

    // --- Create the Synthetic Event ---
    XEvent event;
    memset(&event, 0, sizeof(event));

    event.xbutton.display     = display.get();
    event.xbutton.window      = target_window;
    event.xbutton.root        = root;
    event.xbutton.subwindow   = None;
    event.xbutton.time        = CurrentTime;
    event.xbutton.x           = x;
    event.xbutton.y           = y;
    event.xbutton.x_root      = win_x + x;
    event.xbutton.y_root      = win_y + y;
    event.xbutton.same_screen = True;
    event.xbutton.button      = button;
    event.xbutton.state       = 0;

    // --- Send ButtonPress or ButtonRelease ---
    event.type = is_press ? ButtonPress : ButtonRelease;
    XSendEvent(display.get(), target_window, True, is_press ? ButtonPressMask : ButtonReleaseMask, &event);
    XFlush(display.get());
}

/**
 * @brief The core logic for moving the mouse cursor.
 */
void DoSyntheticMouseMove(const Napi::CallbackInfo& info, const std::string& display_name) {
    Napi::Env env = info.Env();

    // --- Argument Validation ---
    if (info.Length() < 4 || !info[0].IsNumber() || !info[1].IsNumber() || !info[2].IsNumber() || !info[3].IsString()) {
        Napi::TypeError::New(env, "Requires at least 4 arguments: (windowId, x, y, display)").ThrowAsJavaScriptException();
        return;
    }

    // --- Connect to X Server ---
    DisplayPtr display(XOpenDisplay(display_name.empty() ? nullptr : display_name.c_str()));
    if (!display) {
        Napi::Error::New(env, "Failed to connect to X server on display: " + display_name).ThrowAsJavaScriptException();
        return;
    }

    // --- Parse Required Arguments ---
    const Window target_window = info[0].As<Napi::Number>().Int64Value();
    const int x = info[1].As<Napi::Number>().Int32Value();
    const int y = info[2].As<Napi::Number>().Int32Value();

    // --- Get window position relative to root ---
    Window root = XDefaultRootWindow(display.get());
    int win_x, win_y;
    Window child;
    if (!XTranslateCoordinates(display.get(), target_window, root, 0, 0, &win_x, &win_y, &child)) {
        Napi::Error::New(env, "Failed to get window coordinates").ThrowAsJavaScriptException();
        return;
    }

    // --- Create the Synthetic Motion Event ---
    XEvent event;
    memset(&event, 0, sizeof(event));

    event.xmotion.display     = display.get();
    event.xmotion.window      = target_window;
    event.xmotion.root        = root;
    event.xmotion.subwindow   = None;
    event.xmotion.time        = CurrentTime;
    event.xmotion.x           = x;
    event.xmotion.y           = y;
    event.xmotion.x_root      = win_x + x;
    event.xmotion.y_root      = win_y + y;
    event.xmotion.same_screen = True;
    event.xmotion.state       = 0;
    event.xmotion.is_hint     = NotifyNormal;

    // --- Send Motion Event ---
    event.type = MotionNotify;
    XSendEvent(display.get(), target_window, True, PointerMotionMask, &event);
    XFlush(display.get());
}

// --- N-API Exported Functions ---
Napi::Value LeftClick(const Napi::CallbackInfo& info) {
    if (info.Length() < 4 || !info[3].IsString()) {
        Napi::TypeError::New(info.Env(), "LeftClick requires display name as 4th argument").ThrowAsJavaScriptException();
        return info.Env().Null();
    }
    DoSyntheticClick(info, 1, info[3].As<Napi::String>().Utf8Value());
    return info.Env().Null();
}

Napi::Value RightClick(const Napi::CallbackInfo& info) {
    if (info.Length() < 4 || !info[3].IsString()) {
        Napi::TypeError::New(info.Env(), "RightClick requires display name as 4th argument").ThrowAsJavaScriptException();
        return info.Env().Null();
    }
    DoSyntheticClick(info, 3, info[3].As<Napi::String>().Utf8Value());
    return info.Env().Null();
}

Napi::Value MouseDown(const Napi::CallbackInfo& info) {
    if (info.Length() < 4 || !info[3].IsString()) {
        Napi::TypeError::New(info.Env(), "MouseDown requires display name as 4th argument").ThrowAsJavaScriptException();
        return info.Env().Null();
    }
    DoSyntheticMouseEvent(info, 1, true, info[3].As<Napi::String>().Utf8Value());
    return info.Env().Null();
}

Napi::Value MouseUp(const Napi::CallbackInfo& info) {
    if (info.Length() < 4 || !info[3].IsString()) {
        Napi::TypeError::New(info.Env(), "MouseUp requires display name as 4th argument").ThrowAsJavaScriptException();
        return info.Env().Null();
    }
    DoSyntheticMouseEvent(info, 1, false, info[3].As<Napi::String>().Utf8Value());
    return info.Env().Null();
}

Napi::Value RightMouseDown(const Napi::CallbackInfo& info) {
    if (info.Length() < 4 || !info[3].IsString()) {
        Napi::TypeError::New(info.Env(), "RightMouseDown requires display name as 4th argument").ThrowAsJavaScriptException();
        return info.Env().Null();
    }
    DoSyntheticMouseEvent(info, 3, true, info[3].As<Napi::String>().Utf8Value());
    return info.Env().Null();
}

Napi::Value RightMouseUp(const Napi::CallbackInfo& info) {
    if (info.Length() < 4 || !info[3].IsString()) {
        Napi::TypeError::New(info.Env(), "RightMouseUp requires display name as 4th argument").ThrowAsJavaScriptException();
        return info.Env().Null();
    }
    DoSyntheticMouseEvent(info, 3, false, info[3].As<Napi::String>().Utf8Value());
    return info.Env().Null();
}

Napi::Value MouseMove(const Napi::CallbackInfo& info) {
    if (info.Length() < 4 || !info[3].IsString()) {
        Napi::TypeError::New(info.Env(), "MouseMove requires display name as 4th argument").ThrowAsJavaScriptException();
        return info.Env().Null();
    }
    DoSyntheticMouseMove(info, info[3].As<Napi::String>().Utf8Value());
    return info.Env().Null();
}

// --- Module Initialization ---
Napi::Object Init(Napi::Env env, Napi::Object exports) {
    exports.Set("leftClick", Napi::Function::New(env, LeftClick));
    exports.Set("rightClick", Napi::Function::New(env, RightClick));
    exports.Set("mouseDown", Napi::Function::New(env, MouseDown));
    exports.Set("mouseUp", Napi::Function::New(env, MouseUp));
    exports.Set("rightMouseDown", Napi::Function::New(env, RightMouseDown));
    exports.Set("rightMouseUp", Napi::Function::New(env, RightMouseUp));
    exports.Set("mouseMove", Napi::Function::New(env, MouseMove));
    return exports;
}

NODE_API_MODULE(mouse_controller, Init)
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/mouseController/wrapper.js
//start file
const mouseController = require('./build/Release/mouse-controller.node');
module.exports = mouseController;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/pathfinder/src/aStar.h
//start file
#ifndef ASTAR_H
#define ASTAR_H

#include <vector>
#include <cmath>
#include <functional>
#include "pathfinder.h"

// Represents a single point/node in the grid
struct Node {
    int x, y;
    int g; // Cost from start
    int h; // Heuristic cost to end
    const Node* parent;
    int z; // <<< FIX: Added z-level member

    int f() const { return g + h; }

    bool operator==(const Node& other) const {
        return x == other.x && y == other.y;
    }
};

// Simple hash for Node, required for unordered_set
struct NodeHash {
    std::size_t operator()(const Node& node) const {
        // Hash on x and y only, as pathfinding is 2D per floor
        return std::hash<int>()(node.y * 10000 + node.x);
    }
};

namespace AStar {
    std::vector<Node> findPath(
        const Node& start,
        const Node& end,
        const MapData& mapData,
        std::function<void()> onCancelled
    );
}

#endif // ASTAR_H
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/pathfinder/src/aStarWorker.h
//start file
#ifndef ASTAR_WORKER_H
#define ASTAR_WORKER_H

#include <napi.h>
#include <chrono>
#include "pathfinder.h"
#include "aStar.h"

class AStarWorker : public Napi::AsyncWorker {
public:
    AStarWorker(
        Napi::Env env,
        Pathfinder* pathfinderInstance,
        const Node& start,
        const Node& end
    );
    ~AStarWorker();

    void Execute() override;
    void OnOK() override;
    void OnError(const Napi::Error& e) override;
    Napi::Promise GetPromise();
    void Cancel();

private:
    Pathfinder* pathfinder;
    Node startNode;
    Node endNode;
    std::atomic<bool> wasCancelled{false};

    // Result data
    std::vector<Node> pathResult;
    double durationMs;

    // --- CRITICAL FIX: Declare the missing member variable ---
    std::string searchStatus;

    Napi::Promise::Deferred deferred;
};

#endif
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/pathfinder/src/pathfinder.cc
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/pathfinder.cc
// --- Definitive Version with Unified "Stand Still" Logic for All Stances ---

#include "pathfinder.h"
#include <napi.h>
#include <iostream>
#include <fstream>
#include <unordered_set>
#include <unordered_map>
#include <algorithm>
#include <queue>
#include <vector>
#include <cmath>
#include <chrono>
#include <string>
#include <functional>
#include <climits>

// Internal-only helper struct.
struct SpecialArea {
    int x, y, z;
    int width, height;
    int avoidance;
};

namespace AStar {
    // Configuration: costs tuned for Tibia as discussed
    static constexpr int BASE_MOVE_COST = 10;
    static constexpr int DIAGONAL_MOVE_COST = 25;
    static constexpr int DIAGONAL_TIE_PENALTY = 1;

    bool isWalkable(int x, int y, const MapData& mapData) {
        if (x < 0 || x >= mapData.width || y < 0 || y >= mapData.height) return false;
        int linearIndex = y * mapData.width + x;
        int byteIndex = linearIndex / 8;
        int bitIndex = linearIndex % 8;
        if (byteIndex < 0 || byteIndex >= (int)mapData.grid.size()) return false;
        return (mapData.grid[byteIndex] & (1 << bitIndex)) != 0;
    }

    inline bool inBounds(int x, int y, const MapData& mapData) {
        return x >= 0 && x < mapData.width && y >= 0 && y < mapData.height;
    }

    inline int octileHeuristic(int x1, int y1, int x2, int y2, int D = BASE_MOVE_COST, int D2 = DIAGONAL_MOVE_COST) {
        int dx = std::abs(x1 - x2);
        int dy = std::abs(y1 - y2);
        int mn = std::min(dx, dy);
        return D * (dx + dy) + (D2 - 2 * D) * mn;
    }

    static const int INF_COST = 0x3f3f3f3f;

    struct ScratchBuffers {
        std::vector<int> gScore;
        std::vector<int> parent;
        std::vector<int> mark;
        std::vector<int> closedMark;
        int visitToken = 1;
    };

    static thread_local ScratchBuffers sb;

    static inline void ensureBuffersSize(int required) {
        if ((int)sb.gScore.size() < required) {
            sb.gScore.assign(required, INF_COST);
            sb.parent.assign(required, -1);
            sb.mark.assign(required, 0);
            sb.closedMark.assign(required, 0);
            sb.visitToken = 1;
        }
    }

    static inline void nextVisitToken() {
        sb.visitToken++;
        if (sb.visitToken == 0 || sb.visitToken == INT_MAX) {
            std::fill(sb.mark.begin(), sb.mark.end(), 0);
            std::fill(sb.closedMark.begin(), sb.closedMark.end(), 0);
            sb.visitToken = 1;
        }
    }

    std::vector<Node> findPathWithCosts(const Node& start, const Node& end, const MapData& mapData, const std::vector<int>& cost_grid, std::function<void()> onCancelled) {
        std::vector<Node> path;

        int W = mapData.width;
        int H = mapData.height;
        if (W <= 0 || H <= 0) return path;
        int mapSize = W * H;
        ensureBuffersSize(mapSize);
        nextVisitToken();
        int visit = sb.visitToken;

        auto indexOf = [&](int x, int y) { return y * W + x; };

        if (!inBounds(end.x, end.y, mapData)) return path;

        int h0 = octileHeuristic(start.x, start.y, end.x, end.y);

        using PQItem = std::tuple<int,int,int,int>;
        struct Compare {
            bool operator()(PQItem const& a, PQItem const& b) const {
                if (std::get<0>(a) != std::get<0>(b)) return std::get<0>(a) > std::get<0>(b);
                if (std::get<1>(a) != std::get<1>(b)) return std::get<1>(a) > std::get<1>(b);
                return std::get<2>(a) > std::get<2>(b);
            }
        };
        std::priority_queue<PQItem, std::vector<PQItem>, Compare> open;

        int startIdx = indexOf(start.x, start.y);
        int endIdx = indexOf(end.x, end.y);

        sb.gScore[startIdx] = 0;
        sb.parent[startIdx] = -1;
        sb.mark[startIdx] = visit;
        open.emplace(h0 + 0, h0, 0, startIdx);

        int iterations = 0;
        const int dxs[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };
        const int dys[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };

        while (!open.empty()) {
            if (++iterations % 1000 == 0) onCancelled();

            auto [f, h, g, idx] = open.top();
            open.pop();

            if (sb.closedMark[idx] == visit) continue;
            if (!(sb.mark[idx] == visit)) continue;
            if (g > sb.gScore[idx]) continue;

            int cx = idx % W;
            int cy = idx / W;

            if (idx == endIdx) {
                int cur = endIdx;
                while (cur != -1) {
                    Node node_to_add;
                    node_to_add.x = cur % W;
                    node_to_add.y = cur / W;
                    node_to_add.z = start.z;
                    path.push_back(node_to_add);
                    cur = sb.parent[cur];
                }
                std::reverse(path.begin(), path.end());
                return path;
            }

            sb.closedMark[idx] = visit;

            for (int dir = 0; dir < 8; ++dir) {
                int nx = cx + dxs[dir];
                int ny = cy + dys[dir];
                if (!inBounds(nx, ny, mapData)) continue;

                int nIdx = indexOf(nx, ny);
                int tileAvoidance = 0;
                if (nIdx >= 0 && nIdx < (int)cost_grid.size()) {
                    tileAvoidance = cost_grid[nIdx];
                }

                if (tileAvoidance == 255) continue;

                bool isWalkableByMap = isWalkable(nx, ny, mapData);
                if (tileAvoidance != -1 && !isWalkableByMap && !(nx == end.x && ny == end.y)) {
                    continue;
                }

                bool isDiagonal = (dxs[dir] != 0 && dys[dir] != 0);
                int baseMoveCost = isDiagonal ? DIAGONAL_MOVE_COST : BASE_MOVE_COST;
                int addedCost = (tileAvoidance > 0) ? tileAvoidance : 0;
                int tentativeG = (sb.mark[idx] == visit ? sb.gScore[idx] : INF_COST) + baseMoveCost + addedCost;

                if (!(sb.mark[nIdx] == visit) || tentativeG < sb.gScore[nIdx]) {
                    sb.gScore[nIdx] = tentativeG;
                    sb.parent[nIdx] = idx;
                    sb.mark[nIdx] = visit;
                    int nh = octileHeuristic(nx, ny, end.x, end.y);
                    int nf = tentativeG + nh;
                    if (isDiagonal) nf += DIAGONAL_TIE_PENALTY;
                    open.emplace(nf, nh, tentativeG, nIdx);
                }
            }
        }
        return path;
    }

    Node findBestTargetTile(const Node& player, const Node& monster, const std::string& stance, int distance, const MapData& mapData, const std::vector<int>& cost_grid) {
        Node best_node = {-1, -1, 0, 0, nullptr, 0};
        Node playerLocal = {player.x - mapData.minX, player.y - mapData.minY, 0, 0, nullptr, player.z};
        Node monsterLocal = {monster.x - mapData.minX, monster.y - mapData.minY, 0, 0, nullptr, monster.z};

        // --- UNIFIED "STAND STILL" CHECK ---
        // This is the most critical fix. It checks if the player is ALREADY in an optimal position
        // for either stance before doing any expensive calculations. This prevents all orbiting/pacing.
        // The decision to "stand still" should be made by the caller (JS side)
        // after evaluating the path to the best target tile.
        // This function should always find the best possible target tile.

        // If we are not in an optimal position, proceed to find one.
        std::queue<std::pair<Node, int>> q;
        std::unordered_set<int> visited;
        auto indexOf = [&](int x, int y) { return y * mapData.width + x; };

        if (!AStar::inBounds(monsterLocal.x, monsterLocal.y, mapData)) return best_node;

        q.push({monsterLocal, 0});
        visited.insert(indexOf(monsterLocal.x, monsterLocal.y));

        std::vector<Node> candidates;
        while (!q.empty()) {
            auto [current, dist] = q.front();
            q.pop();

            if ((stance == "Reach" && dist == 1) || (stance == "keepAway" && dist == distance)) {
                candidates.push_back(current);
            }

            // Optimization: stop searching once we've passed the desired distance for either stance.
            if ((stance == "Reach" && dist >= 1) || (stance == "keepAway" && dist >= distance)) {
                continue;
            }

            for (int dx = -1; dx <= 1; ++dx) {
                for (int dy = -1; dy <= 1; ++dy) {
                    if (dx == 0 && dy == 0) continue;
                    Node neighbor = {current.x + dx, current.y + dy, 0, 0, nullptr, current.z};
                    if (AStar::inBounds(neighbor.x, neighbor.y, mapData)) {
                        int neighborIdx = indexOf(neighbor.x, neighbor.y);
                        int tileAvoidance = cost_grid.empty() ? 0 : cost_grid[neighborIdx];
                        bool isWalkableNode = (tileAvoidance != 255) && ((tileAvoidance == -1) || isWalkable(neighbor.x, neighbor.y, mapData));

                        if (isWalkableNode && visited.find(neighborIdx) == visited.end()) {
                            visited.insert(neighborIdx);
                            q.push({neighbor, dist + 1});
                        }
                    }
                }
            }
        }

        if (candidates.empty()) return best_node; // No candidates found at desired distance

        std::vector<Node> optimal_candidates;
        int min_dist_from_player = INT_MAX;
        int max_manhattan_dist_tiebreaker = -1;

        for (const auto& cand : candidates) {
            // Ensure candidate is walkable
            int candIdx = indexOf(cand.x, cand.y);
            int tileAvoidance = cost_grid.empty() ? 0 : cost_grid[candIdx];
            bool isWalkableNode = (tileAvoidance != 255) && ((tileAvoidance == -1) || isWalkable(cand.x, cand.y, mapData));
            if (!isWalkableNode) continue; // Skip non-walkable candidates

            int dist_from_player = std::max(std::abs(cand.x - playerLocal.x), std::abs(cand.y - playerLocal.y));
            int manhattan_dist_from_monster = std::abs(cand.x - monsterLocal.x) + std::abs(cand.y - monsterLocal.y);

            if (dist_from_player < min_dist_from_player) {
                min_dist_from_player = dist_from_player;
                max_manhattan_dist_tiebreaker = manhattan_dist_from_monster;
                optimal_candidates.clear();
                optimal_candidates.push_back(cand);
            } else if (dist_from_player == min_dist_from_player) {
                if (manhattan_dist_from_monster > max_manhattan_dist_tiebreaker) {
                    max_manhattan_dist_tiebreaker = manhattan_dist_from_monster;
                    optimal_candidates.clear();
                    optimal_candidates.push_back(cand);
                } else if (manhattan_dist_from_monster == max_manhattan_dist_tiebreaker) {
                    optimal_candidates.push_back(cand);
                }
            }
        }

        if (optimal_candidates.empty()) return best_node; // No walkable candidates found

        // Now, from the optimal_candidates, pick one.
        // If playerLocal is among them, and there are other non-playerLocal candidates,
        // prefer a non-playerLocal one.
        Node final_best_node = optimal_candidates[0]; // Default to the first one

        bool player_is_optimal_candidate = false;
        for (const auto& cand : optimal_candidates) {
            if (cand.x == playerLocal.x && cand.y == playerLocal.y && cand.z == playerLocal.z) {
                player_is_optimal_candidate = true;
                break;
            }
        }

        if (player_is_optimal_candidate) {
            // If player is an optimal candidate, try to find another optimal candidate that is not playerLocal
            for (const auto& cand : optimal_candidates) {
                if (!(cand.x == playerLocal.x && cand.y == playerLocal.y && cand.z == playerLocal.z)) {
                    final_best_node = cand;
                    break; // Found a non-playerLocal optimal candidate, pick it
                }
            }
        }
        best_node = final_best_node;
        return best_node;
    }
}

// --- N-API Section (No changes below this line) ---
Napi::FunctionReference Pathfinder::constructor;

Napi::Object Pathfinder::Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "Pathfinder", {
        InstanceMethod("loadMapData", &Pathfinder::LoadMapData),
        InstanceMethod("findPathSync", &Pathfinder::FindPathSync),
        InstanceMethod("updateSpecialAreas", &Pathfinder::UpdateSpecialAreas),
        InstanceMethod("findPathToGoal", &Pathfinder::FindPathToGoal),
        InstanceAccessor("isLoaded", &Pathfinder::IsLoadedGetter, nullptr),
    });
    constructor = Napi::Persistent(func);
    constructor.SuppressDestruct();
    exports.Set("Pathfinder", func);
    return exports;
}

Pathfinder::Pathfinder(const Napi::CallbackInfo& info) : Napi::ObjectWrap<Pathfinder>(info) {}

Napi::Value Pathfinder::IsLoadedGetter(const Napi::CallbackInfo& info) {
    return Napi::Boolean::New(info.Env(), this->isLoaded.load());
}

Napi::Value Pathfinder::LoadMapData(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1 || !info[0].IsObject()) {
        Napi::TypeError::New(env, "Expected an object mapping Z-levels to map data").ThrowAsJavaScriptException();
        return env.Undefined();
    }
    Napi::Object mapDataObj = info[0].As<Napi::Object>();
    Napi::Array zLevels = mapDataObj.GetPropertyNames();
    this->allMapData.clear();
    for (uint32_t i = 0; i < zLevels.Length(); ++i) {
        Napi::Value zKey = zLevels.Get(i);
        int z = std::stoi(zKey.As<Napi::String>().Utf8Value());
        Napi::Object dataForZ = mapDataObj.Get(zKey).As<Napi::Object>();
        Napi::Buffer<uint8_t> gridBuffer = dataForZ.Get("grid").As<Napi::Buffer<uint8_t>>();
        MapData map;
        map.z = z;
        map.minX = dataForZ.Get("minX").As<Napi::Number>().Int32Value();
        map.minY = dataForZ.Get("minY").As<Napi::Number>().Int32Value();
        map.width = dataForZ.Get("width").As<Napi::Number>().Int32Value();
        map.height = dataForZ.Get("height").As<Napi::Number>().Int32Value();

        size_t expectedBytes = ((size_t)map.width * (size_t)map.height + 7) / 8;
        if (gridBuffer.Length() < expectedBytes) {
            Napi::TypeError::New(env, "Grid buffer shorter than expected for provided width/height").ThrowAsJavaScriptException();
            return env.Undefined();
        }

        map.grid.assign(gridBuffer.Data(), gridBuffer.Data() + gridBuffer.Length());
        this->allMapData[z] = std::move(map);
    }
    this->isLoaded = true;
    return env.Undefined();
}

Napi::Value Pathfinder::UpdateSpecialAreas(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2 || !info[0].IsArray() || !info[1].IsNumber()) {
        Napi::TypeError::New(env, "Expected an array of special area objects and current Z-level").ThrowAsJavaScriptException();
        return env.Undefined();
    }

    this->cost_grid_cache.clear();

    Napi::Array areas_array = info[0].As<Napi::Array>();
    int current_z = info[1].As<Napi::Number>().Int32Value();

    std::vector<SpecialArea> areas_on_current_z;
    for (uint32_t i = 0; i < areas_array.Length(); ++i) {
        Napi::Object area_obj = areas_array.Get(i).As<Napi::Object>();
        SpecialArea area;
        area.x = area_obj.Get("x").As<Napi::Number>().Int32Value();
        area.y = area_obj.Get("y").As<Napi::Number>().Int32Value();
        area.z = area_obj.Get("z").As<Napi::Number>().Int32Value();
        area.avoidance = area_obj.Get("avoidance").As<Napi::Number>().Int32Value();
        area.width = area_obj.Get("width").As<Napi::Number>().Int32Value();
        area.height = area_obj.Get("height").As<Napi::Number>().Int32Value();
        if (area.z == current_z) {
            areas_on_current_z.push_back(area);
        }
    }

    auto it_map = this->allMapData.find(current_z);
    if (it_map == this->allMapData.end()) {
        return env.Undefined();
    }
    const MapData& mapData = it_map->second;

    std::vector<int> cost_grid(mapData.width * mapData.height, 0);
    for (const auto& area : areas_on_current_z) {
        int local_start_x = area.x - mapData.minX;
        int local_start_y = area.y - mapData.minY;
        for (int dx = 0; dx < area.width; ++dx) {
            for (int dy = 0; dy < area.height; ++dy) {
                int current_x = local_start_x + dx;
                int current_y = local_start_y + dy;
                if (current_x >= 0 && current_x < mapData.width && current_y >= 0 && current_y < mapData.height) {
                    cost_grid[current_y * mapData.width + current_x] = std::max(cost_grid[current_y * mapData.width + current_x], area.avoidance);
                }
            }
        }
    }
    this->cost_grid_cache[current_z] = std::move(cost_grid);

    return env.Undefined();
}

Napi::Value Pathfinder::_findPathInternal(Napi::Env env, const Node& start, const Node& end) {
    auto startTime = std::chrono::high_resolution_clock::now();
    Napi::Object result = Napi::Object::New(env);
    std::string searchStatus = "UNKNOWN";
    std::vector<Node> pathResult;

    auto it_map = this->allMapData.find(start.z);
    if (it_map == this->allMapData.end()) {
        Napi::Error::New(env, "Map data for this Z-level is not loaded.").ThrowAsJavaScriptException();
        return env.Undefined();
    }
    const MapData& mapData = it_map->second;

    Node localStart = {start.x - mapData.minX, start.y - mapData.minY, 0, 0, nullptr, start.z};
    Node localEnd = {end.x - mapData.minX, end.y - mapData.minY, 0, 0, nullptr, end.z};

    if (!AStar::inBounds(localStart.x, localStart.y, mapData)) {
        searchStatus = "NO_VALID_START";
    } else {
        auto it_cache = this->cost_grid_cache.find(start.z);
        if (it_cache != this->cost_grid_cache.end()) {
            pathResult = AStar::findPathWithCosts(localStart, localEnd, mapData, it_cache->second, [](){});
        } else {
            std::vector<int> empty_costs;
            pathResult = AStar::findPathWithCosts(localStart, localEnd, mapData, empty_costs, [](){});
        }

        if (!pathResult.empty()) {
            searchStatus = "PATH_FOUND";
        } else {
            searchStatus = "NO_PATH_FOUND";
        }
    }

    if (pathResult.size() > 1 && pathResult[0].x == localStart.x && pathResult[0].y == localStart.y) {
        pathResult.erase(pathResult.begin());
    }

    auto endTime = std::chrono::high_resolution_clock::now();
    double durationMs = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime).count() / 1000.0;
    Napi::Object performance = Napi::Object::New(env);
    performance.Set("totalTimeMs", Napi::Number::New(env, durationMs));
    result.Set("performance", performance);
    result.Set("reason", Napi::String::New(env, searchStatus));

    if (!pathResult.empty()) {
        Napi::Array pathArray = Napi::Array::New(env, pathResult.size());
        for (size_t i = 0; i < pathResult.size(); ++i) {
            Napi::Object point = Napi::Object::New(env);
            point.Set("x", Napi::Number::New(env, pathResult[i].x + mapData.minX));
            point.Set("y", Napi::Number::New(env, pathResult[i].y + mapData.minY));
            point.Set("z", Napi::Number::New(env, pathResult[i].z));
            pathArray[i] = point;
        }
        result.Set("path", pathArray);
    } else {
        result.Set("path", env.Null());
    }
    return result;
}

Napi::Value Pathfinder::FindPathSync(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2 || !info[0].IsObject() || !info[1].IsObject()) {
        Napi::TypeError::New(env, "Expected start and end objects as arguments").ThrowAsJavaScriptException();
        return env.Undefined();
    }
    Napi::Object startObj = info[0].As<Napi::Object>();
    Node start = {startObj.Get("x").As<Napi::Number>().Int32Value(), startObj.Get("y").As<Napi::Number>().Int32Value(), 0, 0, nullptr, startObj.Get("z").As<Napi::Number>().Int32Value()};
    Napi::Object endObj = info[1].As<Napi::Object>();
    Node end = {endObj.Get("x").As<Napi::Number>().Int32Value(), endObj.Get("y").As<Napi::Number>().Int32Value(), 0, 0, nullptr, endObj.Get("z").As<Napi::Number>().Int32Value()};

    return _findPathInternal(env, start, end);
}

Napi::Value Pathfinder::FindPathToGoal(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 2 || !info[0].IsObject() || !info[1].IsObject()) {
        Napi::TypeError::New(env, "Expected start node and goal object").ThrowAsJavaScriptException();
        return env.Undefined();
    }

    Napi::Object startObj = info[0].As<Napi::Object>();
    Node start = {startObj.Get("x").As<Napi::Number>().Int32Value(), startObj.Get("y").As<Napi::Number>().Int32Value(), 0, 0, nullptr, startObj.Get("z").As<Napi::Number>().Int32Value()};

    Napi::Object goalObj = info[1].As<Napi::Object>();
    std::string stance = goalObj.Get("stance").As<Napi::String>().Utf8Value();
    int distance = goalObj.Get("distance").As<Napi::Number>().Int32Value();
    Napi::Object monsterPosObj = goalObj.Get("targetCreaturePos").As<Napi::Object>();
    Node monster = {monsterPosObj.Get("x").As<Napi::Number>().Int32Value(), monsterPosObj.Get("y").As<Napi::Number>().Int32Value(), 0, 0, nullptr, monsterPosObj.Get("z").As<Napi::Number>().Int32Value()};

    auto it_map = this->allMapData.find(start.z);
    if (it_map == this->allMapData.end()) {
        Napi::Error::New(env, "Map data for this Z-level is not loaded.").ThrowAsJavaScriptException();
        return env.Undefined();
    }
    const MapData& mapData = it_map->second;

    auto it_cache = this->cost_grid_cache.find(start.z);
    const std::vector<int>& cost_grid = (it_cache != this->cost_grid_cache.end()) ? it_cache->second : std::vector<int>();

    Node best_target_tile = AStar::findBestTargetTile(start, monster, stance, distance, mapData, cost_grid);

    if (best_target_tile.x == -1) {
        Napi::Object result = Napi::Object::New(env);
        result.Set("reason", Napi::String::New(env, "NO_PATH_FOUND"));
        result.Set("path", env.Null());
        Napi::Object performance = Napi::Object::New(env);
        performance.Set("totalTimeMs", Napi::Number::New(env, 0));
        result.Set("performance", performance);
        return result;
    }

    Node final_end_node = {best_target_tile.x + mapData.minX, best_target_tile.y + mapData.minY, 0, 0, nullptr, best_target_tile.z};
    return _findPathInternal(env, start, final_end_node);
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
    Pathfinder::Init(env, exports);
    return exports;
}

NODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/pathfinder/src/pathfinder.h
//start file
#ifndef PATHFINDER_H
#define PATHFINDER_H

#include <napi.h>
#include <string>
#include <vector>
#include <atomic>
#include <unordered_map>
#include <functional> // For std::hash

// Data Structures
struct Node {
    int x, y;
    int g, h;
    const Node* parent;
    int z;

    int f() const { return g + h; }
    bool operator==(const Node& other) const { return x == other.x && y == other.y; }
};

struct NodeHash {
    std::size_t operator()(const Node& node) const {
        return std::hash<int>()(node.x) ^ (std::hash<int>()(node.y) << 1);
    }
};

struct MapData {
    int z;
    int minX, minY, width, height;
    std::vector<uint8_t> grid;
};

class Pathfinder : public Napi::ObjectWrap<Pathfinder> {
public:
    static Napi::Object Init(Napi::Env env, Napi::Object exports);
    Pathfinder(const Napi::CallbackInfo& info);

private:
    static Napi::FunctionReference constructor;

    // --- Private C++ Helper ---
    Napi::Value _findPathInternal(Napi::Env env, const Node& start, const Node& end);

    // --- Methods exposed to Node.js ---
    Napi::Value LoadMapData(const Napi::CallbackInfo& info);
    Napi::Value FindPathSync(const Napi::CallbackInfo& info);
    Napi::Value IsLoadedGetter(const Napi::CallbackInfo& info);
    Napi::Value UpdateSpecialAreas(const Napi::CallbackInfo& info);
    Napi::Value FindPathToGoal(const Napi::CallbackInfo& info);

    // Internal State
    std::unordered_map<int, MapData> allMapData;
    std::atomic<bool> isLoaded{false};
    std::unordered_map<int, std::vector<int>> cost_grid_cache;
};

#endif // PATHFINDER_H
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/pathfinder/wrapper.js
//start file
const pathfinderNative = require('./build/Release/pathfinderNative.node');
module.exports = pathfinderNative;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/windowInfo/src/windowinfo.cc
//start file
#include <napi.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <string>
#include <cstring>
#include <vector>

// Structure to hold detailed window information
struct WindowInfo {
    Window windowId;
    std::string name;
    std::string className;
    int x;
    int y;
    int width;
    int height;
    bool visible;
    std::string display_name; // New field for display name

    // Extra attributes from XWindowAttributes
    int borderWidth;
    int depth;
    unsigned long colormap;

    // WM hints (from XGetWMHints)
    long wmFlags;
    bool wmInput;
    int wmInitialState;
    Window wmIconWindow;
    Window wmIconPixmap;
    Window wmIconMask;
    Window wmWindowGroup;

    // WM Normal Hints (from XGetWMNormalHints)
    int minWidth;
    int minHeight;
    int maxWidth;
    int maxHeight;
    int widthInc;
    int heightInc;
    int baseWidth;
    int baseHeight;

    // Extended properties
    std::vector<std::string> netWmState;
    std::vector<std::string> netWmWindowType;
    int netWmPid;
    bool hasNetWmPid;
};

// ---------------------------------------------------------------------
// Existing helper functions

bool GetWindowProperty(Display* display, Window window, Atom property, Atom type,
                         unsigned char** value, unsigned long* nitems) {
    Atom actual_type;
    int actual_format;
    unsigned long bytes_after;

    if (XGetWindowProperty(display, window, property, 0, (~0L), False, type,
                           &actual_type, &actual_format, nitems, &bytes_after, value) == Success) {
        return actual_type != None;
    }
    return false;
}

// Helper function to get window class name
std::string GetWindowClassName(Display* display, Window window) {
    XClassHint class_hint;
    std::string class_name;

    if (XGetClassHint(display, window, &class_hint)) {
        if (class_hint.res_class) {
            class_name = class_hint.res_class;
            XFree(class_hint.res_class);
        }
        if (class_hint.res_name) {
            XFree(class_hint.res_name);
        }
    }
    return class_name;
}

// Helper function to find the actual application window
Window FindActualWindow(Display* display, Window start_window, int root_x, int root_y) {
    Window target = start_window;
    Window root_return, parent_return, *children;
    unsigned int nchildren;

    std::string class_name = GetWindowClassName(display, start_window);
    if (!class_name.empty()) {
        return start_window;
    }

    if (XQueryTree(display, start_window, &root_return, &parent_return, &children, &nchildren)) {
        for (unsigned int i = 0; i < nchildren; i++) {
            Window child = children[i];
            XWindowAttributes attrs;
            if (XGetWindowAttributes(display, child, &attrs)) {
                Window found = FindActualWindow(display, child, root_x, root_y);
                if (found != None) {
                    target = found;
                    break;
                }
            }
        }
        if (children) {
            XFree(children);
        }
    }
    return target;
}

// Get window dimensions (basic version)
Napi::Object GetWindowDimensions(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    Napi::Object dimensions = Napi::Object::New(env);

    if (info.Length() < 1 || !info[0].IsNumber()) {
        Napi::TypeError::New(env, "Window ID required").ThrowAsJavaScriptException();
        return dimensions;
    }
    uint64_t window_id = info[0].As<Napi::Number>().Int64Value();
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        Napi::Error::New(env, "Cannot open display").ThrowAsJavaScriptException();
        return dimensions;
    }
    XWindowAttributes attributes;
    Window target_window = (Window)window_id;
    if (XGetWindowAttributes(display, target_window, &attributes)) {
        dimensions.Set("width", attributes.width);
        dimensions.Set("height", attributes.height);
        dimensions.Set("x", attributes.x);
        dimensions.Set("y", attributes.y);
        dimensions.Set("visible", attributes.map_state == IsViewable);
    }
    XCloseDisplay(display);
    return dimensions;
}

// Get window name
Napi::String GetWindowName(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1 || !info[0].IsNumber()) {
        Napi::TypeError::New(env, "Window ID required").ThrowAsJavaScriptException();
        return Napi::String::New(env, "");
    }
    uint64_t window_id = info[0].As<Napi::Number>().Int64Value();
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        Napi::Error::New(env, "Cannot open display").ThrowAsJavaScriptException();
        return Napi::String::New(env, "");
    }
    Window target_window = (Window)window_id;
    char* window_name = NULL;
    std::string name;
    if (XFetchName(display, target_window, &window_name)) {
        name = window_name ? window_name : "";
        XFree(window_name);
    }
    XCloseDisplay(display);
    return Napi::String::New(env, name);
}

// Get window class (basic version)
Napi::Object GetWindowClass(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    Napi::Object classInfo = Napi::Object::New(env);
    if (info.Length() < 1 || !info[0].IsNumber()) {
        Napi::TypeError::New(env, "Window ID required").ThrowAsJavaScriptException();
        return classInfo;
    }
    uint64_t window_id = info[0].As<Napi::Number>().Int64Value();
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        Napi::Error::New(env, "Cannot open display").ThrowAsJavaScriptException();
        return classInfo;
    }
    Window target_window = (Window)window_id;
    XClassHint class_hint;
    if (XGetClassHint(display, target_window, &class_hint)) {
        classInfo.Set("className", class_hint.res_class ? class_hint.res_class : "");
        classInfo.Set("instanceName", class_hint.res_name ? class_hint.res_name : "");
        XFree(class_hint.res_name);
        XFree(class_hint.res_class);
    }
    XCloseDisplay(display);
    return classInfo;
}

// Get window ID by clicking on it
Napi::Number GetWindowIdByClick(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        return Napi::Number::New(env, 0);
    }
    Window root = DefaultRootWindow(display);
    Window target_window = 0;
    Cursor cursor = XCreateFontCursor(display, XC_crosshair);
    if (cursor) {
        int status;
        Window root_return, child_return;
        int root_x, root_y, win_x, win_y;
        unsigned int mask;
        XEvent event;
        status = XGrabPointer(display, root, False,
                              ButtonPressMask | ButtonReleaseMask,
                              GrabModeSync, GrabModeAsync,
                              root, cursor, CurrentTime);
        if (status == GrabSuccess) {
            XAllowEvents(display, SyncPointer, CurrentTime);
            XWindowEvent(display, root, ButtonPressMask, &event);
            if (event.type == ButtonPress) {
                XQueryPointer(display, root,
                              &root_return, &child_return,
                              &root_x, &root_y,
                              &win_x, &win_y,
                              &mask);
                if (child_return) {
                    target_window = FindActualWindow(display, child_return, root_x, root_y);
                }
            }
        }
        XUngrabPointer(display, CurrentTime);
        XFreeCursor(display, cursor);
    }
    XCloseDisplay(display);
    return Napi::Number::New(env, (double)target_window);
}

// Get active window ID
Napi::Number GetActiveWindow(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        return Napi::Number::New(env, 0);
    }
    Window root = DefaultRootWindow(display);
    Window activeWindow = None;
    Atom netActiveWindowAtom = XInternAtom(display, "_NET_ACTIVE_WINDOW", False);
    Atom actualType;
    int actualFormat;
    unsigned long nItems;
    unsigned long bytesAfter;
    unsigned char* data = NULL;
    if (XGetWindowProperty(display, root, netActiveWindowAtom, 0, 1,
                           False, XA_WINDOW, &actualType, &actualFormat,
                           &nItems, &bytesAfter, &data) == Success) {
        if (actualType == XA_WINDOW && actualFormat == 32 && nItems == 1) {
            activeWindow = *((Window*)data);
        }
        if (data) {
            XFree(data);
        }
    }
    if (activeWindow == None || activeWindow == root) {
        Window focused;
        int revert_to;
        if (XGetInputFocus(display, &focused, &revert_to) && focused != None) {
            activeWindow = focused;
        }
    }
    if (activeWindow == None || activeWindow == root) {
        activeWindow = 0;
    }
    XCloseDisplay(display);
    return Napi::Number::New(env, (double)activeWindow);
}

// Get window state (basic version)
Napi::String GetWindowState(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1 || !info[0].IsNumber()) {
        Napi::TypeError::New(env, "Window ID required").ThrowAsJavaScriptException();
        return Napi::String::New(env, "unknown");
    }
    uint64_t window_id = info[0].As<Napi::Number>().Int64Value();
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        Napi::Error::New(env, "Cannot open display").ThrowAsJavaScriptException();
        return Napi::String::New(env, "unknown");
    }
    Window target_window = (Window)window_id;
    Atom* properties = NULL;
    unsigned char* data = NULL;
    unsigned long nitems;
    Atom _NET_WM_STATE = XInternAtom(display, "_NET_WM_STATE", False);
    std::string state = "normal";
    if (GetWindowProperty(display, target_window, _NET_WM_STATE, XA_ATOM, &data, &nitems)) {
        properties = (Atom*)data;
        Atom _NET_WM_STATE_HIDDEN = XInternAtom(display, "_NET_WM_STATE_HIDDEN", False);
        Atom _NET_WM_STATE_MAXIMIZED_VERT = XInternAtom(display, "_NET_WM_STATE_MAXIMIZED_VERT", False);
        Atom _NET_WM_STATE_MAXIMIZED_HORZ = XInternAtom(display, "_NET_WM_STATE_MAXIMIZED_HORZ", False);
        bool is_hidden = false;
        bool is_maximized_vert = false;
        bool is_maximized_horz = false;
        for (unsigned long i = 0; i < nitems; i++) {
            if (properties[i] == _NET_WM_STATE_HIDDEN) is_hidden = true;
            if (properties[i] == _NET_WM_STATE_MAXIMIZED_VERT) is_maximized_vert = true;
            if (properties[i] == _NET_WM_STATE_MAXIMIZED_HORZ) is_maximized_horz = true;
        }
        if (is_hidden) state = "minimized";
        else if (is_maximized_vert && is_maximized_horz) state = "maximized";
        XFree(data);
    }
    XCloseDisplay(display);
    return Napi::String::New(env, state);
}

Napi::Object GetWindowInfoByClick(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    Napi::Object allInfo = Napi::Object::New(env);
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        Napi::Error::New(env, "Cannot open display").ThrowAsJavaScriptException();
        return allInfo;
    }
    Window root = DefaultRootWindow(display);
    Window target_window = 0;
    Cursor cursor = XCreateFontCursor(display, XC_crosshair);
    if (cursor) {
        int status;
        Window root_return, child_return;
        int root_x, root_y, win_x, win_y;
        unsigned int mask;
        status = XGrabPointer(display, root, False,
                              ButtonPressMask | ButtonReleaseMask,
                              GrabModeSync, GrabModeAsync,
                              root, cursor, CurrentTime);
        if (status == GrabSuccess) {
            XEvent event;
            XAllowEvents(display, SyncPointer, CurrentTime);
            XWindowEvent(display, root, ButtonPressMask, &event);
            if (event.type == ButtonPress) {
                XQueryPointer(display, root,
                              &root_return, &child_return,
                              &root_x, &root_y,
                              &win_x, &win_y,
                              &mask);
                target_window = child_return;
            }
        }
        XUngrabPointer(display, CurrentTime);
        XFreeCursor(display, cursor);
    }
    if (target_window != 0) {
        XWindowAttributes attrs;
        if (XGetWindowAttributes(display, target_window, &attrs)) {
            Napi::Object dimensions = Napi::Object::New(env);
            dimensions.Set("x", attrs.x);
            dimensions.Set("y", attrs.y);
            dimensions.Set("width", attrs.width);
            dimensions.Set("height", attrs.height);
            allInfo.Set("dimensions", dimensions);
        }
        char* window_name;
        if (XFetchName(display, target_window, &window_name) && window_name) {
            allInfo.Set("name", Napi::String::New(env, window_name));
            XFree(window_name);
        } else {
            allInfo.Set("name", Napi::String::New(env, "Unknown"));
        }
        XClassHint class_hint;
        if (XGetClassHint(display, target_window, &class_hint)) {
            Napi::Object classInfo = Napi::Object::New(env);
            classInfo.Set("class", Napi::String::New(env, class_hint.res_class ? class_hint.res_class : "Unknown"));
            classInfo.Set("instance", Napi::String::New(env, class_hint.res_name ? class_hint.res_name : "Unknown"));
            allInfo.Set("class", classInfo);
            if (class_hint.res_class) XFree(class_hint.res_class);
            if (class_hint.res_name) XFree(class_hint.res_name);
        } else {
            Napi::Object classInfo = Napi::Object::New(env);
            classInfo.Set("class", Napi::String::New(env, "Unknown"));
            classInfo.Set("instance", Napi::String::New(env, "Unknown"));
            allInfo.Set("class", classInfo);
        }
        allInfo.Set("state", Napi::String::New(env, "Unknown"));
    } else {
        Napi::Error::New(env, "No window selected").ThrowAsJavaScriptException();
    }
    XCloseDisplay(display);
    return allInfo;
}

Napi::Object GetAllWindowInfo(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    Napi::Object allInfo = Napi::Object::New(env);
    if (info.Length() < 1 || !info[0].IsNumber()) {
        Napi::TypeError::New(env, "Window ID required").ThrowAsJavaScriptException();
        return allInfo;
    }
    allInfo.Set("dimensions", GetWindowDimensions(info));
    allInfo.Set("name", GetWindowName(info));
    allInfo.Set("class", GetWindowClass(info));
    allInfo.Set("state", GetWindowState(info));
    return allInfo;
}

// ---------------------------------------------------------------------
// Extended window info collection for GetWindowList

void CollectWindowInfo(Display* display, Window window, std::vector<WindowInfo>& results, const std::string& current_display_name) {
    XWindowAttributes attrs;
    if (!XGetWindowAttributes(display, window, &attrs))
        return;

    WindowInfo info;
    info.windowId = window;
    info.display_name = current_display_name; // Store the display name

    // Basic info: name & class
    {
        char* name = nullptr;
        if (XFetchName(display, window, &name) && name) {
            info.name = name;
            XFree(name);
        }
        info.className = GetWindowClassName(display, window);
    }

    // Geometry & visibility
    info.x = attrs.x;
    info.y = attrs.y;
    info.width = attrs.width;
    info.height = attrs.height;
    info.visible = (attrs.map_state == IsViewable);

    // Extra attributes from XWindowAttributes
    info.borderWidth = attrs.border_width;
    info.depth = attrs.depth;
    info.colormap = attrs.colormap;

    // WM hints via XGetWMHints
    XWMHints* hints = XGetWMHints(display, window);
    if (hints) {
        info.wmFlags = hints->flags;
        info.wmInput = (hints->flags & InputHint) ? hints->input : false;
        info.wmInitialState = (hints->flags & StateHint) ? hints->initial_state : -1;
        info.wmIconWindow = (hints->flags & IconWindowHint) ? hints->icon_window : 0;
        info.wmIconPixmap = (hints->flags & IconPixmapHint) ? hints->icon_pixmap : 0;
        info.wmIconMask = (hints->flags & IconMaskHint) ? hints->icon_mask : 0;
        info.wmWindowGroup = (hints->flags & WindowGroupHint) ? hints->window_group : 0;
        XFree(hints);
    } else {
        info.wmFlags = 0;
        info.wmInput = false;
        info.wmInitialState = -1;
        info.wmIconWindow = 0;
        info.wmIconPixmap = 0;
        info.wmIconMask = 0;
        info.wmWindowGroup = 0;
    }

    // Normal hints via XGetWMNormalHints
    XSizeHints sizeHints;
    long supplied = 0;
    if (XGetWMNormalHints(display, window, &sizeHints, &supplied)) {
        if (supplied & PMinSize) {
            info.minWidth = sizeHints.min_width;
            info.minHeight = sizeHints.min_height;
        } else {
            info.minWidth = info.minHeight = 0;
        }
        if (supplied & PMaxSize) {
            info.maxWidth = sizeHints.max_width;
            info.maxHeight = sizeHints.max_height;
        } else {
            info.maxWidth = info.maxHeight = 0;
        }
        if (supplied & PResizeInc) {
            info.widthInc = sizeHints.width_inc;
            info.heightInc = sizeHints.height_inc;
        } else {
            info.widthInc = info.heightInc = 0;
        }
        if (supplied & PBaseSize) {
            info.baseWidth = sizeHints.base_width;
            info.baseHeight = sizeHints.base_height;
        } else {
            info.baseWidth = info.baseHeight = 0;
        }
    } else {
        info.minWidth = info.minHeight = info.maxWidth = info.maxHeight = 0;
        info.widthInc = info.heightInc = info.baseWidth = info.baseHeight = 0;
    }

    // Extended properties: _NET_WM_STATE
    {
        Atom netWmStateAtom = XInternAtom(display, "_NET_WM_STATE", False);
        Atom actualType;
        int actualFormat;
        unsigned long nitems, bytesAfter;
        unsigned char* prop = NULL;
        if (XGetWindowProperty(display, window, netWmStateAtom, 0, (~0L), False, XA_ATOM,
                               &actualType, &actualFormat, &nitems, &bytesAfter, &prop) == Success && prop) {
            Atom* atoms = (Atom*)prop;
            for (unsigned long j = 0; j < nitems; j++) {
                char* atomName = XGetAtomName(display, atoms[j]);
                if (atomName) {
                    info.netWmState.push_back(std::string(atomName));
                    XFree(atomName);
                }
            }
            XFree(prop);
        }
    }

    // Extended properties: _NET_WM_WINDOW_TYPE
    {
        Atom netWmWindowTypeAtom = XInternAtom(display, "_NET_WM_WINDOW_TYPE", False);
        Atom actualType;
        int actualFormat;
        unsigned long nitems, bytesAfter;
        unsigned char* prop = NULL;
        if (XGetWindowProperty(display, window, netWmWindowTypeAtom, 0, (~0L), False, XA_ATOM,
                               &actualType, &actualFormat, &nitems, &bytesAfter, &prop) == Success && prop) {
            Atom* atoms = (Atom*)prop;
            for (unsigned long j = 0; j < nitems; j++) {
                char* atomName = XGetAtomName(display, atoms[j]);
                if (atomName) {
                    info.netWmWindowType.push_back(std::string(atomName));
                    XFree(atomName);
                }
            }
            XFree(prop);
        }
    }

    // Extended property: _NET_WM_PID
    {
        Atom netWmPidAtom = XInternAtom(display, "_NET_WM_PID", False);
        Atom actualType;
        int actualFormat;
        unsigned long nitems, bytesAfter;
        unsigned char* prop = NULL;
        if (XGetWindowProperty(display, window, netWmPidAtom, 0, 1, False, XA_CARDINAL,
                               &actualType, &actualFormat, &nitems, &bytesAfter, &prop) == Success && prop && nitems == 1) {
            info.netWmPid = *((unsigned long*)prop);
            info.hasNetWmPid = true;
            XFree(prop);
        } else {
            info.netWmPid = 0;
            info.hasNetWmPid = false;
        }
    }

    results.push_back(info);

    // Recurse for child windows
    Window root_return, parent_return;
    Window* children = nullptr;
    unsigned int nchildren = 0;
    if (XQueryTree(display, window, &root_return, &parent_return, &children, &nchildren)) {
        for (unsigned int i = 0; i < nchildren; i++) {
            CollectWindowInfo(display, children[i], results, current_display_name); // Pass display name to recursive calls
        }
        if (children) {
            XFree(children);
        }
    }
}

// New function: Get list of windows (filtered) with as much info as possible
// In this example, we only include windows with class "Tibia" and dimensions > 100x100.
Napi::Array GetWindowList(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    Napi::Array windowArray = Napi::Array::New(env);
    std::vector<WindowInfo> all_results;

    // Iterate through common display numbers
    for (int i = 0; i <= 10; ++i) {
        std::string display_name = ":" + std::to_string(i);
        Display* display = XOpenDisplay(display_name.c_str());
        if (!display) {
            // Display not found or cannot be opened, try next
            continue;
        }

        Window root = DefaultRootWindow(display);
        CollectWindowInfo(display, root, all_results, display_name); // Pass display name
        XCloseDisplay(display);
    }

    uint32_t index = 0;
    for (size_t i = 0; i < all_results.size(); i++) {
        // Filter: only include if name contains "Tibia" and dimensions > 100x100
        if (all_results[i].name.find("Tibia") != std::string::npos && all_results[i].width > 100 && all_results[i].height > 100) {
            Napi::Object obj = Napi::Object::New(env);
            obj.Set("windowId", Napi::Number::New(env, (double)all_results[i].windowId));
            obj.Set("name", Napi::String::New(env, all_results[i].name));
            obj.Set("class", Napi::String::New(env, all_results[i].className));
            obj.Set("display", Napi::String::New(env, all_results[i].display_name)); // Add display name

            // Geometry & basic attributes
            Napi::Object dimensions = Napi::Object::New(env);
            dimensions.Set("x", Napi::Number::New(env, all_results[i].x));
            dimensions.Set("y", Napi::Number::New(env, all_results[i].y));
            dimensions.Set("width", Napi::Number::New(env, all_results[i].width));
            dimensions.Set("height", Napi::Number::New(env, all_results[i].height));
            dimensions.Set("visible", Napi::Boolean::New(env, all_results[i].visible));
            dimensions.Set("borderWidth", Napi::Number::New(env, all_results[i].borderWidth));
            dimensions.Set("depth", Napi::Number::New(env, all_results[i].depth));
            dimensions.Set("colormap", Napi::Number::New(env, all_results[i].colormap));
            obj.Set("dimensions", dimensions);

            // WM hints
            Napi::Object wmHints = Napi::Object::New(env);
            wmHints.Set("wmFlags", Napi::Number::New(env, all_results[i].wmFlags));
            wmHints.Set("wmInput", Napi::Boolean::New(env, all_results[i].wmInput));
            wmHints.Set("wmInitialState", Napi::Number::New(env, all_results[i].wmInitialState));
            wmHints.Set("wmIconWindow", Napi::Number::New(env, (double)all_results[i].wmIconWindow));
            wmHints.Set("wmIconPixmap", Napi::Number::New(env, (double)all_results[i].wmIconPixmap));
            wmHints.Set("wmIconMask", Napi::Number::New(env, (double)all_results[i].wmIconMask));
            wmHints.Set("wmWindowGroup", Napi::Number::New(env, (double)all_results[i].wmWindowGroup));
            obj.Set("wmHints", wmHints);

            // Normal hints
            Napi::Object normalHints = Napi::Object::New(env);
            normalHints.Set("minWidth", Napi::Number::New(env, all_results[i].minWidth));
            normalHints.Set("minHeight", Napi::Number::New(env, all_results[i].minHeight));
            normalHints.Set("maxWidth", Napi::Number::New(env, all_results[i].maxWidth));
            normalHints.Set("maxHeight", Napi::Number::New(env, all_results[i].maxHeight));
            normalHints.Set("widthInc", Napi::Number::New(env, all_results[i].widthInc));
            normalHints.Set("heightInc", Napi::Number::New(env, all_results[i].heightInc));
            normalHints.Set("baseWidth", Napi::Number::New(env, all_results[i].baseWidth));
            normalHints.Set("baseHeight", Napi::Number::New(env, all_results[i].baseHeight));
            obj.Set("normalHints", normalHints);

            // Extended properties
            Napi::Array netWmStateArr = Napi::Array::New(env, all_results[i].netWmState.size());
            for (size_t j = 0; j < all_results[i].netWmState.size(); j++) {
                netWmStateArr.Set(j, Napi::String::New(env, all_results[i].netWmState[j]));
            }
            obj.Set("netWmState", netWmStateArr);

            Napi::Array netWmWindowTypeArr = Napi::Array::New(env, all_results[i].netWmWindowType.size());
            for (size_t j = 0; j < all_results[i].netWmWindowType.size(); j++) {
                netWmWindowTypeArr.Set(j, Napi::String::New(env, all_results[i].netWmWindowType[j]));
            }
            obj.Set("netWmWindowType", netWmWindowTypeArr);

            if (all_results[i].hasNetWmPid) {
                obj.Set("netWmPid", Napi::Number::New(env, all_results[i].netWmPid));
            }
            windowArray.Set(index++, obj);
        }
    }
    return windowArray;
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
    exports.Set("getDimensions", Napi::Function::New(env, GetWindowDimensions));
    exports.Set("getName", Napi::Function::New(env, GetWindowName));
    exports.Set("getClass", Napi::Function::New(env, GetWindowClass));
    exports.Set("getState", Napi::Function::New(env, GetWindowState));
    exports.Set("getAllInfo", Napi::Function::New(env, GetAllWindowInfo));
    exports.Set("getActiveWindow", Napi::Function::New(env, GetActiveWindow));
    exports.Set("getWindowIdByClick", Napi::Function::New(env, GetWindowIdByClick));
    exports.Set("getWindowInfoByClick", Napi::Function::New(env, GetWindowInfoByClick));
    exports.Set("getWindowList", Napi::Function::New(env, GetWindowList));
    return exports;
}

NODE_API_MODULE(windowinfo, Init)

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/windowInfo/test.js
//start file
const windowinfo = require("./build/Release/windowinfo");

try {
	const windowList = windowinfo.getWindowList();
	console.log(windowList);
} catch (error) {
	console.error("Error:", error.message);
}

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/windowInfo/wrapper.js
//start file
const windowinfoNative = require('./build/Release/windowinfo.node');
module.exports = windowinfoNative;

//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/x11RegionCapture/src/x11RegionCapture.cc
//start file
// @x11RegionCapture.cc (Final Corrected Version)
#include <napi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <xcb/xcb.h>
#include <xcb/shm.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <stdint.h>
#include <atomic>
#include <thread>
#include <mutex>
#include <chrono>
#include <algorithm>
#include <system_error>
#include <memory>
#include <vector>
#include <condition_variable>

#ifdef __AVX2__
#include <immintrin.h>
#endif

// ... (structs and helper functions are unchanged) ...
typedef struct {
    xcb_shm_seg_t shmseg;
    uint8_t *data;
    uint64_t size;
    int shmid;
} shm_segment_info_t;

void free_segment_info(shm_segment_info_t *segment) { if (segment) free(segment); }
void cleanup_shm(xcb_connection_t *connection, shm_segment_info_t *segment) {
    if (!segment) return;
    if (connection && segment->shmseg != XCB_NONE) xcb_shm_detach(connection, segment->shmseg);
    if (segment->data != nullptr && segment->data != (void*)-1) shmdt(segment->data);
    free_segment_info(segment);
}
shm_segment_info_t* init_shm(xcb_connection_t *connection, uint64_t requested_size) {
    uint64_t size = 1;
    while (size < requested_size) size *= 2;
    size = std::max(size, static_cast<uint64_t>(4096));

    shm_segment_info_t *segment = static_cast<shm_segment_info_t*>(malloc(sizeof(shm_segment_info_t)));
    if (!segment) { perror("Failed to allocate segment info"); return nullptr; }
    segment->data = nullptr; segment->shmseg = XCB_NONE; segment->shmid = -1; segment->size = 0;
    segment->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0600);
    if (segment->shmid == -1) { perror("shmget failed"); free_segment_info(segment); return nullptr; }
    segment->data = static_cast<uint8_t*>(shmat(segment->shmid, nullptr, 0));
    if (segment->data == reinterpret_cast<void*>(-1)) { perror("shmat failed"); shmctl(segment->shmid, IPC_RMID, nullptr); free_segment_info(segment); return nullptr; }
    if (shmctl(segment->shmid, IPC_RMID, nullptr) == -1) { perror("shmctl(IPC_RMID) failed"); shmdt(segment->data); free_segment_info(segment); return nullptr; }
    segment->shmseg = xcb_generate_id(connection);
    segment->size = size;
    xcb_void_cookie_t attach_cookie = xcb_shm_attach_checked(connection, segment->shmseg, segment->shmid, 0);
    xcb_generic_error_t *error = xcb_request_check(connection, attach_cookie);
    if (error) { fprintf(stderr, "XCB SHM attach failed: error code %d\n", error->error_code); free(error); shmdt(segment->data); free_segment_info(segment); return nullptr; }
    return segment;
}

struct Rect { int x, y, width, height; };

class X11RegionCapture : public Napi::ObjectWrap<X11RegionCapture> {
public:
    static Napi::Object Init(Napi::Env env, Napi::Object exports);
    X11RegionCapture(const Napi::CallbackInfo& info);
    ~X11RegionCapture();

private:
    // ... (member variables are unchanged) ...
    static const int MAX_DIMENSION = 32767; static const int DEFAULT_FPS = 60;
    static const int MIN_FPS = 1; static const int MAX_FPS = 1000;
    static const size_t IMAGE_HEADER_SIZE = 8;
    xcb_connection_t *connection; shm_segment_info_t *shm_segment;
    std::atomic<bool> is_connected; std::atomic<bool> should_capture; std::atomic<bool> is_capturing;
    std::thread capture_thread; xcb_window_t target_window_id;
    std::chrono::microseconds target_frame_time_us; std::string display_name;
    std::unique_ptr<uint8_t[]> buffer_a; std::unique_ptr<uint8_t[]> buffer_b;
    std::atomic<uint8_t*> readable_buffer_ptr; uint8_t* writable_buffer_ptr;
    std::mutex buffer_mutex; uint64_t frame_buffer_size;
    uint64_t latest_capture_timestamp_us;
    std::atomic<uint32_t> latest_width; std::atomic<uint32_t> latest_height;
    std::vector<Rect> latest_dirty_rects;
    std::mutex timing_mutex;
    std::condition_variable cv;

    // ... (unchanged methods) ...
    bool CheckSHM();
    void Connect();
    void Cleanup();
    bool EnsureBufferSizes(uint32_t width, uint32_t height);
    void CoalesceSegment(int start_x, int end_x, int y, std::vector<Rect>& active_rects, std::vector<Rect>& new_active_rects);
#ifdef __AVX2__
    void DiffFramesAVX2(const uint8_t* prev_frame, const uint8_t* curr_frame, int width, int height, std::vector<Rect>& out_rects);
#endif
    void DiffFramesScalar(const uint8_t* prev_frame, const uint8_t* curr_frame, int width, int height, std::vector<Rect>& out_rects);
    void DiffFrames(const uint8_t* prev_frame, const uint8_t* curr_frame, int width, int height, std::vector<Rect>& out_rects);
    void StopCaptureThread();
    Napi::Value IsConnected(const Napi::CallbackInfo& info);
    Napi::Value StartMonitorInstance(const Napi::CallbackInfo& info);
    Napi::Value StopMonitorInstance(const Napi::CallbackInfo& info);
    Napi::Value GetLatestFrame(const Napi::CallbackInfo& info);

    void CaptureLoop();
};

// ... (Init, constructor, destructor, and other helpers are unchanged) ...
Napi::Object X11RegionCapture::Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, "X11RegionCapture", {
        InstanceMethod("startMonitorInstance", &X11RegionCapture::StartMonitorInstance),
        InstanceMethod("stopMonitorInstance", &X11RegionCapture::StopMonitorInstance),
        InstanceMethod("getLatestFrame", &X11RegionCapture::GetLatestFrame),
        InstanceMethod("isConnected", &X11RegionCapture::IsConnected)
    });
    Napi::FunctionReference* constructor = new Napi::FunctionReference();
    *constructor = Napi::Persistent(func);
    env.SetInstanceData(constructor);
    exports.Set("X11RegionCapture", func);
    return exports;
}
X11RegionCapture::X11RegionCapture(const Napi::CallbackInfo& info) : Napi::ObjectWrap<X11RegionCapture>(info) {
    connection = nullptr; shm_segment = nullptr; is_connected = false;
    should_capture = false; is_capturing = false; target_window_id = XCB_NONE;
    target_frame_time_us = std::chrono::microseconds(1000000 / 60);
    display_name = "";
    if (info.Length() > 0 && info[0].IsString()) display_name = info[0].As<Napi::String>().Utf8Value();
    readable_buffer_ptr = nullptr; writable_buffer_ptr = nullptr; frame_buffer_size = 0;
    latest_capture_timestamp_us = 0; latest_width = 0; latest_height = 0;
    Connect();
}
X11RegionCapture::~X11RegionCapture() { StopCaptureThread(); Cleanup(); }
bool X11RegionCapture::CheckSHM() {
    if (!connection) return false;
    const xcb_query_extension_reply_t* shm_ext = xcb_get_extension_data(connection, &xcb_shm_id);
    return shm_ext && shm_ext->present;
}
void X11RegionCapture::Connect() {
    Cleanup(); int screen_num;
    connection = xcb_connect(display_name.empty() ? NULL : display_name.c_str(), &screen_num);
    if (!connection || xcb_connection_has_error(connection)) {
        if (connection) xcb_disconnect(connection);
        connection = nullptr; is_connected = false; return;
    }
    xcb_prefetch_extension_data(connection, &xcb_shm_id);
    if (!CheckSHM()) { Cleanup(); return; }
    is_connected = true;
}
void X11RegionCapture::Cleanup() {
    StopCaptureThread();
    if (shm_segment) { cleanup_shm(connection, shm_segment); shm_segment = nullptr; }
    { std::lock_guard<std::mutex> lock(buffer_mutex); buffer_a.reset(); buffer_b.reset();
      readable_buffer_ptr = nullptr; writable_buffer_ptr = nullptr; frame_buffer_size = 0;
      latest_dirty_rects.clear();
    }
    if (connection) { xcb_disconnect(connection); connection = nullptr; }
    is_connected = false; target_window_id = XCB_NONE;
}
bool X11RegionCapture::EnsureBufferSizes(uint32_t width, uint32_t height) {
    if (!connection) return false;
    uint64_t required_shm_size = static_cast<uint64_t>(width) * height * 4;
    uint64_t required_frame_buffer_size = required_shm_size + IMAGE_HEADER_SIZE;
    if (!shm_segment || shm_segment->size < required_shm_size) {
        if (shm_segment) cleanup_shm(connection, shm_segment);
        shm_segment = init_shm(connection, required_shm_size);
        if (!shm_segment) { fprintf(stderr, "Error: Failed to initialize SHM segment.\n"); return false; }
    }
    if (frame_buffer_size < required_frame_buffer_size) {
        std::lock_guard<std::mutex> lock(buffer_mutex);
        try {
            uint64_t new_size = 1;
            while (new_size < required_frame_buffer_size) new_size *= 2;
            buffer_a.reset(new uint8_t[new_size]);
            buffer_b.reset(new uint8_t[new_size]);
            frame_buffer_size = new_size;
        } catch (const std::bad_alloc& e) { fprintf(stderr, "Error: Failed to allocate frame buffers: %s\n", e.what()); return false; }
        readable_buffer_ptr = buffer_a.get(); writable_buffer_ptr = buffer_b.get();
        latest_dirty_rects.clear();
    }
    return true;
}
void X11RegionCapture::CoalesceSegment(int start_x, int end_x, int y, std::vector<Rect>& active_rects, std::vector<Rect>& new_active_rects) {
    bool merged = false;
    for (auto it = active_rects.begin(); it != active_rects.end(); ) {
        if (start_x < it->x + it->width && end_x > it->x) {
            int new_x = std::min(start_x, it->x);
            it->width = std::max(end_x, it->x + it->width) - new_x;
            it->x = new_x;
            it->height++;
            new_active_rects.push_back(*it);
            it = active_rects.erase(it);
            merged = true;
            break;
        } else {
            ++it;
        }
    }
    if (!merged) {
        new_active_rects.push_back({start_x, y, end_x - start_x, 1});
    }
}

// --- [MODIFIED] --- DiffFrames now writes to an output vector instead of the class member.
#ifdef __AVX2__
void X11RegionCapture::DiffFramesAVX2(const uint8_t* prev_frame, const uint8_t* curr_frame, int width, int height, std::vector<Rect>& out_rects) {
    out_rects.clear();
    if (!prev_frame || !curr_frame) {
        out_rects.push_back({0, 0, width, height});
        return;
    }
    // ... (rest of the function is identical)
    const int stride = width * 4;
    const int pixels_per_avx = 8;
    const int avx_width_limit = width - (width % pixels_per_avx);
    std::vector<Rect> active_rects;
    for (int y = 0; y < height; ++y) {
        const uint8_t* p1_row = prev_frame + y * stride;
        const uint8_t* p2_row = curr_frame + y * stride;
        if (memcmp(p1_row, p2_row, stride) == 0) {
            for (const auto& rect : active_rects) out_rects.push_back(rect);
            active_rects.clear();
            continue;
        }
        std::vector<Rect> new_active_rects;
        int current_dirty_start_x = -1;
        for (int x = 0; x < avx_width_limit; x += pixels_per_avx) {
            __m256i v1 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(p1_row + x * 4));
            __m256i v2 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(p2_row + x * 4));
            int mask = _mm256_movemask_epi8(_mm256_cmpeq_epi32(v1, v2));
            bool all_same = (mask == 0xFFFFFFFF);
            if (!all_same && current_dirty_start_x == -1) {
                current_dirty_start_x = x;
            } else if (all_same && current_dirty_start_x != -1) {
                CoalesceSegment(current_dirty_start_x, x, y, active_rects, new_active_rects);
                current_dirty_start_x = -1;
            }
        }
        for (int x = avx_width_limit; x < width; ++x) {
            bool pixel_diff = (*reinterpret_cast<const uint32_t*>(p1_row + x * 4) != *reinterpret_cast<const uint32_t*>(p2_row + x * 4));
            if (pixel_diff && current_dirty_start_x == -1) {
                current_dirty_start_x = x;
            } else if (!pixel_diff && current_dirty_start_x != -1) {
                CoalesceSegment(current_dirty_start_x, x, y, active_rects, new_active_rects);
                current_dirty_start_x = -1;
            }
        }
        if (current_dirty_start_x != -1) {
            CoalesceSegment(current_dirty_start_x, width, y, active_rects, new_active_rects);
        }
        for (const auto& rect : active_rects) out_rects.push_back(rect);
        active_rects = new_active_rects;
    }
    for (const auto& rect : active_rects) out_rects.push_back(rect);
}
#endif
void X11RegionCapture::DiffFramesScalar(const uint8_t* prev_frame, const uint8_t* curr_frame, int width, int height, std::vector<Rect>& out_rects) {
    out_rects.clear();
    if (!prev_frame || !curr_frame) {
        out_rects.push_back({0, 0, width, height});
        return;
    }
    // ... (rest of the function is identical)
    const int stride = width * 4;
    std::vector<Rect> active_rects;
    for (int y = 0; y < height; ++y) {
        const uint8_t* p1_row = prev_frame + y * stride;
        const uint8_t* p2_row = curr_frame + y * stride;
        if (memcmp(p1_row, p2_row, stride) == 0) {
            for (const auto& rect : active_rects) out_rects.push_back(rect);
            active_rects.clear();
            continue;
        }
        std::vector<Rect> new_active_rects;
        int x = 0;
        while (x < width) {
            const uint64_t* p1_64 = reinterpret_cast<const uint64_t*>(p1_row + x * 4);
            const uint64_t* p2_64 = reinterpret_cast<const uint64_t*>(p2_row + x * 4);
            int start_x = -1;
            while (x < width) {
                if (x + 1 < width) {
                    if (*p1_64 != *p2_64) { start_x = x; break; }
                    p1_64++; p2_64++; x += 2;
                } else {
                    if (*reinterpret_cast<const uint32_t*>(p1_64) != *reinterpret_cast<const uint32_t*>(p2_64)) { start_x = x; }
                    x++; break;
                }
            }
            if (start_x == -1) break;
            int end_x = start_x;
            while (x < width) {
                if (x + 1 < width) {
                    if (*p1_64 == *p2_64) { end_x = x; break; }
                    p1_64++; p2_64++; x += 2;
                } else {
                    if (*reinterpret_cast<const uint32_t*>(p1_64) == *reinterpret_cast<const uint32_t*>(p2_64)) { end_x = x; } else { end_x = x + 1; }
                    x++; break;
                }
            }
            if (end_x <= start_x) end_x = width;
            CoalesceSegment(start_x, end_x, y, active_rects, new_active_rects);
            x = end_x;
        }
        for (const auto& rect : active_rects) out_rects.push_back(rect);
        active_rects = new_active_rects;
    }
    for (const auto& rect : active_rects) out_rects.push_back(rect);
}
void X11RegionCapture::DiffFrames(const uint8_t* prev_frame, const uint8_t* curr_frame, int width, int height, std::vector<Rect>& out_rects) {
#ifdef __AVX2__
    DiffFramesAVX2(prev_frame, curr_frame, width, height, out_rects);
#else
    DiffFramesScalar(prev_frame, curr_frame, width, height, out_rects);
#endif
}

void X11RegionCapture::CaptureLoop() {
    is_capturing = true;
    bool first_frame = true;
    uint32_t current_width = 0, current_height = 0;

    if (should_capture) {
        xcb_get_geometry_cookie_t geom_cookie = xcb_get_geometry(connection, target_window_id);
        xcb_get_geometry_reply_t *geom_reply = xcb_get_geometry_reply(connection, geom_cookie, NULL);
        if (geom_reply) {
            latest_width = geom_reply->width;
            latest_height = geom_reply->height;
            free(geom_reply);
        }
    }

    auto next_frame_time = std::chrono::steady_clock::now();

    while (should_capture) {
        next_frame_time += target_frame_time_us;
        std::unique_lock<std::mutex> lock(timing_mutex);
        if (!cv.wait_until(lock, next_frame_time, [this]{ return !should_capture.load(); })) {
            if (!should_capture) break;

            // ... (event polling and dimension checking is unchanged) ...
            xcb_generic_event_t *event;
            while ((event = xcb_poll_for_event(connection))) {
                if ((event->response_type & ~0x80) == XCB_CONFIGURE_NOTIFY) {
                    xcb_configure_notify_event_t *cfg = (xcb_configure_notify_event_t *)event;
                    if (cfg->window == target_window_id) {
                        latest_width.store(cfg->width);
                        latest_height.store(cfg->height);
                    }
                }
                free(event);
            }
            if (!connection || xcb_connection_has_error(connection)) {
                Connect();
                std::this_thread::sleep_for(std::chrono::seconds(1));
                continue;
            }
            uint32_t width = latest_width.load();
            uint32_t height = latest_height.load();
            if (width < 1 || height < 1 || width > MAX_DIMENSION || height > MAX_DIMENSION) continue;
            bool dimensions_changed = (current_width != width || current_height != height);
            if (dimensions_changed) {
                current_width = width;
                current_height = height;
                if (!EnsureBufferSizes(width, height)) {
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                    continue;
                }
            }

            xcb_shm_get_image_cookie_t img_cookie = xcb_shm_get_image(
                connection, target_window_id, 0, 0, width, height, ~0,
                XCB_IMAGE_FORMAT_Z_PIXMAP, shm_segment->shmseg, 0);
            xcb_shm_get_image_reply_t *img_reply = xcb_shm_get_image_reply(connection, img_cookie, NULL);

            if (img_reply) {
                uint8_t* bgra_data_from_shm = shm_segment->data;
                uint64_t bgra_data_size = static_cast<uint64_t>(width) * height * 4;
                memcpy(writable_buffer_ptr, &width, sizeof(uint32_t));
                memcpy(writable_buffer_ptr + 4, &height, sizeof(uint32_t));
                memcpy(writable_buffer_ptr + IMAGE_HEADER_SIZE, bgra_data_from_shm, bgra_data_size);
                uint64_t timestamp = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch()).count();

                std::vector<Rect> current_frame_rects;
                uint8_t* current_image_data = writable_buffer_ptr + IMAGE_HEADER_SIZE;
                uint8_t* previous_image_data = readable_buffer_ptr.load();
                if (previous_image_data) previous_image_data += IMAGE_HEADER_SIZE;

                if (first_frame || dimensions_changed) {
                    current_frame_rects.push_back({0, 0, (int)width, (int)height});
                    first_frame = false;
                } else {
                    DiffFrames(previous_image_data, current_image_data, width, height, current_frame_rects);
                }

                {
                    std::lock_guard<std::mutex> buffer_lock(buffer_mutex);
                    // --- [FIXED] --- Accumulate new rects instead of replacing.
                    if (!current_frame_rects.empty()) {
                        latest_dirty_rects.insert(latest_dirty_rects.end(), current_frame_rects.begin(), current_frame_rects.end());
                    }

                    uint8_t* previously_readable = readable_buffer_ptr.exchange(writable_buffer_ptr);
                    writable_buffer_ptr = previously_readable;
                    latest_capture_timestamp_us = timestamp;
                }

                free(img_reply);
            }
        }
    }
    is_capturing = false;
}

Napi::Value X11RegionCapture::GetLatestFrame(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    Napi::Object result = Napi::Object::New(env);
    if (info.Length() < 1 || !info[0].IsBuffer()) { Napi::TypeError::New(env, "Expected a Buffer as the first argument").ThrowAsJavaScriptException(); result.Set("success", Napi::Boolean::New(env, false)); return result; }
    Napi::Buffer<uint8_t> targetBuffer = info[0].As<Napi::Buffer<uint8_t>>();
    uint8_t* source_ptr = readable_buffer_ptr.load();
    if (!source_ptr) { result.Set("success", Napi::Boolean::New(env, false)); return result; }

    uint64_t source_size; uint64_t timestamp;
    uint32_t width = latest_width.load();
    uint32_t height = latest_height.load();
    Napi::Array changedRegions = Napi::Array::New(env);

    {
        std::lock_guard<std::mutex> lock(buffer_mutex);
        if (readable_buffer_ptr.load() != source_ptr) { result.Set("success", Napi::Boolean::New(env, false)); return result; }

        source_size = static_cast<uint64_t>(width) * height * 4 + IMAGE_HEADER_SIZE;
        timestamp = latest_capture_timestamp_us;

        if (targetBuffer.Length() < source_size) {
            result.Set("success", Napi::Boolean::New(env, false));
            result.Set("reason", Napi::String::New(env, "Target buffer too small."));
            return result;
        }
        memcpy(targetBuffer.Data(), source_ptr, source_size);
        for (size_t i = 0; i < latest_dirty_rects.size(); ++i) {
            const auto& rect = latest_dirty_rects[i];
            Napi::Object regionObj = Napi::Object::New(env);
            regionObj.Set("x", Napi::Number::New(env, rect.x));
            regionObj.Set("y", Napi::Number::New(env, rect.y));
            regionObj.Set("width", Napi::Number::New(env, rect.width));
            regionObj.Set("height", Napi::Number::New(env, rect.height));
            changedRegions[i] = regionObj;
        }

        // --- [FIXED] --- Acknowledge and clear the queue after reading.
        latest_dirty_rects.clear();
    }

    result.Set("success", Napi::Boolean::New(env, true));
    result.Set("width", Napi::Number::New(env, width));
    result.Set("height", Napi::Number::New(env, height));
    result.Set("captureTimestampUs", Napi::Number::New(env, static_cast<double>(timestamp)));
    result.Set("changedRegions", changedRegions);
    return result;
}

// ... (StopMonitorInstance, IsConnected, and module Init are unchanged) ...
void X11RegionCapture::StopCaptureThread() {
    should_capture = false;
    cv.notify_all();
    if (capture_thread.joinable()) {
        try { capture_thread.join(); }
        catch (const std::system_error& e) { fprintf(stderr, "Error joining capture thread: %s\n", e.what()); }
    }
    is_capturing = false;
}
Napi::Value X11RegionCapture::IsConnected(const Napi::CallbackInfo& info) { return Napi::Boolean::New(info.Env(), is_connected.load()); }
Napi::Value X11RegionCapture::StartMonitorInstance(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1 || !info[0].IsNumber()) { Napi::TypeError::New(env, "Window ID (Number) expected").ThrowAsJavaScriptException(); return env.Null(); }
    uint32_t windowId = info[0].As<Napi::Number>().Uint32Value();
    uint32_t fps = (info.Length() > 1 && info[1].IsNumber()) ? info[1].As<Napi::Number>().Uint32Value() : DEFAULT_FPS;
    fps = std::max((uint32_t)MIN_FPS, std::min(fps, (uint32_t)MAX_FPS));
    if (is_capturing) { Napi::Error::New(env, "Monitoring is already running").ThrowAsJavaScriptException(); return env.Null(); }
    if (!is_connected) { Napi::Error::New(env, "Not connected to X server").ThrowAsJavaScriptException(); return env.Null(); }
    target_window_id = windowId; target_frame_time_us = std::chrono::microseconds(1000000 / fps);

    uint32_t values[] = { XCB_EVENT_MASK_STRUCTURE_NOTIFY };
    xcb_change_window_attributes(connection, target_window_id, XCB_CW_EVENT_MASK, values);
    xcb_flush(connection);

    StopCaptureThread(); should_capture = true;
    try { capture_thread = std::thread(&X11RegionCapture::CaptureLoop, this); }
    catch (const std::system_error& e) { should_capture = false; Napi::Error::New(env, std::string("Failed to create capture thread: ") + e.what()).ThrowAsJavaScriptException(); return env.Null(); }
    return env.Undefined();
}
Napi::Value X11RegionCapture::StopMonitorInstance(const Napi::CallbackInfo& info) { StopCaptureThread(); return info.Env().Undefined(); }
Napi::Object Init(Napi::Env env, Napi::Object exports) { return X11RegionCapture::Init(env, exports); }
NODE_API_MODULE(x11regioncapture, Init)
//endFile

// /home/feiron/Dokumenty/Automaton/nativeModules/x11RegionCapture/wrapper.js
//start file
const x11RegionCaptureNative = require('./build/Release/x11RegionCapture.node');
module.exports = x11RegionCaptureNative;

//endFile

