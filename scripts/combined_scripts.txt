// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/battleListSlice.js
//start file
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  entries: [], // Array of battle list entry objects
};

const battleListSlice = createSlice({
  name: 'battleList',
  initialState,
  reducers: {
    /**
     * Sets the entire battle list entries array.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     * @param {Array<object>} action.payload - An array of battle list entry objects.
     */
    setBattleListEntries: (state, action) => {
      state.entries = action.payload;
    },
    /**
     * Resets the battleList state to its initial empty state.
     */
    resetBattleList: (state) => {
      state.entries = initialState.entries;
    },
    /**
     * Replaces the entire slice state. Use with caution.
     * @param {object} state - The current state.
     * @param {object} action - The action containing the new state.
     */
    setState: (state, action) => {
      return action.payload;
    },
  },
});

export const { setBattleListEntries, resetBattleList, setState } =
  battleListSlice.actions;

export default battleListSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/cavebotSlice.js
//start file
// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/cavebotSlice.js
// --- SIMPLIFIED VERSION ---

import { createSlice } from '@reduxjs/toolkit';

const MAX_WAYPOINTS_PER_SECTION = 1000;

const parseLegacyCoordinates = (payload) => {
  if (typeof payload.coordinates === 'string') {
    const newPayload = { ...payload };
    const coords = newPayload.coordinates.split(',');
    coords.forEach((coord) => {
      const [key, value] = coord.split(':');
      if (key && value) {
        newPayload[key.trim()] = parseInt(value.trim(), 10);
      }
    });
    delete newPayload.coordinates;
    return newPayload;
  }
  return payload;
};

const initialState = {
  enabled: false,
  wptId: 'null',
  wptSelection: null,
  currentSection: 'default',
  standTime: 0,
  isActionPaused: false,
  scriptFeedback: null,
  waypointSections: {
    default: {
      name: 'Default',
      waypoints: [],
    },
  },
  specialAreas: [],
  pathfinderMode: 'cavebot', // 'cavebot' or 'targeting'
  dynamicTarget: null, // Holds {stance, distance, targetCreaturePos} for targeting mode
};

const cavebotSlice = createSlice({
  name: 'cavebot',
  initialState,
  reducers: {
    setenabled: (state, action) => {
      state.enabled = action.payload;
    },
    setActionPaused: (state, action) => {
      state.isActionPaused = action.payload;
    },
    setwptId: (state, action) => {
      const newWptId = action.payload;
      if (state.wptId !== newWptId) {
        state.wptId = newWptId;
        // Note: Path feedback is no longer cleared here, as it lives in a different slice.
      }
    },
    setwptSelection: (state, action) => {
      state.wptSelection = action.payload;
    },
    setState: (state, action) => {
      return { ...initialState, ...(action.payload || {}) };
    },
    setStandTime: (state, action) => {
      state.standTime = action.payload;
    },
    setScriptFeedback: (state, action) => {
      state.scriptFeedback = action.payload;
    },
    addWaypoint: (state, action) => {
      const currentWaypoints =
        state.waypointSections[state.currentSection].waypoints;
      if (currentWaypoints.length >= MAX_WAYPOINTS_PER_SECTION) {
        console.warn('Waypoint limit reached for this section.');
        return;
      }

      const parsedPayload = parseLegacyCoordinates(action.payload);
      const newWaypoint = {
        type: 'Node',
        label: '',
        x: 0,
        y: 0,
        z: 0,
        range: 5,
        script: '',
        log: [],
        ...parsedPayload,
        id: action.payload.id,
      };

      const selectedIndex = currentWaypoints.findIndex(
        (waypoint) => waypoint.id === state.wptSelection,
      );
      let newWaypointIndex;
      if (selectedIndex > -1) {
        newWaypointIndex = selectedIndex + 1;
        currentWaypoints.splice(newWaypointIndex, 0, newWaypoint);
      } else {
        currentWaypoints.push(newWaypoint);
        newWaypointIndex = currentWaypoints.length - 1;
      }
      if (currentWaypoints[newWaypointIndex]) {
        state.wptSelection = currentWaypoints[newWaypointIndex].id;
      }
    },
    addWaypointLogEntry: (state, action) => {
      const { id, message } = action.payload;
      const section = state.waypointSections[state.currentSection];
      if (!section) return;

      const waypoint = section.waypoints.find((wp) => wp.id === id);
      if (waypoint) {
        if (!Array.isArray(waypoint.log)) {
          waypoint.log = [];
        }
        const now = new Date();
        const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(3, '0')}`;
        waypoint.log.push(`[${timestamp}] ${message}`);

        const MAX_LOG_SIZE = 100;
        if (waypoint.log.length > MAX_LOG_SIZE) {
          waypoint.log.splice(0, waypoint.log.length - MAX_LOG_SIZE);
        }
      }
    },
    removeWaypoint: (state, action) => {
      const idToRemove = action.payload;
      const currentWaypoints =
        state.waypointSections[state.currentSection].waypoints;
      const indexToRemove = currentWaypoints.findIndex(
        (waypoint) => waypoint.id === idToRemove,
      );
      if (indexToRemove === -1) return;
      const isRemovingSelected = state.wptSelection === idToRemove;
      currentWaypoints.splice(indexToRemove, 1);

      if (isRemovingSelected) {
        if (currentWaypoints.length === 0) {
          state.wptSelection = null;
        } else if (indexToRemove > 0) {
          state.wptSelection = currentWaypoints[indexToRemove - 1].id;
        } else {
          state.wptSelection = currentWaypoints[0].id;
        }
      }
    },
    reorderWaypoints: (state, action) => {
      const { startIndex, endIndex } = action.payload;
      const currentWaypoints =
        state.waypointSections[state.currentSection].waypoints;
      const [removed] = currentWaypoints.splice(startIndex, 1);
      currentWaypoints.splice(endIndex, 0, removed);
    },
    updateWaypoint: (state, action) => {
      const { id, updates } = action.payload;
      const existingWaypoint = state.waypointSections[
        state.currentSection
      ].waypoints.find((waypoint) => waypoint.id === id);
      if (existingWaypoint) {
        const parsedUpdates = parseLegacyCoordinates(updates);
        Object.assign(existingWaypoint, parsedUpdates);
      }
    },
    addWaypointSection: (state, action) => {
      const { id, name } = action.payload;
      if (!state.waypointSections[id]) {
        state.waypointSections[id] = { name, waypoints: [] };
        state.currentSection = id;
      }
    },
    removeWaypointSection: (state, action) => {
      const idToRemove = action.payload;
      if (idToRemove === 'default') return;
      if (state.waypointSections[idToRemove]) {
        delete state.waypointSections[idToRemove];
        if (state.currentSection === idToRemove) {
          state.currentSection =
            Object.keys(state.waypointSections)[0] || 'default';
          if (!state.waypointSections[state.currentSection]) {
            state.waypointSections['default'] = {
              name: 'Default',
              waypoints: [],
            };
            state.currentSection = 'default';
          }
        }
      }
    },
    setCurrentWaypointSection: (state, action) => {
      const sectionId = action.payload;
      if (state.waypointSections[sectionId]) {
        state.currentSection = sectionId;
        state.wptSelection = null;
        state.wptId = 'null';
      }
    },
    renameWaypointSection: (state, action) => {
      const { id, name } = action.payload;
      if (state.waypointSections[id]) {
        state.waypointSections[id].name = name;
      }
    },
    addSpecialArea: (state, action) => {
      const newArea = {
        name: `Area ${state.specialAreas.length + 1}`,
        x: 0,
        y: 0,
        z: 0,
        sizeX: 1,
        sizeY: 1,
        avoidance: 100, // Standardized default avoidance cost
        type: 'cavebot',
        enabled: true,
        ...action.payload,
      };
      if (!newArea.id) return;
      if (state.specialAreas.some((area) => area.id === newArea.id)) return;
      if (state.specialAreas.some((area) => area.name === newArea.name)) return;
      state.specialAreas.push(newArea);
    },
    removeSpecialArea: (state, action) => {
      state.specialAreas = state.specialAreas.filter(
        (area) => area.id !== action.payload,
      );
    },
    updateSpecialArea: (state, action) => {
      const { id, updates } = action.payload;
      const existingArea = state.specialAreas.find((area) => area.id === id);
      if (existingArea) {
        if (
          updates.name &&
          state.specialAreas.some(
            (area) => area.id !== id && area.name === updates.name,
          )
        ) {
          delete updates.name;
        }
        Object.assign(existingArea, updates);
      }
    },
    setPathfinderMode: (state, action) => {
      state.pathfinderMode = action.payload;
    },
    setDynamicTarget: (state, action) => {
      state.dynamicTarget = action.payload;
    },
  },
});

export const {
  setenabled,
  setState,
  setwptId,
  setwptSelection,
  setStandTime,
  setScriptFeedback,
  addWaypoint,
  addWaypointLogEntry,
  removeWaypoint,
  reorderWaypoints,
  updateWaypoint,
  addWaypointSection,
  removeWaypointSection,
  setCurrentWaypointSection,
  renameWaypointSection,
  addSpecialArea,
  removeSpecialArea,
  updateSpecialArea,
  setActionPaused,
  setPathfinderMode,
  setDynamicTarget,
} = cavebotSlice.actions;

export { MAX_WAYPOINTS_PER_SECTION };

export default cavebotSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/gameStateSlice.js
//start file
import { createSlice } from '@reduxjs/toolkit';
import { createLogger } from '../../../electron/utils/logger.js';
const logger = createLogger({ info: true, error: true, debug: true });

const initialState = {
  hppc: null,
  mppc: null,
  healingCd: false,
  supportCd: false,
  attackCd: false,
  supportCd: false,
  attackCd: false,
  partyNum: 0,
  isWalking: false,
  isTyping: false, // Flag to indicate when a typing action is in progress
  partyMembers: [],
  activeActionItems: {}, // This will now store items with an added 'position' key
  equippedItems: {
    amulet: null,
    ring: null,
    boots: null,
  },
  characterStatus: {
    bleeding: false,
    burning: false,
    cursed: false,
    dazzled: false,
    drowning: false,
    drunk: false,
    electrified: false,
    freezing: false,
    hasted: false,
    hexed: false,
    hungry: false,
    battleSign: false,
    magicShield: false,
    eRing: false,
    poisoned: false,
    redBattleSign: false,
    paralyzed: false,
    strengthened: false,
    inProtectedZone: false,
    inRestingArea: false,
    whiteSkull: false,
    redSkull: false,
  },
  playerMinimapPosition: { x: 0, y: 0, z: 0 },
};

const ITEM_DIMENSION = 34; // Each item is 34x34 pixels
const SPACE_BETWEEN_ITEMS = 2; // 2px space between items
const TOTAL_TILE_DIMENSION = ITEM_DIMENSION + SPACE_BETWEEN_ITEMS; // 36px per grid cell

const gameStateSlice = createSlice({
  name: 'gameState',
  initialState,
  reducers: {
    setHealthPercent: (state, action) => {
      state.hppc = action.payload.hppc;
    },
    setManaPercent: (state, action) => {
      state.mppc = action.payload.mppc;
    },
    updateGameStateFromMonitorData: (state, action) => {
      const {
        hppc,
        mppc,
        healingCd,
        supportCd,
        attackCd,
        characterStatus,
        isWalking,
        partyMembers,
        activeActionItems, // This is the key we'll process
        equippedItems,
        playerMinimapPosition, // Add playerMinimapPosition to destructuring
      } = action.payload;

      // Update fields if they are provided in the payload
      if (hppc !== undefined) state.hppc = hppc;
      if (mppc !== undefined) state.mppc = mppc;
      if (healingCd !== undefined) state.healingCd = healingCd;
      if (supportCd !== undefined) state.supportCd = supportCd;
      if (attackCd !== undefined) state.attackCd = attackCd;

      if (characterStatus !== undefined) {
        // Merge characterStatus to avoid overwriting other potential status fields
        for (const key in characterStatus) {
          if (Object.prototype.hasOwnProperty.call(characterStatus, key)) {
            state.characterStatus[key] = characterStatus[key];
          }
        }
      }

      if (isWalking !== undefined) state.isWalking = isWalking;

      if (partyMembers !== undefined) {
        state.partyMembers = partyMembers;
        state.partyNum = partyMembers.length; // Update partyNum based on the array
      }

      // --- LOGIC TO PROCESS activeActionItems AND ADD 'position' KEY ---
      if (activeActionItems !== undefined) {
        const processedActionItems = {};
        for (const key in activeActionItems) {
          if (Object.prototype.hasOwnProperty.call(activeActionItems, key)) {
            const item = activeActionItems[key];
            const { x, y } = item;

            // Calculate 1-indexed row and column based on coordinates
            // (x / TOTAL_TILE_DIMENSION) gives the 0-indexed column block
            // (y / TOTAL_TILE_DIMENSION) gives the 0-indexed row block
            const column = Math.floor(x / TOTAL_TILE_DIMENSION) + 1;
            const row = Math.floor(y / TOTAL_TILE_DIMENSION) + 1;

            processedActionItems[key] = {
              ...item,
              position: `${row}x${column}`,
            };
          }
        }
        state.activeActionItems = processedActionItems;
      }
      // --- END activeActionItems PROCESSING ---

      if (equippedItems !== undefined) {
        // Merge equippedItems to avoid overwriting other potential equipped fields
        for (const key in equippedItems) {
          if (Object.prototype.hasOwnProperty.call(equippedItems, key)) {
            state.equippedItems[key] = equippedItems[key];
          }
        }
      }

      if (playerMinimapPosition !== undefined) {
        // logger('debug', `[gameStateSlice] updateGameStateFromMonitorData: Updating playerMinimapPosition with:`, playerMinimapPosition);
        state.playerMinimapPosition = playerMinimapPosition;
      }
    },
    sethealingCd: (state, action) => {
      // Note: This reducer seems to have a typo 'rulesCd' instead of 'healingCd'
      // Assuming it should update healingCd based on the name.
      state.healingCd = action.payload.healingCd;
    },
    setsupportCd: (state, action) => {
      state.supportCd = action.payload.supportCd;
    },
    setattackCd: (state, action) => {
      state.attackCd = action.payload.attackCd;
    },
    setCharacterStatus: (state, action) => {
      const { characterStatus } = action.payload || {};
      for (const key in characterStatus) {
        if (Object.prototype.hasOwnProperty.call(characterStatus, key)) {
          state.characterStatus[key] = characterStatus[key];
        }
      }
    },
    setPartyNum: (state, action) => {
      state.partyNum = action.payload.partyNum;
    },
    setState: (state, action) => {
      // This reducer completely replaces the state, which might be dangerous
      // unless used very carefully.
      return action.payload;
    },
    setIsTyping: (state, action) => {
      state.isTyping = action.payload;
    },
    setPlayerMinimapPosition: (state, action) => {
      // logger('info', `[gameStateSlice] setPlayerMinimapPosition received payload:`, action.payload);
      state.playerMinimapPosition = action.payload;
    },
  },
});

export const {
  updateGameStateFromMonitorData,
  setHealthPercent,
  setManaPercent,
  sethealingCd,
  setCharacterStatus,
  setPartyNum,
  setState,
  setPlayerMinimapPosition, // Export the new action
  setIsTyping,
} = gameStateSlice.actions;

export default gameStateSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/globalSlice.js
//start file
/* eslint-disable no-param-reassign */
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  windowName: 'Press Alt+W on focused tibia window to attach bot',
  windowId: null,
  display: null, // New: Stores the selected X display string (e.g., ":0", ":2")
  refreshRate: 32,
  notificationsEnabled: true,
  previousSectionStates: {
    rules: false,
    cavebot: false,
    lua: false,
    targeting: false,
  },
  isGlobalShortcutsEnabled: true, // New: Global shortcuts enabled by default
};

const globalSlice = createSlice({
  name: 'global',
  initialState,
  reducers: {
    setwindowName: (state, action) => {
      state.windowName = action.payload;
    },
    setWindowId: (state, action) => {
      state.windowId = action.payload;
      if (action.payload === null) {
        state.actualFps = 0;
      }
    },
    setDisplay: (state, action) => {
      // New: Reducer to set the display
      state.display = action.payload;
    },
    setWindowName: (state, action) => {
      // New: Reducer to set the window title including character name
      state.windowName = action.payload;
    },
    setRefreshRate: (state, action) => {
      state.refreshRate = Math.max(action.payload, 0);
    },
    toggleNotifications: (state) => {
      state.notificationsEnabled = !state.notificationsEnabled;
    },
    setGlobalShortcutsEnabled: (state, action) => {
      state.isGlobalShortcutsEnabled = action.payload;
    },
    setState: (state, action) => {
      const newState = { ...state };

      Object.keys(newState).forEach((key) => {
        if (!['windowId', 'actualFps', 'display'].includes(key)) {
          // Exclude 'display' from being overwritten by setState
          newState[key] = action.payload[key];
        }
      });

      return newState;
    },
    setPreviousSectionStates: (state, action) => {
      state.previousSectionStates = action.payload;
    },
    resetPreviousSectionStates: (state) => {
      state.previousSectionStates = initialState.previousSectionStates;
    },
  },
});

export const {
  setwindowName,
  setWindowId,
  setDisplay, // Export the new action
  setWindowName, // Export the new action
  setRefreshRate,
  toggleNotifications,
  setGlobalShortcutsEnabled, // Export the new action
  setState,
  setPreviousSectionStates,
  resetPreviousSectionStates,
} = globalSlice.actions;

export default globalSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/luaSlice.js
//start file
import { createSlice } from '@reduxjs/toolkit';

const DEBOUNCE_DELAY = 500; // 500ms debounce delay

const initialState = {
  enabled: false, // State for Lua scripts enable/disable
  persistentScripts: [], // Array to hold persistent Lua script objects
  hotkeyScripts: [], // Array to hold hotkey Lua script objects
  _lastEnabledChange: 0, // Internal timestamp for debouncing
  _lastScriptToggle: {}, // Internal timestamps for individual script debouncing
};

const luaSlice = createSlice({
  name: 'lua',
  initialState,
  reducers: {
    /**
     * Adds a new Lua script.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     * @param {object} action.payload - The payload containing script details.
     */
    addScript: (state, action) => {
      const { id, name, code, type, enabled = false, loopMin = 1000, loopMax = 5000, hotkey = null } = action.payload;
      const newScript = {
        id,
        name: name || 'New Script',
        code: code || '',
        type,
        log: [], // Ensure log array is initialized
      };

      if (type === 'persistent') {
        state.persistentScripts.push({ ...newScript, enabled, loopMin, loopMax });
      } else if (type === 'hotkey') {
        state.hotkeyScripts.push({ ...newScript, hotkey });
      } else {
        console.warn('Attempted to add script with invalid type:', type);
      }
    },

    /**
     * Adds a timestamped log entry to a specific script's log array.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     */
    addLogEntry: (state, action) => {
      const { id, message } = action.payload;
      const script = state.persistentScripts.find((s) => s.id === id) || state.hotkeyScripts.find((s) => s.id === id);

      if (script) {
        if (!Array.isArray(script.log)) {
          script.log = [];
        }
        // Create a timestamp string with milliseconds
        const now = new Date();
        const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}`;

        script.log.push(`[${timestamp}] ${message}`);

        const MAX_LOG_SIZE = 100;
        if (script.log.length > MAX_LOG_SIZE) {
          script.log.splice(0, script.log.length - MAX_LOG_SIZE);
        }
      } else {
        console.warn('Attempted to add log to unknown script ID:', id);
      }
    },

    /**
     * Clears the log for a specific script.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     */
    clearScriptLog: (state, action) => {
      const scriptId = action.payload;
      const script = state.persistentScripts.find((s) => s.id === scriptId) || state.hotkeyScripts.find((s) => s.id === scriptId);
      if (script) {
        script.log = [];
      }
    },

    /**
     * Removes a Lua script by ID from either list.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     */
    removeScript: (state, action) => {
      const scriptIdToRemove = action.payload;
      state.persistentScripts = state.persistentScripts.filter((script) => script.id !== scriptIdToRemove);
      state.hotkeyScripts = state.hotkeyScripts.filter((script) => script.id !== scriptIdToRemove);
    },

    /**
     * Updates an existing Lua script in either list.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     */
    updateScript: (state, action) => {
      const { id, updates } = action.payload;

      const persistentIndex = state.persistentScripts.findIndex((script) => script.id === id);
      if (persistentIndex !== -1) {
        state.persistentScripts[persistentIndex] = {
          ...state.persistentScripts[persistentIndex],
          ...updates,
          log: state.persistentScripts[persistentIndex].log,
        };
        if (updates.hasOwnProperty('loopMin')) state.persistentScripts[persistentIndex].loopMin = Number(updates.loopMin);
        if (updates.hasOwnProperty('loopMax')) state.persistentScripts[persistentIndex].loopMax = Number(updates.loopMax);
        return;
      }

      const hotkeyIndex = state.hotkeyScripts.findIndex((script) => script.id === id);
      if (hotkeyIndex !== -1) {
        state.hotkeyScripts[hotkeyIndex] = {
          ...state.hotkeyScripts[hotkeyIndex],
          ...updates,
          log: state.hotkeyScripts[hotkeyIndex].log,
        };
        return;
      }

      console.warn('Attempted to update script with unknown ID:', id);
    },

    /**
     * Toggles the enabled status of a persistent script.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     */
    togglePersistentScript: (state, action) => {
      const scriptIdToToggle = action.payload;
      const now = Date.now();

      // Ensure _lastScriptToggle exists
      if (!state._lastScriptToggle) {
        state._lastScriptToggle = {};
      }

      // Check if this script was toggled recently
      const lastToggle = state._lastScriptToggle[scriptIdToToggle] || 0;
      if (now - lastToggle < DEBOUNCE_DELAY) {
        return; // Skip if toggled within debounce delay
      }

      const script = state.persistentScripts.find((script) => script.id === scriptIdToToggle);
      if (script) {
        script.enabled = !script.enabled;
        const status = script.enabled ? 'Enabled' : 'Disabled';
        if (!Array.isArray(script.log)) script.log = [];
        script.log.push(`[Status] Script ${status}`);
        const MAX_LOG_SIZE = 100;
        if (script.log.length > MAX_LOG_SIZE) {
          script.log.splice(0, script.log.length - MAX_LOG_SIZE);
        }

        // Update last toggle timestamp
        state._lastScriptToggle[scriptIdToToggle] = now;
      }
    },

    setState: (state, action) => {
      const newState = { ...state };
      Object.keys(newState).forEach((key) => {
        newState[key] = action.payload[key];
      });
      return newState;
    },
    setenabled: (state, action) => {
      const now = Date.now();

      // Ensure _lastEnabledChange exists
      if (typeof state._lastEnabledChange !== 'number') {
        state._lastEnabledChange = 0;
      }

      // Check if enabled state was changed recently
      if (now - state._lastEnabledChange < DEBOUNCE_DELAY) {
        return; // Skip if changed within debounce delay
      }

      state.enabled = action.payload;
      state._lastEnabledChange = now;
    },
  },
});

export const { addScript, addLogEntry, removeScript, updateScript, togglePersistentScript, setState, clearScriptLog, setenabled } =
  luaSlice.actions;

export default luaSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/ocrSlice.js
//start file
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  regions: {
    // This object will store OCR results for different regions.
    // Example:
    // gameLog: "Some text from the game log",
    // skillsWidget: "Text from the skills widget",
  },
};

const ocrSlice = createSlice({
  name: 'ocr',
  initialState,
  reducers: {
    /**
     * Sets the OCR recognized text for a specific region.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     * @param {object} action.payload - Contains the region name and the recognized text.
     * @param {string} action.payload.regionName - The name of the region (e.g., 'gameLog', 'skillsWidget').
     * @param {string} action.payload.text - The recognized text from the region.
     */
    setOcrRegionsText: (state, action) => {
      // The payload is expected to be an object where keys are region names and values are the recognized text.
      // Example: { gameLog: "text", skillsWidget: "text" }
      const newOcrRegions = action.payload;
      if (newOcrRegions && typeof newOcrRegions === 'object') {
        Object.assign(state.regions, newOcrRegions);
      }
    },
    /**
     * Resets the entire ocr state to its initial empty state.
     */
    resetOcr: (state) => {
      state.regions = initialState.regions;
    },
    /**
     * Replaces the entire slice state. Use with caution.
     * @param {object} state - The current state.
     * @param {object} action - The action containing the new state.
     */
    setState: (state, action) => {
      return action.payload;
    },
  },
});

export const { setOcrRegionsText, resetOcr, setState } = ocrSlice.actions;

export default ocrSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/pathfinderSlice.js
//start file
// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/pathfinderSlice.js
// --- NEW FILE ---

import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  pathWaypoints: [],
  wptDistance: null,
  routeSearchMs: 0,
  pathfindingStatus: 'IDLE', // e.g., 'IDLE', 'PATH_FOUND', 'NO_PATH_FOUND'
};

const pathfinderSlice = createSlice({
  name: 'pathfinder',
  initialState,
  reducers: {
    /**
     * Sets the feedback from the pathfinder worker. This is the primary way
     * the pathfinder communicates its results to the rest of the application.
     * @param {object} state - The current state.
     * @param {object} action - The action object containing the pathfinding results.
     */
    setPathfindingFeedback: (state, action) => {
      const { pathWaypoints, wptDistance, routeSearchMs, pathfindingStatus } =
        action.payload;
      state.pathWaypoints = pathWaypoints;
      state.wptDistance = wptDistance;
      state.routeSearchMs = routeSearchMs;
      if (pathfindingStatus) {
        state.pathfindingStatus = pathfindingStatus;
      }
    },
    /**
     * Resets the pathfinder state to its initial values.
     */
    resetPathfinder: (state) => {
      Object.assign(state, initialState);
    },
    /**
     * Replaces the entire slice state. Use with caution.
     */
    setState: (state, action) => {
      return { ...initialState, ...(action.payload || {}) };
    },
  },
});

export const { setPathfindingFeedback, resetPathfinder, setState } =
  pathfinderSlice.actions;

export default pathfinderSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/regionCoordinatesSlice.js
//start file
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  regions: {
    // This object will be populated by the regionMonitor worker.
    // Example structure after being populated (hierarchical):
    // hotkeyBar: {
    //   x: 100, y: 200, width: 300, height: 50,
    //   children: {
    //     actionBarSlot1: { x: 110, y: 210, width: 32, height: 32 },
    //     actionBarSlot2: { x: 150, y: 210, width: 32, height: 32 }
    //   }
    // },
    // healthBar: { x: 1699, y: 312, width: 94, height: 14 },
    // ... etc.
  },
};

const regionCoordinatesSlice = createSlice({
  name: 'regionCoordinates',
  initialState,
  reducers: {
    /**
     * Replaces the entire set of regions with a new regions object.
     * THIS IS THE PREFERRED METHOD for the regionMonitor worker.
     * It performs an atomic update, ensuring consumers get a consistent state.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     * @param {object} action.payload - The new object containing all found regions.
     */
    setAllRegions: (state, action) => {
      // Directly replaces the regions object with the complete payload from the worker.
      // This is much more efficient and safer than updating one by one.
      state.regions = action.payload;
    },

    /**
     * Sets the coordinates and dimensions for a single, specific region.
     * Note: This is inefficient for batch updates and can cause race conditions.
     * Use `setAllRegions` for updates from the regionMonitor.
     * @param {object} state - The current state.
     * @param {object} action - The action object containing region details.
     */
    setRegion: (state, action) => {
      const { name, x, y, width, height } = action.payload;
      if (name) {
        state.regions[name] = { x, y, width, height, pixelCount: width * height };
      }
    },

    /**
     * Updates specific properties of an existing region.
     * Useful for targeted, manual updates, perhaps from the UI.
     * @param {object} state - The current state.
     * @param {object} action - The action object.
     */
    updateRegion: (state, action) => {
      const { name, updates } = action.payload;
      if (name && state.regions[name]) {
        Object.assign(state.regions[name], updates);
        // Recalculate pixelCount if width or height are updated
        if (updates.width !== undefined || updates.height !== undefined) {
          state.regions[name].pixelCount = state.regions[name].width * state.regions[name].height;
        }
      }
    },

    /**
     * Removes a region from the state.
     * @param {object} state - The current state.
     * @param {string} action.payload - The name of the region to remove.
     */
    removeRegion: (state, action) => {
      const nameToRemove = action.payload;
      if (state.regions[nameToRemove]) {
        delete state.regions[nameToRemove];
      }
    },

    /**
     * Resets the entire regionCoordinates state to its initial empty state.
     */
    resetRegions: (state) => {
      state.regions = initialState.regions;
    },

    /**
     * Replaces the entire slice state. Use with caution.
     * @param {object} state - The current state.
     * @param {object} action - The action containing the new state.
     */
    setState: (state, action) => {
      return action.payload;
    },
  },
});

export const { setAllRegions, setRegion, updateRegion, removeRegion, resetRegions, setState } = regionCoordinatesSlice.actions;

export default regionCoordinatesSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/ruleSlice.js
//start file
import { createSlice } from '@reduxjs/toolkit';
import { v4 as uuidv4 } from 'uuid';
import actionBarItemsData from '../../../electron/constants/actionBarItems.js'; // Import for defaults
import equippedItems from '../../../electron/constants/equippedItems.js'; // Import for equipped items

// Define the allowed potion keys for ManaSync rules (can be shared or redefined)
const ALLOWED_POTION_KEYS = new Set([
  'healthPotion',
  'strongHealthPotion',
  'greatHealthPotion',
  'ultimateHealthPotion',
  'supremeHealthPotion',
  'smallHealthPotion',
  'manaPotion',
  'strongManaPotion',
  'greatManaPotion',
  'ultimateManaPotion',
  'greatSpiritPotion',
  'ultimateSpiritPotion',
]);

// Find a default potion actionItem key (e.g., the first one in the set)
const getDefaultPotionActionItem = () => {
  for (const key of ALLOWED_POTION_KEYS) {
    // Check if it exists in the main data just in case
    if (actionBarItemsData[key]) {
      return key;
    }
  }
  return ''; // Fallback if no valid default is found
};

const DEFAULT_POTION_ACTION_ITEM = getDefaultPotionActionItem();

// Find a default action bar item for equip rules (e.g., stoneSkinAmulet if available)
const getDefaultEquipActionItem = () => {
  const itemWithSlot = Object.keys(actionBarItemsData).find(
    (key) => actionBarItemsData[key].slot && actionBarItemsData[key].categories?.includes('equipment'),
  );
  if (itemWithSlot) return itemWithSlot;
  const firstActionItem = Object.keys(actionBarItemsData)[0];
  return firstActionItem || '';
};
const DEFAULT_EQUIP_ACTION_ITEM = getDefaultEquipActionItem();
const DEFAULT_INFERRED_SLOT_FOR_EQUIP = actionBarItemsData[DEFAULT_EQUIP_ACTION_ITEM]?.slot || 'amulet';

// Get a default item name from equippedItems (e.g., emptyAmuletSlot)
const getDefaultSlotMustBeItem = () => {
  if (actionBarItemsData.emptyAmuletSlot) return 'Empty'; // Assuming equippedItems might have this, or use a known key
  const firstEquippedItemKey = Object.keys(equippedItems).find((key) => key.toLowerCase().includes('Empty')); // Prioritize an "empty" state
  return firstEquippedItemKey || Object.keys(equippedItems)[0] || '';
};
const DEFAULT_SLOT_MUST_BE_ITEM = getDefaultSlotMustBeItem();

// Default for slotMustBeItemName in equipRule template
const DEFAULT_SLOT_CONDITION = '_ANY_'; // Represents "Don't care"

// Helper to validate delay (e.g., positive integer)
const validateDelay = (value) => {
  const num = parseInt(value, 10);
  return isNaN(num) || num < 0 ? 0 : num;
};

const initialPreset = [];

const initialState = {
  enabled: false, // State for global rule processing enable/disable
  activePresetIndex: 0,
  presets: [initialPreset, initialPreset, initialPreset, initialPreset, initialPreset],
  sortBy: ['priority'],
  sortOrder: { priority: 'desc' },
};

const sortingCriteriaMap = {
  enabled: { key: 'enabled', type: 'boolean' },
  name: { key: 'name', type: 'string' },
  category: { key: 'category', type: 'string' },
  key: { key: 'key', type: 'string' },
  priority: { key: 'priority', type: 'number' },
  monsterNum: { key: 'monsterNum', type: 'number' },
  hpTriggerPercentage: { key: 'hpTriggerPercentage', type: 'number' },
  manaTriggerPercentage: { key: 'manaTriggerPercentage', type: 'number' },
  friendHpTriggerPercentage: { key: 'friendHpTriggerPercentage', type: 'number' },
  partyPosition: { key: 'partyPosition', type: 'number' },
  requireAttackCooldown: { key: 'requireAttackCooldown', type: 'boolean' },
  actionItem: { key: 'actionItem', type: 'string' },
  targetSlot: { key: 'targetSlot', type: 'string' },
  equipOnlyIfSlotIsEmpty: { key: 'equipOnlyIfSlotIsEmpty', type: 'boolean' },
};

const sortPresetRules = (state) => {
  const { sortBy, sortOrder } = state;
  if (!sortBy || sortBy.length === 0) return;

  const compareValues = (a, b, type, isAscending) => {
    let comparison;
    if (type === 'number') {
      comparison = (Number(a) || 0) - (Number(b) || 0);
    } else if (type === 'string') {
      comparison = String(a || '').localeCompare(String(b || ''));
    } else if (type === 'boolean') {
      comparison = a === b ? 0 : a ? -1 : 1;
    } else {
      return 0;
    }
    return isAscending ? comparison : -comparison;
  };

  state.presets[state.activePresetIndex].sort((a, b) => {
    for (const criterion of sortBy) {
      const criteriaDefinition = sortingCriteriaMap[criterion];
      if (!criteriaDefinition) {
        console.warn(`Sorting criterion "${criterion}" not found.`);
        continue;
      }
      const { key, type } = criteriaDefinition;
      const isAscending = sortOrder[criterion] !== 'desc';
      const valueA = a && typeof a === 'object' && a.hasOwnProperty(key) ? a[key] : undefined;
      const valueB = b && typeof b === 'object' && b.hasOwnProperty(key) ? b[key] : undefined;

      if (valueA === undefined || valueA === null) {
        return valueB === undefined || valueB === null ? 0 : isAscending ? 1 : -1;
      }
      if (valueB === undefined || valueB === null) {
        return isAscending ? -1 : 1;
      }

      const comparison = compareValues(valueA, valueB, type, isAscending);
      if (comparison !== 0) return comparison;
    }
    return 0;
  });
};

const validateField = (field, value) => {
  switch (field) {
    case 'friendHpTriggerPercentage':
    case 'hpTriggerPercentage':
    case 'manaTriggerPercentage':
      return Math.max(0, Math.min(100, parseInt(value, 10) || 0));
    case 'monsterNum':
      return Math.max(0, Math.min(10, parseInt(value, 10) || 0));
    case 'priority':
      return Math.max(-999, Math.min(999, parseInt(value, 10) || 0));
    case 'partyPosition':
      return Math.max(0, Math.min(10, parseInt(value, 10) || 0));
    case 'delay':
      const num = parseInt(value, 10);
      return isNaN(num) ? 0 : Math.max(0, Math.min(86400000, num));
    default:
      return value;
  }
};

const validateRule = (rule) => {
  // Start with common validations
  const validated = {
    ...rule,
    modifierKey: rule.modifierKey ?? '',
    activationKey: rule.activationKey ?? 'F1',
    friendHpTriggerPercentage: Math.max(0, Math.min(100, parseInt(rule.friendHpTriggerPercentage, 10) || 80)),
    hpTriggerPercentage: Math.max(0, Math.min(100, parseInt(rule.hpTriggerPercentage, 10) || 0)),
    manaTriggerPercentage: Math.max(0, Math.min(100, parseInt(rule.manaTriggerPercentage, 10) || 0)),
    monsterNum: Math.max(0, Math.min(10, parseInt(rule.monsterNum, 10) || 0)),
    priority: Math.max(-99, Math.min(99, parseInt(rule.priority, 10) || 0)),
    delay: Math.max(0, Math.min(86400000, parseInt(rule.delay, 10) || 0)),
  };
  // Clean up potentially obsolete fields
  delete validated.useRune;
  delete validated.slotMustBeItemName;

  // --- Rule Type Specific Validation ---

  if (rule.id.startsWith('equipRule')) {
    const itemData = actionBarItemsData[rule.actionItem];
    validated.actionItem = itemData && itemData.categories?.includes('equipment') && itemData.slot ? rule.actionItem : '';
    const inferredSlotFromActionItem = actionBarItemsData[validated.actionItem]?.slot;
    validated.key = rule.key || 'F5';
    validated.targetSlot = inferredSlotFromActionItem || rule.targetSlot || DEFAULT_INFERRED_SLOT_FOR_EQUIP;
    validated.equipOnlyIfSlotIsEmpty = typeof rule.equipOnlyIfSlotIsEmpty === 'boolean' ? rule.equipOnlyIfSlotIsEmpty : true;
    delete validated.isWalking; // Explicitly remove isWalking for equipRule
    delete validated.category; // Equip rules don't use category
  } else if (rule.id.startsWith('userRule')) {
    // Ensure userRule keeps its category and isWalking
    validated.category = rule.category || 'Healing'; // Default category if missing
    validated.isWalking = typeof rule.isWalking === 'boolean' ? rule.isWalking : false; // Ensure boolean, default false
  } else if (rule.id.startsWith('actionBarItem')) {
    // Ensure actionBarItem keeps its isWalking
    validated.actionItem = rule.actionItem || ''; // Default actionItem if missing
    validated.isWalking = typeof rule.isWalking === 'boolean' ? rule.isWalking : false; // Ensure boolean, default false
    delete validated.category; // Action bar rules don't use category
  } else if (rule.id.startsWith('healFriend')) {
    validated.actionItem = rule.actionItem || 'ultimateHealingRune'; // Default actionItem
    validated.requireAttackCooldown = typeof rule.requireAttackCooldown === 'boolean' ? rule.requireAttackCooldown : false;
    validated.partyPosition = String(validateField('partyPosition', rule.partyPosition ?? '0')); // Ensure string after validation
    delete validated.category; // Heal friend rules don't use category
    delete validated.isWalking; // Heal friend rules don't use isWalking
  } else if (rule.id.startsWith('manaSync')) {
    validated.actionItem = rule.actionItem || DEFAULT_POTION_ACTION_ITEM; // Default actionItem
    delete validated.category; // Mana sync rules don't use category
    delete validated.isWalking; // Mana sync rules don't use isWalking
    delete validated.delay;
    delete validated.monsterNum;
    delete validated.monsterNumCondition;
  } else if (rule.id.startsWith('rotationRule')) {
    validated.repeat = typeof rule.repeat === 'boolean' ? rule.repeat : true;
    delete validated.category; // Rotation rules don't use category
    delete validated.isWalking; // Rotation rules don't use isWalking
    delete validated.delay; // Delay is per-step
    delete validated.key; // Key is per-step
  }
  // --- End Rule Type Specific Validation ---

  // Sequence validation (applies only if sequence exists, e.g., for rotationRule)
  if (validated.sequence && Array.isArray(validated.sequence)) {
    validated.sequence = validated.sequence.map((step) => ({
      key: step.key || 'F1', // Default key
      delay: validateDelay(step.delay ?? 1000), // Validate and default delay
      leftClick: typeof step.leftClick === 'boolean' ? step.leftClick : false, // Ensured boolean
    }));
  }

  return validated;
};

const ruleSlice = createSlice({
  name: 'rules',
  initialState,
  reducers: {
    addRule: (state, action) => {
      const ruleId = action.payload;
      let newRule;

      if (ruleId && typeof ruleId === 'string' && ruleId.startsWith('manaSync')) {
        newRule = {
          id: ruleId,
          enabled: true,
          name: `Mana Sync Rule`,
          actionItem: DEFAULT_POTION_ACTION_ITEM,
          key: 'F12',
          hpTriggerCondition: '>=',
          hpTriggerPercentage: 1,
          manaTriggerCondition: '<=',
          manaTriggerPercentage: 80,
          priority: 0,
          conditions: [],
        };
      } else if (ruleId && typeof ruleId === 'string' && ruleId.startsWith('healFriend')) {
        newRule = {
          id: ruleId,
          enabled: false,
          name: 'New Party Heal',
          actionItem: 'ultimateHealingRune',
          key: 'T',
          hpTriggerCondition: '>',
          hpTriggerPercentage: 0,
          manaTriggerCondition: '>',
          manaTriggerPercentage: 0,
          friendHpTriggerPercentage: '50',
          priority: 9,
          requireAttackCooldown: false,
          partyPosition: '0',
          conditions: [],
        };
      } else if (ruleId && typeof ruleId === 'string' && ruleId.startsWith('actionBarItem')) {
        newRule = {
          id: ruleId,
          enabled: false,
          name: `New Action Rule`,
          actionItem: '',
          key: 'F1',
          hpTriggerCondition: '<=',
          hpTriggerPercentage: 90,
          manaTriggerCondition: '>=',
          manaTriggerPercentage: 0,
          monsterNumCondition: '>=',
          monsterNum: 0,
          priority: 0,
          delay: 0,
          isWalking: false,
          conditions: [],
        };
      } else if (ruleId && typeof ruleId === 'string' && ruleId.startsWith('rotationRule')) {
        newRule = {
          id: ruleId,
          name: 'New Rotation',
          enabled: false,
          repeat: true,
          modifierKey: '',
          activationKey: 'F1',
          priority: 0,
          conditions: [],
          sequence: [
            { key: 'F1', delay: 1000, leftClick: false },
            { key: 'F2', delay: 1000, leftClick: false },
            { key: 'F3', delay: 1000, leftClick: false },
            { key: 'F4', delay: 1000, leftClick: false },
            { key: 'F5', delay: 1000, leftClick: false },
            { key: 'F6', delay: 1000, leftClick: false },
          ],
        };
      } else if (ruleId && typeof ruleId === 'string' && ruleId.startsWith('equipRule')) {
        const defaultActionItem = DEFAULT_EQUIP_ACTION_ITEM;
        const defaultInferredSlot = actionBarItemsData[defaultActionItem]?.slot || 'amulet';
        newRule = {
          id: ruleId,
          name: 'New Equip Rule',
          enabled: false,
          actionItem: defaultActionItem,
          key: 'F5',
          targetSlot: defaultInferredSlot,
          equipOnlyIfSlotIsEmpty: true,
          hpTriggerCondition: '<=',
          hpTriggerPercentage: 60,
          manaTriggerCondition: '>',
          manaTriggerPercentage: 0,
          monsterNumCondition: '>=',
          monsterNum: 0,
          priority: 5,
          delay: 250,
          conditions: [],
        };
      } else {
        newRule = {
          id: ruleId || `userRule${uuidv4()}`,
          enabled: false,
          name: `New Rule`,
          category: 'Healing',
          key: 'F1',
          hpTriggerCondition: '<=',
          hpTriggerPercentage: 80,
          manaTriggerCondition: '>=',
          manaTriggerPercentage: 20,
          monsterNumCondition: '>=',
          monsterNum: 0,
          priority: 0,
          delay: 1000,
          isWalking: false,
          conditions: [],
        };
      }

      if (newRule) {
        state.presets[state.activePresetIndex].push(validateRule(newRule));
        sortPresetRules(state);
      } else {
        console.warn('No rule type matched for ID:', ruleId);
      }
    },

    removeRule: (state, action) => {
      state.presets[state.activePresetIndex] = state.presets[state.activePresetIndex].filter((rule) => rule.id !== action.payload);
    },
    updateRule: (state, action) => {
      const { id, field, value } = action.payload;

      const ruleIndex = state.presets[state.activePresetIndex].findIndex((rule) => rule.id === id);

      if (ruleIndex !== -1) {
        let actualValue = value;
        const booleanFields = ['enabled', 'equipOnlyIfSlotIsEmpty', 'isWalking', 'requireAttackCooldown', 'repeat'];
        if (booleanFields.includes(field)) {
          actualValue = value === 'true' || value === true;
        }

        state.presets[state.activePresetIndex][ruleIndex][field] = validateField(field, actualValue);

        state.presets[state.activePresetIndex][ruleIndex] = validateRule(state.presets[state.activePresetIndex][ruleIndex]);

        sortPresetRules(state);
      }
    },

    setenabled: (state, action) => {
      state.enabled = action.payload;
    },

    updateCondition: (state, action) => {
      const { id, condition, value } = action.payload;
      const ruleIndex = state.presets[state.activePresetIndex].findIndex((rule) => rule.id === id);

      if (ruleIndex !== -1) {
        const rule = state.presets[state.activePresetIndex][ruleIndex];
        if (!rule.conditions) {
          rule.conditions = [];
        }
        const conditionIndex = rule.conditions.findIndex((c) => c.name === condition);

        if (conditionIndex !== -1) {
          if (value === undefined) {
            rule.conditions.splice(conditionIndex, 1);
          } else {
            rule.conditions[conditionIndex].value = value;
          }
        } else if (value !== undefined) {
          rule.conditions.push({ name: condition, value });
        }
      }
    },

    removeCondition: (state, action) => {
      const { id, condition } = action.payload;
      const ruleIndex = state.presets[state.activePresetIndex].findIndex((rule) => rule.id === id);

      if (ruleIndex !== -1 && state.presets[state.activePresetIndex][ruleIndex].conditions) {
        state.presets[state.activePresetIndex][ruleIndex].conditions = state.presets[state.activePresetIndex][ruleIndex].conditions.filter(
          (c) => c.name !== condition,
        );
      }
    },

    loadRules: (state, action) => {
      state.presets[state.activePresetIndex] = action.payload.map((rule) => validateRule(rule));
      sortPresetRules(state);
    },

    setActivePresetIndex: (state, action) => {
      const newIndex = parseInt(action.payload, 10);
      if (!isNaN(newIndex) && newIndex >= 0 && newIndex < state.presets.length) {
        state.activePresetIndex = newIndex;
        sortPresetRules(state);
      }
    },
    setState: (state, action) => {
      const loadedState = action.payload;
      // Apply validateRule during load/set state to clean up/migrate old states
      const cleanPreset = (preset) => (preset && Array.isArray(preset) ? preset.map((rule) => validateRule(rule)) : []);

      if (loadedState && typeof loadedState === 'object') {
        if (!Array.isArray(loadedState.presets)) {
          state.presets = [cleanPreset(loadedState.presets || initialPreset)];
          state.activePresetIndex = 0;
        } else {
          state.presets = loadedState.presets.map((preset) => cleanPreset(preset));
          state.activePresetIndex = Math.max(
            0,
            Math.min((state.presets?.length || 1) - 1, parseInt(loadedState.activePresetIndex, 10) || 0),
          );
        }
        state.sortBy = loadedState.sortBy || initialState.sortBy;
        state.sortOrder = loadedState.sortOrder || initialState.sortOrder;
        sortPresetRules(state);
      } else {
        Object.assign(state, initialState);
        sortPresetRules(state);
      }
    },
    sortRulesBy: (state, action) => {
      const newSortByRaw = action.payload;
      const newSortBy = Array.isArray(newSortByRaw) ? newSortByRaw : [newSortByRaw];

      if (newSortBy.length === 0 || !sortingCriteriaMap[newSortBy[0]]) {
        console.warn('Invalid sort criteria provided:', newSortByRaw);
        return;
      }

      const primaryCriterion = newSortBy[0];

      if (state.sortBy && state.sortBy[0] === primaryCriterion) {
        state.sortOrder[primaryCriterion] = state.sortOrder[primaryCriterion] === 'desc' ? 'asc' : 'desc';
      } else {
        state.sortOrder = {
          [primaryCriterion]: sortingCriteriaMap[primaryCriterion].type === 'number' || primaryCriterion === 'priority' ? 'desc' : 'asc',
        };
      }

      state.sortBy = newSortBy;

      newSortBy.slice(1).forEach((criterion) => {
        if (!state.sortOrder[criterion] && sortingCriteriaMap[criterion]) {
          state.sortOrder[criterion] = sortingCriteriaMap[criterion].type === 'number' ? 'desc' : 'asc';
        }
      });
      sortPresetRules(state);
    },
    copyPreset: (state, action) => {
      const { sourceIndex, targetIndex } = action.payload;
      if (
        sourceIndex !== targetIndex &&
        sourceIndex >= 0 &&
        sourceIndex < state.presets.length &&
        targetIndex >= 0 &&
        targetIndex < state.presets.length
      ) {
        state.presets[targetIndex] = JSON.parse(JSON.stringify(state.presets[sourceIndex]));
        if (targetIndex === state.activePresetIndex) {
          sortPresetRules(state);
        }
      }
    },
  },
});

export const {
  addRule,
  removeRule,
  updateRule,
  updateCondition,
  removeCondition,
  loadRules,
  setActivePresetIndex,
  setState,
  sortRulesBy,
  copyPreset,
  setenabled,
} = ruleSlice.actions;

export default ruleSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/statusMessagesSlice.js
//start file
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  notPossible: null,
  thereIsNoWay: null,
};

const statusMessagesSlice = createSlice({
  name: 'statusMessages',
  initialState,
  reducers: {
    setNotPossibleTimestamp: (state) => {
      state.notPossible = Date.now();
    },
    setThereIsNoWayTimestamp: (state) => {
      state.thereIsNoWay = Date.now();
    },
  },
});

export const { setNotPossibleTimestamp, setThereIsNoWayTimestamp } = statusMessagesSlice.actions;

export default statusMessagesSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/targetingSlice.js
//start file
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  enabled: false,
  creatures: [], // List of creatures on screen with their coordinates
  target: null, // { name: string, distance: number, gameCoordinates: {x,y,z}, absoluteCoordinates: {x,y} }
  targetingList: [], // [{ id: string, name: string, stance: string, distance: number }]
};

const targetingSlice = createSlice({
  name: 'targeting',
  initialState,
  reducers: {
    setState: (state, action) => {
      // This allows loading a saved state, merging it with the initial state
      // to ensure all keys are present even if the saved file is from an older version.
      return { ...initialState, ...action.payload };
    },
    setenabled: (state, action) => {
      state.enabled = action.payload;
    },
    setEntities: (state, action) => {
      // This will be dispatched by the targetMonitor worker
      state.creatures = action.payload;
    },
    setTarget: (state, action) => {
      state.target = action.payload;
    },
    addCreatureToTargetingList: (state, action) => {
      const { id, name, stance, distance } = action.payload;
      state.targetingList.push({ id, name, stance, distance });
    },
    removeCreatureFromTargetingList: (state, action) => {
      state.targetingList = state.targetingList.filter(
        (creature) => creature.id !== action.payload,
      );
    },
    updateCreatureInTargetingList: (state, action) => {
      const { id, updates } = action.payload;
      const creatureIndex = state.targetingList.findIndex(
        (creature) => creature.id === id,
      );
      if (creatureIndex !== -1) {
        state.targetingList[creatureIndex] = {
          ...state.targetingList[creatureIndex],
          ...updates,
        };
      }
    },
  },
});

export const {
  setState,
  setenabled,
  setEntities,
  setTarget,
  addCreatureToTargetingList,
  removeCreatureFromTargetingList,
  updateCreatureInTargetingList,
} = targetingSlice.actions;

export default targetingSlice;

//endFile

// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/uiValuesSlice.js
//start file
// /home/feiron/Dokumenty/Automaton/frontend/redux/slices/uiValuesSlice.js
// --- MODIFIED ---

import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  skillsWidget: {
    level: null,
    experience: null,
    xpGainRate: null,
    hitPoints: null,
    mana: null,
    soulPoints: null,
    capacity: null,
    speed: null,
    food: null,
    stamina: null,
    offlineTraining: null,
    skills: {
      magic: null,
      fist: null,
      club: null,
      sword: null,
      axe: null,
      distance: null,
      shielding: null,
      fishing: null,
    },
    combat: {
      damageHealing: null,
      attack: null,
      defence: null,
      armor: null,
      mantra: null,
      mitigation: null,
    },
  },
  chatboxMain: {
    messages: [],
    lastUpdate: null,
  },
  chatboxSecondary: {
    messages: [],
    lastUpdate: null,
  },
  chatboxTabs: {
    activeTab: null,
    tabs: {},
    lastUpdate: null,
  },
  selectCharacterModal: {
    selectedCharacter: null,
    characters: {},
    accountStatus: null,
    lastUpdate: null,
  },
  vipWidget: {
    online: [],
    offline: [],
    lastUpdate: null,
  },
  // REMOVED gameWorld state
  battleListEntries: [],
};

const uiValuesSlice = createSlice({
  name: 'uiValues',
  initialState,
  reducers: {
    setSkillsWidget: (state, action) => {
      if (action.payload) {
        state.skillsWidget = action.payload;
      }
    },
    setBattleListEntries: (state, action) => {
      state.battleListEntries = action.payload;
    },
    setChatboxMain: (state, action) => {
      state.chatboxMain.messages = action.payload;
      state.chatboxMain.lastUpdate = Date.now();
    },
    setChatboxSecondary: (state, action) => {
      state.chatboxSecondary.messages = action.payload;
      state.chatboxSecondary.lastUpdate = Date.now();
    },
    setChatTabs: (state, action) => {
      state.chatboxTabs = { ...action.payload, lastUpdate: Date.now() };
    },
    setSelectCharacterModal: (state, action) => {
      state.selectCharacterModal = {
        ...action.payload,
        lastUpdate: Date.now(),
      };
    },
    setVipWidget: (state, action) => {
      state.vipWidget = { ...action.payload, lastUpdate: Date.now() };
    },
    // REMOVED setGameWorldOcr reducer
    resetUiValues: () => initialState,
    resetRegion: (state, action) => {
      const region = action.payload;
      if (initialState[region]) {
        state[region] = initialState[region];
      }
    },
    setState: (state, action) => {
      return action.payload;
    },
  },
});

export const {
  setSkillsWidget,
  setBattleListEntries,
  setChatboxMain,
  setChatboxSecondary,
  setChatTabs,
  setSelectCharacterModal,
  setVipWidget,
  resetUiValues,
  resetRegion,
  setState,
} = uiValuesSlice.actions;

export const selectSkillsWidget = (state) => state.uiValues.skillsWidget;
export const selectSkillsData = (state) => state.uiValues.skillsWidget.skills;
export const selectCombatData = (state) => state.uiValues.skillsWidget.combat;
export const selectCharacterLevel = (state) =>
  state.uiValues.skillsWidget.level;
export const selectCharacterExperience = (state) =>
  state.uiValues.skillsWidget.experience;
export const selectChatboxMainMessages = (state) =>
  state.uiValues.chatboxMain.messages;
export const selectChatboxMainLastUpdate = (state) =>
  state.uiValues.chatboxMain.lastUpdate;
export const selectChatboxSecondaryMessages = (state) =>
  state.uiValues.chatboxSecondary.messages;
export const selectChatboxSecondaryLastUpdate = (state) =>
  state.uiValues.chatboxSecondary.lastUpdate;
export const selectChatboxTabs = (state) => state.uiValues.chatboxTabs;
export const selectChatboxActiveTab = (state) =>
  state.uiValues.chatboxTabs.activeTab;
export const selectChatboxTabsList = (state) => state.uiValues.chatboxTabs.tabs;
export const selectVipWidget = (state) => state.uiValues.vipWidget;
export const selectOnlineVips = (state) => state.uiValues.vipWidget.online;
export const selectOfflineVips = (state) => state.uiValues.vipWidget.offline;
export const selectBattleListEntries = (state) =>
  state.uiValues.battleListEntries;
// REMOVED selectGameWorldOcr selector

export default uiValuesSlice;

//endFile

