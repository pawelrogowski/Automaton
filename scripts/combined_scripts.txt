// /home/feiron/Dokumenty/Automaton/electron/constants/actionBarItems.js
//start file
const actionBarItems = {
  exuraMaxVita: {
    name: 'Exura Max Vita',
    iconName: 'Restoration',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [240, 248, 255],
      [227, 241, 255],
      [215, 235, 255],
    ],
  },
  exuraVita: {
    name: 'Exura Vita',
    iconName: 'Ultimate_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [215, 235, 254],
      [223, 239, 255],
      [228, 242, 255],
    ],
  },
  exuraGran: {
    name: 'Exura Gran',
    iconName: 'Intense_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [235, 238, 243],
      [224, 227, 233],
      [233, 229, 233],
    ],
  },
  exura: {
    name: 'Exura',
    iconName: 'Light_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [228, 210, 216],
      [223, 209, 217],
      [229, 228, 234],
    ],
  },
  exuraInfir: {
    name: 'Exura Infir',
    iconName: 'Magic_Patch',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [222, 215, 223],
      [216, 210, 218],
      [210, 199, 209],
    ],
  },
  utetaResVen: {
    name: 'Uteta Res Ven',
    iconName: 'Avatar_Of_Storm',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [173, 152, 240],
      [153, 103, 253],
      [255, 255, 255],
    ],
  },
  cancelMagicShield: {
    name: 'Exana Vita',
    iconName: 'Cancel_Magic_Shield',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [249, 200, 193],
      [251, 210, 203],
      [213, 139, 198],
    ],
  },
  curePoison: {
    name: 'Exana Pox',
    iconName: 'Cure_Poison',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [211, 236, 243],
      [184, 217, 222],
      [229, 242, 243],
    ],
  },
  exposeWeakness: {
    name: 'Exori Moe',
    iconName: 'Expose_Weakness',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [59, 63, 40],
      [59, 63, 40],
      [103, 113, 69],
    ],
  },
  magicShield: {
    name: 'Utamo Vita',
    iconName: 'Magic_Shield',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [147, 115, 27],
      [182, 151, 28],
      [226, 129, 206],
    ],
  },
  sapStrength: {
    name: 'Exori Kor',
    iconName: 'Sap_Strength',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [153, 169, 101],
      [180, 187, 118],
      [27, 27, 27],
      [22, 22, 22],
      [22, 22, 22],
    ],
  },
  utaniGranHur: {
    name: 'Utani Gran Hur',
    iconName: 'Strong_Haste',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [38, 116, 112],
      [11, 37, 36],
      [7, 29, 28],
      [6, 29, 28],
      [6, 30, 28],
    ],
  },
  utaniHur: {
    name: 'Utani Hur',
    iconName: 'Haste',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [78, 173, 166],
      [69, 157, 151],
      [12, 32, 31],
      [11, 27, 26],
      [11, 27, 26],
      [18, 44, 42],
      [29, 74, 70],
    ],
  },
  ultimateManaPotion: {
    name: 'Ultimate Mana Potion',
    iconName: 'Ultimate_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [141, 53, 102],
      [152, 58, 109],
      [116, 39, 87],
      [171, 58, 129],
      [151, 47, 114],
      [48, 44, 44],
    ],
  },
  greatManaPotion: {
    name: 'Great Mana Potion',
    iconName: 'Great_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [141, 53, 102],
      [152, 58, 109],
      [116, 39, 87],
      [171, 58, 129],
      [151, 47, 114],
      [143, 43, 109],
    ],
  },
  strongManaPotion: {
    name: 'Strong Mana Potion',
    iconName: 'Strong_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [169, 0, 131],
      [184, 0, 153],
      [143, 0, 89],
    ],
  },
  ManaPotion: {
    name: 'Mana Potion',
    iconName: 'Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [125, 6, 111],
      [150, 25, 148],
      [136, 7, 121],
    ],
  },
  healthPotion: {
    name: 'Health Potion',
    iconName: 'Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 11, 0],
      [170, 16, 16],
      [193, 47, 54],
    ],
  },
  supremeHealthPotion: {
    name: 'Supreme Health Potion',
    iconName: 'Supreme_Health_Potion',
    categories: ['potion'],
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [[222, 3, 0], 'any', 'any', [53, 43, 40]],
  },
  ultimateHealthPotion: {
    name: 'Ultimate Health Potion',
    iconName: 'Ultimate_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [247, 49, 67],
      [240, 70, 85],
      [238, 55, 66],
    ],
  },
  greatHealthPotion: {
    name: 'Great Health Potion',
    iconName: 'Great_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [247, 49, 67],
      [240, 70, 85],
      [238, 55, 66],
      [208, 2, 0],
      [161, 1, 0],
      [168, 1, 0],
    ],
  },
  strongHealthPotion: {
    name: 'Strong Health Potion',
    iconName: 'Strong_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [228, 0, 17],
      [229, 0, 17],
      [229, 1, 15],
    ],
  },
  smallHealthPotion: {
    name: 'Small Health Potion',
    iconName: 'Small_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [5, 2, 0],
      [67, 67, 67],
      [69, 69, 69],
      [109, 13, 0],
    ],
  },
  ultimateSpiritPotion: {
    name: 'Ultimate Spirit Potion',
    iconName: 'Ultimate_Spirit_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 35, 0],
      [92, 37, 0],
      [75, 30, 0],
      [111, 44, 0],
      [111, 44, 0],
      [48, 44, 44],
    ],
  },
  greatSpiritPotion: {
    name: 'Great Spirit Potion',
    iconName: 'Great_Spirit_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 35, 0],
      [92, 37, 0],
      [75, 30, 0],
      [111, 44, 0],
      [122, 59, 0],
    ],
  },
  avalancheRune: {
    name: 'Avalanche Rune',
    iconName: 'Avalanche',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [44, 81, 131],
      [45, 86, 135],
      [1, 2, 4],
      [0, 0, 0],
      [66, 129, 176],
    ],
  },
  thunderstormRune: {
    name: 'Thunderstorm Rune',
    iconName: 'Thunderstorm',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [124, 62, 162],
      [11, 5, 14],
      [9, 4, 9],
      [134, 62, 170],
    ],
  },
  greatFireballRune: {
    name: 'Great Fireball Rune',
    iconName: 'Great_Fireball',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [199, 71, 57],
      [237, 88, 72],
      [178, 73, 55],
    ],
  },
  stoneShowerRune: {
    name: 'Stone Shower Rune',
    iconName: 'Stone_Shower',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [181, 191, 133],
      [126, 166, 93],
      [116, 157, 85],
    ],
  },
  ultimateHealingRune: {
    name: 'Ultimate Healing Rune',
    iconName: 'Ultimate_Healing_Rune',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [18, 18, 18],
      [185, 185, 185],
      [255, 255, 255],
      [235, 235, 235],
      [233, 233, 233],
      [225, 225, 225],
      [209, 209, 209],
      [211, 211, 211],
      [210, 210, 210],
      [101, 101, 101],
    ],
  },
  suddenDeathRune: {
    name: 'Sudden Death Rune',
    iconName: 'Sudden_Death',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [148, 142, 132],
      [146, 137, 127],
      [79, 75, 70],
    ],
  },
  intenseHealingRune: {
    name: 'Intense Healing Rune',
    iconName: 'Intense_Healing_Rune',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [210, 210, 210],
      [100, 100, 100],
      [200, 200, 200],
    ],
  },
  explosionRune: {
    name: 'Explosion Rune',
    iconName: 'Explosion_Rune',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [13, 6, 16],
      [60, 30, 78],
      [142, 69, 182],
    ],
  },
  stoneSkinAmulet: {
    name: 'Stone Skin Amulet',
    iconName: 'Stone_Skin_Amulet',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [115, 115, 115],
      [65, 65, 65],
      [73, 73, 73],
      [73, 74, 73],
      [69, 69, 69],
      [68, 68, 68],
      [68, 69, 69],
      [73, 73, 73],
      [67, 67, 67],
      [73, 73, 73],
      [67, 67, 67],
      [74, 74, 74],
      [65, 65, 65],
      [67, 68, 68],
      [70, 71, 71],
      [0, 0, 0],
      [59, 59, 59],
      [135, 135, 135],
    ],
  },
  mightRing: {
    name: 'Might Ring',
    iconName: 'Might_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [115, 115, 115],
      [65, 65, 65],
      [73, 73, 73],
      [73, 74, 73],
      [69, 69, 69],
      [68, 68, 68],
      [68, 69, 69],
      [73, 73, 73],
      [67, 67, 67],
      [73, 73, 73],
      [67, 67, 67],
      [74, 74, 74],
      [65, 65, 65],
      [67, 68, 68],
      [0, 0, 0],
      [205, 172, 69],
    ],
  },
  mastermindPotion: {
    name: 'Mastermind Potion',
    iconName: 'Mastermind_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [67, 68, 68],
      [0, 0, 3],
      [87, 142, 92],
      [90, 160, 98],
    ],
  },
  bullseyePotion: {
    name: 'Bullseye Potion',
    iconName: 'Bullseye_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [57, 49, 44],
      [93, 80, 72],
      [115, 98, 87],
    ],
  },
  berserkPotion: {
    name: 'Berserk Potion',
    iconName: 'Berserk_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [116, 76, 36],
      [147, 91, 34],
      [137, 80, 19],
    ],
  },
  transcendencePotion: {
    name: 'Transcendence Potion',
    iconName: 'Transcendence_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [109, 82, 36],
      [109, 82, 36],
      [59, 43, 16],
      [59, 43, 16],
    ],
  },
  magicShieldPotion: {
    name: 'Magic Shield Potion',
    iconName: 'Magic_Shield_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [67, 67, 67],
      [69, 69, 69],
      [0, 0, 0],
      [239, 244, 253],
    ],
  },
  createThunderstormRune: {
    name: 'Create Thunderstorm Rune',
    iconName: 'Create_Thunderstorm_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [136, 68, 159],
      [63, 37, 64],
      [57, 34, 57],
    ],
  },
  createGreatFireballRune: {
    name: 'Create Great Fireball Rune',
    iconName: 'Create_Great_Fireball_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [89, 39, 17],
      [80, 32, 13],
      [61, 24, 8],
    ],
  },
  createSuddenDeathRune: {
    name: 'Create Sudden Death Rune',
    iconName: 'Create_Sudden_Death_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [134, 128, 122],
      [93, 90, 87],
      [50, 50, 50],
    ],
  },
  createMagicWallRune: {
    name: 'Create Magic Wall Rune',
    iconName: 'Create_Magic_Wall_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [138, 143, 93],
      [93, 106, 77],
      [100, 124, 90],
    ],
  },
  createExplosionRune: {
    name: 'Create Explosion Rune',
    iconName: 'Create_Explosion_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [39, 27, 46],
      [180, 98, 181],
      [108, 59, 133],
    ],
  },
  energyRing: {
    name: 'Energy Ring',
    iconName: 'Energy_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [88, 227, 177],
      [200, 255, 255],
      [57, 149, 118],
      [0, 0, 0],
    ],
  },
  lifeRing: {
    name: 'Life Ring',
    iconName: 'Life_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [91, 206, 68],
      [175, 253, 171],
      [60, 137, 45],
      [0, 0, 0],
    ],
  },
  dwarvenRing: {
    name: 'Dwarven Ring',
    iconName: 'Dwarven_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [196, 196, 196],
      [255, 255, 255],
      [150, 150, 150],
      [0, 0, 0],
    ],
  },
  axeRing: {
    name: 'Axe Ring',
    iconName: 'Axe_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [137, 137, 137],
      [212, 212, 212],
      [91, 91, 91],
      [0, 0, 0],
    ],
  },
  clubRing: {
    name: 'Club Ring',
    iconName: 'Club_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [206, 68, 172],
      [253, 171, 221],
      [137, 45, 114],
      [0, 0, 0],
    ],
  },
  powerRing: {
    name: 'Power Ring',
    iconName: 'Power_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [124, 53, 197],
      [214, 147, 253],
      [79, 39, 119],
      [0, 0, 0],
    ],
  },
  stealthRing: {
    name: 'Stealth Ring',
    iconName: 'Stealth_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [68, 114, 206],
      [171, 186, 253],
      [45, 75, 137],
      [0, 0, 0],
    ],
  },
  swordRing: {
    name: 'Sword Ring',
    iconName: 'Sword_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [226, 122, 0],
      [255, 212, 121],
      [134, 73, 0],
      [0, 0, 0],
    ],
  },
  timeRing: {
    name: 'Time Ring',
    iconName: 'Time_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [66, 66, 66],
      [141, 141, 141],
      [20, 20, 20],
      [0, 0, 0],
    ],
  },
  collarOfGreenPlasma: {
    name: 'Collar of Green Plasma',
    iconName: 'Collar_Of_Green_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [14, 107, 68],
      [120, 255, 198],
      [14, 107, 68],
    ],
  },
  collarOfOrangePlasma: {
    name: 'Collar of Orange Plasma',
    iconName: 'Collar_Of_Orange_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [107, 57, 14],
      [255, 182, 120],
      [107, 57, 14],
    ],
  },
  collarOfRedPlasma: {
    name: 'Collar of Red Plasma',
    iconName: 'Collar_Of_Red_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [107, 14, 53],
      [255, 120, 177],
      [107, 14, 53],
    ],
  },
  collarOfBluePlasma: {
    name: 'Collar of Blue Plasma',
    iconName: 'Collar_Of_Blue_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [14, 51, 107],
      [120, 175, 255],
      [14, 51, 107],
    ],
  },
  ringOfGreenPlasma: {
    name: 'Ring of Green Plasma',
    iconName: 'Ring_Of_Green_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [14, 107, 68],
      [210, 255, 236],
      [14, 107, 68],
    ],
  },
  ringOfRedPlasma: {
    name: 'Ring of Red Plasma',
    iconName: 'Ring_Of_Red_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [107, 14, 53],
      [255, 210, 229],
      [107, 14, 53],
    ],
  },
  ringOfOrangePlasma: {
    name: 'Ring of Orange Plasma',
    iconName: 'Ring_Of_Orange_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [107, 57, 14],
      [255, 231, 210],
      [107, 57, 14],
    ],
  },
  ringOfBluePlasma: {
    name: 'Ring of Blue Plasma',
    iconName: 'Ring_Of_Blue_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [14, 51, 107],
      [210, 228, 255],
      [14, 51, 107],
    ],
  },
  softBoots: {
    name: 'Soft Boots',
    iconName: 'Soft_Boots',
    categories: ['equipment'],
    slot: 'boots',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 117],
      [70, 70, 70],
      [71, 71, 71],
      [83, 84, 83],
      [69, 70, 69],
      [72, 72, 72],
      [74, 74, 74],
      [72, 73, 72],
      [0, 0, 0],
      [77, 62, 145],
      [124, 109, 195],
      [17, 0, 54],
    ],
  },
  blankRune: {
    name: 'Blank Rune',
    iconName: 'Blank_Rune',
    categories: ['others'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [143, 136, 127],
      [167, 161, 153],
      [180, 173, 164],
    ],
  },
  exuraSio: {
    name: 'Exura Sio',
    iconName: 'Heal_Friend',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [179, 228, 247],
      [201, 232, 245],
      [208, 239, 247],
      [27, 111, 135],
      [8, 33, 39],
    ],
  },
  exuraGranSio: {
    name: 'Exura Gran Sio',
    iconName: 'Natures_Embrace',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [198, 232, 247],
      [196, 232, 248],
      [201, 235, 247],
      [11, 110, 172],
      [44, 60, 79],
      [94, 108, 131],
    ],
  },
  uturaMasSio: {
    name: 'Utura Mas Sio',
    iconName: 'Heal_Party',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [31, 14, 16],
      [46, 19, 22],
      [125, 78, 84],
      [243, 236, 238],
      [243, 241, 245],
    ],
  },
  utanaVid: {
    name: 'Utana Vid',
    iconName: 'Invisible',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [59, 107, 107],
      [91, 98, 228],
      [52, 99, 98],
      [41, 94, 91],
    ],
  },
  exuraGranMasRes: {
    name: 'Exura Gran Mas Res',
    iconName: 'Mass_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [220, 241, 250],
      [199, 229, 240],
      [208, 234, 248],
      [196, 213, 218],
      [192, 205, 204],
    ],
  },
  exanaKor: {
    name: 'Exana Kor',
    iconName: 'Cure_Bleeding',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [213, 231, 242],
      [190, 203, 216],
      [232, 237, 240],
      [116, 35, 48],
    ],
  },
  exanaFlam: {
    name: 'Exana Flam',
    iconName: 'Cure_Burning',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [151, 99, 80],
      [185, 137, 102],
      [227, 166, 128],
      [213, 192, 138],
    ],
  },
  exanaVis: {
    name: 'Exana Vis',
    iconName: 'Cure_Electrification',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 114, 163],
      [214, 232, 253],
      [203, 224, 252],
      [90, 108, 172],
    ],
  },
  exanaMort: {
    name: 'Exana Mort',
    iconName: 'Cure_Curse',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [219, 241, 250],
      [209, 236, 247],
      [242, 251, 254],
      [229, 246, 252],
      [209, 238, 248],
    ],
  },
  utevoLux: {
    name: 'Utevo Lux',
    iconName: 'Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [253, 245, 204],
      [252, 228, 148],
      [244, 189, 99],
      [249, 201, 118],
    ],
  },
  utevoGranLux: {
    name: 'Utevo Gran Lux',
    iconName: 'Great_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [255, 252, 225],
      [255, 247, 195],
      [253, 232, 143],
      [254, 237, 164],
    ],
  },
  utevoVisLux: {
    name: 'Utevo Vis Lux',
    iconName: 'Ultimate_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [254, 253, 242],
      [255, 253, 249],
      [246, 240, 177],
      [232, 215, 104],
    ],
  },
  exuraSan: {
    name: 'Exura San',
    iconName: 'Divine_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [180, 97, 48],
      [245, 248, 221],
      [231, 243, 231],
      [204, 229, 232],
    ],
  },
  uturaGran: {
    name: 'Utura Gran',
    iconName: 'Intense_Recovery',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [51, 77, 91],
      [147, 183, 204],
      [188, 205, 209],
      [179, 179, 164],
    ],
  },
  exuraGranSan: {
    name: 'Exura Gran San',
    iconName: 'Salvation',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [199, 119, 32],
      [239, 212, 120],
      [236, 204, 117],
      [232, 199, 107],
      [201, 126, 42],
    ],
  },
  utetaResSac: {
    name: 'Uteta Res Sac',
    iconName: 'Avatar_Of_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [161, 108, 50],
      [199, 174, 147],
      [199, 174, 147],
      [27, 16, 17],
    ],
  },
  exanaIna: {
    name: 'Exana Ina',
    iconName: 'Cancel_Invisibility',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [12, 178, 167],
      [99, 99, 255],
      [9, 209, 201],
      [8, 212, 203],
    ],
  },
  utevoGravSan: {
    name: 'Utevo Grav San',
    iconName: 'Cancel_Invisibility',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [248, 247, 204],
      [247, 246, 199],
      [175, 161, 123],
    ],
  },
  utamoMasSio: {
    name: 'Utamo Mas Sio',
    iconName: 'Protect_Party',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [215, 245, 251],
      [13, 22, 21],
      [13, 22, 21],
      [13, 22, 21],
      [20, 30, 29],
      [189, 226, 232],
    ],
  },
  utitoTempoSan: {
    name: 'Utito Tempo San',
    iconName: 'Sharpshooter',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [23, 24, 25],
      [48, 50, 51],
      [48, 50, 51],
      [48, 50, 51],
      [112, 116, 118],
      [154, 159, 162],
    ],
  },
  utamoTempoSan: {
    name: 'Utamo Tempo San',
    iconName: 'Swift_Foot',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [21, 86, 81],
      [27, 91, 87],
      [47, 89, 83],
      [48, 93, 88],
    ],
  },
  exuraInfirIco: {
    name: 'Exura Infir Ico',
    iconName: 'Bruise_Bane',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [237, 219, 187],
      [244, 236, 212],
      [237, 242, 237],
      [219, 241, 250],
      [201, 232, 245],
      [207, 236, 247],
    ],
  },
  exuraMedIco: {
    name: 'Exura Med Ico',
    iconName: 'Fair_Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [240, 223, 188],
      [244, 233, 201],
      [240, 219, 181],
      [213, 152, 106],
    ],
  },
  exuraGranIco: {
    name: 'Exura Gran Ico',
    iconName: 'Intense_Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [244, 233, 197],
      [248, 241, 209],
      [246, 235, 198],
      [235, 215, 179],
    ],
  },
  woundCleansing: {
    name: 'Exura Ico',
    iconName: 'Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [236, 217, 183],
      [241, 229, 196],
      [236, 212, 174],
      [201, 129, 98],
    ],
  },
  utetaResEq: {
    name: 'Uteta Res Sac',
    iconName: 'Avatar_Of_Steel',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [42, 55, 70],
      [15, 15, 15],
      [46, 55, 71],
      [37, 46, 60],
    ],
  },
  utitoTempo: {
    name: 'Utito Tempo',
    iconName: 'Blood_Rage',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [219, 123, 119],
      [228, 172, 172],
      [236, 197, 197],
      [239, 167, 164],
    ],
  },
  utaniTempoHur: {
    name: 'Utani Tempo Hur',
    iconName: 'Charge',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [143, 80, 56],
      [196, 161, 147],
      [139, 105, 96],
      [66, 79, 65],
    ],
  },
  utamoTempo: {
    name: 'Utamo Tempo',
    iconName: 'Protector',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [41, 68, 62],
      [127, 136, 114],
      [122, 163, 141],
      [82, 108, 100],
    ],
  },
  utitoMasSio: {
    name: 'Utito Mas Sio',
    iconName: 'Train_Party',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [64, 189, 58],
      [122, 151, 106],
      [27, 111, 135],
      [8, 33, 39],
    ],
  },
  utetaResDru: {
    name: 'Utera Res Dru',
    iconName: 'Avatar_Of_Nature',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [21, 12, 8],
      [0, 0, 0],
      [0, 0, 0],
      [25, 25, 25],
      [0, 0, 0],
      [33, 33, 33],
    ],
  },
};

Object.freeze(actionBarItems);

export default actionBarItems;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/battleListSequences.js
//start file
const battleListSequences = {
  // Border detection sequences for battle entries
  targetBorder: {
    offset: { x: 0, y: 0 },
    direction: 'horizontal',
    sequence: [
      [255, 0, 0], // Red target indicator
    ],
  },
  attackBorder: {
    offset: { x: 1, y: 1 },
    direction: 'horizontal',
    sequence: [
      [0, 0, 0], // Black attack indicator
    ],
  },
  healthBarValidation: {
    offset: { x: 0, y: 0 },
    direction: 'horizontal',
    sequence: [
      [0, 0, 0], // Black border validation
    ],
  },
  // Legacy sequences (can be removed if not used)
  battleEntry: {
    offset: { x: 0, y: 0 },
    direction: 'vertical',
    sequence: [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
  partyEntry: {
    offset: { x: 0, y: 0 },
    direction: 'vertical',
    sequence: [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
};

export default battleListSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/cooldownColorSequences.js
//start file
const cooldownColorSequences = {
  attack: {
    direction: 'vertical',
    sequence: [
      [0, 0, 6],
      [70, 13, 1],
      [171, 42, 9],
      [255, 255, 255],
    ],
    backupSequence: [
      [0, 0, 6],
      [70, 13, 1],
      [171, 42, 9],
      [255, 255, 255],
    ],
  },
  healing: {
    direction: 'vertical',
    sequence: [
      [1, 37, 102],
      [77, 111, 158],
      [39, 75, 116],
      [255, 255, 255],
    ],
  },
  support: {
    direction: 'vertical',
    sequence: [
      [0, 61, 52],
      [0, 109, 99],
      [52, 179, 172],
      [255, 255, 255],
    ],
  },
  attackInactive: {
    direction: 'vertical',
    sequence: [
      [71, 13, 2],
      [53, 10, 3],
      [0, 0, 0],
    ],
    backupSequence: [
      [72, 13, 2],
      [53, 11, 3],
      [0, 0, 0],
    ],
  },
  healingInactive: {
    direction: 'vertical',
    sequence: [
      [17, 29, 45],
      [6, 16, 30],
      [0, 0, 0],
    ],
  },
  supportInactive: {
    direction: 'vertical',
    sequence: [
      [42, 74, 73],
      [28, 50, 48],
      [0, 0, 0],
    ],
  },
};

export default cooldownColorSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/equippedItems.js
//start file
const equippedItems = {
  emptyRingSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [53, 56, 59],
      [35, 39, 42],
      [36, 39, 42],
      [66, 69, 72],
      [79, 81, 84],
      [37, 40, 43],
    ],
  },
  emptyAmuletSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [30, 33, 36],
      [65, 67, 70],
      [70, 73, 75],
      [82, 84, 87],
      [71, 73, 75],
      [67, 69, 72],
      [32, 35, 37],
    ],
  },
  emptyBootsSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [76, 78, 81],
      [61, 64, 66],
      [61, 64, 66],
      [52, 54, 57],
    ],
  },
  softBoots: {
    name: 'Soft Boots',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [36, 9, 93],
      [119, 92, 176],
      [115, 88, 172],
      [79, 52, 136],
    ],
  },
  mightRing: {
    name: 'Might Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [250, 237, 117],
      [246, 219, 98],
      [200, 166, 65],
      [221, 184, 71],
    ],
  },
  stoneSkinAmulet: {
    name: 'Stone Skin Amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [60, 60, 60],
      [110, 110, 110],
      [119, 119, 119],
      [110, 110, 110],
      [60, 60, 60],
    ],
  },
  energyRing: {
    name: 'Energy Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [88, 227, 177],
      [200, 255, 255],
      [57, 149, 118],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
  lifeRing: {
    name: 'Life Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [91, 206, 68],
      [175, 253, 171],
      [60, 137, 45],
    ],
  },
};

export default equippedItems;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/floorLevelIndicators.js
//start file
const floorLevelIndicators = {
  0: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[115, 182, 212]],
  },
  1: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[104, 165, 193]],
  },
  2: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[95, 152, 177]],
  },
  3: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[88, 140, 163]],
  },
  4: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[82, 130, 151]],
  },
  5: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[76, 121, 141]],
  },
  6: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[71, 114, 132]],
  },
  7: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[120, 147, 79]],
  },
  8: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[147, 100, 79]],
  },
  9: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[134, 90, 72]],
  },
  10: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[122, 83, 66]],
  },
  11: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[113, 76, 61]],
  },
  12: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[105, 71, 57]],
  },
  13: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[98, 66, 53]],
  },
  14: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[92, 62, 49]],
  },
  15: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[86, 58, 47]],
  },
};

export default floorLevelIndicators;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/index.js
//start file
export { default as regionColorSequences } from './regionColorSequeces.js';
export { default as regionDefinitions } from './regionDefinitions.js';
export { default as cooldownColorSequences } from './cooldownColorSequences.js';
export { default as battleListSequences } from './battleListSequences.js';
export { default as statusBarSequences } from './statusBarSequences.js';
export { default as resourceBars } from './resourceBars.js';
export { default as actionBarItems } from './actionBarItems.js';
export { default as equippedItems } from './equippedItems.js';
export { default as floorLevelIndicators } from './floorLevelIndicators.js';

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/palette.js
//start file
export const PALETTE_DATA = [
  { r: 0, g: 0, b: 0 },
  { r: 0, g: 102, b: 0 },
  { r: 0, g: 204, b: 0 },
  { r: 51, g: 102, b: 153 },
  { r: 102, g: 102, b: 102 },
  { r: 153, g: 51, b: 0 },
  { r: 153, g: 102, b: 51 },
  { r: 153, g: 153, b: 153 },
  { r: 153, g: 255, b: 102 },
  { r: 204, g: 255, b: 255 },
  { r: 255, g: 51, b: 0 },
  { r: 255, g: 102, b: 0 },
  { r: 255, g: 204, b: 153 },
  { r: 255, g: 255, b: 0 },
  { r: 255, g: 255, b: 255 },
];

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/regionColorSequeces.js
//start file
const regionColorSequences = {
  healthBar: {
    direction: 'horizontal',
    offset: { x: 5, y: 0 },
    sequence: [
      [241, 97, 97],
      [219, 91, 91],
      [103, 55, 55],
      'any',
      'any',
      [120, 61, 64],
    ],
  },
  manaBar: {
    direction: 'horizontal',
    offset: { x: 9, y: 0 },
    sequence: [
      [99, 96, 248],
      [95, 92, 219],
      [80, 79, 140],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [61, 61, 125],
    ],
  },
  minimap: {
    direction: 'horizontal',
    offset: { x: -117, y: 35 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  minimapFloorIndicatorColumn: {
    direction: 'horizontal',
    offset: { x: 33, y: 25 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  minimapFull: {
    direction: 'horizontal',
    offset: { x: -117, y: -20 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  cooldownBar: {
    direction: 'horizontal',
    offset: { x: -154, y: 8 },
    sequence: [
      [76, 75, 67],
      [77, 76, 71],
      [67, 66, 59],
    ],
    backupSequence: [
      [76, 75, 67],
      [76, 75, 71],
      [66, 65, 58],
    ],
  },
  // cooldownBarFallback: {
  //   direction: 'horizontal',
  //   offset: { x: -154, y: 8 },
  //   sequence: [
  //     [76, 75, 67],
  //     [77, 76, 71],
  //     [67, 66, 59],
  //   ],
  // },
  statusBar: {
    direction: 'horizontal',
    offset: { x: -99, y: 1 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  amuletSlot: {
    direction: 'horizontal',
    offset: { x: -100, y: -130 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  ringSlot: {
    direction: 'horizontal',
    offset: { x: -100, y: -58 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  bootsSlot: {
    direction: 'horizontal',
    offset: { x: -63, y: -36 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  // weaponSlot: {
  //   direction: 'horizontal',
  //   offset: { x: -100, y: -58 },
  //   sequence: [
  //     [41, 42, 42],
  //     [28, 28, 29],
  //     [44, 45, 45],
  //     [40, 40, 41],
  //     [44, 44, 44],
  //     [46, 46, 46],
  //     [112, 112, 113],
  //   ],
  // },
  chatOn: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [108, 108, 108],
      [110, 110, 110],
      [192, 192, 192],
      [161, 161, 161],
      [175, 175, 175],
      [185, 185, 185],
      [81, 81, 81],
    ],
  },
  chatOff: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [174, 174, 174],
      [183, 183, 183],
      [136, 136, 136],
      [174, 174, 174],
      [183, 183, 183],
      [128, 128, 128],
      [62, 62, 62],
    ],
  },

  hotkeyBarBottomStart: {
    direction: 'horizontal',
    offset: { x: 19, y: 0 },
    sequence: [
      [75, 75, 75],
      [68, 68, 68],
      [76, 76, 76],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [46, 46, 47],
      [53, 54, 54],
    ],
  },
  hotkeyBarBottomEnd: {
    direction: 'horizontal',
    offset: { x: -2, y: 0 },
    sequence: [
      [40, 40, 40],
      [43, 43, 43],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [66, 66, 66],
    ],
  },
  battleListStart: {
    direction: 'horizontal',
    offset: { x: 11, y: 17 },
    sequence: [
      [49, 49, 49],
      [129, 79, 41],
      [113, 91, 70],
      [56, 56, 56],
    ],
  },
  battleListEnd: {
    direction: 'horizontal',
    offset: { x: -137, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  partyListStart: {
    direction: 'horizontal',
    offset: { x: 13, y: 13 },
    sequence: [
      [30, 115, 255],
      [55, 55, 55],
      [113, 91, 70],
      [56, 56, 56],
    ],
  },
  partyListEnd: {
    direction: 'horizontal',
    offset: { x: -7, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  playerListStart: {
    direction: 'horizontal',
    offset: { x: 11, y: 17 },
    sequence: [
      [135, 86, 41],
      [159, 136, 40],
      [75, 74, 55],
      [61, 61, 61],
      [128, 193, 84],
      [128, 193, 84],
    ],
  },
  playerListEnd: {
    direction: 'horizontal',
    offset: { x: -137, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  onlineMarker: {
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [
      [118, 54, 54],
      [74, 74, 75],
      [72, 72, 72],
      [68, 66, 99],
    ],
  },
  gameWorldStart: {
    direction: 'horizontal',
    offset: { x: 1, y: 1 },
    sequence: [
      [22, 22, 22],
      [24, 24, 24],
      [23, 23, 23],
      [22, 22, 22],
      [21, 21, 21],
      [24, 24, 24],
      [23, 24, 23],
      [24, 24, 24],
      [27, 27, 26],
      [24, 24, 24],
      [22, 22, 22],
    ],
  },
  gameWorldEnd: {
    direction: 'horizontal',
    offset: { x: 9, y: -1 },
    sequence: [
      [111, 111, 111],
      [117, 117, 117],
      [116, 116, 116],
      [116, 116, 116],
      [113, 113, 113],
      [115, 115, 115],
      [116, 116, 115],
      [115, 115, 115],
      [118, 118, 117],
      [115, 115, 115],
      [114, 114, 114],
    ],
  },
  chatboxMainStart: {
    direction: 'vertical',
    offset: { x: 1, y: 5 },
    sequence: [
      [112, 112, 113],
      [116, 116, 117],
      'any',
      'any',
      [117, 117, 117],
      'any',
      [27, 27, 28],
    ],
  },
  chatboxSecondaryStart: {
    direction: 'horizontal',
    offset: { x: -1, y: 1 },
    sequence: [
      [63, 63, 63],
      [27, 27, 28],
      'any',
      'any',
      [117, 117, 117],
      [63, 63, 63],
      [27, 27, 28],
    ],
  },
  chatboxMainEnd: {
    direction: 'vertical',
    offset: { x: -7, y: 3 },
    sequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [54, 54, 54],
      [54, 54, 54],
    ],
    backupSequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      [115, 116, 115],
      [75, 75, 75],
    ],
  },
  chatboxSecondaryEnd: {
    direction: 'vertical',
    offset: { x: -7, y: 3 },
    sequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      [115, 116, 115],
      [75, 75, 75],
    ],
  },
  chatBoxTabRowStart: {
    direction: 'vertical',
    offset: { x: 13, y: -14 },
    sequence: [
      [112, 112, 113],
      [116, 116, 117],
      'any',
      'any',
      [117, 117, 117],
      'any',
      [27, 27, 28],
    ],
  },
  chatBoxTabRowEnd: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [89, 89, 89],
      [38, 38, 38],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [89, 89, 89],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [66, 66, 66],
    ],
  },
  skillsWidgetStart: {
    direction: 'horizontal',
    offset: { x: -3, y: 13 },
    sequence: [
      [170, 143, 100],
      [188, 174, 103],
      [55, 55, 55],
      [65, 65, 65],
    ],
  },
  skillsWidgetEnd: {
    direction: 'horizontal',
    offset: { x: -11, y: 1 },
    sequence: [
      [108, 108, 108],
      [160, 160, 160],
      [81, 81, 81],
      [67, 67, 67],
      [67, 67, 67],
    ],
  },
  preyWindow: {
    direction: 'horizontal',
    offset: { x: -13, y: -6 },
    sequence: [
      [229, 169, 24],
      [25, 70, 10],
      [39, 103, 18],
    ],
  },
  connectionLostCloseButton: {
    direction: 'horizontal',
    offset: { x: 129, y: 117 },
    sequence: [
      [56, 56, 56],
      [144, 144, 144],
      [144, 144, 144],
      [52, 52, 52],
      [64, 64, 64],
      [55, 56, 56],
      [144, 144, 144],
      [144, 144, 144],
      [67, 67, 67],
      [52, 52, 52],
      [144, 144, 144],
      [144, 144, 144],
      [48, 48, 48],
    ],
  },
};

export default regionColorSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/regionDefinitions.js
//start file
import actionBarItems from './actionBarItems.js';

const actionBarEntries = Object.entries(actionBarItems);
const regionDefinitions = {
  healthBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 5, y: 0 },
    sequence: [
      [241, 97, 97],
      [219, 91, 91],
      [103, 55, 55],
      'any',
      'any',
      [120, 61, 64],
    ],
    width: 94,
    height: 14,
  },
  manaBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 9, y: 0 },
    sequence: [
      [99, 96, 248],
      [95, 92, 219],
      [80, 79, 140],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [61, 61, 125],
    ],
    width: 94,
    height: 14,
  },
  minimap: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -117, y: 35 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 106,
    height: 109,
  },
  minimapFloorIndicatorColumn: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 33, y: 25 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 2,
    height: 63,
  },
  minimapFull: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -117, y: -20 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 106,
    height: 109,
  },
  cooldownBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -154, y: 8 },
    sequence: [
      [76, 75, 67],
      [77, 76, 71],
      [67, 66, 59],
    ],
    backupSequence: [
      [76, 75, 67],
      [76, 75, 71],
      [66, 65, 58],
    ],
    width: 56,
    height: 4,
    children: {
      healing: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [1, 37, 102],
          [77, 111, 158],
          [39, 75, 116],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      support: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [0, 61, 52],
          [0, 109, 99],
          [52, 179, 172],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      attack: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [0, 0, 6],
          [70, 13, 1],
          [171, 42, 9],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      healingInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [17, 29, 45],
          [6, 16, 30],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
      supportInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [42, 74, 73],
          [28, 50, 48],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
      attackInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [71, 13, 2],
          [53, 10, 3],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
    },
  },
  statusBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -99, y: 1 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 104,
    height: 9,
    children: {
      inRestingArea: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [101, 157, 101],
          [120, 34, 34],
          [26, 45, 27],
        ],
      },
      inProtectedZone: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [172, 201, 246],
          [29, 77, 155],
          [118, 165, 242],
        ],
      },
      hungry: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [246, 212, 143],
          [246, 212, 143],
          [239, 180, 63],
        ],
      },
      poisoned: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [52, 118, 62],
          [54, 168, 70],
          [52, 118, 62],
        ],
      },
      hasted: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [176, 139, 80],
          [72, 57, 33],
          [249, 249, 248],
        ],
      },
      battleSign: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [151, 151, 156],
          [182, 182, 185],
          [124, 124, 128],
        ],
      },
      redBattleSign: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [55, 8, 8],
          [127, 0, 0],
          [173, 0, 0],
        ],
      },
      whiteSkull: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [242, 242, 242],
          [235, 235, 235],
          [232, 232, 232],
        ],
      },
      redSkull: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [213, 206, 206],
          [255, 173, 173],
          [255, 171, 171],
        ],
      },
      burning: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [174, 16, 13],
          [253, 139, 0],
          [218, 32, 4],
          [174, 16, 13],
        ],
      },
      magicShield: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [211, 198, 27],
          [86, 97, 91],
          [154, 26, 55],
        ],
      },
      strengthened: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [37, 170, 21],
          [32, 56, 30],
          [243, 153, 32],
        ],
      },
      cursed: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [9, 9, 9],
          [164, 164, 164],
          [210, 210, 210],
        ],
      },
      electrified: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [67, 21, 70],
          [241, 173, 245],
          [67, 21, 70],
        ],
      },
      paralyzed: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [120, 24, 24],
          [213, 8, 8],
          [243, 2, 2],
        ],
      },
      drowning: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [75, 206, 222],
          [208, 220, 224],
          [48, 142, 170],
        ],
      },
      bleeding: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [54, 28, 32],
          [128, 42, 50],
          [54, 28, 32],
        ],
      },
      freezing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [128, 255, 255],
          [190, 252, 252],
          [128, 255, 255],
        ],
      },
      eRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [30, 32, 119],
          [42, 46, 148],
          [26, 28, 111],
        ],
      },
      drunk: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [95, 79, 54],
          [151, 121, 74],
          [145, 116, 70],
        ],
      },
    },
  },
  amuletSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -100, y: -130 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    children: {
      emptyAmuletSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [30, 33, 36],
          [65, 67, 70],
          [70, 73, 75],
          [82, 84, 87],
          [71, 73, 75],
          [67, 69, 72],
          [32, 35, 37],
        ],
      },
      stoneSkinAmulet: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [60, 60, 60],
          [110, 110, 110],
          [119, 119, 119],
          [110, 110, 110],
          [60, 60, 60],
        ],
      },
    },
  },
  ringSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -100, y: -58 },
    sequence: [
      [41, 41, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    children: {
      emptyRingSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [53, 56, 59],
          [35, 39, 42],
          [36, 39, 42],
          [66, 69, 72],
          [79, 81, 84],
          [37, 40, 43],
        ],
      },
      mightRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [250, 237, 117],
          [246, 219, 98],
          [200, 166, 65],
          [221, 184, 71],
        ],
      },
      energyRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [88, 227, 177],
          [200, 255, 255],
          [57, 149, 118],
          [0, 0, 0],
          [0, 0, 0],
        ],
      },
      lifeRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [91, 206, 68],
          [175, 253, 171],
          [60, 137, 45],
        ],
      },
    },
  },
  bootsSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -63, y: -36 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    children: {
      emptyBootsSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [76, 78, 81],
          [61, 64, 66],
          [61, 64, 66],
          [52, 54, 57],
        ],
      },
      softBoots: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [36, 9, 93],
          [119, 92, 176],
          [115, 88, 172],
          [79, 52, 136],
        ],
      },
    },
  },
  chatOn: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [108, 108, 108],
      [110, 110, 110],
      [192, 192, 192],
      [161, 161, 161],
      [175, 175, 175],
      [185, 185, 185],
      [81, 81, 81],
    ],
    width: 8,
    height: 1,
  },
  chatOff: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [174, 174, 174],
      [183, 183, 183],
      [136, 136, 136],
      [174, 174, 174],
      [183, 183, 183],
      [128, 128, 128],
      [62, 62, 62],
    ],
    width: 7,
    height: 1,
  },
  hotkeyBar: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 19, y: 0 },
      sequence: [
        [75, 75, 75],
        [68, 68, 68],
        [76, 76, 76],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [46, 46, 47],
        [53, 54, 54],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -2, y: 0 },
      sequence: [
        [40, 40, 40],
        [43, 43, 43],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [66, 66, 66],
      ],
    },
    maxRight: 2000,
    maxDown: 110,
    children: Object.fromEntries(
      actionBarEntries.map(([key, value]) => {
        const isVertical = value.direction === 'vertical';
        const seqLen = value.sequence.length;
        return [
          key,
          {
            type: 'single',
            direction: value.direction,
            offset: value.offset,
            sequence: value.sequence,
            width: isVertical ? 1 : seqLen,
            height: isVertical ? seqLen : 1,
          },
        ];
      }),
    ),
  },
  battleList: {
    ocrColors: [
      [192, 192, 192],
      [247, 247, 247],
    ],
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -4, y: -9 },
      sequence: [
        [113, 75, 43],
        [135, 86, 41],
        [159, 136, 40],
        [65, 65, 65],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: 9, y: 7 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
      ],
    },
    maxRight: 165,
    maxDown: 9999,
    children: {
      entries: {
        type: 'boundingBox',
        start: {
          direction: 'horizontal',
          offset: { x: -2, y: 4 },
          sequence: [
            [113, 75, 43],
            [135, 86, 41],
            [159, 136, 40],
            [65, 65, 65],
          ],
        },
        end: {
          direction: 'vertical',
          offset: { x: -7, y: -3 },
          sequence: [
            [159, 159, 159],
            [160, 160, 160],
            [104, 104, 104],
            [10, 10, 10],
          ],
        },
        maxRight: 180,
        maxDown: 9999,
      },
      close: {
        type: 'fixed',
        x: 164,
        y: 8,
        width: 3,
        height: 3,
      },
      minimize: {
        type: 'fixed',
        x: 151,
        y: 8,
        width: 3,
        height: 3,
      },
      types: {
        type: 'fixed',
        x: 136,
        y: 8,
        width: 3,
        height: 3,
      },
      order: {
        type: 'fixed',
        x: 125,
        y: 8,
        width: 3,
        height: 3,
      },
      new: {
        type: 'fixed',
        x: 112,
        y: 8,
        width: 3,
        height: 3,
      },
    },
  },
  partyList: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 13, y: 13 },
      sequence: [
        [30, 115, 255],
        [55, 55, 55],
        [113, 91, 70],
        [56, 56, 56],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -7, y: 0 },
      sequence: [
        [67, 67, 67],
        [78, 78, 78],
        [104, 104, 104],
        [67, 67, 67],
      ],
    },
    maxRight: 160,
    maxDown: 200,
  },

  playerList: {
    ocrColors: [
      [192, 192, 192],
      [247, 247, 247],
    ],
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -4, y: 4 },
      sequence: [
        [159, 136, 40],
        [75, 74, 55],
        [61, 61, 61],
        [128, 193, 84],
        [128, 193, 84],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -3, y: 12 },
      sequence: [
        [10, 10, 10],
        [103, 103, 103],
        [53, 53, 53],
        [11, 11, 11],
        [30, 30, 30],
      ],
    },
    children: {
      whiteSkull: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [0, 0, 0],
          [227, 227, 227],
          [138, 138, 138],
          [83, 83, 83],
        ],
      },
    },
    maxRight: 168,
    maxDown: 2000,
  },
  gameWorld: {
    ocrColors: [
      [192, 192, 192],
      [0, 192, 0],
      [96, 192, 96],
      [192, 192, 0],
      [192, 48, 48],
      [192, 0, 0],
      [96, 0, 0],
    ],
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 1, y: 1 },
      sequence: [
        [22, 22, 22],
        [24, 24, 24],
        [23, 23, 23],
        [22, 22, 22],
        [21, 21, 21],
        [24, 24, 24],
        [23, 24, 23],
        [24, 24, 24],
        [27, 27, 26],
        [24, 24, 24],
        [22, 22, 22],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: 9, y: -1 },
      sequence: [
        [111, 111, 111],
        [117, 117, 117],
        [116, 116, 116],
        [116, 116, 116],
        [113, 113, 113],
        [115, 115, 115],
        [116, 116, 115],
        [115, 115, 115],
        [118, 118, 117],
        [115, 115, 115],
        [114, 114, 114],
      ],
    },
    maxRight: 'fullWidth',
    maxDown: 'fullHeight',
  },
  chatboxMain: {
    type: 'boundingBox',
    start: {
      direction: 'vertical',
      offset: { x: 1, y: 5 },
      sequence: [
        [112, 112, 113],
        [116, 116, 117],
        'any',
        'any',
        [117, 117, 117],
        'any',
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -7, y: 3 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [54, 54, 54],
        [54, 54, 54],
      ],
      backupSequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        [115, 116, 115],
        [75, 75, 75],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
    ocrColors: [
      [240, 240, 0],
      [248, 96, 96],
      [240, 240, 240],
      [96, 248, 248],
      [32, 160, 255],
      [160, 160, 255],
      [0, 240, 0],
    ],
  },
  chatboxSecondary: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -1, y: 1 },
      sequence: [
        [63, 63, 63],
        [27, 27, 28],
        'any',
        'any',
        [117, 117, 117],
        [63, 63, 63],
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -7, y: 3 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        [115, 116, 115],
        [75, 75, 75],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
    ocrColors: [
      [240, 240, 0],
      [248, 96, 96],
      [240, 240, 240],
      [96, 248, 248],
      [32, 160, 255],
      [160, 160, 255],
      [0, 240, 0],
    ],
  },
  chatBoxTabRow: {
    ocrColors: [
      [223, 223, 223],
      [247, 95, 95],
      [127, 127, 127],
    ],
    type: 'boundingBox',
    start: {
      direction: 'vertical',
      offset: { x: 13, y: -14 },
      sequence: [
        [112, 112, 113],
        [116, 116, 117],
        'any',
        'any',
        [117, 117, 117],
        'any',
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: 0, y: 0 },
      sequence: [
        [89, 89, 89],
        [38, 38, 38],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [89, 89, 89],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [66, 66, 66],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
  },
  skillsWidget: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -3, y: 13 },
      sequence: [
        [170, 143, 100],
        [188, 174, 103],
        [55, 55, 55],
        [65, 65, 65],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -11, y: 1 },
      sequence: [
        [108, 108, 108],
        [160, 160, 160],
        [81, 81, 81],
        [67, 67, 67],
        [67, 67, 67],
      ],
    },
    maxRight: 170,
    maxDown: 1000,
    ocrColors: [
      [192, 192, 192],
      [68, 173, 37],
    ],
  },
  loginModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [74, 74, 74],
      [192, 192, 192],
      [192, 192, 192],
      [75, 75, 75],
      [69, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [76, 76, 75],
      [74, 74, 73],
      [73, 74, 73],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [82, 82, 82],
      [72, 73, 72],
      [71, 72, 71],
      [74, 75, 75],
      [192, 192, 192],
      [192, 192, 192],
      [74, 74, 74],
    ],
    width: 1,
    height: 1,
    children: {
      emailInput: {
        type: 'fixed',
        x: 0,
        y: -76,
        width: 1,
        height: 1,
      },
      passwordInput: {
        type: 'fixed',
        x: 0,
        y: -43,
        width: 1,
        height: 1,
      },
      login: {
        type: 'fixed',
        x: 75,
        y: 39,
        width: 60,
        height: 3,
      },
      createNewAccount: {
        type: 'fixed',
        x: -71,
        y: 42,
        width: 60,
        height: 3,
      },
    },
  },
  connectionLostModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [144, 144, 144],
      [53, 53, 53],
      [55, 55, 55],
      [144, 144, 144],
      [144, 144, 144],
      [61, 61, 61],
      [49, 49, 49],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 57],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [62, 62, 62],
      [59, 60, 60],
      [61, 61, 61],
      [144, 144, 144],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 101,
        y: 118,
        width: 1,
        height: 1,
      },
    },
  },
  warningModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [56, 56, 57],
      [144, 144, 144],
      [144, 144, 144],
      [51, 51, 51],
      [144, 144, 144],
      [144, 144, 144],
      [47, 48, 48],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    children: {
      abort: {
        type: 'fixed',
        x: 93,
        y: 125,
        width: 1,
        height: 1,
      },
    },
  },
  connectionFailedModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [53, 53, 52],
      [144, 144, 144],
      [144, 144, 144],
      [49, 49, 49],
      [44, 44, 44],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 142,
        y: 166,
        width: 1,
        height: 1,
      },
    },
  },
  wrongPasswordModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [65, 65, 65],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [64, 64, 64],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [65, 65, 65],
      [62, 62, 62],
      [75, 76, 75],
      [76, 76, 76],
      [67, 67, 67],
      [65, 65, 65],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [70, 70, 70],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 45,
        y: 40,
        width: 1,
        height: 1,
      },
    },
  },
  connectingModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [56, 57, 56],
      [144, 144, 144],
      [144, 144, 144],
      [67, 68, 67],
      [58, 59, 58],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [54, 54, 54],
      [50, 50, 49],
      [144, 144, 144],
      [144, 144, 144],
      [53, 53, 53],
      [55, 55, 55],
      [144, 144, 144],
      [144, 144, 144],
      [61, 61, 61],
      [49, 49, 49],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 57],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [53, 53, 53],
    ],
    width: 1,
    height: 1,
    children: {
      cancel: {
        type: 'fixed',
        x: 192,
        y: 68,
        width: 1,
        height: 1,
      },
    },
  },
  pleaseWaitModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [65, 64, 64],
      [67, 68, 68],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [72, 72, 72],
    ],
    width: 1,
    height: 1,
    children: {
      abort: {
        type: 'fixed',
        x: 125,
        y: 93,
        width: 1,
        height: 1,
      },
    },
  },
  ipChangedModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [144, 144, 144],
      [144, 144, 144],
      [56, 56, 56],
      [59, 59, 59],
      [59, 60, 59],
      [52, 52, 52],
      [144, 144, 144],
      [144, 144, 144],
      [49, 49, 49],
      [52, 52, 52],
      [67, 67, 67],
      [52, 52, 52],
      [52, 53, 53],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [56, 56, 56],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 220,
        y: 65,
        width: 1,
        height: 1,
      },
    },
  },
  selectCharacterModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -358, y: 48 },
    sequence: [
      [144, 144, 144],
      [144, 144, 144],
      [55, 55, 54],
      [56, 56, 55],
      [54, 54, 54],
      [65, 65, 65],
      [49, 49, 49],
      [56, 57, 56],
      [144, 144, 144],
      [144, 144, 144],
      [54, 54, 53],
    ],
    width: 263,
    height: 266,
    ocrColors: [
      [244, 244, 244],
      [192, 192, 192],
    ],
    children: {
      ok: {
        type: 'fixed',
        x: 634,
        y: 345,
        width: 7,
        height: 7,
      },
      cancel: {
        type: 'fixed',
        x: 683,
        y: 347,
        width: 7,
        height: 7,
      },
    },
  },
  warningModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -99, y: -10 },
    sequence: [
      [52, 52, 51],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [58, 58, 58],
      [55, 55, 54],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 56],
      [52, 53, 52],
      [49, 49, 49],
      [144, 144, 144],
    ],
    width: 250,
    height: 157,
    children: {
      abort: {
        type: 'fixed',
        x: 213,
        y: 137,
        width: 5,
        height: 5,
      },
    },
  },
  notLoggedInAnymoreModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -271, y: -172 },
    sequence: [
      [192, 192, 192],
      [192, 192, 192],
      [67, 67, 66],
      [69, 70, 69],
      [192, 192, 192],
      [192, 192, 192],
      [73, 73, 73],
      [72, 73, 72],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [70, 70, 70],
      [61, 61, 61],
      [73, 73, 73],
      [192, 192, 192],
      [192, 192, 192],
      [76, 76, 76],
      [79, 79, 79],
      [192, 192, 192],
      [192, 192, 192],
      [65, 65, 65],
    ],
    width: 470,
    height: 100,
    children: {
      ok: {
        type: 'fixed',
        x: 154,
        y: 36,
        width: 5,
        height: 5,
      },
    },
  },

  gameLog: {
    type: 'fixed',
    x: 808,
    y: 695,
    width: 125,
    height: 11,
    ocrColors: [[240, 240, 240]],
  },
  onlineMarker: {
    type: 'single',
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [
      [118, 54, 54],
      [74, 74, 75],
      [72, 72, 72],
      [68, 66, 99],
    ],
    width: 1,
    height: 1,
  },
  stowText: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [70, 70, 70],
      [65, 65, 65],
    ],
    width: 1,
    height: 1,
  },
  stashIcon: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [45, 13, 13],
      [45, 13, 13],
      [255, 213, 212],
      [206, 60, 57],
      [45, 13, 13],
      [116, 86, 62],
    ],
    width: 1,
    height: 1,
  },
  vipWidget: {
    type: 'boundingBox',
    maxRight: 176,
    maxDown: 99999,
    ocrColors: [
      [248, 96, 96],
      [96, 248, 96],
    ],
    start: {
      direction: 'horizontal',
      offset: { x: -9, y: -9 },
      sequence: [
        [118, 93, 57],
        [108, 80, 41],
        [102, 87, 38],
        [121, 114, 48],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: 9, y: 6 },
      sequence: [
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
      ],
    },
  },
};

export default regionDefinitions;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/resourceBars.js
//start file
const resourceBars = {
  healthBar: [
    [120, 61, 64],
    [211, 79, 79],
    [219, 79, 79],
    [194, 74, 74],
    [100, 46, 49],
  ],
  manaBar: [
    [83, 80, 218],
    [77, 74, 194],
    [45, 45, 105],
    [61, 61, 125],
    [82, 79, 211],
  ],
  partyEntryHpBar: [
    [0, 192, 0],
    [96, 192, 96],
    [192, 192, 0],
    [192, 48, 48],
    [96, 0, 0],
  ],
};

export default resourceBars;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/statusBarSequences.js
//start file
const statusBarSequences = {
  inRestingArea: {
    direction: 'horizontal',
    sequence: [
      [101, 157, 101],
      [120, 34, 34],
      [26, 45, 27],
    ],
  },
  inProtectedZone: {
    direction: 'horizontal',
    sequence: [
      [172, 201, 246],
      [29, 77, 155],
      [118, 165, 242],
    ],
  },
  hungry: {
    direction: 'horizontal',
    sequence: [
      [246, 212, 143],
      [246, 212, 143],
      [239, 180, 63],
    ],
  },
  poisoned: {
    direction: 'horizontal',
    sequence: [
      [52, 118, 62],
      [54, 168, 70],
      [52, 118, 62],
    ],
  },
  hasted: {
    direction: 'horizontal',
    sequence: [
      [176, 139, 80],
      [72, 57, 33],
      [249, 249, 248],
    ],
  },
  battleSign: {
    direction: 'horizontal',
    sequence: [
      [151, 151, 156],
      [182, 182, 185],
      [124, 124, 128],
    ],
  },
  redBattleSign: {
    direction: 'horizontal',
    sequence: [
      [55, 8, 8],
      [127, 0, 0],
      [173, 0, 0],
    ],
  },
  whiteSkull: {
    direction: 'horizontal',
    sequence: [
      [242, 242, 242],
      [235, 235, 235],
      [232, 232, 232],
    ],
  },
  redSkull: {
    direction: 'horizontal',
    sequence: [
      [213, 206, 206],
      [255, 173, 173],
      [255, 171, 171],
    ],
  },
  burning: {
    direction: 'horizontal',
    sequence: [
      [174, 16, 13],
      [253, 139, 0],
      [218, 32, 4],
      [174, 16, 13],
    ],
  },
  magicShield: {
    direction: 'horizontal',
    sequence: [
      [211, 198, 27],
      [86, 97, 91],
      [154, 26, 55],
    ],
  },
  strengthened: {
    direction: 'horizontal',
    sequence: [
      [37, 170, 21],
      [32, 56, 30],
      [243, 153, 32],
    ],
  },
  cursed: {
    direction: 'horizontal',
    sequence: [
      [9, 9, 9],
      [164, 164, 164],
      [210, 210, 210],
    ],
  },
  electrified: {
    direction: 'horizontal',
    sequence: [
      [67, 21, 70],
      [241, 173, 245],
      [67, 21, 70],
    ],
  },
  paralyzed: {
    direction: 'horizontal',
    sequence: [
      [120, 24, 24],
      [213, 8, 8],
      [243, 2, 2],
    ],
  },
  drowning: {
    direction: 'horizontal',
    sequence: [
      [75, 206, 222],
      [208, 220, 224],
      [48, 142, 170],
    ],
  },
  bleeding: {
    direction: 'horizontal',
    sequence: [
      [54, 28, 32],
      [128, 42, 50],
      [54, 28, 32],
    ],
  },
  freezing: {
    direction: 'horizontal',
    sequence: [
      [128, 255, 255],
      [190, 252, 252],
      [128, 255, 255],
    ],
  },
  eRing: {
    direction: 'horizontal',
    sequence: [
      [30, 32, 119],
      [42, 46, 148],
      [26, 28, 111],
    ],
  },
  drunk: {
    direction: 'horizontal',
    sequence: [
      [95, 79, 54],
      [151, 121, 74],
      [145, 116, 70],
    ],
  },
};

export default statusBarSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/createMainWindow.js
//start file
import {
  app,
  ipcMain,
  BrowserWindow,
  Tray,
  Menu,
  dialog,
  nativeImage,
} from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';

import { loadRulesFromFile, saveRulesToFile } from './saveManager.js';
import {
  toggleNotifications,
  setGlobalShortcutsEnabled,
} from '../frontend/redux/slices/globalSlice.js';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import {
  registerGlobalShortcuts,
  unregisterGlobalShortcuts,
} from './globalShortcuts.js';

const HTML_PATH = '../dist/index.html';

let mainWindow;
let tray;
let isNotificationEnabled = false;
let isTrayVisible = true;
let widgetWindow = null;
let isMainWindowVisible = false;
let isWidgetWindowVisible = false;
let isGlobalShortcutsEnabled = true;

const filename = fileURLToPath(import.meta.url);
const dirname = path.dirname(filename);

const WIDGET_HTML_PATH = path.join(dirname, 'widget', 'widget.html');
const WIDGET_PRELOAD_PATH = path.join(dirname, 'widget', 'preload.js');

const ICON_PATHS = {
  white: path.join(dirname, './icons/white_dot.png'),
  green: path.join(dirname, './icons/green_dot.png'),
  red: path.join(dirname, './icons/red_dot.png'),
  app: path.join(dirname, './icons/automaton.png'),
};

const updateTrayIcon = () => {
  if (!tray) return;

  const state = store.getState().global;
  let iconPath;

  if (!state.windowId) {
    iconPath = ICON_PATHS.white;
  } else {
    iconPath = state.isBotEnabled ? ICON_PATHS.green : ICON_PATHS.red;
  }

  const icon = nativeImage.createFromPath(iconPath);
  tray.setImage(icon);
};

export const toggleTrayVisibility = () => {
  isTrayVisible = !isTrayVisible;
  if (isTrayVisible) {
    createTray();
  } else {
    tray.destroy();
    tray = null;
  }
  Menu.setApplicationMenu(buildAppMenu());
};

const buildTrayContextMenu = () => {
  const state = store.getState().global;
  return Menu.buildFromTemplate([
    {
      label: state.windowName || 'Bot',
    },
    { type: 'separator' },
    {
      label: 'Show/Hide Main Window',
      type: 'checkbox',
      checked: isMainWindowVisible,
      click: toggleMainWindowVisibility,
    },
    {
      label: 'Show/Hide Controls Widget',
      type: 'checkbox',
      checked: isWidgetWindowVisible,
      click: toggleWidgetWindowVisibility,
    },
    {
      label: 'Notifications',
      type: 'checkbox',
      checked: isNotificationEnabled,
      click: () => store.dispatch(toggleNotifications()),
    },
    {
      label: 'Global Shortcuts',
      type: 'checkbox',
      checked: isGlobalShortcutsEnabled,
      click: () =>
        store.dispatch(setGlobalShortcutsEnabled(!isGlobalShortcutsEnabled)),
    },
    {
      label: isTrayVisible ? 'Hide Tray' : 'Show Tray',
      click: toggleTrayVisibility,
    },
    { type: 'separator' },
    { label: 'Close', click: closeAppFromTray },
  ]);
};

const buildAppMenu = () => {
  const template = [
    {
      label: 'File',
      submenu: [
        {
          label: 'Show/Hide Main Window',
          type: 'checkbox',
          checked: isMainWindowVisible,
          click: toggleMainWindowVisibility,
        },
        {
          label: 'Show/Hide Controls Widget',
          type: 'checkbox',
          checked: isWidgetWindowVisible,
          click: toggleWidgetWindowVisibility,
        },
        { type: 'separator' },
        {
          label: 'Load Settings...',
          click: () => loadRulesFromFile(() => {}),
          accelerator: 'CmdOrCtrl+O',
        },
        {
          label: 'Save Settings As...',
          click: () => saveRulesToFile(() => {}),
          accelerator: 'CmdOrCtrl+S',
        },
        { type: 'separator' },
        { label: 'Close', click: closeAppFromTray },
      ],
    },
    {
      label: 'View',
      submenu: [
        {
          label: 'Notifications',
          type: 'checkbox',
          checked: isNotificationEnabled,
          click: () => store.dispatch(toggleNotifications()),
        },
        {
          label: 'Global Shortcuts',
          type: 'checkbox',
          checked: isGlobalShortcutsEnabled,
          click: () =>
            store.dispatch(
              setGlobalShortcutsEnabled(!isGlobalShortcutsEnabled),
            ),
        },
        {
          label: isTrayVisible ? 'Hide Tray' : 'Show Tray',
          click: toggleTrayVisibility,
        },
      ],
    },
  ];

  template.push({
    label: 'Developer',
    submenu: [
      { role: 'reload' },
      { role: 'forceReload' },
      { role: 'toggleDevTools' },
    ],
  });

  return Menu.buildFromTemplate(template);
};

const createTray = () => {
  const state = store.getState().global;
  let initialIconPath = ICON_PATHS.white;
  if (state.windowId) {
    initialIconPath = state.isBotEnabled ? ICON_PATHS.green : ICON_PATHS.red;
  }

  tray = new Tray(initialIconPath);
  tray.setToolTip('Click to show/hide the bot');
  tray.setContextMenu(buildTrayContextMenu());

  tray.on('click', toggleMainWindowVisibility);
};

const handleMainWindowClose = (event) => {
  event.preventDefault();
  app.quit();
};

const closeAppFromTray = () => {
  app.quit();
};

export const createMainWindow = (selectedWindowId, display, windowName) => {
  mainWindow = new BrowserWindow({
    minWidth: 1200,
    minHeight: 640,
    height: 640,
    width: 1200,
    resizable: false,
    icon: ICON_PATHS.app,
    autoHideMenuBar: true,
    titleBarStyle: 'hidden',
    alwaysOnTop: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(dirname, '/preload.js'),
    },
  });

  mainWindow
    .loadURL(`file://${path.join(dirname, HTML_PATH)}`)
    .catch((err) => console.error('Failed to load URL:', err));

  mainWindow.on('ready-to-show', () => {
    mainWindow.show();
    isMainWindowVisible = true;
    createTray();
    Menu.setApplicationMenu(buildAppMenu());
    setGlobalState('global/setWindowId', selectedWindowId);
    setGlobalState('global/setDisplay', display);
    setGlobalState('global/setWindowName', windowName);
    createWidgetWindow();
    toggleWidgetWindowVisibility();
    // Register global shortcuts on app start
    const { isGlobalShortcutsEnabled: globalShortcutsState } =
      store.getState().global;
    if (globalShortcutsState) {
      registerGlobalShortcuts();
    }
  });

  mainWindow.on('show', () => {
    mainWindow.setMinimizable(false);
    isMainWindowVisible = true;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  mainWindow.on('hide', () => {
    isMainWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  mainWindow.on('close', handleMainWindowClose);
  return mainWindow;
};

export const toggleMainWindowVisibility = () => {
  if (!mainWindow) return;

  if (mainWindow.isVisible()) {
    mainWindow.hide();
  } else {
    mainWindow.show();
    mainWindow.focus();
  }
  isMainWindowVisible = mainWindow.isVisible();
  Menu.setApplicationMenu(buildAppMenu());
  if (tray) tray.setContextMenu(buildTrayContextMenu());
};

export const createWidgetWindow = () => {
  if (widgetWindow && !widgetWindow.isDestroyed()) {
    if (widgetWindow.isMinimized()) widgetWindow.restore();
    widgetWindow.focus();
    return;
  }

  widgetWindow = new BrowserWindow({
    width: 210,
    height: 250,
    x: 100,
    y: 100,
    frame: false,
    show: false,
    resizable: false,
    maximizable: false,
    fullscreenable: false,
    transparent: true,
    icon: ICON_PATHS.app,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: WIDGET_PRELOAD_PATH,
      devTools: false,
    },
  });

  widgetWindow.loadURL(`file://${WIDGET_HTML_PATH}`).catch((err) => {
    console.error('Failed to load widget URL:', err);
    widgetWindow = null;
  });

  widgetWindow.on('closed', () => {
    widgetWindow = null;
    isWidgetWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  widgetWindow.on('show', () => {
    isWidgetWindowVisible = true;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  widgetWindow.on('hide', () => {
    isWidgetWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });
};

export const toggleWidgetWindowVisibility = () => {
  if (!widgetWindow) {
    createWidgetWindow();
    widgetWindow.on('ready-to-show', () => {
      widgetWindow.show();
      widgetWindow.focus();
      isWidgetWindowVisible = true;
      Menu.setApplicationMenu(buildAppMenu());
      if (tray) tray.setContextMenu(buildTrayContextMenu());
    });
  } else {
    if (widgetWindow.isVisible()) {
      widgetWindow.hide();
    } else {
      widgetWindow.show();
      widgetWindow.focus();
    }
    isWidgetWindowVisible = widgetWindow.isVisible();
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  }
};

let lastState = {};
store.subscribe(() => {
  const state = store.getState().global;

  const newState = {
    windowName: state.windowName,
    isBotEnabled: state.isBotEnabled,
    windowId: state.windowId,
    notificationsEnabled: state.notificationsEnabled,
    isGlobalShortcutsEnabled: state.isGlobalShortcutsEnabled,
    isMainWindowVisible: mainWindow ? mainWindow.isVisible() : false,
    isWidgetWindowVisible: widgetWindow ? widgetWindow.isVisible() : false,
  };

  // Only update if the relevant state has changed
  const iconChanged =
    lastState.isBotEnabled !== newState.isBotEnabled ||
    lastState.windowId !== newState.windowId;

  const menuChanged =
    lastState.windowName !== newState.windowName ||
    lastState.isMainWindowVisible !== newState.isMainWindowVisible ||
    lastState.isWidgetWindowVisible !== newState.isWidgetWindowVisible ||
    lastState.notificationsEnabled !== newState.notificationsEnabled ||
    lastState.isGlobalShortcutsEnabled !== newState.isGlobalShortcutsEnabled;

  if (tray) {
    if (iconChanged) {
      updateTrayIcon();
    }
    if (menuChanged) {
      tray.setContextMenu(buildTrayContextMenu());
    }
  }

  if (menuChanged) {
    Menu.setApplicationMenu(buildAppMenu());
  }

  // Handle global shortcuts enable/disable
  if (
    lastState.isGlobalShortcutsEnabled !== newState.isGlobalShortcutsEnabled
  ) {
    if (newState.isGlobalShortcutsEnabled) {
      registerGlobalShortcuts();
    } else {
      unregisterGlobalShortcuts();
    }
  }

  // Update local module state
  isNotificationEnabled = newState.notificationsEnabled;
  isGlobalShortcutsEnabled = newState.isGlobalShortcutsEnabled;
  isMainWindowVisible = newState.isMainWindowVisible;
  isWidgetWindowVisible = newState.isWidgetWindowVisible;

  lastState = newState;
});

export const getMainWindow = () => mainWindow;
export const getWidgetWindow = () => widgetWindow;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/globalShortcuts.js
//start file
import { globalShortcut } from 'electron';
import setGlobalState from './setGlobalState.js';
import { getMainWindow } from './createMainWindow.js';

import { showNotification } from './notificationHandler.js';
import debounce from 'lodash/debounce.js';
import store from './store.js';
import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { exec } from 'child_process';
import { createLogger } from './utils/logger.js';

const log = createLogger();
const debounceTime = 25;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let windId = '';
let isBotEnabled = false;
let previousSectionStates = {};
let windowName = '';

store.subscribe(() => {
  const state = store.getState();
  const { global, rules, cavebot, lua, targeting } = state; // Destructure all relevant slices
  windId = global.windowId;
  isBotEnabled = global.isBotEnabled;
  previousSectionStates = global.previousSectionStates;
  windowName = global.windowName;

  // Log warnings if any slice is undefined, but don't prevent access
  if (!rules)
    log(
      'warn',
      '[Global Shortcuts] rules slice is undefined in store.getState()',
    );
  if (!cavebot)
    log(
      'warn',
      '[Global Shortcuts] cavebot slice is undefined in store.getState()',
    );
  if (!lua)
    log(
      'warn',
      '[Global Shortcuts] lua slice is undefined in store.getState()',
    );
  if (!targeting)
    log(
      'warn',
      '[Global Shortcuts] targeting slice is undefined in store.getState()',
    );
});

const soundCache = new Map();

export const playSound = (filePath) => {
  const asarPath = path.join(__dirname, 'sounds', filePath);
  if (soundCache.has(filePath)) {
    const cachedPath = soundCache.get(filePath);
    exec(`aplay '${cachedPath}'`);
  } else {
    const tempDir = path.join(os.tmpdir(), 'automaton-sounds');
    const tempFilePath = path.join(tempDir, filePath);
    fs.mkdirSync(tempDir, { recursive: true });
    fs.copyFileSync(asarPath, tempFilePath);
    soundCache.set(filePath, tempFilePath);
    exec(`aplay '${tempFilePath}'`);
  }
};

const getNotificationTitle = () => `Automaton - ${windowName}`;

const debouncedToggleisBotEnabled = debounce(() => {
  setGlobalState('global/toggleisBotEnabled');
  const status = isBotEnabled ? 'Disabled' : 'Enabled';
  showNotification(`Bot: ${status}`, getNotificationTitle());
  playSound(isBotEnabled ? 'disable.wav' : 'enable.wav');
}, debounceTime);

const debouncedToggleMainWindowVisibility = debounce(() => {
  const mainWindow = getMainWindow();
  if (mainWindow) {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
    }
  }
}, debounceTime);

const switchToPreset = debounce((presetIndex) => {
  setGlobalState('rules/setActivePresetIndex', presetIndex);
}, debounceTime);

const toggleSection = (sectionName, setEnabledAction) => {
  const state = store.getState();
  const currentEnabledState = state[sectionName]?.enabled ?? false;
  const newEnabledState = !currentEnabledState; // This is the state it will become

  console.log(
    `[DEBUG] Toggling ${sectionName}: current=${currentEnabledState}, new=${newEnabledState}, action=${setEnabledAction}`,
  );

  setGlobalState(setEnabledAction, newEnabledState); // Dispatch the action with the new state

  showNotification(
    `${sectionName.charAt(0).toUpperCase() + sectionName.slice(1)}: ${newEnabledState ? 'Enabled' : 'Disabled'}`, // Use newEnabledState for notification
    getNotificationTitle(),
  );
};

const debouncedToggleCavebot = debounce(
  () => toggleSection('cavebot', 'cavebot/setenabled'),
  debounceTime,
);
const debouncedToggleHealing = debounce(
  () => toggleSection('rules', 'rules/setenabled'),
  debounceTime,
);
const debouncedToggleScripts = debounce(
  () => toggleSection('lua', 'lua/setenabled'),
  debounceTime,
);
const debouncedToggleTargeting = debounce(
  () => toggleSection('targeting', 'targeting/setenabled'),
  debounceTime,
);

const debouncedToggleAllSections = debounce(() => {
  const state = store.getState();
  const allSections = {
    rules: state.rules?.enabled ?? false,
    cavebot: state.cavebot?.enabled ?? false,
    lua: state.lua?.enabled ?? false,
    targeting: state.targeting?.enabled ?? false,
  };

  const allEnabled = Object.values(allSections).every(Boolean);
  const allDisabled = Object.values(allSections).every((val) => !val);

  if (allEnabled) {
    // If all are enabled, disable all and store current states
    setGlobalState('global/setPreviousSectionStates', allSections);
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification('All sections disabled', getNotificationTitle());
  } else if (allDisabled) {
    // If all are disabled, restore previous states
    const restoredStates = previousSectionStates;
    setGlobalState('rules/setenabled', restoredStates.rules);
    setGlobalState('cavebot/setenabled', restoredStates.cavebot);
    setGlobalState('lua/setenabled', restoredStates.lua);
    setGlobalState('targeting/setenabled', restoredStates.targeting);
    showNotification(
      'Restored previous section states',
      getNotificationTitle(),
    );
  } else {
    // If mixed, disable all and store current states
    setGlobalState('global/setPreviousSectionStates', allSections);
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification(
      'Mixed states detected, all sections disabled',
      getNotificationTitle(),
    );
  }
}, debounceTime);

const debouncedToggleEverything = debounce(() => {
  const state = store.getState();
  const allSections = {
    rules: state.rules?.enabled ?? false,
    cavebot: state.cavebot?.enabled ?? false,
    lua: state.lua?.enabled ?? false,
    targeting: state.targeting?.enabled ?? false,
  };

  const allEnabled = Object.values(allSections).every(Boolean);
  const allDisabled = Object.values(allSections).every((val) => !val);

  if (!allEnabled) {
    // If not all enabled (mixed or all disabled), enable all
    setGlobalState('rules/setenabled', true);
    setGlobalState('cavebot/setenabled', true);
    setGlobalState('lua/setenabled', true);
    setGlobalState('targeting/setenabled', true);
    showNotification('All sections enabled', getNotificationTitle());
  } else {
    // If all are enabled, disable all
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification('All sections disabled', getNotificationTitle());
  }
}, debounceTime);

export const registerGlobalShortcuts = () => {
  try {
    if (globalShortcut.isRegistered('Alt+E')) {
      log('info', '[Global Shortcuts] already registered, skipping.');
      return;
    }
    log('info', '[Global Shortcuts] registering');
    globalShortcut.register('Alt+E', debouncedToggleisBotEnabled);
    globalShortcut.register('Alt+V', debouncedToggleMainWindowVisibility);

    globalShortcut.register('Alt+Escape', debouncedToggleAllSections);
    globalShortcut.register('Alt+C', debouncedToggleCavebot);
    globalShortcut.register('Alt+H', debouncedToggleHealing);
    globalShortcut.register('Alt+S', debouncedToggleScripts);
    globalShortcut.register('Alt+T', debouncedToggleTargeting);
    globalShortcut.register('Alt+B', debouncedToggleEverything);

    for (let i = 0; i < 5; i++) {
      const presetKey = `Alt+${i + 1}`;
      const debouncedSwitchToPreset = debounce(
        () => switchToPreset(i),
        debounceTime,
      );
      globalShortcut.register(presetKey, debouncedSwitchToPreset);
    }
    log('info', '[Global Shortcuts] registered');
  } catch (error) {
    log('error', `[Global Shortcuts] registration error: ${error}`);
  }
};

export const unregisterGlobalShortcuts = () => {
  try {
    log('info', '[Global Shortcuts] unregistering all');
    globalShortcut.unregisterAll();
  } catch (error) {
    log('error', `[Global Shortcuts] unregistration error: ${error}`);
  }
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/hardwareId.js
//start file
import { execSync } from 'child_process';
import { existsSync } from 'fs';

export function getLinuxHardwareId() {
  try {
    // Try machine-id first (most modern systems)
    if (existsSync('/etc/machine-id')) {
      const machineId = execSync('cat /etc/machine-id', {
        encoding: 'utf-8',
      }).trim();
      if (machineId.length >= 32) return machineId;
    }

    // Fallback to product_uuid (AWS/Azure/GCP and some VMs)
    if (existsSync('/sys/class/dmi/id/product_uuid')) {
      return execSync('cat /sys/class/dmi/id/product_uuid', {
        encoding: 'utf-8',
      }).trim();
    }

    // Final fallback using system information
    const fallbackId = execSync('uname -a | sha256sum | head -c 64', {
      encoding: 'utf-8',
    }).trim();
    return fallbackId || 'unknown-device';
  } catch (error) {
    console.error('Hardware ID detection failed:', error);
    return 'error-no-id';
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/ipcListeners.js
//start file
// /home/orimorfus/Documents/Automaton/electron/ipcListeners.js
import { ipcMain, BrowserWindow } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import store from './store.js';
import {
  saveRulesToFile,
  loadRulesFromFile,
  autoLoadRules,
} from './saveManager.js';
import { playSound, registerGlobalShortcuts } from './globalShortcuts.js';
import { getMainWindow } from './createMainWindow.js';
import luaSlice from '../frontend/redux/slices/luaSlice.js'; // Import the luaSlice
import setGlobalState from './setGlobalState.js';
const { updateScript, removeScript } = luaSlice.actions; // Destructure actions from the slice

const filename = fileURLToPath(import.meta.url);
const cwd = dirname(filename);
const preloadPath = path.join(cwd, '/preload.js');

ipcMain.on('state-change-batch', (_, serializedBatch) => {
  try {
    const batch = JSON.parse(serializedBatch);
    if (Array.isArray(batch)) {
      for (const action of batch) {
        if (action.origin === 'renderer') {
          setGlobalState(action.type, action.payload);
        }
      }
    }
  } catch (error) {
    console.error('Error handling state-change-batch from renderer:', error);
  }
});

ipcMain.on('save-rules', async () => {
  const mainWindow = getMainWindow();
  mainWindow.minimize();
  await saveRulesToFile(() => {
    mainWindow.restore();
  });
});

ipcMain.handle('load-rules', async () => {
  const mainWindow = getMainWindow();
  mainWindow.minimize();
  await loadRulesFromFile(() => {
    mainWindow.restore();
  });
});

ipcMain.on('renderer-ready', () => {
  autoLoadRules();
  registerGlobalShortcuts();
});

// IPC handler to provide current control states to the widget
ipcMain.handle('get-control-states', () => {
  const state = store.getState();
  return {
    isRulesEnabled: state.rules.enabled,
    isCavebotEnabled: state.cavebot.enabled,
    isTargetingEnabled: state.targeting.enabled,
    isLuaEnabled: state.lua.enabled,
  };
});

// IPC handler for widget to toggle main window visibility
ipcMain.handle('toggle-main-window', () => {
  const mainWindow = getMainWindow();
  if (mainWindow) {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
      mainWindow.focus();
    }
    return mainWindow.isVisible();
  }
  return false;
});

// IPC handler to check if main window is visible
ipcMain.handle('is-main-window-visible', () => {
  const mainWindow = getMainWindow();
  return mainWindow ? mainWindow.isVisible() : false;
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/keyboardControll/keyPress.js
//start file
import keypress from 'keypress-native';

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

/**
 * Sends a single key press with an optional modifier.
 * @param {string} display - The display to send the key to (e.g., ':0').
 * @param {string} key - The key to press (e.g., 'a', 'f1', 'enter').
 * @param {object} [options] - Optional parameters.
 * @param {string|null} [options.modifier=null] - The modifier key (e.g., 'shift', 'ctrl').
 */
export const keyPress = async (display, key, { modifier = null } = {}) => {
  await keypress.sendKey(key, display, modifier);
};

/**
 * Sends a key press multiple times with a delay.
 * @param {string} display - The display to send the key to.
 * @param {string} key - The key to press.
 * @param {object} [options] - Optional parameters.
 * @param {number} [options.count=1] - The number of times to press the key.
 * @param {string|null} [options.modifier=null] - The modifier key.
 * @param {number} [options.delayMs=50] - The delay between key presses.
 */
export const keyPressMultiple = async (
  display,
  key,
  { count = 1, modifier = null, delayMs = 50 } = {},
) => {
  for (let i = 0; i < count; i++) {
    await keyPress(display, key, { modifier });
    if (i < count - 1) {
      await delay(delayMs);
    }
  }
};

/**
 * Types an array of strings with human-like behavior. This is the primary function for typing text.
 * It is aliased as 'type' in luaApi.js.
 * @param {string} display - The display to send the keys to.
 * @param {string[]} texts - An array of strings to type.
 * @param {boolean} [startAndEndWithEnter=true] - Whether to press Enter before and after each string.
 */
export const typeArray = async (
  display,
  texts,
  startAndEndWithEnter = true,
) => {
  // The native addon's typeArray function can handle both single and multiple strings efficiently.
  await keypress.typeArray(texts, display, startAndEndWithEnter);
};

/**
 * Simulates a complex rotation key sequence.
 * @param {string} display - The display to send the keys to.
 * @param {string} [direction] - An optional final direction ('n', 's', 'e', 'w').
 */
export const rotate = async (display, direction) => {
  await keypress.rotate(display, direction);
};

/**
 * A stub function to indicate typing status.
 * @returns {boolean} Always returns false.
 */
export const getIsTyping = () => false;

/**
 * Holds a key down.
 * @param {string} display - The display to send the key to.
 * @param {string} key - The key to hold down.
 * @param {object} [options] - Optional parameters.
 * @param {string|null} [options.modifier=null] - The modifier key.
 */
export const keyDown = (display, key, { modifier = null } = {}) => {
  keypress.keyDown(key, display, modifier);
};

/**
 * Releases a key.
 * @param {string} display - The display to send the key to.
 * @param {string} key - The key to release.
 * @param {object} [options] - Optional parameters.
 * @param {string|null} [options.modifier=null] - The modifier key.
 */
export const keyUp = (display, key, { modifier = null } = {}) => {
  keypress.keyUp(key, display, modifier);
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/loginWindow/loginWindow.js
//start file
document.getElementById('login-form').addEventListener('submit', (e) => {
  e.preventDefault();
  attemptLogin();
});

let currentHardwareId = null;
let resetTimer = null;
let autoLoginTimeout = null;

function toggleCheckbox(checkboxId) {
  const checkbox = document.getElementById(checkboxId);
  if (checkbox) {
    checkbox.checked = !checkbox.checked;
  }
}

function setLoadingState(isLoading) {
  const loginButton = document.querySelector('button[type="submit"]');
  loginButton.disabled = isLoading;
  loginButton.style.opacity = isLoading ? '0.7' : '1';
  if (isLoading) {
    loginButton.textContent = 'Authenticating...';
  }
}

function showButtonMessage(message, color) {
  const loginButton = document.querySelector('button[type="submit"]');
  clearTimeout(resetTimer);
  loginButton.textContent = message;
  loginButton.style.color = color;
  resetTimer = setTimeout(() => {
    loginButton.textContent = 'Login';
    loginButton.style.color = '';
  }, 10000);
}

async function checkHardwareId() {
  const hardwareIdElement = document.getElementById('hardware-id');
  try {
    hardwareIdElement.classList.remove('valid', 'invalid');
    currentHardwareId =
      await window.electron.ipcRenderer.invoke('get-hardware-id');

    if (!currentHardwareId || currentHardwareId.includes('error')) {
      throw new Error('Invalid hardware ID');
    }

    const storedHardwareId = localStorage.getItem('validHardwareId');
    const shortId =
      currentHardwareId.length > 53
        ? `${currentHardwareId.slice(-10)}`
        : currentHardwareId;
    hardwareIdElement.textContent = shortId;
    hardwareIdElement.title = `Device Fingerprint: ${currentHardwareId}`;

    if (storedHardwareId) {
      const isMatch = currentHardwareId === storedHardwareId;
      hardwareIdElement.classList.toggle('valid', isMatch);
      hardwareIdElement.classList.toggle('invalid', !isMatch);
      if (!isMatch)
        showButtonMessage('New device detected', 'var(--error-message)');
    }
  } catch (error) {
    console.error('Hardware check failed:', error);
    hardwareIdElement.textContent = 'ID UNAVAILABLE';
    hardwareIdElement.classList.add('invalid');
    showButtonMessage('Device verification failed', 'var(--error-message)');
  }
}

async function attemptLogin() {
  if (autoLoginTimeout) {
    clearTimeout(autoLoginTimeout);
    autoLoginTimeout = null;
  }

  const loginButton = document.querySelector('button[type="submit"]');
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  const rememberMeCheckbox = document.getElementById('remember-me');
  const autoLoginCheckbox = document.getElementById('auto-login');

  const username = usernameInput.value;
  const password = passwordInput.value;
  const rememberMe = rememberMeCheckbox.checked;
  const autoLogin = autoLoginCheckbox.checked;

  setLoadingState(true);

  try {
    const response = await fetch(
      'https://automaton-login-server-h3kn.onrender.com/login',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Device-ID': currentHardwareId,
        },
        body: JSON.stringify({
          email: username,
          password: password,
          hardwareId: currentHardwareId,
        }),
      },
    );

    const data = await response.json();

    if (response.ok) {
      localStorage.setItem('validHardwareId', currentHardwareId);
      if (rememberMe) {
        localStorage.setItem(
          'credentials',
          JSON.stringify({ username, password }),
        );
        if (autoLogin) {
          localStorage.setItem('autoLoginEnabled', 'true');
        } else {
          localStorage.removeItem('autoLoginEnabled');
        }
      } else {
        localStorage.removeItem('credentials');
        localStorage.removeItem('autoLoginEnabled');
      }
      showButtonMessage(data.message || 'Login successful!', '#00ff00');
      await new Promise((resolve) => setTimeout(resolve, 1500));
      window.electron.ipcRenderer.send('login-success');
    } else {
      showButtonMessage(
        data.message || `Error: ${response.status}`,
        'var(--error-message)',
      );
    }
  } catch (error) {
    showButtonMessage(
      'Connection error. Please try again.',
      'var(--error-message)',
    );
  } finally {
    setLoadingState(false);
  }
}

function cancelAutoLogin() {
  if (autoLoginTimeout) {
    clearTimeout(autoLoginTimeout);
    autoLoginTimeout = null;
    console.log('Auto-login cancelled due to user interaction.');
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  const rememberMeCheckbox = document.getElementById('remember-me');
  const autoLoginCheckbox = document.getElementById('auto-login');
  const loginButton = document.querySelector('button[type="submit"]');

  const credentials = JSON.parse(localStorage.getItem('credentials'));
  const autoLoginEnabled = localStorage.getItem('autoLoginEnabled') === 'true';

  if (credentials) {
    usernameInput.value = credentials.username;
    passwordInput.value = credentials.password;
    rememberMeCheckbox.checked = true;
    autoLoginCheckbox.checked = autoLoginEnabled;
  }

  checkHardwareId();

  if (credentials && autoLoginEnabled) {
    console.log('Auto-login enabled. Starting 1s timer...');
    autoLoginTimeout = setTimeout(() => {
      console.log('Auto-login timer expired. Attempting login...');
      autoLoginTimeout = null;
      attemptLogin();
    }, 1000);
  }

  usernameInput.addEventListener('input', cancelAutoLogin);
  passwordInput.addEventListener('input', cancelAutoLogin);
  loginButton.addEventListener('click', cancelAutoLogin);
  rememberMeCheckbox.addEventListener('change', cancelAutoLogin);
  autoLoginCheckbox.addEventListener('change', cancelAutoLogin);

  usernameInput.focus();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/main.js
//start file
import { app, ipcMain, BrowserWindow, dialog } from 'electron';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import path from 'path';
import { createMainWindow, getWidgetWindow } from './createMainWindow.js';
import './ipcListeners.js';
import { registerGlobalShortcuts } from './globalShortcuts.js';
import { getLinuxHardwareId } from './hardwareId.js';
// import { autoLoadRules } from './saveManager.js';
import { createLogger } from './utils/logger.js';
import workerManager from './workerManager.js';
import windowinfo from 'windowinfo-native';
import setGlobalState from './setGlobalState.js';
import store from './store.js';

const filename = fileURLToPath(import.meta.url);
const cwd = dirname(filename);
const log = createLogger();

let selectWindow;
let mainWindow;
let isQuitting = false;

const createSelectWindow = () => {
  selectWindow = new BrowserWindow({
    width: 600,
    height: 400,
    autoHideMenuBar: true,
    titleBarStyle: 'hidden',
    resizable: false,
    maximizable: false,
    fullscreenable: false,
    devTools: false,
    frame: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(cwd, 'selectWindow', 'preload.js'),
    },
  });

  const selectHtmlPath = path.join(cwd, 'selectWindow', 'selectWindow.html');
  selectWindow.loadFile(selectHtmlPath);

  selectWindow.on('closed', () => {
    selectWindow = null;
    if (!isQuitting && !mainWindow) {
      app.quit();
    }
  });
};

app.whenReady().then(async () => {
  try {
    // await autoLoadRules();
    createSelectWindow();

    workerManager.initialize(app, cwd, {});
    registerGlobalShortcuts(); // Register global shortcuts on startup
    setGlobalState('global/setGlobalShortcutsEnabled', true); // Set default to enabled
  } catch (error) {
    console.error('[Main] FATAL: Error during application startup:', error);
    dialog.showErrorBox(
      'Application Startup Error',
      `Failed to initialize critical components: ${error.message}\n\nPlease check logs for details. The application will now exit.`,
    );
    app.quit();
  }
});

app.on('before-quit', async (event) => {
  event.preventDefault();
  console.log('[Main] App is quitting. Terminating all workers...');
  await workerManager.stopAllWorkers();
  console.log('[Main] All workers terminated. Exiting now.');
  app.exit();
});
app.on('window-all-closed', () => {
  log('info', '[Main] All windows closed, initiating app quit.');
  app.quit();
});

ipcMain.handle('get-hardware-id', () => {
  try {
    return getLinuxHardwareId();
  } catch (error) {
    console.error('Hardware ID error:', error);
    return 'error-failed-retrieval';
  }
});

ipcMain.handle('get-tibia-window-list', async () => {
  try {
    const windowList = await windowinfo.getWindowList();
    return windowList;
  } catch (error) {
    console.error('[Main] Error getting Tibia window list:', error);
    return [];
  }
});

ipcMain.on('select-tibia-window', (event, windowId, display, windowName) => {
  if (selectWindow && !selectWindow.isDestroyed()) {
    selectWindow.close();
  }
  setGlobalState('global/setWindowId', windowId);
  setGlobalState('global/setDisplay', display);
  setGlobalState('global/setWindowName', windowName);

  mainWindow = createMainWindow(windowId, display, windowName);
});

ipcMain.on('exit-app', () => {
  isQuitting = true;
  app.quit();
});

ipcMain.on('update-bot-status', (event, { feature, isEnabled }) => {
  console.log(`[Main] Received update from widget: ${feature} - ${isEnabled}`);
  switch (feature) {
    case 'healing':
      setGlobalState('rules/setenabled', isEnabled);
      break;
    case 'cavebot':
      setGlobalState('cavebot/setenabled', isEnabled);
      break;
    case 'targeting':
      setGlobalState('targeting/setenabled', isEnabled);
      break;
    case 'scripts':
      setGlobalState('lua/setenabled', isEnabled);
      break;
    default:
      console.warn(`[Main] Unknown feature received from widget: ${feature}`);
  }
});

// Store subscription to send state updates to the widget window
let previousRulesEnabled = false;
let previousCavebotEnabled = false;
let previousTargetingEnabled = false;
let previousLuaEnabled = false;

store.subscribe(() => {
  const state = store.getState();
  const widgetWindow = getWidgetWindow();

  if (widgetWindow && !widgetWindow.isDestroyed()) {
    const currentRulesEnabled = state.rules.enabled;
    const currentCavebotEnabled = state.cavebot.enabled;
    const currentTargetingEnabled = state.targeting.enabled;
    const currentLuaEnabled = state.lua.enabled;

    if (currentRulesEnabled !== previousRulesEnabled) {
      widgetWindow.webContents.send('state-update', {
        type: 'rules/setenabled',
        payload: currentRulesEnabled,
      });
      previousRulesEnabled = currentRulesEnabled;
    }

    if (currentCavebotEnabled !== previousCavebotEnabled) {
      widgetWindow.webContents.send('state-update', {
        type: 'cavebot/setenabled',
        payload: currentCavebotEnabled,
      });
      previousCavebotEnabled = currentCavebotEnabled;
    }

    if (currentTargetingEnabled !== previousTargetingEnabled) {
      widgetWindow.webContents.send('state-update', {
        type: 'targeting/setenabled',
        payload: currentTargetingEnabled,
      });
      previousTargetingEnabled = currentTargetingEnabled;
    }

    if (currentLuaEnabled !== previousLuaEnabled) {
      widgetWindow.webContents.send('state-update', {
        type: 'lua/setenabled',
        payload: currentLuaEnabled,
      });
      previousLuaEnabled = currentLuaEnabled;
    }
  }
});

export default app;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/mouseControll/useItemOnCoordinates.js
//start file
import mouseController from 'mouse-controller';
import { keyPress } from '../keyboardControll/keyPress.js';

function useItemOnCoordinates(targetWindowId, display, targetX, targetY, key) {
  // Add display parameter
  // First press the key
  keyPress(display, key); // Pass display to keyPress

  // Then perform left click on coordinates
  mouseController.leftClick(
    parseInt(targetWindowId),
    parseInt(targetX),
    parseInt(targetY),
    display, // Pass display to mouseController
  );
}

export default useItemOnCoordinates;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/notificationHandler.js
//start file
import { Notification, nativeImage } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import store from './store.js';

let notiEnabled = false;

const __filenamePath = fileURLToPath(import.meta.url);
const __dirnamePath = path.dirname(__filenamePath);

const iconPath = path.join(__dirnamePath, 'icons', 'greenSkull.png');

let windowName = '';

store.subscribe(() => {
  const state = store.getState();
  notiEnabled = state.global.notificationsEnabled;
  windowName = state.global.windowName;
});

const createIconImage = () => {
  try {
    return nativeImage.createFromPath(iconPath);
  } catch (error) {
    console.error('Error creating icon image:', error);
    return null;
  }
};

export const showNotification = (body, customTitle) => {
  if (!notiEnabled) return;

  const title = customTitle || `Automaton - ${windowName}`;

  try {
    new Notification({
      title: title,
      body: body,
      icon: createIconImage(),
    }).show();
  } catch (error) {
    console.error('Error showing notification:', error);
  }
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/preload.js
//start file
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  ipcRenderer: {
    invoke: (channel, ...args) => ipcRenderer.invoke(channel, ...args),
    send: (channel, data) => ipcRenderer.send(channel, data),
    on: (channel, func) => ipcRenderer.on(channel, func),
  },
  saveRules: () => ipcRenderer.send('save-rules'),
  loadRules: () => ipcRenderer.invoke('load-rules'),
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/saveManager.js
//start file
import { app, dialog } from 'electron';
import fs from 'fs/promises';
import path from 'path';
import { showNotification } from './notificationHandler.js';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import throttle from 'lodash/throttle.js';
import omit from 'lodash/omit.js';

// ... (normalizeLuaScripts and STATE_SCHEMA are unchanged)
// Helper to normalize Lua scripts
const normalizeLuaScripts = (luaState) => {
  if (!luaState) return luaState;
  const normalizedState = { ...luaState };
  if (
    normalizedState.persistentScripts &&
    Array.isArray(normalizedState.persistentScripts)
  ) {
    normalizedState.persistentScripts = normalizedState.persistentScripts.map(
      (script) => ({ ...script, type: script.type || 'persistent' }),
    );
  }
  if (
    normalizedState.hotkeyScripts &&
    Array.isArray(normalizedState.hotkeyScripts)
  ) {
    normalizedState.hotkeyScripts = normalizedState.hotkeyScripts.map(
      (script) => ({ ...script, type: script.type || 'hotkey' }),
    );
  }
  return normalizedState;
};

// STATE PERSISTENCE SCHEMA
const STATE_SCHEMA = {
  global: {
    transformOnSave: (state) => ({
      notificationsEnabled: state.notificationsEnabled,
      isGlobalShortcutsEnabled: state.isGlobalShortcutsEnabled,
    }),
  },
  rules: {},
  lua: {
    transformOnSave: (state) => ({
      enabled: false,
      persistentScripts:
        state.persistentScripts?.map((script) => ({
          ...script,
          log: [],
        })) || [],
    }),
    transformOnLoad: (state) =>
      normalizeLuaScripts({ ...state, enabled: false }),
  },
  cavebot: {
    transformOnSave: (state) => ({
      enabled: false,
      waypointSections: state.waypointSections,
      specialAreas: state.specialAreas,
    }),
    transformOnLoad: (state) => ({ ...state, enabled: false }),
  },
  targeting: {
    transformOnSave: (state) => ({
      enabled: false,
      targetingList: state.targetingList,
    }),
    transformOnLoad: (state) => ({ ...state, enabled: false }),
  },
};

const PERSISTED_SLICES = Object.keys(STATE_SCHEMA);
const user_data_path = app.getPath('userData');
const auto_load_file_path = path.join(user_data_path, 'autoLoadRules.json');

// ============================================================================
// Schema-Driven Helper Functions
// ============================================================================

const prepareStateForSave = (fullState) => {
  const stateToSave = {};
  for (const sliceName of PERSISTED_SLICES) {
    if (fullState[sliceName]) {
      const sliceConfig = STATE_SCHEMA[sliceName];
      stateToSave[sliceName] = sliceConfig.transformOnSave
        ? sliceConfig.transformOnSave(fullState[sliceName])
        : fullState[sliceName];
    }
  }
  return stateToSave;
};

const applyLoadedState = (loadedState) => {
  if (!loadedState || typeof loadedState !== 'object') return;
  for (const sliceName of PERSISTED_SLICES) {
    if (loadedState[sliceName]) {
      let sliceData = loadedState[sliceName];
      const sliceConfig = STATE_SCHEMA[sliceName];
      if (sliceConfig.transformOnLoad) {
        sliceData = sliceConfig.transformOnLoad(sliceData);
      }
      setGlobalState(`${sliceName}/setState`, sliceData);
    }
  }
};

// ============================================================================
// Generic Save Function & Factory
// ============================================================================

/**
 * A generic function to handle the logic of saving data to a file.
 * @param {object} dataToSave - The JavaScript object to be stringified and saved.
 * @param {string} dialogTitle - The title for the save file dialog window.
 * @param {string} defaultFilename - The suggested filename in the dialog.
 * @param {function} [callback] - An optional callback to run after completion.
 */
const genericSaveToFile = async (
  dataToSave,
  dialogTitle,
  defaultFilename,
  callback,
) => {
  try {
    const dialog_result = await dialog.showSaveDialog({
      title: dialogTitle,
      defaultPath: defaultFilename,
      filters: [{ name: 'JSON Files', extensions: ['json'] }],
    });

    if (!dialog_result.canceled && dialog_result.filePath) {
      const save_file_path = dialog_result.filePath.endsWith('.json')
        ? dialog_result.filePath
        : `${dialog_result.filePath}.json`;

      await fs.writeFile(save_file_path, JSON.stringify(dataToSave, null, 2));
      showNotification(` Saved | ${path.basename(save_file_path)}`);
    }
  } catch (err) {
    console.error(`Failed to save file for "${dialogTitle}":`, err);
    showNotification(` Failed to save ${defaultFilename}`);
  } finally {
    if (callback) callback();
  }
};

/**
 * Factory function to create a dedicated save function for a specific state slice.
 * @param {string} sliceName - The key of the state slice (e.g., 'targeting').
 * @param {string} dialogTitle - The title for the save dialog.
 * @param {string} defaultFilename - The suggested filename.
 * @returns {function} An async function that takes an optional callback.
 */
const createSliceSaver = (sliceName, dialogTitle, defaultFilename) => {
  return async (callback) => {
    const sliceState = store.getState()[sliceName];
    if (!sliceState) {
      console.error(`Attempted to save non-existent slice: ${sliceName}`);
      showNotification(` Cannot save ${sliceName}: state not found`);
      if (callback) callback();
      return;
    }

    // Use the schema to prepare the slice for saving, ensuring consistency.
    const sliceConfig = STATE_SCHEMA[sliceName];
    const stateToSave = sliceConfig.transformOnSave
      ? sliceConfig.transformOnSave(sliceState)
      : sliceState;

    await genericSaveToFile(
      stateToSave,
      dialogTitle,
      defaultFilename,
      callback,
    );
  };
};

// ============================================================================
// Public API (Save/Load Functions)
// ============================================================================

/** Saves the ENTIRE configured state to a file. */
export const saveRulesToFile = async (callback) => {
  const fullStateToSave = prepareStateForSave(store.getState());
  await genericSaveToFile(
    fullStateToSave,
    'Save Full Profile',
    'full_profile.json',
    callback,
  );
};

/** Loads state from a file. */
export const loadRulesFromFile = async (callback) => {
  try {
    const dialog_result = await dialog.showOpenDialog({
      title: 'Load Profile',
      filters: [{ name: 'JSON Files', extensions: ['json'] }],
      properties: ['openFile'],
    });

    if (!dialog_result.canceled && dialog_result.filePaths.length > 0) {
      const file_path = dialog_result.filePaths[0];
      const content = await fs.readFile(file_path, 'utf8');
      const loaded_state = JSON.parse(content);
      applyLoadedState(loaded_state);
      showNotification(` Loaded | ${path.basename(file_path)}`);
    }
  } catch (err) {
    console.error('Failed to load state:', err);
    showNotification(' Failed to load state');
  } finally {
    if (callback) callback();
  }
};

// --- NEW SLICE-SPECIFIC SAVE FUNCTIONS ---

export const saveTargeting = createSliceSaver(
  'targeting',
  'Save Targeting Profile',
  'targeting_profile.json',
);

export const saveCavebot = createSliceSaver(
  'cavebot',
  'Save Cavebot Profile',
  'cavebot_profile.json',
);

export const saveRules = createSliceSaver(
  'rules',
  'Save Rules Profile',
  'rules_profile.json',
);

export const saveLua = createSliceSaver(
  'lua',
  'Save Lua Scripts Profile',
  'lua_profile.json',
);

// ============================================================================
// Auto Save / Load & Store Subscription (Unchanged)
// ============================================================================

const perform_auto_save = async () => {
  try {
    const stateToSave = prepareStateForSave(store.getState());
    if (Object.keys(stateToSave).length > 0) {
      await fs.writeFile(
        auto_load_file_path,
        JSON.stringify(stateToSave, null, 2),
      );
    }
  } catch (error) {
    console.error('Failed to auto-save rules:', error);
  }
};

const auto_save_rules = throttle(perform_auto_save, 1000, {
  leading: false,
  trailing: true,
});

export const autoLoadRules = async () => {
  try {
    await fs.access(auto_load_file_path);
    const content = await fs.readFile(auto_load_file_path, 'utf8');
    const loaded_state = JSON.parse(content);
    applyLoadedState(loaded_state);
  } catch (error) {
    if (error.code !== 'ENOENT') {
      console.error('Failed to auto-load rules:', error);
    }
  }
};

const previousStates = {};
const hasStateChanged = (newState, prevState) => {
  if (newState === prevState) return false;
  if (
    !prevState ||
    typeof newState !== 'object' ||
    typeof prevState !== 'object'
  )
    return true;
  return JSON.stringify(newState) !== JSON.stringify(prevState);
};

store.subscribe(() => {
  const currentState = store.getState();
  let hasChanged = false;

  for (const sliceName of PERSISTED_SLICES) {
    if (hasStateChanged(currentState[sliceName], previousStates[sliceName])) {
      hasChanged = true;
      previousStates[sliceName] = currentState[sliceName];
    }
  }

  // if (hasChanged) {
  //   auto_save_rules();
  // }
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePartyEntryRegions.js
//start file
export const calculatePartyEntryRegions = (partyListStart, entryCount) => {
  const regions = [];
  for (let i = 0; i < entryCount; i++) {
    regions.push({
      bar: {
        x: partyListStart.x + 1,
        y: partyListStart.y + 6 + i * 26,
        width: 130,
        height: 1,
      },
      name: {
        x: partyListStart.x + 1,
        y: partyListStart.y + i * 26,
        width: 15,
        height: 6,
      },
      uhCoordinates: {
        x: partyListStart.x,
        y: partyListStart.y + i * 26,
      },
    });
  }
  return regions;
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePartyHpPercentage.js
//start file
// screenMonitor/calcs/calculatePartyHpPercentage.js

/**
 * Calculates the percentage of matching pixels in a party member's HP bar.
 * This is now a convenience wrapper around the main calculatePercentages function.
 *
 * @param {Buffer} fullFrameBuffer - The full-frame image buffer, including its 8-byte header.
 * @param {object} fullFrameMeta - Metadata object { width, height } for the full frame.
 * @param {object} barAbsoluteCoords - The bar's absolute start {x, y} within the window.
 * @param {Array<Array<number>>} validColors - Array of valid [R, G, B] color arrays for the bar.
 * @param {number} barPixelWidth - The width of the bar in pixels to analyze.
 * @returns {number} The calculated HP percentage (0-100) or -1 on error.
 */
import calculatePercentages from './calculatePercentages.js'; // Assuming it's in the same folder

function calculatePartyHpPercentage(
  fullFrameBuffer,
  fullFrameMeta,
  barAbsoluteCoords,
  validColors,
  barPixelWidth,
) {
  // This function now just calls the main, more generic percentage calculator.
  // This reduces code duplication.
  return calculatePercentages(
    fullFrameBuffer,
    fullFrameMeta,
    barAbsoluteCoords,
    validColors,
    barPixelWidth,
  );
}

export default calculatePartyHpPercentage;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePercentages.js
//start file
// screenMonitor/calcs/calculatePercentages.js

/**
 * Calculates the percentage of matching pixels horizontally for a bar (like HP/Mana)
 * at a specific ABSOLUTE position within the full-frame image buffer.
 *
 * @param {Buffer} fullFrameBuffer - The full-frame image buffer, including its 8-byte header.
 * @param {object} fullFrameMeta - Metadata object { width, height } for the full frame.
 * @param {object} barAbsoluteCoords - The bar's absolute start {x, y} within the window.
 * @param {Array<Array<number>>} validColors - Array of valid [R, G, B] color arrays for the bar.
 * @param {number} barPixelWidth - The width of the bar in pixels to analyze.
 * @returns {number} The calculated percentage (0-100) or -1 on error.
 */
function calculatePercentages(
  fullFrameBuffer,
  fullFrameMeta,
  barAbsoluteCoords,
  validColors,
  barPixelWidth,
) {
  try {
    // 1. Validate Inputs
    if (
      !fullFrameBuffer ||
      fullFrameBuffer.length < 8 ||
      !fullFrameMeta ||
      !barAbsoluteCoords ||
      !validColors ||
      barPixelWidth <= 0
    ) {
      return -1;
    }

    const { width: imageWidth, height: imageHeight } = fullFrameMeta;

    if (imageWidth <= 0 || imageHeight <= 0) {
      return -1;
    }

    // 2. Constants for BGRA format
    const bytesPerPixel = 4; // BGRA format
    const headerSize = 8;
    const imageStride = imageWidth * bytesPerPixel;

    // 3. Calculate Start Byte Index in the full buffer
    const { x: absoluteBarStartX, y: absoluteBarStartY } = barAbsoluteCoords;

    // Ensure coordinates are within the buffer dimensions
    if (
      absoluteBarStartX < 0 ||
      absoluteBarStartX >= imageWidth ||
      absoluteBarStartY < 0 ||
      absoluteBarStartY >= imageHeight
    ) {
      return -1;
    }

    const startIndexBytes =
      headerSize +
      absoluteBarStartY * imageStride +
      absoluteBarStartX * bytesPerPixel;

    // 4. Bounds Check
    const endIndexBytes = startIndexBytes + barPixelWidth * bytesPerPixel;
    if (
      absoluteBarStartX + barPixelWidth > imageWidth ||
      startIndexBytes < headerSize ||
      endIndexBytes > fullFrameBuffer.length
    ) {
      return -1;
    }

    // 5. Prepare color set for quick lookup
    const colorSet = new Set(validColors.map((color) => color.join(',')));

    // 6. Count matching pixels
    let matchingPixelsCount = 0;
    for (let i = 0; i < barPixelWidth; i++) {
      const currentPixelIndex = startIndexBytes + i * bytesPerPixel;

      // Read BGRA, but we only care about RGB for comparison
      // B = index + 0, G = index + 1, R = index + 2
      const r = fullFrameBuffer[currentPixelIndex + 2];
      const g = fullFrameBuffer[currentPixelIndex + 1];
      const b = fullFrameBuffer[currentPixelIndex];

      if (colorSet.has(`${r},${g},${b}`)) {
        matchingPixelsCount++;
      }
    }

    if (barPixelWidth === 0) return 0;
    return Math.round((matchingPixelsCount / barPixelWidth) * 100);
  } catch (error) {
    console.error('Error in calculatePercentages:', error);
    return -1;
  }
}

export default calculatePercentages;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/selectWindow/preload.js
//start file
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  getTibiaWindowList: () => ipcRenderer.invoke('get-tibia-window-list'),
  selectTibiaWindow: (windowId, display, windowName) =>
    ipcRenderer.send('select-tibia-window', windowId, display, windowName),
  exitApp: () => ipcRenderer.send('exit-app'),
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/selectWindow/selectWindow.js
//start file
document.addEventListener('DOMContentLoaded', async () => {
  const windowList = document.getElementById('window-list');
  const selectButton = document.getElementById('select-button');
  const refreshButton = document.getElementById('refresh-button');
  const exitButton = document.getElementById('exit-button');
  const messageElement = document.getElementById('message');

  let availableWindows = [];

  const fetchWindows = async () => {
    messageElement.textContent = 'Searching for Tibia windows...';
    selectButton.disabled = true;
    windowList.innerHTML = ''; // Clear previous list

    try {
      availableWindows = await window.electronAPI.getTibiaWindowList();
      if (availableWindows.length > 0) {
        availableWindows.forEach((win) => {
          const option = document.createElement('option');
          option.value = win.windowId;
          option.textContent = `${win.name} (ID: ${win.windowId}, Display: ${win.display})`; // Assuming display info is added
          windowList.appendChild(option);
        });
        windowList.selectedIndex = 0; // Select the first one by default
        selectButton.disabled = false;
        messageElement.textContent = `${availableWindows.length} Tibia window(s) found.`;
      } else {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No Tibia windows found.';
        windowList.appendChild(option);
        messageElement.textContent =
          'No Tibia windows found. Please ensure Tibia is running.';
      }
    } catch (error) {
      console.error('Failed to fetch window list:', error);
      messageElement.textContent = `Error: ${error.message}. Could not retrieve window list.`;
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'Error loading windows.';
      windowList.appendChild(option);
    }
  };

  selectButton.addEventListener('click', () => {
    const selectedIndex = windowList.selectedIndex;
    if (selectedIndex !== -1) {
      const selectedWindow = availableWindows[selectedIndex];
      if (selectedWindow) {
        window.electronAPI.selectTibiaWindow(
          selectedWindow.windowId,
          selectedWindow.display,
          selectedWindow.name,
        ); // Pass ID, display, and window title
      }
    }
  });

  refreshButton.addEventListener('click', fetchWindows);
  exitButton.addEventListener('click', () => {
    window.electronAPI.exitApp();
  });

  // Initial fetch
  fetchWindows();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/setGlobalState.js
//start file
import store from './store.js';
import { getMainWindow, getWidgetWindow } from './createMainWindow.js';

let actionQueue = [];
let isScheduled = false;

function sendBatch() {
  if (actionQueue.length === 0) {
    isScheduled = false;
    return;
  }

  const mainWindow = getMainWindow();
  const widgetWindow = getWidgetWindow();
  const batch = [...actionQueue];
  actionQueue = [];

  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send('state-update-batch', batch);
  }
  if (widgetWindow && !widgetWindow.isDestroyed()) {
    widgetWindow.webContents.send('state-update-batch', batch);
  }

  isScheduled = false;
}

function scheduleBatch() {
  if (!isScheduled) {
    isScheduled = true;
    // --- THIS IS THE FIX ---
    // Use setImmediate for high-throughput, non-UI-blocking batching.
    // It is more reliable than requestIdleCallback in a busy main process.
    setImmediate(sendBatch);
  }
}

/**
 * A centralized function to update the main process Redux store
 * and broadcast the change to the renderer process.
 * @param {string} type - The action type (e.g., 'cavebot/setEnabled').
 * @param {*} payload - The action payload.
 */
function setGlobalState(type, payload) {
  const action = {
    type,
    payload,
    origin: 'backend',
  };

  // 1. Dispatch the action to the main process store immediately.
  store.dispatch(action);

  // 2. Queue the action to be sent to the renderer in a batch.
  actionQueue.push(action);
  scheduleBatch();
}

export default setGlobalState;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/store.js
//start file
import { configureStore, combineReducers } from '@reduxjs/toolkit';
import globalSlice from '../frontend/redux/slices/globalSlice.js';
import ruleSlice from '../frontend/redux/slices/ruleSlice.js';
import gameStateSlice from '../frontend/redux/slices/gameStateSlice.js';
import luaSlice from '../frontend/redux/slices/luaSlice.js';
import cavebotSlice from '../frontend/redux/slices/cavebotSlice.js';
import targetingSlice from '../frontend/redux/slices/targetingSlice.js';
import statusMessagesSlice from '../frontend/redux/slices/statusMessagesSlice.js';
import regionCoordinatesSlice from '../frontend/redux/slices/regionCoordinatesSlice.js';
import ocrSlice from '../frontend/redux/slices/ocrSlice.js';
import uiValuesSlice from '../frontend/redux/slices/uiValuesSlice.js';
import battleListSlice from '../frontend/redux/slices/battleListSlice.js';
import pathfinderSlice from '../frontend/redux/slices/pathfinderSlice.js';

const rootReducer = combineReducers({
  global: globalSlice.reducer,
  gameState: gameStateSlice.reducer,
  rules: ruleSlice.reducer,
  lua: luaSlice.reducer,
  cavebot: cavebotSlice.reducer,
  targeting: targetingSlice.reducer,
  statusMessages: statusMessagesSlice.reducer,
  regionCoordinates: regionCoordinatesSlice.reducer,
  ocr: ocrSlice.reducer,
  uiValues: uiValuesSlice.reducer,
  battleList: battleListSlice.reducer,
  pathfinder: pathfinderSlice.reducer,
});

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      immutableCheck: false,
      serializableCheck: false,
    }),
});

export default store;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/areStatusConditionsMet.js
//start file
/**
 * Check if character status conditions are met.
 * @param {Object} rule - The rule object.
 * @param {Object} gameState - The game state object.
 * @returns {boolean} - True if all conditions are met, false otherwise.
 */
const areCharStatusConditionsMet = (rule, gameState) => {
  // If there are no conditions, the check passes.
  if (!rule.conditions || rule.conditions.length === 0) {
    return true;
  }

  // Check each condition in the rule's conditions array.
  return rule.conditions.every((condition) => {
    // Treat a missing status as false. This is the key fix.
    const charStatusValue = gameState.characterStatus[condition.name] ?? false;
    return charStatusValue === condition.value;
  });
};

export default areCharStatusConditionsMet;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/compareUtils.js
//start file
// electron/utils/compareUtils.js

/**
 * Performs a shallow comparison of two arrays of special area objects.
 * It checks for changes in length and relevant properties of each object.
 *
 * @param {Array<object>} arr1 - The first array of special area objects.
 * @param {Array<object>} arr2 - The second array of special area objects.
 * @returns {boolean} True if the arrays are considered equal, false otherwise.
 */
export function areSpecialAreasEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0; i < arr1.length; i++) {
    const a1 = arr1[i];
    const a2 = arr2[i];

    // Compare relevant properties. 'id' is ignored as it's an internal identifier.
    if (
      a1.x !== a2.x ||
      a1.y !== a2.y ||
      a1.z !== a2.z ||
      a1.sizeX !== a2.sizeX ||
      a1.sizeY !== a2.sizeY ||
      a1.avoidance !== a2.avoidance ||
      a1.type !== a2.type ||
      a1.enabled !== a2.enabled
    ) {
      return false;
    }
  }
  return true;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/deepHash.js
//start file
// electron/utils/deepHash.js

/**
 * Computes a deep hash of an object or array.
 * This function is designed to be more efficient than JSON.stringify for hashing,
 * especially for nested structures, by avoiding string conversion overhead.
 * It handles primitives, objects, and arrays.
 *
 * @param {any} obj - The object or value to hash.
 * @returns {number} A 32-bit unsigned integer hash.
 */
export function deepHash(obj) {
  let hash = 0x811c9dc5; // FNV-1a 32-bit offset basis

  const processString = (str) => {
    for (let i = 0; i < str.length; i++) {
      hash ^= str.charCodeAt(i);
      hash = (hash * 0x01000193) >>> 0; // FNV-1a 32-bit prime
    }
  };

  const processValue = (value) => {
    const type = typeof value;

    if (value === null) {
      processString('null');
    } else if (type === 'object') {
      if (Array.isArray(value)) {
        processString('array');
        for (let i = 0; i < value.length; i++) {
          processValue(value[i]);
        }
      } else {
        processString('object');
        const keys = Object.keys(value).sort(); // Ensure consistent order
        for (let i = 0; i < keys.length; i++) {
          processString(keys[i]); // Hash the key
          processValue(value[keys[i]]); // Hash the value
        }
      }
    } else if (
      type === 'function' ||
      type === 'symbol' ||
      type === 'undefined'
    ) {
      // Ignore functions, symbols, and undefined values for hashing
      processString(type);
    } else {
      processString(String(value)); // Convert primitives to string and hash
    }
  };

  processValue(obj);
  return hash;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/distance.js
//start file
export function chebyshevDistance(pos1, pos2) {
  return Math.max(Math.abs(pos1.x - pos2.x), Math.abs(pos1.y - pos2.y));
}

export function calculateDistance(pos1, pos2) {
  if (!pos1 || !pos2) return Infinity;
  const dx = pos1.x - pos2.x;
  const dy = pos1.y - pos2.y;
  const dz = pos1.z - pos2.z;
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

export const getDistance = (p1, p2) =>
  Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/frameUpdateManager.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/utils/frameUpdateManager.js
/**
 * Manages the accumulation of dirty rectangles for a worker.
 * This class acts as a simple flag. If a worker receives dirty rects,
 * shouldProcess() will return true once and then reset.
 */
export class FrameUpdateManager {
  constructor() {
    this.accumulatedDirtyRects = [];
  }

  /**
   * This is now a no-op, as region interest is handled by the workerManager.
   * It's kept for API compatibility to prevent errors from existing calls.
   * @param {Array<object>|object} regions - Ignored.
   */
  setRegionsOfInterest(regions) {
    // Intentionally empty.
  }

  /**
   * Adds new dirty rectangles to the internal accumulator.
   * @param {Array<object>} rects - An array of dirty rectangles.
   */
  addDirtyRects(rects) {
    if (rects && rects.length > 0) {
      this.accumulatedDirtyRects.push(...rects);
    }
  }

  /**
   * Determines if the worker should perform its main processing logic.
   * Returns true if any dirty rectangles have been accumulated since the last check.
   * This method also clears the accumulator.
   * @returns {boolean} True if processing is needed, false otherwise.
   */
  shouldProcess() {
    if (this.accumulatedDirtyRects.length === 0) {
      return false;
    }
    // Atomically check, clear, and return true.
    this.accumulatedDirtyRects.length = 0;
    return true;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/gameWorldClickTranslator.js
//start file
// Player's fixed position on the screen within the game world window (0-indexed).
// This is a design constant representing the center of the viewport.
export const PLAYER_SCREEN_TILE_X = 7; // 8th tile from the left
export const PLAYER_SCREEN_TILE_Y = 5; // 6th tile from the top

/**
 * Translates absolute in-game world coordinates to absolute screen coordinates for clicking.
 * This function is pure and relies on dynamically detected region data passed as arguments.
 *
 * @param {number} targetGameX - The target absolute X coordinate in the game world.
 * @param {number} targetGameY - The target absolute Y coordinate in the game world.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current absolute position.
 * @param {object} gameWorldRegion - The dynamically found gameWorld region object {x, y, width, height}.
 * @param {object} tileSize - The dynamically calculated tile size object {width, height}.
 * @param {'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight' | 'center'} [targetPoint='center'] - The specific point within the tile to target.
 * @returns {{x: number, y: number}|null} The absolute screen coordinates for the click, or null if inputs are invalid.
 */
export function getAbsoluteGameWorldClickCoordinates(
  targetGameX,
  targetGameY,
  playerMinimapPosition,
  gameWorldRegion,
  tileSize,
  targetPoint = 'center',
) {
  // --- Input Validation ---
  if (!playerMinimapPosition) {
    console.error(
      '[ClickTranslator] Missing playerMinimapPosition for coordinate translation.',
    );
    return null;
  }
  if (!gameWorldRegion || !gameWorldRegion.width || !gameWorldRegion.height) {
    console.error(
      '[ClickTranslator] Missing or invalid gameWorldRegion for coordinate translation.',
    );
    return null;
  }
  if (!tileSize || !tileSize.width || !tileSize.height) {
    console.error(
      '[ClickTranslator] Missing or invalid tileSize for coordinate translation.',
    );
    return null;
  }

  // Calculate the difference in global game coordinates (in tiles)
  const deltaTilesX = targetGameX - playerMinimapPosition.x;
  const deltaTilesY = targetGameY - playerMinimapPosition.y;

  // Calculate the top-left pixel of the player's tile on screen using dynamic data
  const playerScreenPixelX_topLeft =
    gameWorldRegion.x + PLAYER_SCREEN_TILE_X * tileSize.width;
  const playerScreenPixelY_topLeft =
    gameWorldRegion.y + PLAYER_SCREEN_TILE_Y * tileSize.height;

  // Calculate the top-left pixel of the target tile on screen
  const targetTileScreenPixelX =
    playerScreenPixelX_topLeft + deltaTilesX * tileSize.width;
  const targetTileScreenPixelY =
    playerScreenPixelY_topLeft + deltaTilesY * tileSize.height;

  // Adjust based on targetPoint within the tile
  let finalClickX = targetTileScreenPixelX;
  let finalClickY = targetTileScreenPixelY;

  switch (targetPoint) {
    case 'topRight':
      finalClickX += tileSize.width;
      break;
    case 'bottomLeft':
      finalClickY += tileSize.height;
      break;
    case 'bottomRight':
      // Subtract a couple of pixels to ensure the click is inside the boundary
      finalClickX += tileSize.width - 2;
      finalClickY += tileSize.height - 2;
      break;
    case 'center':
    default: // Default to center for safety
      finalClickX += tileSize.width / 2;
      finalClickY += tileSize.height / 2;
      break;
  }

  // Return the final, rounded coordinates to ensure they are integers
  return { x: Math.round(finalClickX), y: Math.round(finalClickY) };
}

/**
 * Translates absolute screen coordinates to in-game world coordinates.
 *
 * @param {number} screenX - The absolute X coordinate on the screen.
 * @param {number} screenY - The absolute Y coordinate on the screen.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current absolute position.
 * @param {object} gameWorldRegion - The dynamically found gameWorld region object {x, y, width, height}.
 * @param {object} tileSize - The dynamically calculated tile size object {width, height}.
 * @returns {{x: number, y: number, z: number}|null} The absolute game world coordinates, or null if inputs are invalid.
 */
export function getGameCoordinatesFromScreen(
  screenX,
  screenY,
  playerMinimapPosition,
  gameWorldRegion,
  tileSize,
) {
  // --- Input Validation ---
  if (!playerMinimapPosition) {
    console.error(
      '[ClickTranslator] Missing playerMinimapPosition for coordinate translation.',
    );
    return null;
  }
  if (!gameWorldRegion || !gameWorldRegion.width || !gameWorldRegion.height) {
    console.error(
      '[ClickTranslator] Missing or invalid gameWorldRegion for coordinate translation.',
    );
    return null;
  }
  if (!tileSize || !tileSize.width || !tileSize.height) {
    console.error(
      '[ClickTranslator] Missing or invalid tileSize for coordinate translation.',
    );
    return null;
  }

  // --- Corrected Logic ---

  // 1. Calculate the entity's pixel position relative to the gameWorld region's origin.
  const relativeX = screenX - gameWorldRegion.x;
  const relativeY = screenY - gameWorldRegion.y;

  // 2. Convert the relative pixel position to a tile position within the gameWorld grid.
  const entityTileX = Math.floor(relativeX / tileSize.width);
  const entityTileY = Math.floor(relativeY / tileSize.height);

  // 3. Calculate the difference in tiles between the entity and the player's fixed screen position.
  const deltaTilesX = entityTileX - PLAYER_SCREEN_TILE_X;
  const deltaTilesY = entityTileY - PLAYER_SCREEN_TILE_Y;

  // 4. Add this tile difference to the player's absolute game world coordinates.
  const gameX = playerMinimapPosition.x + deltaTilesX;
  const gameY = playerMinimapPosition.y + deltaTilesY;

  return {
    x: gameX,
    y: gameY,
    z: playerMinimapPosition.z, // Z-level is the same as the player's
  };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/getDirectionKey.js
//start file
const getDirectionKey = (current, target) => {
  const dx = target.x - current.x;
  const dy = target.y - current.y;
  if (dy < 0) {
    if (dx < 0) return 'q';
    if (dx === 0) return 'w';
    if (dx > 0) return 'e';
  } else if (dy === 0) {
    if (dx < 0) return 'a';
    if (dx > 0) return 'd';
  } else if (dy > 0) {
    if (dx < 0) return 'z';
    if (dx === 0) return 's';
    if (dx > 0) return 'c';
  }
  return null;
};

export default getDirectionKey;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/getRandomNumber.js
//start file
export const getRandomNumber = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/getWindowDimensions.js
//start file
import { spawn } from 'child_process';

class XdotoolManager {
  constructor() {
    this.process = null;
    this.commandQueue = [];
    this.isProcessing = false;
  }

  init() {
    if (this.process) return;

    this.process = spawn('xdotool', ['-']);

    // Handle process output
    this.process.stdout.on('data', (data) => {
      const result = data.toString().trim();
      if (this.commandQueue.length > 0) {
        const { resolve } = this.commandQueue.shift();
        resolve(result);
        this.processNextCommand();
      }
    });

    this.process.stderr.on('data', (data) => {
      if (this.commandQueue.length > 0) {
        const { reject } = this.commandQueue.shift();
        reject(new Error(data.toString()));
        this.processNextCommand();
      }
    });

    // Clean up on exit
    process.on('exit', () => {
      if (this.process) {
        this.process.kill();
      }
    });
  }

  async executeCommand(command) {
    return new Promise((resolve, reject) => {
      this.commandQueue.push({ command, resolve, reject });
      if (!this.isProcessing) {
        this.processNextCommand();
      }
    });
  }

  async processNextCommand() {
    if (this.commandQueue.length === 0) {
      this.isProcessing = false;
      return;
    }

    this.isProcessing = true;
    const { command } = this.commandQueue[0];

    try {
      // Send command through stdin
      this.process.stdin.write(`${command}\n`);
    } catch (error) {
      const { reject } = this.commandQueue.shift();
      reject(error);
      this.processNextCommand();
    }
  }
}

// Singleton instance
const xdotoolManager = new XdotoolManager();

async function getWindowDimensions(windowId) {
  xdotoolManager.init();

  try {
    const output = await xdotoolManager.executeCommand(
      `getwindowgeometry ${windowId}`,
    );
    const dimensions = output.match(/Geometry: (\d+)x(\d+)/);

    if (!dimensions) {
      throw new Error('Failed to parse window dimensions');
    }

    return {
      width: parseInt(dimensions[1]),
      height: parseInt(dimensions[2]),
    };
  } catch (error) {
    console.error('Error:', error);
    return null;
  }
}

export { getWindowDimensions, xdotoolManager };

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/logger.js
//start file
// electron/utils/logger.js
/**
 * Creates a configured logger function.
 *
 * @param {object} config - Logging configuration.
 * @param {boolean} [config.error=true] - Enable error logs.
 * @param {boolean} [config.warn=false] - Enable warning logs.
 * @param {boolean} [config.info=false] - Enable info logs.
 * @param {boolean} [config.debug=false] - Enable debug logs.
 * @param {boolean} [config.colors=true] - Enable colored output.
 * @returns {function(string, string, ...any): void} - The logging function.
 *   The function takes (level, message, ...optionalParams).
 */
export function createLogger(config = {}) {
  const defaultConfig = {
    error: true,
    warn: false,
    info: false,
    debug: false,
    colors: true,
  };

  // Merge provided config with default config
  const loggerConfig = { ...defaultConfig, ...config };

  const levels = {
    error: { tag: 'ERROR', color: 31, consoleMethod: 'error' }, // Red
    warn: { tag: 'WARN', color: 33, consoleMethod: 'warn' }, // Yellow
    info: { tag: 'INFO', color: 34, consoleMethod: 'log' }, // Blue
    debug: { tag: 'DEBUG', color: 32, consoleMethod: 'log' }, // Green
  };

  /**
   * Logs a message with a specific level.
   *
   * @param {string} level - The logging level ('error', 'warn', 'info', 'debug').
   * @param {string} message - The message to log.
   * @param {...any} optionalParams - Optional parameters to log (e.g., objects, variables).
   */
  return function log(level, message, ...optionalParams) {
    // Normalize level to lowercase for config lookup
    const lowerLevel = level.toLowerCase();
    const levelDetails = levels[lowerLevel];

    // Check if the level exists and is enabled in the config
    if (!levelDetails || !loggerConfig[lowerLevel]) {
      return; // Don't log if level is not configured or invalid
    }

    const now = new Date();
    // Format timestamp as YYYY-MM-DD HH:MM:SS.sss
    const timestamp = now.toISOString().replace('T', ' ').slice(0, 23);
    const tag = levelDetails.tag;
    const consoleMethod = levelDetails.consoleMethod;

    let formattedMessage;
    if (loggerConfig.colors) {
      const colorCode = levelDetails.color;
      // --- FIX: Apply color once at the start and reset once at the end ---
      // This ensures the tag, timestamp, and message are all the same color.
      // OLD: `\x1b[${colorCode}m[${tag}] [\x1b[90m${timestamp}\x1b[0m]\x1b[0m ${message}`
      formattedMessage = `\x1b[${colorCode}m[${tag}] [${timestamp}] ${message}\x1b[0m`;
    } else {
      // Format: [TAG] [TIMESTAMP] Message
      formattedMessage = `[${tag}] [${timestamp}] ${message}`;
    }

    // Use the appropriate console method to maintain console output streams (stdout vs stderr)
    console[consoleMethod](formattedMessage, ...optionalParams);
  };
}

// Example usage (can be removed or kept for testing)
// const defaultLogger = createLogger();
// defaultLogger('error', 'This is an error message.');
// defaultLogger('warn', 'This is a warning message.'); // Won't show with default config
// defaultLogger('info', 'This is an info message.');   // Won't show with default config
// defaultLogger('debug', 'This is a debug message.'); // Won't show with default config

// const verboseLogger = createLogger({ info: true, warn: true, debug: true });
// verboseLogger('error', 'This is an error message (verbose).');
// verboseLogger('warn', 'This is a warning message (verbose).');
// verboseLogger('info', 'This is an info message (verbose).');
// verboseLogger('debug', 'This is a debug message (verbose).', { data: 123 });

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/minimapClickTranslator.js
//start file
const MINIMAP_WIDTH = 106; // From preprocessMinimaps.js
const MINIMAP_HEIGHT = 109; // From preprocessMinimaps.js

/**
 * Translates global minimap coordinates to absolute screen coordinates for clicking.
 * @param {number} targetMapX - The target X coordinate on the global minimap.
 * @param {number} targetMapY - The target Y coordinate on the global minimap.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current position on the global minimap.
 * @param {{x: number, y: number, width: number, height: number}} minimapRegionDef - The screen coordinates and dimensions of the visible minimap.
 * @returns {{x: number, y: number}|null} The absolute screen coordinates for the click, or null if inputs are invalid.
 */
export function getAbsoluteClickCoordinates(
  targetMapX,
  targetMapY,
  playerMinimapPosition,
  minimapRegionDef,
) {
  if (!playerMinimapPosition || !minimapRegionDef) {
    console.error(
      'Missing playerMinimapPosition or minimapRegionDef for coordinate translation.',
    );
    return null;
  }

  // Calculate relative pixel position on the visible minimap
  const relativePixelX =
    targetMapX - playerMinimapPosition.x + MINIMAP_WIDTH / 2;
  const relativePixelY =
    targetMapY - playerMinimapPosition.y + MINIMAP_HEIGHT / 2;

  // Calculate absolute screen coordinates
  const absoluteClickX = minimapRegionDef.x + relativePixelX;
  const absoluteClickY = minimapRegionDef.y + relativePixelY;

  return { x: absoluteClickX, y: absoluteClickY };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/minimapMatcher.js
//start file
import fs from 'fs/promises';
import path from 'path';
import { createLogger } from './logger.js';
import MinimapMatcherNative from 'minimap_matcher-native';

const logger = createLogger({ info: true, error: true, debug: false });

let PREPROCESSED_BASE_DIR = null;

// Allow setting the base directory externally (e.g., from workerData)
export const setMinimapResourcesPath = (basePath) => {
  PREPROCESSED_BASE_DIR = basePath;
};

const getPreprocessedBaseDir = () => {
  if (!PREPROCESSED_BASE_DIR) {
    // Fallback for backward compatibility
    const getResourcesPath = () => {
      if (process.resourcesPath) {
        return process.resourcesPath;
      }
      return process.cwd();
    };
    return path.join(getResourcesPath(), 'resources', 'preprocessed_minimaps');
  }
  return PREPROCESSED_BASE_DIR;
};
const LANDMARK_SIZE = 3;
// The landmark pattern is now packed at 4-bits per pixel.
// The C++ addon will now work with 25-byte keys instead of 49-byte keys.
const LANDMARK_PATTERN_BYTES = Math.ceil((LANDMARK_SIZE * LANDMARK_SIZE) / 2); // 25

const EXCLUDED_COLORS_RGB = [
  { r: 51, g: 102, b: 153 },
  { r: 0, g: 0, b: 0 },
  { r: 255, g: 255, b: 255 },
  { r: 153, g: 153, b: 153 },
  { r: 0, g: 204, b: 0 },
  { r: 102, g: 102, b: 102 },
  { r: 255, g: 204, b: 153 },
  { r: 153, g: 102, b: 51 },
  { r: 255, g: 102, b: 0 },
];

class MinimapMatcher {
  constructor() {
    try {
      this.nativeMatcher = new MinimapMatcherNative.MinimapMatcher({
        LANDMARK_SIZE,
        LANDMARK_PATTERN_BYTES,
        EXCLUDED_COLORS_RGB,
      });
    } catch (error) {
      logger(
        'error',
        `Failed to load native minimap matcher module: ${error.message}`,
      );
      throw error;
    }

    this.isLoaded = false;
    this.lastKnownPositionByZ = new Map();
  }

  async loadMapData() {
    if (this.isLoaded) return;
    try {
      const baseDir = getPreprocessedBaseDir();
      const paletteFilePath = path.join(baseDir, 'palette.json');
      const palette = JSON.parse(await fs.readFile(paletteFilePath, 'utf8'));

      const landmarkData = new Map();

      const zLevelDirs = (await fs.readdir(baseDir, { withFileTypes: true }))
        .filter((d) => d.isDirectory() && d.name.startsWith('z'))
        .map((d) => parseInt(d.name.substring(1), 10));

      for (const z of zLevelDirs) {
        const zLevelDir = path.join(baseDir, `z${z}`);
        try {
          const landmarkBuffer = await fs.readFile(
            path.join(zLevelDir, 'landmarks.bin'),
          );
          const landmarks = [];

          // --- KEY CHANGE #2 ---
          // The size of each entry in the file is now based on the packed size.
          // 8 bytes for x/y coordinates + 25 bytes for the packed pattern.
          const landmarkEntrySize = 8 + LANDMARK_PATTERN_BYTES;

          for (let i = 0; i < landmarkBuffer.length; i += landmarkEntrySize) {
            landmarks.push({
              x: landmarkBuffer.readUInt32LE(i),
              y: landmarkBuffer.readUInt32LE(i + 4),
              // The pattern is now the 25-byte packed buffer.
              pattern: landmarkBuffer.subarray(i + 8, i + landmarkEntrySize),
            });
          }
          landmarkData.set(z, landmarks);
        } catch (e) {
          if (e.code === 'ENOENT') {
            logger(
              'warn',
              `No landmarks.bin found for Z=${z}. Position finding will be unavailable for this floor.`,
            );
          } else {
            logger(
              'error',
              `Could not load landmarks.bin for Z=${z}: ${e.message}`,
            );
          }
          landmarkData.set(z, []);
        }
      }

      // Sync data to the native module once on load
      this.nativeMatcher.palette = palette;
      this.nativeMatcher.landmarkData = Object.fromEntries(landmarkData);
      this.nativeMatcher.isLoaded = true;
      this.isLoaded = true;

      logger('info', `All minimap data loaded and synced to native module.`);
    } catch (error) {
      logger('error', `Failed to load minimap data: ${error.message}`);
      this.isLoaded = false;
      this.nativeMatcher.isLoaded = false;
    }
  }

  /**
   * Finds the player position asynchronously.
   * This method returns a promise that resolves with the position or rejects on error/cancellation.
   * It will automatically cancel any previously running search.
   * @param {Buffer} unpackedMinimap - A buffer of 8-bit palette indices.
   * @param {number} minimapWidth
   * @param {number} minimapHeight
   * @param {number} targetZ
   * @returns {Promise<object|null>} A promise that resolves with the result object.
   */
  async findPosition(unpackedMinimap, minimapWidth, minimapHeight, targetZ) {
    if (!this.isLoaded) {
      throw new Error(
        'MinimapMatcher is not loaded. Call loadMapData() first.',
      );
    }

    const resultPromise = this.nativeMatcher.findPosition(
      unpackedMinimap,
      minimapWidth,
      minimapHeight,
      targetZ,
    );

    resultPromise
      .then((result) => {
        if (result && result.position) {
          this.lastKnownPositionByZ.set(targetZ, {
            x: result.mapViewX,
            y: result.mapViewY,
          });
        }
      })
      .catch((err) => {
        if (err.message !== 'Search cancelled') {
          logger('error', `Native findPosition error: ${err.message}`);
        }
      });

    return resultPromise;
  }

  /**
   * Explicitly cancels any ongoing search.
   */
  cancelCurrentSearch() {
    this.nativeMatcher.cancelSearch();
  }
}

export { MinimapMatcher };

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/parseMathCondition.js
//start file
/**
 * Parse mathematical conditions for HP and mana triggers.
 * @param {string} condition - The mathematical condition to check.
 * @param {number} triggerPercentage - The trigger percentage value.
 * @param {number} actualPercentage - The actual percentage value to check against.
 * @returns {boolean} - True if the condition is met, false otherwise.
 */
const parseMathCondition = (condition, triggerPercentage, actualPercentage) => {
  switch (condition) {
    case '<':
      return actualPercentage < triggerPercentage;
    case '<=':
      return actualPercentage <= triggerPercentage;
    case '=':
      return actualPercentage === triggerPercentage;
    case '>':
      return actualPercentage > triggerPercentage;
    case '>=':
      return actualPercentage >= triggerPercentage;
    case '!=':
      return actualPercentage !== triggerPercentage;
    default:
      return false;
  }
};

export default parseMathCondition;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/widget/preload.js
//start file
// Automaton/electron/widget/preload.js
const { contextBridge, ipcRenderer } = require('electron');

// Expose controlled functions to the renderer process
contextBridge.exposeInMainWorld('electronAPI', {
  // Send messages to the main process
  send: (channel, ...args) => {
    ipcRenderer.send(channel, ...args);
  },
  // Receive messages from the main process
  on: (channel, listener) => {
    ipcRenderer.on(channel, listener);
  },
  // Invoke functions in the main process and wait for a response
  invoke: (channel, ...args) => {
    return ipcRenderer.invoke(channel, ...args);
  },
  // Remove a listener
  removeListener: (channel, listener) => {
    ipcRenderer.removeListener(channel, listener);
  },
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/widget/renderer.js
//start file
// Automaton/electron/widget/renderer.js

// Function to get current state from main process
async function getInitialStates() {
  try {
    const states = await window.electronAPI.invoke('get-control-states');
    if (states) {
      document.getElementById('healing-switch').checked = states.isRulesEnabled;
      document.getElementById('cavebot-switch').checked =
        states.isCavebotEnabled;
      document.getElementById('targeting-switch').checked =
        states.isTargetingEnabled;
      document.getElementById('scripts-switch').checked = states.isLuaEnabled;
    }
  } catch (error) {
    console.error('Error getting initial states:', error);
  }
}

// Function to handle switch changes
function handleSwitchChange(switchId, feature) {
  const switchElement = document.getElementById(switchId);
  switchElement.addEventListener('change', () => {
    window.electronAPI.send('update-bot-status', {
      feature,
      isEnabled: switchElement.checked,
    });
  });
}

// Function to handle state updates from main process
function handleStateUpdates() {
  window.electronAPI.on('state-update', (event, action) => {
    // Update switches based on state changes from main process
    switch (action.type) {
      case 'rules/setenabled':
        document.getElementById('healing-switch').checked = action.payload;
        break;
      case 'cavebot/setenabled':
        document.getElementById('cavebot-switch').checked = action.payload;
        break;
      case 'targeting/setenabled':
        document.getElementById('targeting-switch').checked = action.payload;
        break;
      case 'lua/setenabled':
        document.getElementById('scripts-switch').checked = action.payload;
        break;
      case 'rules/setState':
        if (action.payload) {
          document.getElementById('healing-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'cavebot/setState':
        if (action.payload) {
          document.getElementById('cavebot-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'targeting/setState':
        if (action.payload) {
          document.getElementById('targeting-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'lua/setState':
        if (action.payload) {
          document.getElementById('scripts-switch').checked =
            action.payload.enabled;
        }
        break;
    }
  });
}

// Function to update main window toggle button
async function updateMainWindowToggle() {
  const isVisible = await window.electronAPI.invoke('is-main-window-visible');
  const toggleIcon = document.getElementById('toggle-main-icon');

  if (isVisible) {
    toggleIcon.textContent = '';
  } else {
    toggleIcon.textContent = '';
  }
}

// Function to handle main window toggle
function handleMainWindowToggle() {
  const toggleBtn = document.getElementById('toggle-main-btn');
  toggleBtn.addEventListener('click', async () => {
    await window.electronAPI.invoke('toggle-main-window');
    await updateMainWindowToggle();
  });
}

// Initialize the widget when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
  // Get initial states
  await getInitialStates();
  await updateMainWindowToggle();

  // Set up switch change handlers
  handleSwitchChange('healing-switch', 'healing');
  handleSwitchChange('cavebot-switch', 'cavebot');
  handleSwitchChange('targeting-switch', 'targeting');
  handleSwitchChange('scripts-switch', 'scripts');

  // Set up state update listener
  handleStateUpdates();

  // Set up main window toggle
  handleMainWindowToggle();
});

// Clean up listeners when window is closed
window.addEventListener('beforeunload', () => {
  window.electronAPI.removeListener('state-update', handleStateUpdates);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workerManager.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workerManager.js
// --- Drop-in Replacement ---

import { Worker } from 'worker_threads';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import { showNotification } from './notificationHandler.js';
import { createLogger } from './utils/logger.js';
import { BrowserWindow } from 'electron';
import { playSound } from './globalShortcuts.js';
import { deepHash } from './utils/deepHash.js'; // Import deepHash
import {
  PLAYER_POS_SAB_SIZE,
  PATH_DATA_SAB_SIZE,
} from './workers/sharedConstants.js';

const log = createLogger();

const DEFAULT_WORKER_CONFIG = {
  captureWorker: true,
  regionMonitor: true,
  screenMonitor: true,
  minimapMonitor: true,
  ocrWorker: true,
  creatureMonitor: true,
  cavebotWorker: true,
  targetingWorker: true,
  pathfinderWorker: true,
  windowTitleMonitor: true,
  lootingWorker: true, // NEW: Add lootingWorker
  enableLuaScriptWorkers: true,
};

const MAX_RESTART_ATTEMPTS = 5;
const RESTART_COOLDOWN = 500;
const RESTART_LOCK_TIMEOUT = 5000;
const DEBOUNCE_INTERVAL = 16;

function quickHash(obj) {
  return deepHash(obj);
}

const WORKER_STATE_DEPENDENCIES = {
  // cavebotWorker needs the full state, so it's handled separately
  // luaScriptWorker also needs the full state, handled separately

  targetingWorker: [
    'targeting',
    'global',
    'gameState',
    'pathfinder',
    'cavebot',
    'regionCoordinates',
    'battleList',
  ],
  lootingWorker: ['global', 'battleList'], // NEW: Add lootingWorker dependencies
  regionMonitor: ['global'],
  screenMonitor: [
    'global',
    'regionCoordinates',
    'gameState',
    'rules',
    'uiValues',
  ],
  minimapMonitor: ['gameState', 'regionCoordinates'],
  ocrWorker: ['global', 'regionCoordinates', 'gameState', 'ocr'],
  creatureMonitor: [
    'global',
    'regionCoordinates',
    'gameState',
    'ocr',
    'cavebot',
    'targeting',
  ],
  captureWorker: ['global'],
  pathfinderWorker: ['targeting', 'cavebot', 'gameState'],
  windowTitleMonitor: ['global', 'gameState'],
};

const GRACEFUL_SHUTDOWN_WORKERS = new Set([
  'regionMonitor',
  'screenMonitor',
  'minimapMonitor',
  'ocrWorker',
  'creatureMonitor',
  'cavebotWorker',
  'targetingWorker',
  'pathfinderWorker',
]);

// --- NEW ---
/**
 * Checks if two rectangle objects intersect.
 * @param {object} rectA - The first rectangle {x, y, width, height}.
 * @param {object} rectB - The second rectangle {x, y, width, height}.
 * @returns {boolean} True if the rectangles overlap.
 */
function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

// --- NEW ---
// Maps workers to the regions they depend on for frame updates.
const WORKER_REGION_DEPENDENCIES = {
  screenMonitor: [
    'healthBar',
    'manaBar',
    'cooldownBar',
    'statusBar',
    'amuletSlot',
    'ringSlot',
    'bootsSlot',
    'hotkeyBar',
    'battleList',
  ],
  minimapMonitor: ['minimapFull', 'minimapFloorIndicatorColumn'],
  ocrWorker: [
    'skillsWidget',
    'chatBoxTabRow',
    'selectCharacterModal',
    'vipWidget',
    'gameWorld',
    'battleList',
  ],
  creatureMonitor: ['gameWorld'],
  // `null` is a special case: regionMonitor needs an update on ANY screen change.
  regionMonitor: null,
};

class WorkerManager {
  constructor() {
    const filename = fileURLToPath(import.meta.url);
    this.electronDir = dirname(filename);
    this.workers = new Map();
    this.workerInitialized = new Map();
    this.workerPaths = new Map();
    this.restartLocks = new Map();
    this.restartAttempts = new Map();
    this.restartTimeouts = new Map();
    this.sharedData = null;
    this.workerConfig = {};
    this.paths = { utils: null, workers: null, minimapResources: null };
    this.previousState = null;
    this.storeUpdateTimeout = null;
    this.updateCount = 0;
    this.lastPerfReport = Date.now();
    this.reusableChangedSlices = {};
    this.workerStateCache = new Map();
    this.debounceTimeout = null;
    this.sharedLuaGlobals = {}; // NEW: Centralized object for shared Lua globals
    this.handleWorkerError = this.handleWorkerError.bind(this);
    this.handleWorkerExit = this.handleWorkerExit.bind(this);
    this.handleWorkerMessage = this.handleWorkerMessage.bind(this);
    this.handleStoreUpdate = this.handleStoreUpdate.bind(this);
    this.debouncedStoreUpdate = this.debouncedStoreUpdate.bind(this);
    this.precalculatedWorkerPayloads = new Map(); // New map for pre-calculated payloads
  }

  setupPaths(app, cwd) {
    if (app.isPackaged) {
      this.paths.utils = path.join(
        app.getAppPath(),
        '..',
        'resources',
        'x11utils',
      );
      this.paths.minimapResources = path.join(
        app.getAppPath(),
        '..',
        'resources',
        'preprocessed_minimaps',
      );
    } else {
      this.paths.utils = path.join(cwd, '..', 'resources', 'x11utils');
      this.paths.minimapResources = path.join(
        cwd,
        '..',
        'resources',
        'preprocessed_minimaps',
      );
    }
    if (!app.isPackaged) {
      log('info', '[Worker Manager] Paths initialized:', this.paths);
    }
  }

  resetRestartState(name) {
    this.restartLocks.set(name, false);
    this.restartAttempts.set(name, 0);
    clearTimeout(this.restartTimeouts.get(name));
    this.restartTimeouts.delete(name);
  }

  async clearRestartLockWithTimeout(name) {
    const timeout = setTimeout(() => {
      log('warn', `[Worker Manager] Force clearing restart lock: ${name}`);
      this.resetRestartState(name);
    }, RESTART_LOCK_TIMEOUT);
    this.restartTimeouts.set(name, timeout);
  }

  getWorkerPath(workerName) {
    const isUUID = /^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/.test(
      workerName,
    );
    if (isUUID) {
      return resolve(this.electronDir, './workers', 'luaScriptWorker.js');
    }
    // ====================== MODIFICATION START ======================
    // Point cavebotWorker to its new modular entry point.
    if (workerName === 'cavebotWorker') {
      return resolve(this.electronDir, './workers', 'cavebot', 'index.js');
    }
    // ======================= MODIFICATION END =======================
    return resolve(this.electronDir, './workers', `${workerName}.js`);
  }

  createSharedBuffers() {
    const maxImageSize = 3840 * 2160 * 4;
    const imageSAB = new SharedArrayBuffer(maxImageSize);
    const MAX_DIRTY_REGIONS = 64;
    const SYNC_BUFFER_SIZE = 5 + 1 + MAX_DIRTY_REGIONS * 4;
    const syncSAB = new SharedArrayBuffer(
      SYNC_BUFFER_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const playerPosSAB = new SharedArrayBuffer(
      PLAYER_POS_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const pathDataSAB = new SharedArrayBuffer(
      PATH_DATA_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );

    this.sharedData = {
      imageSAB,
      syncSAB,
      playerPosSAB,
      pathDataSAB,
    };
    log('info', '[Worker Manager] Created SharedArrayBuffers.');
  }

  handleWorkerError(name, error) {
    log('error', `[Worker Manager] Worker error: ${name}`, error);
    if (!name.startsWith('script-') && !this.restartLocks.get(name)) {
      this.restartWorker(name).catch((err) =>
        log(
          'error',
          `[Worker Manager] Restart failed after error: ${name}`,
          err,
        ),
      );
    } else if (name.startsWith('script-')) {
      log(
        'info',
        `[Worker Manager] Script worker ${name} encountered an error. Lifecycle managed by store updates.`,
      );
      this.workers.delete(name);
    }
  }

  handleWorkerExit(name, code) {
    log('info', `[Worker Manager] Worker exited: ${name}, code ${code}`);
    this.workers.delete(name);
    this.workerPaths.delete(name);
    this.workerInitialized.delete(name);
    const isUUID = /^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/.test(
      name,
    );
    if (!isUUID && code !== 0) {
      const attempts = this.restartAttempts.get(name) || 0;
      if (!this.restartLocks.get(name) && attempts < MAX_RESTART_ATTEMPTS) {
        log(
          'error',
          `[Worker Manager] Non-script worker exited with error: ${name}, code ${code}, attempt ${attempts + 1}/${MAX_RESTART_ATTEMPTS}`,
        );
        setTimeout(
          () => {
            this.restartWorker(name).catch((err) =>
              log('error', `Failed to restart worker ${name} after exit:`, err),
            );
          },
          RESTART_COOLDOWN * (attempts + 1),
        );
      } else if (attempts >= MAX_RESTART_ATTEMPTS) {
        log(
          'error',
          `[Worker Manager] Max restart attempts reached for non-script worker: ${name}`,
        );
        this.resetRestartState(name);
      }
    }
  }

  handleWorkerMessage(message, workerName) {
    if (message.type === 'request_state_snapshot') {
      const worker = this.workers.get(workerName)?.worker;
      if (worker) {
        worker.postMessage({
          type: 'state_snapshot',
          payload: store.getState(),
        });
      }
      return;
    }

    // --- MODIFIED: Centralized Frame Update Distribution ---
    if (message.type === 'frame-update') {
      const dirtyRects = message.payload.dirtyRects;
      if (!dirtyRects || dirtyRects.length === 0) return;

      const allRegions = store.getState().regionCoordinates.regions;
      if (!allRegions) return;

      for (const [name, workerEntry] of this.workers.entries()) {
        if (name === 'captureWorker' || !workerEntry.worker) continue;

        const dependencies = WORKER_REGION_DEPENDENCIES[name];

        // Special case for regionMonitor: it needs an update on any screen change.
        if (dependencies === null) {
          workerEntry.worker.postMessage(message);
          continue;
        }

        if (dependencies) {
          let needsUpdate = false;
          for (const regionKey of dependencies) {
            const region = allRegions[regionKey];
            if (region) {
              for (const dirtyRect of dirtyRects) {
                if (rectsIntersect(region, dirtyRect)) {
                  workerEntry.worker.postMessage(message);
                  needsUpdate = true;
                  break; // Break from inner loop (dirtyRects)
                }
              }
            }
            if (needsUpdate) break; // Break from outer loop (dependencies)
          }
        }
      }
      return;
    }
    // --- END MODIFICATION ---

    if (message.notification) {
      showNotification(message.notification.title, message.notification.body);
    } else if (message.storeUpdate) {
      this.incomingActionQueue.push({
        type: message.type,
        payload: message.payload,
      });
    } else if (message.type === 'batch-update') {
      for (const action of message.payload) {
        setGlobalState(action.type, action.payload);
      }
    } else if (message.command === 'requestRegionRescan') {
      const regionWorkerEntry = this.workers.get('regionMonitor');
      if (regionWorkerEntry?.worker) {
        regionWorkerEntry.worker.postMessage({ command: 'forceRegionSearch' });
      }
    } else if (message.command === 'executeLuaScript') {
      const state = store.getState();
      const { enabled: luaEnabled } = state.lua;
      const { script, id } = message.payload;
      if (!luaEnabled) {
        const cavebotWorkerEntry = this.workers.get('cavebotWorker');
        if (cavebotWorkerEntry?.worker) {
          cavebotWorkerEntry.worker.postMessage({
            type: 'script-finished',
            id,
            success: false,
            error: 'Lua scripts are disabled',
          });
        }
        return;
      }
      this.startWorker(id, { id, code: script, type: 'oneshot' }, this.paths);
    } else if (message.type === 'scriptExecutionResult') {
      const { id, success, error } = message;
      if (error)
        log(
          'error',
          `[Worker Manager] Script ${id} failed with error: ${error}`,
        );
      const cavebotWorkerEntry = this.workers.get('cavebotWorker');
      if (cavebotWorkerEntry?.worker) {
        cavebotWorkerEntry.worker.postMessage({ type: 'script-finished', id });
      }
      this.stopWorker(id);
    } else if (
      ['scriptError', 'luaPrint', 'luaStatusUpdate'].includes(message.type)
    ) {
      const { scriptId, message: logMessage } = message;
      if (scriptId) {
        setGlobalState('lua/addLogEntry', {
          id: scriptId,
          message: logMessage,
        });
        BrowserWindow.getAllWindows().forEach((win) => {
          if (!win.isDestroyed())
            win.webContents.send('script-log-update', {
              scriptId,
              message: logMessage,
            });
        });
      }
    } else if (message.type === 'lua_global_update') {
      const { key, value } = message.payload;
      log(
        'debug',
        `[Worker Manager] Received lua_global_update: key=${key}, value=${value}`,
      );
      this.sharedLuaGlobals[key] = value; // Update the master copy

      // Broadcast to all other workers, including cavebotWorker
      for (const [name, workerEntry] of this.workers) {
        // The `workerName` is the sender, so don't send it back to the sender
        if (
          name !== workerName &&
          (/^[0-9a-fA-F]{8}-/.test(name) || name === 'cavebotWorker')
        ) {
          log(
            'debug',
            `[Worker Manager] Broadcasting lua_global_broadcast to ${name}: key=${key}, value=${value}`,
          );
          workerEntry.worker.postMessage({
            type: 'lua_global_broadcast',
            payload: { key, value },
          });
        }
      }
      return; // Message handled
    } else if (message.type === 'play_alert') {
      playSound('alert.wav');
      return;
    } else if (message.type === 'lua-pause-walking') {
      store.dispatch(setWalkingPause(message.payload));
      return;
    } else if (message.type === 'lua-pause-targeting') {
      store.dispatch(setTargetingPause(message.payload));
      return;
    } else if (message.type === 'lua_set_script_enabled') {
      const { name, enabled } = message.payload;
      setGlobalState('lua/setScriptEnabledByName', { name, enabled });
    }
  }

  startWorker(name, scriptConfig = null, paths = null) {
    if (this.workers.has(name)) return this.workers.get(name).worker;
    try {
      const workerPath = this.getWorkerPath(name);
      const needsSharedScreen = [
        'captureWorker',
        'screenMonitor',
        'minimapMonitor',
        'regionMonitor',
        'ocrWorker',
        'creatureMonitor',
      ].includes(name);
      const needsPlayerPosSAB = [
        'minimapMonitor',
        'pathfinderWorker',
        'cavebotWorker',
        'targetingWorker',
        'creatureMonitor',
      ].includes(name);
      const needsPathDataSAB = [
        'pathfinderWorker',
        'cavebotWorker',
        'targetingWorker',
      ].includes(name);

      const workerData = {
        paths: paths || this.paths,
        sharedData: needsSharedScreen ? this.sharedData : null,
        playerPosSAB: needsPlayerPosSAB ? this.sharedData.playerPosSAB : null,
        pathDataSAB: needsPathDataSAB ? this.sharedData.pathDataSAB : null,
        sharedLuaGlobals: this.sharedLuaGlobals, // NEW: Pass the shared Lua globals object
        enableMemoryLogging: true,
      };
      if (needsSharedScreen) {
        workerData.display = store.getState().global.display;
      }
      const worker = new Worker(workerPath, { name, workerData });
      this.workers.set(name, { worker, config: scriptConfig });
      this.workerInitialized.set(name, false);
      worker.on('message', (msg) => this.handleWorkerMessage(msg, name));
      worker.on('error', (error) => this.handleWorkerError(name, error));
      worker.on('exit', (code) => this.handleWorkerExit(name, code));
      log('info', `[Worker Manager] Worker ${name} started successfully.`);

      if (scriptConfig) {
        setTimeout(() => {
          worker.postMessage({ type: 'init', script: scriptConfig });
        }, 16);
      }

      return worker;
    } catch (error) {
      log('error', `[Worker Manager] Failed to start worker: ${name}`, error);
      return null;
    }
  }

  async restartWorker(name, scriptConfig = null) {
    if (this.restartLocks.get(name)) return null;
    this.restartLocks.set(name, true);
    this.restartAttempts.set(name, (this.restartAttempts.get(name) || 0) + 1);
    this.clearRestartLockWithTimeout(name);
    try {
      await this.stopWorker(name);
      const newWorker = this.startWorker(name, scriptConfig, this.paths);
      if (!newWorker) throw new Error(`Failed to create new worker: ${name}`);
      log('info', `[Worker Manager] Worker ${name} restarted successfully.`);
      this.resetRestartState(name);
      return newWorker;
    } catch (error) {
      log('error', `[Worker Manager] Error during restart: ${name}`, error);
    } finally {
      this.restartLocks.set(name, false);
    }
  }

  stopWorker(name) {
    const workerEntry = this.workers.get(name);
    // FIX: If worker doesn't exist or is already stopping, do nothing.
    if (!workerEntry?.worker || workerEntry.stopping) {
      return Promise.resolve();
    }
    // FIX: Mark the worker as stopping to prevent duplicate shutdown commands.
    workerEntry.stopping = true;

    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        if (this.workers.has(name) && !workerEntry.worker.killed) {
          log(
            'warn',
            `[Worker Manager] Worker ${name} did not exit gracefully. Forcing termination.`,
          );
          workerEntry.worker.terminate();
        }
        resolve();
      }, 5000);

      workerEntry.worker.once('exit', () => {
        clearTimeout(timeout);
        resolve();
      });

      if (
        /^[0-9a-fA-F]{8}-/.test(name) ||
        GRACEFUL_SHUTDOWN_WORKERS.has(name)
      ) {
        workerEntry.worker.postMessage({ type: 'shutdown' });
      } else {
        workerEntry.worker.terminate();
      }
    });
  }

  async stopAllWorkers() {
    log('info', '[Worker Manager] Stopping all workers...');
    if (this.incomingActionInterval) {
      clearInterval(this.incomingActionInterval);
      this.incomingActionInterval = null;
    }
    await Promise.all(
      Array.from(this.workers.keys()).map((name) => this.stopWorker(name)),
    );
    log('info', '[Worker Manager] All workers have been terminated.');
  }

  getStateChanges(currentState, previousState) {
    const changedSlices = {};
    let hasChanges = false;
    for (const key in currentState) {
      if (currentState[key] !== previousState[key]) {
        changedSlices[key] = currentState[key];
        hasChanges = true;
      }
    }
    return hasChanges ? changedSlices : null;
  }

  broadcastStateUpdate(changedSlices, currentState) {
    this.precalculatedWorkerPayloads.clear();
    for (const workerName in WORKER_STATE_DEPENDENCIES) {
      const workerDeps = WORKER_STATE_DEPENDENCIES[workerName];
      const relevantPayload = {};
      let hasRelevantChanges = false;
      for (const k of Object.keys(changedSlices)) {
        if (workerDeps.includes(k)) {
          relevantPayload[k] = changedSlices[k];
          hasRelevantChanges = true;
        }
      }
      if (hasRelevantChanges) {
        this.precalculatedWorkerPayloads.set(workerName, relevantPayload);
      }
    }

    for (const [name, workerEntry] of this.workers) {
      if (!workerEntry.worker || name === 'captureWorker') continue;

      const isLuaWorker = /^[0-9a-fA-F]{8}-/.test(name) || name === 'cavebotWorker';

      if (!this.workerInitialized.get(name) || isLuaWorker) {
        // For initial setup or Lua workers, always send the full state
        workerEntry.worker.postMessage(currentState);
        this.workerInitialized.set(name, true);
        if (isLuaWorker) {
          // For Lua workers, we don't use state_diff, so clear cache
          this.workerStateCache.delete(name);
        }
        log('info', `[Worker Manager] Sent full state to ${name}.`);
        continue;
      }

      const relevant = this.precalculatedWorkerPayloads.get(name);

      if (relevant && Object.keys(relevant).length) {
        const hash = quickHash(relevant);
        if (this.workerStateCache.get(name) !== hash) {
          this.workerStateCache.set(name, hash);
          workerEntry.worker.postMessage({
            type: 'state_diff',
            payload: relevant,
          });
        }
      }
    }
  }

  logPerformanceStats() {
    const now = Date.now();
    if (now - this.lastPerfReport >= 10000) {
      const ups = (
        (this.updateCount / (now - this.lastPerfReport)) *
        1000
      ).toFixed(1);
      log(
        'debug',
        `[Worker Manager] Performance: ${ups} store updates/sec, ${this.workers.size} active workers`,
      );
      this.updateCount = 0;
      this.lastPerfReport = now;
    }
  }

  debouncedStoreUpdate() {
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout);
    }
    this.debounceTimeout = setTimeout(() => {
      this.handleStoreUpdate();
    }, DEBOUNCE_INTERVAL);
  }

  async handleStoreUpdate() {
    const perfStart = performance.now();
    this.updateCount++;
    try {
      const currentState = store.getState();
      const { windowId, display } = currentState.global;

      if (windowId && display) {
        if (!this.sharedData) this.createSharedBuffers();
        if (
          !this.previousState ||
          currentState.global.windowId !== this.previousState.global.windowId
        ) {
          const syncArray = new Int32Array(this.sharedData.syncSAB);
          Atomics.store(syncArray, 4, parseInt(windowId, 10) || 0);
        }

        if (
          this.workerConfig.captureWorker &&
          !this.workers.has('captureWorker')
        )
          this.startWorker('captureWorker');
        if (
          this.workerConfig.regionMonitor &&
          !this.workers.has('regionMonitor')
        )
          this.startWorker('regionMonitor');
        if (
          this.workerConfig.screenMonitor &&
          !this.workers.has('screenMonitor')
        )
          this.startWorker('screenMonitor');
        if (
          this.workerConfig.minimapMonitor &&
          !this.workers.has('minimapMonitor')
        )
          this.startWorker('minimapMonitor');
        if (this.workerConfig.ocrWorker && !this.workers.has('ocrWorker'))
          this.startWorker('ocrWorker');
        if (
          this.workerConfig.creatureMonitor &&
          !this.workers.has('creatureMonitor')
        )
          this.startWorker('creatureMonitor');
        if (
          this.workerConfig.pathfinderWorker &&
          !this.workers.has('pathfinderWorker')
        )
          this.startWorker('pathfinderWorker');
        if (
          this.workerConfig.cavebotWorker &&
          !this.workers.has('cavebotWorker')
        )
          this.startWorker('cavebotWorker');
        if (
          this.workerConfig.targetingWorker &&
          !this.workers.has('targetingWorker')
        )
          this.startWorker('targetingWorker');
        if (
          this.workerConfig.windowTitleMonitor &&
          !this.workers.has('windowTitleMonitor')
        )
          this.startWorker('windowTitleMonitor');
        if (
          this.workerConfig.lootingWorker && // NEW: Start lootingWorker
          !this.workers.has('lootingWorker')
        )
          this.startWorker('lootingWorker');
      } else {
        if (this.workers.size > 0) {
          log(
            'info',
            '[Worker Manager] Window not detected, stopping all workers...',
          );
          await this.stopAllWorkers();
        }
        if (this.sharedData) {
          log('info', '[Worker Manager] Clearing SharedArrayBuffers.');
          this.sharedData = null;
        }
      }

      await this.manageLuaWorkers(currentState, currentState.lua.enabled);

      if (this.previousState) {
        const changed = this.getStateChanges(currentState, this.previousState);
        if (changed) this.broadcastStateUpdate(changed, currentState);
      }
      this.previousState = currentState;
      this.logPerformanceStats();
    } catch (error) {
      log('error', '[Worker Manager] Error in handleStoreUpdate:', error);
    }
    const updateTime = performance.now() - perfStart;
    if (updateTime > 16) {
      log(
        'warn',
        `[Worker Manager] Slow store update: ${updateTime.toFixed(2)}ms`,
      );
    }
  }

  async manageLuaWorkers(currentState, luaEnabled) {
    const allPersistentScripts = currentState.lua.persistentScripts;
    const runningScriptWorkerIds = new Set(
      Array.from(this.workers.keys()).filter((n) => /^[0-9a-fA-F]{8}-/.test(n)),
    );
    if (this.workerConfig.enableLuaScriptWorkers && luaEnabled) {
      const activeScripts = allPersistentScripts.filter((s) => s.enabled);
      const activeScriptIds = new Set(activeScripts.map((s) => s.id));
      const workersToStop = Array.from(runningScriptWorkerIds).filter(
        (id) => !activeScriptIds.has(id),
      );
      if (workersToStop.length)
        await Promise.all(workersToStop.map((id) => this.stopWorker(id)));
      for (const script of activeScripts) {
        const entry = this.workers.get(script.id);
        if (!entry) {
          this.startWorker(script.id, script, this.paths);
        } else if (
          entry.config &&
          (entry.config.code !== script.code ||
            entry.config.loopMin !== script.loopMin ||
            entry.config.loopMax !== script.loopMax)
        ) {
          await this.restartWorker(script.id, script);
        } else {
          entry.config = script;
        }
      }
    } else {
      if (runningScriptWorkerIds.size > 0) {
        await Promise.all(
          Array.from(runningScriptWorkerIds).map((id) => this.stopWorker(id)),
        );
      }
    }
  }

  initialize(app, cwd, config = {}) {
    this.setupPaths(app, cwd);
    this.workerConfig = { ...DEFAULT_WORKER_CONFIG, ...config };
    log('info', '[Worker Manager] Initializing with debounced store updates.');
    this.previousState = store.getState();
    store.subscribe(this.debouncedStoreUpdate);

    this.incomingActionQueue = [];
    this.incomingActionInterval = setInterval(() => {
      if (this.incomingActionQueue.length > 0) {
        const batch = this.incomingActionQueue.splice(
          0,
          this.incomingActionQueue.length,
        );
        for (const action of batch) {
          setGlobalState(action.type, action.payload);
        }
      }
    }, 5);
  }
}

const workerManager = new WorkerManager();
export default workerManager;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/config.js
//start file
export const TARGET_FPS = 20;

// --- SharedArrayBuffer (SAB) Indices ---
export const FRAME_COUNTER_INDEX = 0;
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const WINDOW_ID_INDEX = 4;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

// --- Capture Limits ---
// This must match the value used when creating the SharedArrayBuffer
export const MAX_DIRTY_REGIONS = 64;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/core.js
//start file
import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import X11RegionCapture from 'x11-region-capture-native';
import * as config from './config.js';
import { PerformanceTracker } from './performanceTracker.js';

// --- Worker State & Setup ---
const { sharedData, display } = workerData;
if (!sharedData) throw new Error('[CaptureCore] Shared data not provided.');

const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const imageBuffer = Buffer.from(imageSAB);

const captureInstance = X11RegionCapture
  ? new X11RegionCapture.X11RegionCapture(display)
  : null;
let isCapturing = false;

// --- Performance Tracking ---
const perfTracker = new PerformanceTracker();
let lastPerfReportTime = Date.now();

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function logPerformanceReport() {
  if (!config.PERFORMANCE_LOGGING_ENABLED) return;

  const now = Date.now();
  if (now - lastPerfReportTime >= config.PERFORMANCE_LOG_INTERVAL_MS) {
    console.log(perfTracker.getReport());
    perfTracker.reset();
    lastPerfReportTime = now;
  }
}

async function captureLoop() {
  if (!captureInstance) {
    console.error(
      '[CaptureCore] X11 native module is not available. Cannot start capture.',
    );
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  const windowId = Atomics.load(syncArray, config.WINDOW_ID_INDEX);
  if (!windowId) {
    console.error('[CaptureCore] No Window ID provided. Cannot start capture.');
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  try {
    captureInstance.startMonitorInstance(windowId, config.TARGET_FPS);
    isCapturing = true;
    console.log(
      `[CaptureCore] Started monitoring window: ${windowId} at ${config.TARGET_FPS} FPS.`,
    );
  } catch (err) {
    console.error(
      '[CaptureCore] Failed to start native capture instance:',
      err,
    );
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  Atomics.store(syncArray, config.IS_RUNNING_INDEX, 1);

  while (Atomics.load(syncArray, config.IS_RUNNING_INDEX) === 1) {
    const loopStartTime = performance.now();

    try {
      const frameResult = captureInstance.getLatestFrame(imageBuffer);

      if (frameResult) {
        const regionsToWrite = frameResult.changedRegions
          ? Math.min(
              frameResult.changedRegions.length,
              config.MAX_DIRTY_REGIONS,
            )
          : 0;

        Atomics.store(
          syncArray,
          config.DIRTY_REGION_COUNT_INDEX,
          regionsToWrite,
        );

        if (frameResult.changedRegions) {
          for (let i = 0; i < regionsToWrite; i++) {
            const rect = frameResult.changedRegions[i];
            const offset = config.DIRTY_REGIONS_START_INDEX + i * 4;
            Atomics.store(syncArray, offset + 0, rect.x);
            Atomics.store(syncArray, offset + 1, rect.y);
            Atomics.store(syncArray, offset + 2, rect.width);
            Atomics.store(syncArray, offset + 3, rect.height);
          }
        }

        Atomics.store(syncArray, config.WIDTH_INDEX, frameResult.width);
        Atomics.store(syncArray, config.HEIGHT_INDEX, frameResult.height);

        const newFrameCounter = Atomics.add(
          syncArray,
          config.FRAME_COUNTER_INDEX,
          1,
        );
        Atomics.notify(syncArray, config.FRAME_COUNTER_INDEX);

        // NEW: Broadcast the dirty rects to the main thread for distribution
        if (
          frameResult.changedRegions &&
          frameResult.changedRegions.length > 0
        ) {
          parentPort.postMessage({
            type: 'frame-update',
            payload: {
              frameCounter: newFrameCounter,
              dirtyRects: frameResult.changedRegions,
            },
          });
        }

        const loopDuration = performance.now() - loopStartTime;
        perfTracker.addFrameMeasurement(loopDuration, regionsToWrite);
      }
    } catch (err) {
      console.error('[CaptureCore] Error in capture loop, stopping:', err);
      Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, config.IS_RUNNING_INDEX);
      break;
    }

    const loopDuration = performance.now() - loopStartTime;
    const delayTime = Math.max(0, 1000 / config.TARGET_FPS - loopDuration);
    await delay(delayTime);

    logPerformanceReport();
  }

  if (isCapturing) {
    captureInstance.stopMonitorInstance();
    isCapturing = false;
    console.log('[CaptureCore] Stopped capture instance.');
  }
}

function handleMessage(message) {
  if (message.command === 'stop') {
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
  }
}

export async function start() {
  console.log('[CaptureCore] Worker starting up...');
  parentPort.on('message', handleMessage);
  await captureLoop();
  console.log(
    '[CaptureCore] Worker has finished its capture loop and is shutting down.',
  );
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report capture performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  /**
   * Resets all statistics to their initial state.
   */
  reset() {
    this.frameTimes = [];
    this.totalFrameTime = 0;
    this.minFrameTime = Infinity;
    this.maxFrameTime = 0;

    this.dirtyRegionCounts = [];
    this.totalDirtyRegions = 0;
    this.minDirtyRegions = Infinity;
    this.maxDirtyRegions = 0;
  }

  /**
   * Adds a new frame measurement to the tracker.
   * @param {number} duration - The time in milliseconds for the frame capture loop.
   * @param {number} regionCount - The number of dirty regions in the frame.
   */
  addFrameMeasurement(duration, regionCount) {
    // Frame time stats
    this.frameTimes.push(duration);
    this.totalFrameTime += duration;
    if (duration < this.minFrameTime) this.minFrameTime = duration;
    if (duration > this.maxFrameTime) this.maxFrameTime = duration;

    // Dirty region stats
    this.dirtyRegionCounts.push(regionCount);
    this.totalDirtyRegions += regionCount;
    if (regionCount < this.minDirtyRegions) this.minDirtyRegions = regionCount;
    if (regionCount > this.maxDirtyRegions) this.maxDirtyRegions = regionCount;
  }

  /**
   * Generates a formatted string of the current performance statistics.
   * @returns {string|null} A report string or null if no data is available.
   */
  getReport() {
    const frameCount = this.frameTimes.length;
    if (frameCount === 0) {
      return '[CapturePerformance] No frames captured in the last period.';
    }

    const avgFrameTime = this.totalFrameTime / frameCount;
    const avgDirtyRegions = this.totalDirtyRegions / frameCount;

    const frameReport = `Frames: ${frameCount} | Avg Time: ${avgFrameTime.toFixed(2)}ms | Min: ${this.minFrameTime.toFixed(2)}ms | Max: ${this.maxFrameTime.toFixed(2)}ms`;
    const regionReport = `Dirty Regions: Avg: ${avgDirtyRegions.toFixed(1)} | Min: ${this.minDirtyRegions} | Max: ${this.maxDirtyRegions}`;

    return `[CapturePerformance] ${frameReport} | ${regionReport}`;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/captureWorker.js
//start file
/**
 * @file captureWorker.js
 * @summary A dedicated worker for capturing screen frames from a specific window.
 * @description This file is the entry point for the capture worker. It delegates
 * all logic to the modules in the /capture sub-directory for maintainability.
 */

import { workerData } from 'worker_threads';
import { start } from './capture/core.js';
import { IS_RUNNING_INDEX } from './capture/config.js';

start().catch((err) => {
  console.error(
    '[CaptureWorker] A fatal, unhandled error occurred during startup:',
    err,
  );

  // Attempt to notify other workers that we are not running.
  // This is a "best effort" signal in case of a catastrophic startup failure.
  try {
    // workerData is available synchronously at the top level of a worker module.
    const { sharedData } = workerData;
    if (sharedData?.syncSAB) {
      const syncArray = new Int32Array(sharedData.syncSAB);
      Atomics.store(syncArray, IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, IS_RUNNING_INDEX);
      console.log(
        '[CaptureWorker] Successfully signaled shutdown to other workers.',
      );
    } else {
      console.error(
        '[CaptureWorker] Could not signal shutdown: sharedData or syncSAB not available.',
      );
    }
  } catch (e) {
    console.error(
      '[CaptureWorker] An error occurred while trying to signal shutdown:',
      e,
    );
  }

  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/actionHandlers.js
//start file
// /workers/cavebot/actionHandlers.js

import keypress from 'keypress-native';
import mouseController from 'mouse-controller';
// ====================== MODIFICATION START ======================
// Corrected paths to go up two directories to the electron root
import useItemOnCoordinates from '../../mouseControll/useItemOnCoordinates.js';
import getDirectionKey from '../../utils/getDirectionKey.js';
import { getDistance } from '../../utils/distance.js';
// ======================= MODIFICATION END =======================
import { getAbsoluteClickCoordinatesForAction } from './helpers/actionUtils.js';
import {
  delay,
  awaitWalkConfirmation,
  awaitZLevelChange,
  awaitStandConfirmation,
} from './helpers/asyncUtils.js';
import { advanceToNextWaypoint } from './helpers/navigation.js';

async function performWalk(
  workerState,
  config,
  targetPos,
  timeout,
  isDiagonal,
) {
  const posCounterBeforeMove = workerState.lastPlayerPosCounter;
  const pathCounterBeforeMove = workerState.lastPathDataCounter;
  const dirKey = getDirectionKey(workerState.playerMinimapPosition, targetPos);
  if (!dirKey) return;

  keypress.sendKey(dirKey, workerState.globalState.global.display);
  await awaitWalkConfirmation(
    workerState,
    config,
    posCounterBeforeMove,
    pathCounterBeforeMove,
    timeout,
  );
  if (isDiagonal) {
    await delay(config.postDiagonalMoveDelayMs);
  }
}

export async function handleWalkAction(workerState, config) {
  if (!workerState.path || workerState.path.length < 2) return;

  const nextStep = workerState.path[1];

  const dirKey = getDirectionKey(workerState.playerMinimapPosition, nextStep);
  if (!dirKey) return;

  const isDiagonal = ['q', 'e', 'z', 'c'].includes(dirKey);
  const timeout = isDiagonal
    ? config.moveConfirmTimeoutDiagonalMs
    : config.moveConfirmTimeoutMs;

  await performWalk(workerState, config, nextStep, timeout, isDiagonal);
}

export async function handleStandAction(workerState, config, targetWaypoint) {
  const initialPos = { ...workerState.playerMinimapPosition };
  const dirKey = getDirectionKey(initialPos, targetWaypoint);
  if (!dirKey) return false;

  keypress.sendKey(dirKey, workerState.globalState.global.display);

  try {
    const { finalPos } = await awaitStandConfirmation(
      workerState,
      config,
      initialPos,
      config.defaultAwaitStateChangeTimeoutMs,
    );

    if (finalPos.z !== initialPos.z) {
      workerState.floorChangeGraceUntil =
        Date.now() + config.floorChangeGraceMs;
    }
    if (getDistance(initialPos, finalPos) >= config.teleportDistanceThreshold) {
      // Grace is handled by the caller, this just confirms success
    }
    return true;
  } catch (error) {
    workerState.logger(
      'warn',
      `[handleStandAction] Await confirmation failed: ${error.message}`,
    );
    return false;
  }
}

async function handleToolAction(
  workerState,
  config,
  targetCoords,
  hotkey,
  useType,
  clickOffset,
) {
  const { logger, globalState } = workerState;
  const initialPos = { ...workerState.playerMinimapPosition };
  if (!initialPos) return false;

  // Use the standardized animation delay for these tools
  if (useType === 'shovel' || useType === 'rope') {
    await delay(config.animationArrivalTimeoutMs);
  }

  const clickCoords = getAbsoluteClickCoordinatesForAction(
    globalState,
    targetCoords,
    initialPos,
    clickOffset,
  );

  if (!clickCoords) {
    logger(
      'error',
      `[handleToolAction:${useType}] Could not calculate click coordinates.`,
    );
    return false;
  }

  const windowId = parseInt(globalState.global.windowId, 10);
  const display = globalState.global.display || ':0';

  if (useType === 'ladder') {
    mouseController.leftClick(windowId, clickCoords.x, clickCoords.y, display);
  } else if (useType === 'rope') {
    keypress.sendKey(hotkey, display);
    await delay(50); // Small delay between hotkey and click
    mouseController.leftClick(windowId, clickCoords.x, clickCoords.y, display);
  } else if (useType === 'shovel') {
    useItemOnCoordinates(
      windowId,
      display,
      clickCoords.x,
      clickCoords.y,
      hotkey,
    );
  }

  const zChanged = await awaitZLevelChange(
    workerState,
    config,
    initialPos.z,
    config.defaultAwaitStateChangeTimeoutMs,
  );

  if (zChanged) {
    workerState.floorChangeGraceUntil = Date.now() + config.floorChangeGraceMs;
    return true;
  }
  return false;
}

export const handleLadderAction = (workerState, config, targetCoords) =>
  handleToolAction(
    workerState,
    config,
    targetCoords,
    null,
    'ladder',
    'bottomRight',
  );
export const handleRopeAction = (workerState, config, targetCoords) =>
  handleToolAction(
    workerState,
    config,
    targetCoords,
    config.toolHotkeys.rope,
    'rope',
    'bottomRight',
  );
export const handleShovelAction = (workerState, config, targetCoords) =>
  handleToolAction(
    workerState,
    config,
    targetCoords,
    config.toolHotkeys.shovel,
    'shovel',
    'center',
  );

export async function handleMacheteAction(workerState, config, targetWaypoint) {
  const { logger, globalState } = workerState;
  const hotkey = config.toolHotkeys.machete;
  if (!hotkey) {
    logger('error', '[handleMacheteAction] Machete hotkey not configured.');
    return false;
  }

  const initialPos = { ...workerState.playerMinimapPosition };
  const clickCoords = getAbsoluteClickCoordinatesForAction(
    globalState,
    targetWaypoint,
    initialPos,
    'center',
  );
  if (!clickCoords) {
    logger(
      'error',
      '[handleMacheteAction] Could not calculate click coordinates.',
    );
    return false;
  }

  const windowId = parseInt(globalState.global.windowId, 10);
  const display = globalState.global.display || ':0';

  for (let i = 0; i < config.maxMacheteRetries; i++) {
    try {
      // First, try to just walk
      await performWalk(
        workerState,
        config,
        targetWaypoint,
        config.moveConfirmTimeoutMs,
        false,
      );
      return true; // Walk succeeded, no need for machete
    } catch (error) {
      logger(
        'debug',
        `[handleMacheteAction] Walk failed (attempt ${
          i + 1
        }), trying to use machete.`,
      );
    }

    // Walk failed, use tool
    useItemOnCoordinates(
      windowId,
      display,
      clickCoords.x,
      clickCoords.y,
      hotkey,
    );
    await delay(config.actionFailureRetryDelayMs);

    try {
      // Try to walk again after using the tool
      await performWalk(
        workerState,
        config,
        targetWaypoint,
        config.moveConfirmTimeoutMs,
        false,
      );
      return true; // Success after using tool
    } catch (error) {
      logger(
        'debug',
        `[handleMacheteAction] Walk after machete also failed (attempt ${
          i + 1
        }).`,
      );
    }
  }

  logger(
    'warn',
    `[handleMacheteAction] Failed to clear path after ${config.maxMacheteRetries} attempts.`,
  );
  return false;
}

export async function handleDoorAction(workerState, config, targetWaypoint) {
  const { logger, globalState } = workerState;

  // First, try to just walk in case door is already open
  try {
    await performWalk(
      workerState,
      config,
      targetWaypoint,
      config.moveConfirmTimeoutMs,
      false,
    );
    return true;
  } catch (error) {
    logger(
      'debug',
      '[handleDoorAction] Walk failed, attempting to click door.',
    );
  }

  // Walk failed, so try clicking the door
  const initialPos = { ...workerState.playerMinimapPosition };
  const clickCoords = getAbsoluteClickCoordinatesForAction(
    globalState,
    targetWaypoint,
    initialPos,
    'center',
  );
  if (!clickCoords) {
    logger(
      'error',
      '[handleDoorAction] Could not calculate click coordinates.',
    );
    return false;
  }

  const posCounterBeforeMove = workerState.lastPlayerPosCounter;
  const pathCounterBeforeMove = workerState.lastPathDataCounter;

  mouseController.leftClick(
    parseInt(globalState.global.windowId, 10),
    clickCoords.x,
    clickCoords.y,
    globalState.global.display || ':0',
  );

  try {
    await awaitWalkConfirmation(
      workerState,
      config,
      posCounterBeforeMove,
      pathCounterBeforeMove,
      config.actionStateChangeTimeoutMs,
    );
    return true;
  } catch (e) {
    logger('warn', '[handleDoorAction] Failed to confirm move after clicking.');
    return false;
  }
}

export async function handleScriptAction(workerState, config, targetWpt) {
  const { luaExecutor, logger } = workerState;
  if (!luaExecutor || !luaExecutor.isInitialized) {
    await delay(config.controlHandoverGraceMs);
    return;
  }

  if (workerState.scriptErrorWaypointId !== targetWpt.id) {
    workerState.scriptErrorWaypointId = targetWpt.id;
    workerState.scriptErrorCount = 0;
  }

  const result = await luaExecutor.executeScript(targetWpt.script);

  if (result.success) {
    workerState.scriptErrorCount = 0;
    if (!result.navigationOccurred) {
      await advanceToNextWaypoint(workerState, config);
    }
  } else {
    workerState.scriptErrorCount++;
    logger(
      'warn',
      `[Cavebot] Script at waypoint ${targetWpt.id} failed. Attempt ${workerState.scriptErrorCount}/${config.maxScriptRetries}.`,
    );

    if (workerState.scriptErrorCount >= config.maxScriptRetries) {
      const attemptText =
        config.maxScriptRetries === 1
          ? '1 time'
          : `${config.maxScriptRetries} times`;
      logger(
        'error',
        `[Cavebot] Script at waypoint ${targetWpt.id} failed ${attemptText}. Skipping to next waypoint.`,
      );
      await advanceToNextWaypoint(workerState, config);
    } else {
      await delay(config.scriptErrorDelayMs);
    }
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/config.js
//start file
// /workers/cavebot/config.js

/**
 * Centralized configuration for the Cavebot Worker.
 * All time-based values are in milliseconds (Ms).
 */
export const config = {
  // --- Core Loop & Timing ---
  mainLoopIntervalMs: 25,
  stateChangePollIntervalMs: 25,
  mainLoopErrorDelayMs: 1000, // Delay after a critical error in the main loop

  // --- Action & Movement Timing ---
  animationArrivalTimeoutMs: 400, // Used for shovel/rope to let animation settle
  actionStateChangeTimeoutMs: 200,
  postDiagonalMoveDelayMs: 150,
  postTeleportGraceMs: 1250,
  moveConfirmTimeoutMs: 400,
  moveConfirmTimeoutDiagonalMs: 750,
  defaultAwaitStateChangeTimeoutMs: 500,
  floorChangeGraceMs: 500,
  controlHandoverGraceMs: 100,

  // --- Retries & Delays ---
  maxScriptRetries: 1,
  maxMacheteRetries: 3, // Centralized from hardcoded value
  maxSABReadRetries: 3, // Centralized from hardcoded value
  actionFailureRetryDelayMs: 250, // Renamed from macheteRetryDelay
  scriptErrorDelayMs: 250,

  // --- Gameplay Parameters ---
  teleportDistanceThreshold: 5,
  toolHotkeys: {
    rope: 'b',
    machete: 'n',
    shovel: 'v',
  },
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/fsm.js
//start file
// /workers/cavebot/fsm.js

import { postStoreUpdate } from './helpers/communication.js';
import { advanceToNextWaypoint } from './helpers/navigation.js';
import { delay } from './helpers/asyncUtils.js';
import { getDistance } from '../../utils/distance.js';
import {
  handleWalkAction,
  handleStandAction,
  handleLadderAction,
  handleRopeAction,
  handleShovelAction,
  handleMacheteAction,
  handleDoorAction,
  handleScriptAction,
} from './actionHandlers.js';
import {
  PATH_STATUS_PATH_FOUND,
  PATH_STATUS_WAYPOINT_REACHED,
  PATH_STATUS_NO_PATH_FOUND,
  PATH_STATUS_DIFFERENT_FLOOR,
  PATH_STATUS_ERROR,
  PATH_STATUS_NO_VALID_START_OR_END,
  PATH_STATUS_IDLE,
} from '../sharedConstants.js';

export function createFsm(workerState, config) {
  const logger = workerState.logger;
  return {
    IDLE: {
      enter: () => postStoreUpdate('cavebot/setActionPaused', true),
      execute: (context) =>
        context.targetWaypoint ? 'EVALUATING_WAYPOINT' : 'IDLE',
    },
    EVALUATING_WAYPOINT: {
      execute: async (context) => {
        const { playerPos, targetWaypoint, status, chebyshevDist } = context;

        switch (targetWaypoint.type) {
          case 'Script':
            return 'EXECUTING_SCRIPT';
          case 'Stand':
          case 'Ladder':
          case 'Rope':
          case 'Shovel':
          case 'Machete':
          case 'Door':
            if (typeof chebyshevDist === 'number' && chebyshevDist <= 1) {
              if (
                playerPos.x === targetWaypoint.x &&
                playerPos.y === targetWaypoint.y
              ) {
                logger(
                  'info',
                  `[Cavebot] Player is on action waypoint ${targetWaypoint.type}. Performing action.`,
                );
              }
              return 'PERFORMING_ACTION';
            }
            break;
          case 'Node':
          case 'Walk':
            if (
              playerPos.x === targetWaypoint.x &&
              playerPos.y === targetWaypoint.y &&
              playerPos.z === targetWaypoint.z
            ) {
              await advanceToNextWaypoint(workerState, config);
              return 'IDLE';
            }
            break;
        }

        if (status === PATH_STATUS_WAYPOINT_REACHED) {
          logger('debug', '[FSM] Waypoint reached per pathfinder. Advancing.');
          await advanceToNextWaypoint(workerState, config);
          return 'IDLE';
        }

        switch (status) {
          case PATH_STATUS_PATH_FOUND:
            if (workerState.path.length > 1) {
              // Path has player position and at least one step, it's walkable.
              return 'WALKING';
            }
            // Path is empty or only contains the player's position, re-evaluate.
            return 'EVALUATING_WAYPOINT';
          case PATH_STATUS_NO_PATH_FOUND:
          case PATH_STATUS_NO_VALID_START_OR_END:
          case PATH_STATUS_ERROR:
          case PATH_STATUS_DIFFERENT_FLOOR:
            logger(
              'warn',
              `[FSM] Unreachable waypoint due to path status: ${status}. Skipping.`,
            );
            await advanceToNextWaypoint(workerState, config);
            return 'IDLE';
          case PATH_STATUS_IDLE:
          default:
            return 'EVALUATING_WAYPOINT'; // Waiting for pathfinder
        }
      },
    },
    WALKING: {
      enter: () => postStoreUpdate('cavebot/setActionPaused', false),
      execute: async () => {
        try {
          await handleWalkAction(workerState, config);
        } catch (error) {
          logger(
            'warn',
            `[FSM] Walk action failed: ${error.message}. Re-evaluating.`,
          );
        }
        return 'EVALUATING_WAYPOINT';
      },
    },
    PERFORMING_ACTION: {
      enter: () => postStoreUpdate('cavebot/setActionPaused', true),
      execute: async (context) => {
        const { targetWaypoint } = context;
        let actionSucceeded = false;
        const targetCoords = {
          x: targetWaypoint.x,
          y: targetWaypoint.y,
          z: targetWaypoint.z,
        };
        switch (targetWaypoint.type) {
          case 'Stand':
            actionSucceeded = await handleStandAction(
              workerState,
              config,
              targetWaypoint,
            );
            break;
          case 'Ladder':
            actionSucceeded = await handleLadderAction(
              workerState,
              config,
              targetCoords,
            );
            break;
          case 'Rope':
            actionSucceeded = await handleRopeAction(
              workerState,
              config,
              targetCoords,
            );
            break;
          case 'Shovel':
            actionSucceeded = await handleShovelAction(
              workerState,
              config,
              targetCoords,
            );
            break;
          case 'Machete':
            actionSucceeded = await handleMacheteAction(
              workerState,
              config,
              targetWaypoint,
            );
            break;
          case 'Door':
            actionSucceeded = await handleDoorAction(
              workerState,
              config,
              targetWaypoint,
            );
            break;
        }

        if (actionSucceeded) {
          if (
            getDistance(workerState.playerMinimapPosition, targetWaypoint) >=
            config.teleportDistanceThreshold
          ) {
            // After a teleport-like action, give grace
            workerState.floorChangeGraceUntil =
              Date.now() + config.postTeleportGraceMs;
          }
          await advanceToNextWaypoint(workerState, config);
          return 'IDLE';
        } else {
          logger(
            'warn',
            `[FSM] Action '${targetWaypoint.type}' failed. Retrying after delay.`,
          );
          await delay(config.actionFailureRetryDelayMs);
          return 'EVALUATING_WAYPOINT';
        }
      },
    },
    EXECUTING_SCRIPT: {
      enter: () => postStoreUpdate('cavebot/setActionPaused', true),
      execute: async (context) => {
        await handleScriptAction(workerState, config, context.targetWaypoint);
        return 'EVALUATING_WAYPOINT';
      },
    },
  };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/actionUtils.js
//start file
// /workers/cavebot/helpers/actionUtils.js

// ====================== MODIFICATION START ======================
// Corrected path to go up three directories to the electron root
import { getAbsoluteGameWorldClickCoordinates } from '../../../utils/gameWorldClickTranslator.js';
// ======================= MODIFICATION END =======================

/**
 * A centralized helper to calculate absolute on-screen click coordinates for an action.
 * @param {object} globalState - The full global state object.
 * @param {object} targetCoords - The {x, y, z} of the target waypoint.
 * @param {object} playerPos - The player's current {x, y, z} position.
 * @param {string} clickOffset - The offset within the tile to click ('center', 'bottomRight', etc).
 * @returns {object|null} The {x, y} screen coordinates or null on failure.
 */
export function getAbsoluteClickCoordinatesForAction(
  globalState,
  targetCoords,
  playerPos,
  clickOffset,
) {
  const { gameWorld, tileSize } = globalState.regionCoordinates.regions;
  if (!gameWorld || !tileSize) {
    console.error(
      '[getAbsoluteClickCoordinatesForAction] Missing region coordinates for click.',
    );
    return null;
  }

  return getAbsoluteGameWorldClickCoordinates(
    targetCoords.x,
    targetCoords.y,
    playerPos,
    gameWorld,
    tileSize,
    clickOffset,
  );
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/asyncUtils.js
//start file
// /workers/cavebot/helpers/asyncUtils.js

import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
} from '../../sharedConstants.js';
// ====================== MODIFICATION START ======================
// Corrected path to go up three directories to the electron root
import { getDistance } from '../../../utils/distance.js';
// ======================= MODIFICATION END =======================

export const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

export const awaitStateChange = (
  getState,
  condition,
  timeoutMs,
  pollIntervalMs,
) => {
  return new Promise((resolve) => {
    let intervalId = null;
    const timeoutId = setTimeout(() => {
      if (intervalId) clearInterval(intervalId);
      resolve(false);
    }, timeoutMs);

    intervalId = setInterval(() => {
      const globalState = getState();
      if (globalState && condition(globalState)) {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        resolve(true);
      }
    }, pollIntervalMs);
  });
};

export const awaitWalkConfirmation = (
  workerState,
  config,
  posCounterBeforeMove,
  pathCounterBeforeMove,
  timeoutMs,
) => {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      clearInterval(intervalId);
      reject(new Error(`awaitWalkConfirmation timed out after ${timeoutMs}ms`));
    }, timeoutMs);

    const intervalId = setInterval(() => {
      const posChanged =
        workerState.playerPosArray &&
        Atomics.load(
          workerState.playerPosArray,
          PLAYER_POS_UPDATE_COUNTER_INDEX,
        ) > posCounterBeforeMove;

      const pathChanged =
        workerState.pathDataArray &&
        Atomics.load(workerState.pathDataArray, PATH_UPDATE_COUNTER_INDEX) >
          pathCounterBeforeMove;

      if (posChanged || pathChanged) {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        resolve(true);
      }
    }, config.stateChangePollIntervalMs);
  });
};

export const awaitZLevelChange = (workerState, config, initialZ, timeoutMs) => {
  return new Promise((resolve) => {
    const startTime = Date.now();
    const intervalId = setInterval(() => {
      const currentZ = Atomics.load(workerState.playerPosArray, PLAYER_Z_INDEX);
      if (currentZ !== initialZ) {
        clearInterval(intervalId);
        resolve(true);
      }
      if (Date.now() - startTime > timeoutMs) {
        clearInterval(intervalId);
        resolve(false);
      }
    }, config.stateChangePollIntervalMs);
  });
};

export const awaitStandConfirmation = (
  workerState,
  config,
  initialPos,
  timeoutMs,
) => {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    const intervalId = setInterval(() => {
      const finalPos = {
        x: Atomics.load(workerState.playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(workerState.playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(workerState.playerPosArray, PLAYER_Z_INDEX),
      };

      const zChanged = finalPos.z !== initialPos.z;
      const teleported =
        getDistance(initialPos, finalPos) >= config.teleportDistanceThreshold;

      if (zChanged || teleported) {
        clearInterval(intervalId);
        // A small delay to ensure state propagates
        setTimeout(() => resolve({ success: true, finalPos }), 10);
      }

      if (Date.now() - startTime > timeoutMs) {
        clearInterval(intervalId);
        reject(
          new Error(`awaitStandConfirmation timed out after ${timeoutMs}ms`),
        );
      }
    }, config.stateChangePollIntervalMs);
  });
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/communication.js
//start file
// /workers/cavebot/helpers/communication.js

import { parentPort } from 'worker_threads';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_WAYPOINTS_START_INDEX,
  PATH_WAYPOINT_SIZE,
  PATH_CHEBYSHEV_DISTANCE_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
  MAX_PATH_WAYPOINTS,
} from '../../sharedConstants.js';

export const postStoreUpdate = (type, payload) =>
  parentPort.postMessage({ storeUpdate: true, type, payload });

export const postGlobalVarUpdate = (key, value) => {
  parentPort.postMessage({
    type: 'lua_global_update',
    payload: { key, value },
  });
};

export const getFreshState = () =>
  new Promise((res) => {
    const onSnap = (msg) => {
      if (msg.type === 'state_snapshot') {
        parentPort.off('message', onSnap);
        res(msg.payload);
      }
    };
    parentPort.on('message', onSnap);
    parentPort.postMessage({ type: 'request_state_snapshot' });
  });

export const updateSABData = (workerState, config) => {
  if (workerState.playerPosArray) {
    const newPlayerPosCounter = Atomics.load(
      workerState.playerPosArray,
      PLAYER_POS_UPDATE_COUNTER_INDEX,
    );
    if (newPlayerPosCounter > workerState.lastPlayerPosCounter) {
      workerState.playerMinimapPosition = {
        x: Atomics.load(workerState.playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(workerState.playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(workerState.playerPosArray, PLAYER_Z_INDEX),
      };
      workerState.lastPlayerPosCounter = newPlayerPosCounter;
    }
  }

  if (workerState.pathDataArray) {
    if (workerState.shouldRequestNewPath) {
      workerState.path = [];
      workerState.pathfindingStatus = PATH_STATUS_IDLE;
      workerState.lastPathDataCounter = -1;
      workerState.shouldRequestNewPath = false;
      return;
    }

    let consistentRead = false;
    let attempts = 0;
    do {
      const counterBeforeRead = Atomics.load(
        workerState.pathDataArray,
        PATH_UPDATE_COUNTER_INDEX,
      );
      if (counterBeforeRead === workerState.lastPathDataCounter) return;

      const tempPathfindingStatus = Atomics.load(
        workerState.pathDataArray,
        PATHFINDING_STATUS_INDEX,
      );
      const tempPathChebyshevDistance = Atomics.load(
        workerState.pathDataArray,
        PATH_CHEBYSHEV_DISTANCE_INDEX,
      );
      const pathLength = Atomics.load(
        workerState.pathDataArray,
        PATH_LENGTH_INDEX,
      );
      const tempPath = [];
      const safePathLength = Math.min(pathLength, MAX_PATH_WAYPOINTS);
      for (let i = 0; i < safePathLength; i++) {
        const offset = PATH_WAYPOINTS_START_INDEX + i * PATH_WAYPOINT_SIZE;
        tempPath.push({
          x: Atomics.load(workerState.pathDataArray, offset + 0),
          y: Atomics.load(workerState.pathDataArray, offset + 1),
          z: Atomics.load(workerState.pathDataArray, offset + 2),
        });
      }

      const counterAfterRead = Atomics.load(
        workerState.pathDataArray,
        PATH_UPDATE_COUNTER_INDEX,
      );

      if (counterBeforeRead === counterAfterRead) {
        consistentRead = true;
        if (tempPath.length > 0) {
          const pathStart = tempPath[0];
          if (
            !workerState.playerMinimapPosition ||
            pathStart.x !== workerState.playerMinimapPosition.x ||
            pathStart.y !== workerState.playerMinimapPosition.y ||
            pathStart.z !== workerState.playerMinimapPosition.z
          ) {
            workerState.path = []; // Invalidate path
          } else {
            workerState.path = tempPath;
          }
        } else {
          workerState.path = tempPath;
        }
        workerState.pathfindingStatus = tempPathfindingStatus;
        workerState.pathChebyshevDistance = tempPathChebyshevDistance;
        workerState.lastPathDataCounter = counterAfterRead;
      } else {
        attempts++;
      }
    } while (!consistentRead && attempts < config.maxSABReadRetries);
  }
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/navigation.js
//start file
// /workers/cavebot/helpers/navigation.js

import { postStoreUpdate } from './communication.js';
import { awaitStateChange } from './asyncUtils.js';
import { PATH_STATUS_IDLE } from '../../sharedConstants.js';

/**
 * Finds the current waypoint object from the global state.
 * This function is now a pure "getter" and does not modify state.
 * @param {object} globalState - The full global state object.
 * @returns {object|null} The current waypoint object or null if not found.
 */
export function findCurrentWaypoint(globalState) {
  if (!globalState?.cavebot) return null;
  const { waypointSections, currentSection, wptId } = globalState.cavebot;
  return waypointSections[currentSection]?.waypoints.find(
    (wp) => wp.id === wptId,
  );
}

/**
 * Finds the first valid waypoint in the script, used as a fallback.
 * @param {object} globalState - The full global state object.
 * @returns {object|null} The first valid waypoint or null.
 */
export function findFirstValidWaypoint(globalState) {
  if (!globalState?.cavebot) return null;
  const { waypointSections } = globalState.cavebot;
  const firstSectionWithWaypoints = Object.keys(waypointSections).find(
    (id) => waypointSections[id]?.waypoints?.length > 0,
  );
  if (firstSectionWithWaypoints) {
    const firstWaypoint =
      waypointSections[firstSectionWithWaypoints].waypoints[0];
    if (firstWaypoint) {
      return {
        waypoint: firstWaypoint,
        sectionId: firstSectionWithWaypoints,
      };
    }
  }
  return null;
}

export async function advanceToNextWaypoint(workerState, config) {
  workerState.scriptErrorWaypointId = null;
  workerState.scriptErrorCount = 0;

  const globalState = workerState.globalState;
  if (!globalState?.cavebot) return false;

  const {
    waypointSections,
    currentSection,
    wptId: oldWptId,
  } = globalState.cavebot;
  const waypoints = waypointSections[currentSection]?.waypoints || [];
  if (waypoints.length === 0) return false;

  const currentIndex = waypoints.findIndex((wp) => wp.id === oldWptId);
  if (currentIndex === -1) return false;

  const nextIndex = (currentIndex + 1) % waypoints.length;
  const nextWpt = waypoints[nextIndex];

  if (nextWpt) {
    postStoreUpdate('cavebot/setwptId', nextWpt.id);
    const confirmed = await awaitStateChange(
      () => workerState.globalState,
      (state) => state?.cavebot?.wptId === nextWpt.id,
      config.defaultAwaitStateChangeTimeoutMs,
      config.stateChangePollIntervalMs,
    );
    if (confirmed) {
      workerState.lastProcessedWptId = nextWpt.id;
    }
    return confirmed;
  }
  return false;
}

export const goToLabel = async (label, globalState) => {
  const { waypointSections, currentSection } = globalState.cavebot;
  const targetWaypoint = waypointSections[currentSection].waypoints.find(
    (wpt) => wpt.label === label,
  );
  if (targetWaypoint) {
    postStoreUpdate('cavebot/setwptId', targetWaypoint.id);
  }
};

export const goToSection = async (sectionName, workerState, config) => {
  const { waypointSections } = workerState.globalState.cavebot;
  const foundEntry = Object.entries(waypointSections).find(
    ([, section]) => section.name === sectionName,
  );
  if (foundEntry) {
    const [targetSectionId, targetSection] = foundEntry;
    if (targetSection.waypoints?.length > 0) {
      const firstWpt = targetSection.waypoints[0];
      postStoreUpdate('cavebot/setCurrentWaypointSection', targetSectionId);
      postStoreUpdate('cavebot/setwptId', firstWpt.id);
    } else {
      await advanceToNextWaypoint(workerState, config);
    }
  } else {
    await advanceToNextWaypoint(workerState, config);
  }
};

export const goToWpt = async (index, globalState) => {
  const userIndex = parseInt(index, 10);
  if (isNaN(userIndex) || userIndex < 1) return;
  const arrayIndex = userIndex - 1;
  const { waypointSections, currentSection } = globalState.cavebot;
  const waypoints = waypointSections[currentSection]?.waypoints || [];
  if (arrayIndex < waypoints.length) {
    postStoreUpdate('cavebot/setwptId', waypoints[arrayIndex].id);
  }
};

export const resetInternalState = (workerState, fsm) => {
  if (workerState.fsmState !== 'IDLE') {
    workerState.fsmState = 'IDLE';
    fsm.IDLE.enter();
  }
  workerState.path = [];
  workerState.pathfindingStatus = PATH_STATUS_IDLE;
  workerState.lastPathDataCounter = -1;
  workerState.lastFsmState = null;
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/objectUtils.js
//start file
const isObject = (item) => {
  return item && typeof item === 'object' && !Array.isArray(item);
};

export const deepMerge = (target, ...sources) => {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} });
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }

  return deepMerge(target, ...sources);
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/index.js
//start file
// /workers/cavebot/index.js

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import { CavebotLuaExecutor } from '../cavebotLuaExecutor.js';
import { createLogger } from '../../utils/logger.js';
import { config } from './config.js'; // Still need config for other values
import { createFsm } from './fsm.js';
import { delay } from './helpers/asyncUtils.js';
import {
  postStoreUpdate,
  postGlobalVarUpdate,
  getFreshState,
  updateSABData,
} from './helpers/communication.js';
import {
  findCurrentWaypoint,
  findFirstValidWaypoint,
  advanceToNextWaypoint,
  resetInternalState,
  goToLabel,
  goToSection,
  goToWpt,
} from './helpers/navigation.js';
import { deepMerge } from './helpers/objectUtils.js';

// --- Worker State Management ---
const workerState = {
  globalState: null,
  isShuttingDown: false,
  isInitialized: false,
  fsmState: 'IDLE',
  lastFsmState: null,
  lastControlState: 'CAVEBOT',
  lastPlayerPosCounter: -1,
  lastPathDataCounter: -1,
  playerMinimapPosition: null,
  path: [],
  pathChebyshevDistance: null,
  pathfindingStatus: 0,
  playerPosArray: null,
  pathDataArray: null,
  luaExecutor: null,
  floorChangeGraceUntil: 0,
  lastProcessedWptId: null,
  shouldRequestNewPath: false,
  scriptErrorWaypointId: null,
  scriptErrorCount: 0,
  logger: createLogger({ info: false, error: true, debug: false }),
};

// --- Initialization ---
const fsm = createFsm(workerState, config);
if (workerData.playerPosSAB) {
  workerState.playerPosArray = new Int32Array(workerData.playerPosSAB);
}
if (workerData.pathDataSAB) {
  workerState.pathDataArray = new Int32Array(workerData.pathDataSAB);
}

// --- Main Loop & Orchestration ---

function handleControlHandover() {
  const { waypointIdAtTargetingStart, visitedTiles } =
    workerState.globalState.cavebot;
  let skippedWaypoint = false;

  if (waypointIdAtTargetingStart && visitedTiles && visitedTiles.length > 0) {
    const currentWaypoint = findCurrentWaypoint(workerState.globalState);
    if (
      currentWaypoint &&
      currentWaypoint.id === waypointIdAtTargetingStart &&
      currentWaypoint.type === 'Node'
    ) {
      // Get nodeRange from Redux store
      const radius = workerState.globalState.cavebot.nodeRange;
      const wasVisited = visitedTiles.some(
        (tile) =>
          tile.z === currentWaypoint.z &&
          Math.max(
            Math.abs(tile.x - currentWaypoint.x),
            Math.abs(tile.y - currentWaypoint.y),
          ) <= radius,
      );

      if (wasVisited) {
        workerState.logger(
          'info',
          `[Cavebot] Node waypoint ${currentWaypoint.id} was visited during targeting. Skipping.`,
        );
        advanceToNextWaypoint(workerState, config);
        skippedWaypoint = true;
      }
    }
  }

  postStoreUpdate('cavebot/clearVisitedTiles');
  if (!skippedWaypoint) {
    workerState.shouldRequestNewPath = true;
  }
}

async function performOperation() {
  const { globalState, isInitialized } = workerState;
  if (!globalState || !isInitialized || !globalState.global?.windowId) {
    return;
  }

  if (!globalState.regionCoordinates?.regions?.onlineMarker) {
    if (
      workerState.fsmState === 'SCRIPT' &&
      workerState.luaExecutor.isExecuting()
    ) {
      const scriptContent = workerState.luaExecutor.getCurrentScriptContent();
      if (scriptContent && !scriptContent.includes('login(')) {
        workerState.logger(
          'warn',
          '[Cavebot] Player is offline. Terminating non-login script.',
        );
        workerState.luaExecutor.forceStop();
        resetInternalState(workerState, fsm);
      }
    } else if (workerState.fsmState !== 'IDLE') {
      workerState.logger('info', '[Cavebot] Player is offline. Resetting cavebot state.');
      resetInternalState(workerState, fsm);
    }
    return;
  }

  if (
    !globalState.regionCoordinates ||
    !globalState.regionCoordinates.regions.gameWorld
  ) {
    if (
      workerState.fsmState === 'SCRIPT' &&
      workerState.luaExecutor.isExecuting()
    ) {
      const scriptContent = workerState.luaExecutor.getCurrentScriptContent();
      if (scriptContent && !scriptContent.includes('login(')) {
        workerState.logger(
          'warn',
          '[Cavebot] Game world not visible. Terminating non-login script.',
        );
        workerState.luaExecutor.forceStop();
        resetInternalState(workerState, fsm);
      }
    }
    return;
  }

  const {
    enabled: cavebotIsEnabled,
    controlState,
    isPausedByScript,
  } = globalState.cavebot;

  if (isPausedByScript) {
    if (workerState.fsmState !== 'IDLE') resetInternalState(workerState, fsm);
    return;
  }

  if (!cavebotIsEnabled) {
    if (workerState.fsmState !== 'IDLE') resetInternalState(workerState, fsm);
    return;
  }

  if (controlState !== 'CAVEBOT') {
    if (workerState.lastControlState === 'CAVEBOT') {
      resetInternalState(workerState, fsm); // Reset state when losing control
    }
    workerState.lastControlState = controlState;
    return;
  }

  if (workerState.lastControlState !== 'CAVEBOT') {
    handleControlHandover();
    await delay(config.controlHandoverGraceMs);
  }

  updateSABData(workerState, config);
  if (!workerState.playerMinimapPosition) return;

  let targetWaypoint = findCurrentWaypoint(globalState);
  if (!targetWaypoint) {
    const fallback = findFirstValidWaypoint(globalState);
    if (fallback) {
      workerState.logger(
        'warn',
        'Current waypoint not found, resetting to first valid waypoint.',
      );
      postStoreUpdate('cavebot/setCurrentWaypointSection', fallback.sectionId);
      postStoreUpdate('cavebot/setwptId', fallback.waypoint.id);
    }
    if (workerState.fsmState !== 'IDLE') resetInternalState(workerState, fsm);
    return;
  }

  if (
    workerState.lastProcessedWptId &&
    targetWaypoint.id !== workerState.lastProcessedWptId
  ) {
    resetInternalState(workerState, fsm);
  }
  workerState.lastProcessedWptId = targetWaypoint.id;

  // --- Z-level Mismatch Logic Change ---
  if (
    targetWaypoint.z !== workerState.playerMinimapPosition.z &&
    targetWaypoint.type !== 'Script' // Scripts are now exempt from this check
  ) {
    workerState.logger(
      'debug',
      `Skipping waypoint ${targetWaypoint.id} due to Z-level mismatch.`,
    );
    await advanceToNextWaypoint(workerState, config);
    return;
  }

  const context = {
    playerPos: workerState.playerMinimapPosition,
    targetWaypoint: targetWaypoint,
    status: workerState.pathfindingStatus,
    chebyshevDist: workerState.pathChebyshevDistance,
  };

  const stateLogic = fsm[workerState.fsmState];
  if (stateLogic) {
    const nextState = await stateLogic.execute(context);
    if (nextState && nextState !== workerState.fsmState) {
      workerState.logger(
        'debug',
        `[FSM] State transition: ${workerState.fsmState} -> ${nextState}`,
      );
      workerState.lastFsmState = workerState.fsmState;
      workerState.fsmState = nextState;
      const newStateLogic = fsm[workerState.fsmState];
      if (newStateLogic && newStateLogic.enter) {
        newStateLogic.enter(context);
      }
    }
  } else {
    workerState.logger(
      'error',
      `Invalid FSM state: ${workerState.fsmState}. Resetting to IDLE.`,
    );
    workerState.fsmState = 'IDLE';
  }

  workerState.lastControlState = globalState.cavebot.controlState;
}

async function mainLoop() {
  workerState.logger('info', '[CavebotWorker] Starting main loop...');
  while (!workerState.isShuttingDown) {
    const loopStart = performance.now();
    try {
      await performOperation();
    } catch (error) {
      workerState.logger(
        'error',
        '[CavebotWorker] Unhandled error in main loop:',
        error,
      );
      workerState.fsmState = 'IDLE';
      // --- Error Resilience Change ---
      await delay(config.mainLoopErrorDelayMs);
    }
    const loopEnd = performance.now();
    const elapsedTime = loopEnd - loopStart;
    const delayTime = Math.max(0, config.mainLoopIntervalMs - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  workerState.logger('info', '[CavebotWorker] Main loop stopped.');
}

// --- Worker Lifecycle ---

async function initializeWorker() {
  workerState.logger('info', 'Cavebot worker starting up...');
  try {
    workerState.luaExecutor = new CavebotLuaExecutor({
      logger: workerState.logger,
      postStoreUpdate,
      getState: () => workerState.globalState,
      getFreshState,
      advanceToNextWaypoint: () => advanceToNextWaypoint(workerState, config),
      goToLabel: (label) => goToLabel(label, workerState.globalState),
      goToSection: (sectionName) =>
        goToSection(sectionName, workerState, config),
      goToWpt: (index) => goToWpt(index, workerState.globalState),
      sharedLuaGlobals: workerData.sharedLuaGlobals,
      postGlobalVarUpdate,
    });
    if (!(await workerState.luaExecutor.initialize()))
      throw new Error('LuaExecutor failed to initialize.');
    workerState.logger(
      'info',
      'Cavebot Lua Executor initialized successfully.',
    );
  } catch (e) {
    workerState.logger(
      'error',
      `Could not initialize Cavebot Lua Executor: ${e.message}`,
    );
    workerState.luaExecutor = null;
  }
  workerState.isInitialized = true;
  workerState.logger('info', 'Cavebot worker initialization complete.');
}

parentPort.on('message', (message) => {
  try {
    if (message.type === 'state_full_sync') {
      workerState.globalState = message.payload;
    } else if (message.type === 'state_diff') {
      if (workerState.globalState && message.payload) {
        deepMerge(workerState.globalState, message.payload);
      }
    } else if (message.type === 'shutdown') {
      workerState.isShuttingDown = true;
      if (workerState.luaExecutor) workerState.luaExecutor.destroy();
    } else if (message.type === 'lua_global_broadcast') {
      const { key, value } = message.payload;
      if (workerData.sharedLuaGlobals) {
        workerData.sharedLuaGlobals[key] = value;
        workerState.logger(
          'debug',
          `[CavebotWorker] Received lua_global_broadcast: ${key} = ${value}`,
        );
      }
    } else if (typeof message === 'object' && !message.type) {
      workerState.globalState = message;
      if (!workerState.isInitialized) {
        initializeWorker().catch((error) => {
          workerState.logger(
            'error',
            '[CavebotWorker] Failed to initialize worker:',
            error,
          );
          process.exit(1);
        });
      }
    }
  } catch (error) {
    workerState.logger(
      'error',
      '[CavebotWorker] Error handling message:',
      error,
    );
  }
});

function startWorker() {
  if (!workerData) throw new Error('[CavebotWorker] Worker data not provided');
  mainLoop().catch((error) => {
    workerState.logger(
      'error',
      '[CavebotWorker] Fatal error in main loop:',
      error,
    );
    process.exit(1);
  });
}

startWorker();

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebotLuaExecutor.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/cavebotLuaExecutor.js

import { LuaFactory } from 'wasmoon';
import { parentPort } from 'worker_threads';
import { performance } from 'perf_hooks';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createLuaApi, createStateShortcutObject } from './luaApi.js';
import { preprocessLuaScript } from './luaScriptProcessor.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class CavebotLuaExecutor {
  constructor(context) {
    this.lua = null;
    this.logger = context.logger;
    this.context = context;
    this.isInitialized = false;
    this.isShuttingDown = false;
    this.executionCount = 0;
    this.totalExecutionTime = 0;
    this.lastPerfReport = Date.now();
    this.asyncFunctionNames = [];
    this.navigationOccurred = false;
    this.consecutiveErrors = 0;
    this.maxConsecutiveErrors = 5000000;
    this.reusableResult = {
      success: false,
      error: null,
      navigationOccurred: false,
    };
    this.logger(
      'info',
      '[CavebotLuaExecutor] Instance created with performance monitoring.',
    );
  }

  // ======================= FIX START: COMPLETE REFACTOR OF INITIALIZATION AND SYNC =======================

  async _loadLuaLibraries() {
    if (!this.lua) return;
    const libPath = path.join(__dirname, 'lua', 'lib');
    try {
      const files = await fs.readdir(libPath);
      for (const file of files) {
        if (path.extname(file) === '.lua') {
          const filePath = path.join(libPath, file);
          const content = await fs.readFile(filePath, 'utf8');
          await this.lua.doString(content);
          this.logger('info', `[CavebotLuaExecutor] Loaded Lua library: ${file}`);
        }
      }
    } catch (error) {
      if (error.code !== 'ENOENT') {
        this.logger('error', `[CavebotLuaExecutor] Error loading Lua libraries:`, error);
      } else {
        this.logger('info', `[CavebotLuaExecutor] No Lua libraries found to load.`);
      }
    }
  }

  async initialize() {
    if (this.isShuttingDown) return false;
    this.logger(
      'info',
      '[CavebotLuaExecutor] Initializing Lua VM and full API...',
    );

    try {
      const initStart = performance.now();
      const factory = new LuaFactory();
      this.lua = await factory.createEngine();
      await this._loadLuaLibraries();

      // Create the full API, including the SharedGlobals proxy, ONCE.
      const { api, asyncFunctionNames: newNames } = await createLuaApi({
        type: 'cavebot',
        ...this.context,
        postSystemMessage: (message) => {
          if (!this.isShuttingDown) parentPort.postMessage(message);
        },
        refreshLuaGlobalState: () => this._syncDynamicStateToLua(), // This now calls the lightweight sync
        sharedLuaGlobals: this.context.sharedLuaGlobals,
        lua: this.lua,
      });

      this.asyncFunctionNames = newNames;

      // Wrap navigation functions to track events
      const wrappedApi = { ...api };
      const navFuncs = ['skipWaypoint', 'goToLabel', 'goToSection', 'goToWpt'];
      navFuncs.forEach((funcName) => {
        if (api[funcName]) {
          wrappedApi[funcName] = (...args) => {
            this.navigationOccurred = true;
            return api[funcName](...args);
          };
        }
      });

      // Set all functions and the SharedGlobals proxy in the Lua environment
      const globals = this.lua.global;
      for (const funcName in wrappedApi) {
        globals.set(funcName, wrappedApi[funcName]);
      }

      // Perform the first sync of dynamic state (__BOT_STATE__)
      await this._syncDynamicStateToLua();

      const initTime = performance.now() - initStart;
      this.logger(
        'info',
        `[CavebotLuaExecutor] Lua VM and API initialized successfully in ${initTime.toFixed(2)}ms.`,
      );

      this.isInitialized = true;
      this.consecutiveErrors = 0;
      return true;
    } catch (error) {
      this.logger(
        'error',
        '[CavebotLuaExecutor] Failed to initialize Lua VM:',
        error,
      );
      this.isInitialized = false;
      return false;
    }
  }

  // This is the new lightweight function that runs before each script execution.
  // It ONLY updates the __BOT_STATE__ object with fresh, per-tick data.
  async _syncDynamicStateToLua() {
    if (!this.lua || this.isShuttingDown) return;

    // Get fresh state from the main thread
    await this.context.getFreshState();

    // Create and set only the dynamic state object
    const stateObject = createStateShortcutObject(
      () => this.context.getState(),
      'cavebot',
    );
    this.lua.global.set('__BOT_STATE__', stateObject);
  }

  // The old _syncApiToLua function is no longer needed and has been replaced by the logic above.

  // ======================= FIX END =======================

  _logPerformanceStats() {
    const now = Date.now();
    const timeSinceLastReport = now - this.lastPerfReport;

    if (timeSinceLastReport >= 30000) {
      const avgExecTime =
        this.executionCount > 0
          ? (this.totalExecutionTime / this.executionCount).toFixed(2)
          : 0;
      const execPerMinute = (
        (this.executionCount / timeSinceLastReport) *
        60000
      ).toFixed(1);

      this.logger(
        'info',
        `[CavebotLuaExecutor] Performance: ${execPerMinute} executions/min, avg: ${avgExecTime}ms, errors: ${this.consecutiveErrors}`,
      );

      this.executionCount = 0;
      this.totalExecutionTime = 0;
      this.lastPerfReport = now;
    }
  }

  _resetResult() {
    this.reusableResult.success = false;
    this.reusableResult.error = null;
    this.reusableResult.navigationOccurred = false;
    return this.reusableResult;
  }

  async executeScript(scriptCode) {
    if (this.isShuttingDown) {
      const result = this._resetResult();
      result.error = 'Executor is shutting down';
      return result;
    }

    if (!this.isInitialized) {
      const result = this._resetResult();
      result.error = 'Lua VM is not initialized';
      return result;
    }

    if (this.consecutiveErrors >= this.maxConsecutiveErrors) {
      this.logger(
        'error',
        `[CavebotLuaExecutor] Circuit breaker triggered: ${this.consecutiveErrors} consecutive errors. Refusing execution.`,
      );
      const result = this._resetResult();
      result.error = 'Too many consecutive errors, execution disabled';
      return result;
    }

    if (!scriptCode?.trim()) {
      const result = this._resetResult();
      result.success = true;
      return result;
    }

    const execStart = performance.now();
    this.logger('debug', '[CavebotLuaExecutor] Executing script...');
    this.navigationOccurred = false;

    try {
      // Now only syncs the dynamic state, not the whole API
      await this._syncDynamicStateToLua();

      let processedCode;
      try {
        processedCode = preprocessLuaScript(
          scriptCode,
          this.asyncFunctionNames,
        );
      } catch (preprocessError) {
        throw new Error(
          `Script preprocessing failed: ${preprocessError.message}`,
        );
      }

      await this.lua.doString(processedCode);

      const execTime = performance.now() - execStart;
      this.executionCount++;
      this.totalExecutionTime += execTime;

      if (execTime > 100) {
        this.logger(
          'warn',
          `[CavebotLuaExecutor] Slow script execution: ${execTime.toFixed(2)}ms`,
        );
      }

      this.consecutiveErrors = 0;
      const result = this._resetResult();
      result.success = true;
      result.navigationOccurred = this.navigationOccurred;
      this._logPerformanceStats();
      return result;
    } catch (error) {
      const execTime = performance.now() - execStart;
      this.executionCount++;
      this.totalExecutionTime += execTime;
      this.consecutiveErrors++;

      const errorMessage = error.message || String(error);
      this.logger(
        'error',
        `[CavebotLuaExecutor] Script execution failed (attempt ${this.consecutiveErrors}): ${errorMessage}`,
      );

      try {
        const currentState = this.context.getState();
        const scriptId = currentState?.cavebot?.wptId;

        if (scriptId) {
          this.context.postStoreUpdate('cavebot/addWaypointLogEntry', {
            id: scriptId,
            message: `[ERROR] ${errorMessage}`,
          });
        }
      } catch (storeError) {
        this.logger(
          'error',
          '[CavebotLuaExecutor] Failed to log error to store:',
          storeError,
        );
      }

      const result = this._resetResult();
      result.error = errorMessage;
      result.navigationOccurred = this.navigationOccurred;
      this._logPerformanceStats();
      return result;
    }
  }

  reset() {
    this.consecutiveErrors = 0;
    this.logger('info', '[CavebotLuaExecutor] Error state reset.');
  }

  getMetrics() {
    return {
      isInitialized: this.isInitialized,
      isShuttingDown: this.isShuttingDown,
      executionCount: this.executionCount,
      avgExecutionTime:
        this.executionCount > 0
          ? this.totalExecutionTime / this.executionCount
          : 0,
      consecutiveErrors: this.consecutiveErrors,
      circuitBreakerTripped:
        this.consecutiveErrors >= this.maxConsecutiveErrors,
    };
  }

  destroy() {
    this.logger('info', '[CavebotLuaExecutor] Starting graceful shutdown...');
    this.isShuttingDown = true;

    if (this.lua) {
      try {
        if (this.executionCount > 0) {
          const avgTime = (
            this.totalExecutionTime / this.executionCount
          ).toFixed(2);
          this.logger(
            'info',
            `[CavebotLuaExecutor] Final stats - Executions: ${this.executionCount}, Avg time: ${avgTime}ms`,
          );
        }

        this.lua.global.close();
        this.lua = null;
        this.isInitialized = false;

        this.logger(
          'info',
          '[CavebotLuaExecutor] Lua VM destroyed successfully.',
        );
      } catch (error) {
        this.logger(
          'error',
          '[CavebotLuaExecutor] Error during cleanup:',
          error,
        );
      }
    }

    this.context = null;
    this.asyncFunctionNames = [];
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/creatureMonitor.js
//start file
import { parentPort, workerData } from 'worker_threads';
import findTarget from 'find-target-native';
import Pathfinder from 'pathfinder-native';
import { calculateDistance } from '../utils/distance.js';
import {
  getGameCoordinatesFromScreen,
  PLAYER_SCREEN_TILE_X,
  PLAYER_SCREEN_TILE_Y,
} from '../utils/gameWorldClickTranslator.js';

let pathfinderInstance = null;
const { sharedData, paths } = workerData;
if (!sharedData) throw new Error('[CreatureMonitor] Shared data not provided.');
const { imageSAB, syncSAB, playerPosSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const sharedBufferView = Buffer.from(imageSAB);

const IS_RUNNING_INDEX = 3;
const PLAYER_X_INDEX = 0;
const PLAYER_Y_INDEX = 1;
const PLAYER_Z_INDEX = 2;

const PLAYER_ANIMATION_FREEZE_MS = 120;
const PLAYER_SETTLING_GRACE_PERIOD_MS = 200;
const STICKY_SNAP_THRESHOLD_TILES = 0.5;
const JITTER_CONFIRMATION_TIME_MS = 75; // Time-based window for jitter detection.

// Increased from 45 to make correlation much more robust against player and creature movement.
const CORRELATION_DISTANCE_THRESHOLD_PIXELS = 125;

// Grace period to prevent target loss from single-frame detection failures.
const TARGET_LOSS_GRACE_PERIOD_MS = 100;

let currentState = null;
let isInitialized = false;
let isShuttingDown = false;
let lastSentCreatures = [];
let lastSentTarget = null;
let lastSpecialAreasJson = '';

let nextInstanceId = 0;
let activeCreatures = new Map(); // Map<instanceId, creatureObject>
let reachableTilesCache = new Map(); // Map<string, boolean>

function getCoordsKey(coords) {
  return `${coords.x},${coords.y},${coords.z}`;
}

// Timestamp for when the target is truly considered lost after disappearing.
let targetLossGracePeriodEndTime = 0;

let previousPlayerMinimapPosition = { x: 0, y: 0, z: 0 };
let playerAnimationFreezeEndTime = 0;
let playerSettlingGracePeriodEndTime = 0;
let lastStablePlayerMinimapPosition = { x: 0, y: 0, z: 0 };

function getHealthTagFromColor(color) {
  if (!color) return 'Full';
  const { r, g, b } = color;
  if (r === 96 && g === 0 && b === 0) return 'Critical';
  if (r === 192 && g === 0 && b === 0) return 'Low';
  if (r === 192 && g === 192 && b === 0) return 'Medium';
  if (r === 96 && g === 192 && b === 96) return 'High';
  if (r === 0 && g === 192 && b === 0) return 'Full';
  return 'Full';
}

function arePositionsEqual(pos1, pos2) {
  if (!pos1 || !pos2) return pos1 === pos2;
  return pos1.x === pos2.x && pos1.y === pos2.y && pos1.z === pos2.z;
}

function areAbsoluteCoordsEqual(coords1, coords2) {
  if (!coords1 || !coords2) return coords1 === coords2;
  return coords1.x === coords2.x && coords1.y === coords2.y;
}

function deepCompareEntities(a, b) {
  if (a === b) return true;
  if (!a || !b) return false;

  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      const entityA = a[i];
      const entityB = b[i];
      if (
        entityA.instanceId !== entityB.instanceId ||
        entityA.name !== entityB.name ||
        entityA.healthTag !== entityB.healthTag ||
        entityA.isReachable !== entityB.isReachable ||
        !arePositionsEqual(entityA.gameCoords, entityB.gameCoords) ||
        !areAbsoluteCoordsEqual(entityA.absoluteCoords, entityB.absoluteCoords)
      ) {
        return false;
      }
    }
    return true;
  }

  if (typeof a === 'object' && typeof b === 'object') {
    return (
      a.instanceId === b.instanceId &&
      a.name === b.name &&
      arePositionsEqual(a.gameCoordinates, b.gameCoordinates) &&
      areAbsoluteCoordsEqual(a.absoluteCoordinates, b.absoluteCoordinates)
    );
  }
  return a === b;
}

function screenDist(p1, p2) {
  if (!p1 || !p2) return Infinity;
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function updateCreatureState(
  creature,
  detection,
  currentPlayerMinimapPosition,
  regions,
  tileSize,
  now,
  isPlayerInAnimationFreeze,
) {
  const { gameWorld } = regions;
  const { r } = detection;
  const creatureName = r.text;
  const creatureScreenX = r.click.x;
  const NAMEPLATE_TEXT_HEIGHT = 10;
  const textHeight = r.height ?? NAMEPLATE_TEXT_HEIGHT;
  const nameplateCenterY = r.y + textHeight / 2 + tileSize.height / 10;
  const creatureScreenY = nameplateCenterY + tileSize.height / 1.4;

  let finalGameX,
    finalGameY,
    finalGameZ = currentPlayerMinimapPosition.z;

  const playerPosForCreatureCalc = isPlayerInAnimationFreeze
    ? lastStablePlayerMinimapPosition
    : currentPlayerMinimapPosition;

  const rawGameCoordsFloat = getGameCoordinatesFromScreen(
    creatureScreenX,
    creatureScreenY,
    playerPosForCreatureCalc,
    gameWorld,
    tileSize,
  );

  if (!rawGameCoordsFloat) return null;

  if (isPlayerInAnimationFreeze && creature.gameCoords) {
    finalGameX = creature.gameCoords.x;
    finalGameY = creature.gameCoords.y;
    finalGameZ = creature.gameCoords.z;
  } else {
    let intermediateX = Math.floor(rawGameCoordsFloat.x);
    let intermediateY = Math.floor(rawGameCoordsFloat.y);
    let finalCoords;

    // Sticky snapping logic to reduce minor drift
    const lastReportedGameCoords = creature.gameCoords;
    if (lastReportedGameCoords) {
      const distX = Math.abs(rawGameCoordsFloat.x - lastReportedGameCoords.x);
      const distY = Math.abs(rawGameCoordsFloat.y - lastReportedGameCoords.y);
      if (
        distX < STICKY_SNAP_THRESHOLD_TILES &&
        distY < STICKY_SNAP_THRESHOLD_TILES
      ) {
        intermediateX = lastReportedGameCoords.x;
        intermediateY = lastReportedGameCoords.y;
      }
    }

    // --- Refactored Jitter Logic ---
    const newCoords = {
      x: intermediateX,
      y: intermediateY,
      z: currentPlayerMinimapPosition.z,
    };

    // Initialize stable coordinates on the creature object if they don't exist.
    if (!creature.stableCoords) {
      creature.stableCoords = newCoords;
    }

    const hasChanged = !arePositionsEqual(newCoords, creature.stableCoords);
    const isUnconfirmed = !!creature.unconfirmedChange;

    if (isUnconfirmed) {
      const unconfirmed = creature.unconfirmedChange;
      // An unconfirmed change is in progress.
      if (arePositionsEqual(newCoords, unconfirmed.newCoords)) {
        // The new detection matches the unconfirmed position.
        // Check if enough time has passed to confirm it.
        if (now - unconfirmed.timestamp > JITTER_CONFIRMATION_TIME_MS) {
          // Time has passed. The move is confirmed.
          creature.stableCoords = unconfirmed.newCoords;
          creature.unconfirmedChange = null;
          finalCoords = creature.stableCoords;
        } else {
          // Not enough time has passed. Keep reporting the last stable position.
          finalCoords = creature.stableCoords;
        }
      } else if (arePositionsEqual(newCoords, creature.stableCoords)) {
        // The position reverted to the last stable one. This was a jitter. Cancel the unconfirmed change.
        creature.unconfirmedChange = null;
        finalCoords = creature.stableCoords;
      } else {
        // A third, different position was detected. Reset the timer with this new position.
        creature.unconfirmedChange = { newCoords: newCoords, timestamp: now };
        finalCoords = creature.stableCoords;
      }
    } else if (hasChanged) {
      // No unconfirmed change, but the detected position is new.
      // Start the confirmation process. Report the last stable position for now.
      creature.unconfirmedChange = { newCoords: newCoords, timestamp: now };
      finalCoords = creature.stableCoords;
    } else {
      // No change and no unconfirmed process. Everything is stable.
      finalCoords = creature.stableCoords;
    }

    finalGameX = finalCoords.x;
    finalGameY = finalCoords.y;
    finalGameZ = finalCoords.z;
  }

  creature.lastCalculatedFloatCoords = {
    x: rawGameCoordsFloat.x,
    y: rawGameCoordsFloat.y,
  };

  const playerFixedScreenCenterX =
    gameWorld.x + (PLAYER_SCREEN_TILE_X + 0.5) * tileSize.width;
  const playerFixedScreenCenterY =
    gameWorld.y + (PLAYER_SCREEN_TILE_Y + 0.5) * tileSize.height;

  const dx_pixels = creatureScreenX - playerFixedScreenCenterX;
  const dy_pixels = creatureScreenY - playerFixedScreenCenterY;
  const dx_tiles = dx_pixels / tileSize.width;
  const dy_tiles = dy_pixels / tileSize.height;
  const distance = Math.sqrt(dx_tiles * dx_tiles + dy_tiles * dy_tiles);

  creature.name = creatureName;
  creature.healthTag = getHealthTagFromColor(r.color);
  creature.absoluteCoords = {
    x: Math.round(creatureScreenX),
    y: Math.round(creatureScreenY),
    lastUpdate: now,
  };
  creature.gameCoords = { x: finalGameX, y: finalGameY, z: finalGameZ };
  creature.distance = parseFloat(distance.toFixed(1));

  return creature;
}

async function performOperation() {
  try {
    if (
      !isInitialized ||
      !currentState?.regionCoordinates?.regions ||
      !currentState?.ocr?.regions ||
      !currentState?.gameState ||
      !pathfinderInstance ||
      !pathfinderInstance.isLoaded
    )
      return;

    const specialAreas = currentState.cavebot?.specialAreas || [];
    const currentSpecialAreasJson = JSON.stringify(specialAreas);
    if (currentSpecialAreasJson !== lastSpecialAreasJson) {
      const areasForNative = specialAreas.map((area) => ({
        x: area.x,
        y: area.y,
        z: area.z,
        avoidance: area.avoidance,
        width: area.sizeX,
        height: area.sizeY,
      }));
      pathfinderInstance.updateSpecialAreas(
        areasForNative,
        currentState.gameState.playerMinimapPosition.z,
      );
      lastSpecialAreasJson = currentSpecialAreasJson;
      reachableTilesCache.clear(); // Invalidate cache when special areas change
    }

    const { regions } = currentState.regionCoordinates;
    const { gameWorld, tileSize } = regions;
    if (
      !gameWorld ||
      !tileSize ||
      typeof gameWorld.x !== 'number' ||
      typeof tileSize.width !== 'number'
    )
      return;

    const currentPlayerMinimapPosition = {
      x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
      y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
      z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
    };

    const now = Date.now();
    const playerPositionChanged = !arePositionsEqual(
      currentPlayerMinimapPosition,
      previousPlayerMinimapPosition,
    );

    if (playerPositionChanged) {
      playerAnimationFreezeEndTime = now + PLAYER_ANIMATION_FREEZE_MS;
      playerSettlingGracePeriodEndTime =
        playerAnimationFreezeEndTime + PLAYER_SETTLING_GRACE_PERIOD_MS;
      lastStablePlayerMinimapPosition = { ...currentPlayerMinimapPosition };
      reachableTilesCache.clear(); // Invalidate cache when player position changes
    }
    previousPlayerMinimapPosition = { ...currentPlayerMinimapPosition };

    const isPlayerInAnimationFreeze = now < playerAnimationFreezeEndTime;
    const ocrData = currentState.ocr.regions.gameWorld || [];

    const preliminaryDetections = ocrData
      .map((r) => ({
        name: r.text,
        absoluteCoords: { x: r.click.x, y: r.click.y },
        r,
      }))
      .filter(Boolean);

    const newActiveCreatures = new Map();
    const matchedDetections = new Set();

    for (const [instanceId, oldCreature] of activeCreatures.entries()) {
      let bestMatch = null;
      let minDistance = CORRELATION_DISTANCE_THRESHOLD_PIXELS;

      for (const newDetection of preliminaryDetections) {
        if (matchedDetections.has(newDetection)) continue;
        if (newDetection.name !== oldCreature.name) continue;

        const distance = screenDist(
          newDetection.absoluteCoords,
          oldCreature.absoluteCoords,
        );
        if (distance < minDistance) {
          minDistance = distance;
          bestMatch = newDetection;
        }
      }

      if (bestMatch) {
        const updatedCreature = updateCreatureState(
          oldCreature,
          bestMatch,
          currentPlayerMinimapPosition,
          regions,
          tileSize,
          now,
          isPlayerInAnimationFreeze,
        );
        if (updatedCreature) {
          newActiveCreatures.set(instanceId, updatedCreature);
        }
        matchedDetections.add(bestMatch);
      }
    }

    for (const newDetection of preliminaryDetections) {
      if (!matchedDetections.has(newDetection)) {
        const newInstanceId = nextInstanceId++;
        let newCreature = { instanceId: newInstanceId }; // Removed reportHistory initialization
        newCreature = updateCreatureState(
          newCreature,
          newDetection,
          currentPlayerMinimapPosition,
          regions,
          tileSize,
          now,
          isPlayerInAnimationFreeze,
        );
        if (newCreature) {
          newActiveCreatures.set(newInstanceId, newCreature);
        }
      }
    }

    activeCreatures = newActiveCreatures;

    let detectedEntities = Array.from(activeCreatures.values()).filter(
      (e) =>
        e.gameCoords.x !== currentPlayerMinimapPosition.x ||
        e.gameCoords.y !== currentPlayerMinimapPosition.y ||
        e.gameCoords.z !== currentPlayerMinimapPosition.z,
    );

    if (detectedEntities.length > 0) {
      // Use the full, up-to-date creature list from the *targeting* slice as obstacles
      const allCreaturePositions = (
        currentState.targeting?.creatures || []
      ).map((c) => c.gameCoords);

      detectedEntities = detectedEntities.map((entity) => {
        const coordsKey = getCoordsKey(entity.gameCoords);
        let isReachable = reachableTilesCache.get(coordsKey);

        if (typeof isReachable === 'undefined') {
          const otherCreatures = allCreaturePositions.filter(
            (p) => p !== entity.gameCoords,
          );
          const reachableDistance =
            currentState.targeting?.reachableDistance ?? 14;
          const pathLength = pathfinderInstance.getPathLength(
            currentPlayerMinimapPosition,
            entity.gameCoords,
            otherCreatures,
          );
          isReachable = pathLength !== -1 && pathLength <= reachableDistance;
          reachableTilesCache.set(coordsKey, isReachable);
        }

        return {
          ...entity,
          isReachable: isReachable,
        };
      });
    }

    detectedEntities.sort((a, b) => {
      if (a.distance !== b.distance) return a.distance - b.distance;
      return a.name.localeCompare(b.name);
    });

    if (!deepCompareEntities(detectedEntities, lastSentCreatures)) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'targeting/setEntities',
        payload: detectedEntities,
      });
      lastSentCreatures = detectedEntities;
    }

    let currentTarget = null;
    try {
      const targetRect = await findTarget.findTarget(
        sharedBufferView,
        gameWorld,
      );

      if (targetRect) {
        targetLossGracePeriodEndTime = 0; // Target found, reset grace period.
        const screenX = targetRect.x + targetRect.width / 2;
        const screenY = targetRect.y + targetRect.height / 2;
        const playerPosForTargetCalc = isPlayerInAnimationFreeze
          ? lastStablePlayerMinimapPosition
          : currentPlayerMinimapPosition;
        const targetGameCoordsRaw = getGameCoordinatesFromScreen(
          screenX,
          screenY,
          playerPosForTargetCalc,
          gameWorld,
          tileSize,
        );

        if (targetGameCoordsRaw) {
          let closestCreature = null;
          let minDistance = Infinity;
          for (const entity of detectedEntities) {
            if (entity.gameCoords) {
              const distance = calculateDistance(
                targetGameCoordsRaw,
                entity.gameCoords,
              );
              if (distance < minDistance) {
                minDistance = distance;
                closestCreature = entity;
              }
            }
          }

          if (closestCreature) {
            const distanceFromPlayer = calculateDistance(
              currentPlayerMinimapPosition,
              closestCreature.gameCoords,
            );
            // The target object in Redux needs the instanceId for unique identification.
            currentTarget = {
              instanceId: closestCreature.instanceId,
              name: closestCreature.name,
              distance: parseFloat(distanceFromPlayer.toFixed(1)),
              gameCoordinates: closestCreature.gameCoords,
              absoluteCoordinates: closestCreature.absoluteCoords,
            };
          }
        }
      } else {
        // --- Target NOT FOUND ---
        if (lastSentTarget) {
          // Only apply grace period if we previously had a target.
          if (targetLossGracePeriodEndTime === 0) {
            // Target was visible last frame, but not this one. Start the grace period.
            targetLossGracePeriodEndTime = now + TARGET_LOSS_GRACE_PERIOD_MS;
          }

          if (now < targetLossGracePeriodEndTime) {
            // Grace period is active, so we pretend the target is still there to prevent flickering.
            currentTarget = lastSentTarget;
          } else {
            // Grace period has expired. The target is officially lost.
            currentTarget = null;
          }
        }
      }
    } catch (err) {
      console.error('[CreatureMonitor] Error finding target:', err);
    }

    if (!deepCompareEntities(currentTarget, lastSentTarget)) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'targeting/setTarget',
        payload: currentTarget,
      });
      lastSentTarget = currentTarget;
    }
  } catch (error) {
    console.error('[CreatureMonitor] Error in operation:', error);
  }
}

async function initialize() {
  console.log('[CreatureMonitor] Initializing Pathfinder instance...');
  try {
    pathfinderInstance = new Pathfinder.Pathfinder();
    const fs = await import('fs/promises');
    const path = await import('path');

    const mapDataForAddon = {};
    const baseDir = paths.minimapResources;
    const zLevelDirs = (await fs.readdir(baseDir, { withFileTypes: true }))
      .filter((d) => d.isDirectory() && d.name.startsWith('z'))
      .map((d) => d.name);

    for (const zDir of zLevelDirs) {
      const zLevel = parseInt(zDir.substring(1), 10);
      const zLevelPath = path.join(baseDir, zDir);
      try {
        const metadata = JSON.parse(
          await fs.readFile(path.join(zLevelPath, 'walkable.json'), 'utf8'),
        );
        const grid = await fs.readFile(path.join(zLevelPath, 'walkable.bin'));
        mapDataForAddon[zLevel] = { ...metadata, grid };
      } catch (e) {
        if (e.code !== 'ENOENT') {
          console.warn(
            `[CreatureMonitor] Could not load path data for Z=${zLevel}: ${e.message}`,
          );
        }
      }
    }
    pathfinderInstance.loadMapData(mapDataForAddon);
    if (pathfinderInstance.isLoaded) {
      console.log(
        '[CreatureMonitor] Pathfinder instance loaded map data successfully.',
      );
    } else {
      throw new Error('Pathfinder failed to load map data.');
    }
  } catch (err) {
    console.error(
      '[CreatureMonitor] FATAL: Could not initialize Pathfinder instance:',
      err,
    );
    pathfinderInstance = null;
  }
}

parentPort.on('message', (message) => {
  if (isShuttingDown) {
    return;
  }
  try {
    if (message.type === 'shutdown') {
      isShuttingDown = true;
      return;
    } else if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      Object.assign(currentState, message.payload);
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
    }

    if (currentState && !isInitialized) {
      isInitialized = true;
      initialize()
        .then(() => {
          if (currentState.gameState?.playerMinimapPosition) {
            previousPlayerMinimapPosition = {
              ...currentState.gameState.playerMinimapPosition,
            };
            lastStablePlayerMinimapPosition = {
              ...currentState.gameState.playerMinimapPosition,
            };
          }
        })
        .catch((err) => {
          console.error('[CreatureMonitor] Initialization failed:', err);
        });
    }
    performOperation();
  } catch (e) {
    console.error('[CreatureMonitor] Error handling message:', e);
  }
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/exposedLuaFunctions.js
//start file
import { getRandomNumber } from '../utils/getRandomNumber.js';

export const wait = async (min_ms, max_ms, refreshCallback = null) => {
  const delay = max_ms === undefined ? min_ms : getRandomNumber(min_ms, max_ms);
  return new Promise((resolve) =>
    setTimeout(() => {
      if (refreshCallback) {
        refreshCallback(); // Call the refresh callback after the delay
      }
      resolve();
    }, delay),
  );
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/lootingWorker.js
//start file
import { parentPort } from 'worker_threads';
import keypress from 'keypress-native';
import { createLogger } from '../utils/logger.js';

const logger = createLogger({ info: false, error: true, debug: false });
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

let isInitialized = false;
let globalState = null;
let isShuttingDown = false;
let isProcessing = false;
let previousBattleListLength = 0;

parentPort.on('message', async (message) => {
  if (isShuttingDown) return;

  try {
    if (message.type === 'shutdown') {
      isShuttingDown = true;
      return;
    } else if (message.type === 'state_diff') {
      if (!globalState) globalState = {};
      Object.assign(globalState, message.payload);
    } else if (typeof message === 'object' && !message.type) {
      globalState = message;
      if (!isInitialized) {
        isInitialized = true;
        logger(
          'info',
          '[LootingWorker] Initial state received. Worker is now active.',
        );
      }
    }

    if (isProcessing || !globalState?.battleList?.entries) return;

    isProcessing = true;

    try {
      const currentBattleListEntries = globalState.battleList.entries;
      const currentBattleListLength = currentBattleListEntries.length;

      if (isInitialized && currentBattleListLength < previousBattleListLength) {
        logger(
          'info',
          `[LootingWorker] BattleList entries decreased from ${previousBattleListLength} to ${currentBattleListLength}. Pressing F8.`,
        );
        keypress.sendKey('f8', globalState.global.display);
        await delay(50);
      }

      previousBattleListLength = currentBattleListLength;
    } catch (err) {
      logger('error', '[LootingWorker] Error in processing logic:', err);
    } finally {
      isProcessing = false;
    }
  } catch (error) {
    logger('error', '[LootingWorker] Error handling message:', error);
    isProcessing = false;
  }
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaApi.js
//start file
import {
  keyPress,
  keyPressMultiple,
  typeArray,
  rotate,
  getIsTyping,
} from '../keyboardControll/keyPress.js';
import mouseController from 'mouse-controller';
import { getAbsoluteGameWorldClickCoordinates } from '../utils/gameWorldClickTranslator.js';
import { getAbsoluteClickCoordinates } from '../utils/minimapClickTranslator.js';
import { wait } from './exposedLuaFunctions.js';

const getNested = (obj, path) => {
  if (path === null || path === undefined) return obj;
  return path.split('.').reduce((acc, part) => acc && acc[part], obj);
};

/**
 * Creates an object with getters for convenient, direct access to state in Lua.
 * This object will be exposed globally in Lua as `__BOT_STATE__`.
 * @param {function} getState - A function that returns the latest full Redux state.
 * @param {'script'|'cavebot'} type - The type of worker, to determine which variables to expose.
 * @returns {object} The state shortcut object.
 */
export const createStateShortcutObject = (getState, type) => {
  const shortcuts = {};

  Object.defineProperty(shortcuts, 'hppc', {
    get: () => getState().gameState?.hppc,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'mppc', {
    get: () => getState().gameState?.mppc,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'characterName', {
    get: () => getState().gameState?.characterName,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'lastCharacterName', {
    get: () => getState().gameState?.lastCharacterName,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'lastLabel', {
    get: () => getState().cavebot?.lastLabel,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'cap', {
    get: () => getState().uiValues?.skillsWidget?.capacity || 0,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'stamina', {
    get: () => getState().uiValues?.skillsWidget?.stamina || 0,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'level', {
    get: () => getState().uiValues?.skillsWidget?.level,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'exp', {
    get: () => getState().uiValues?.skillsWidget?.experience,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'soul', {
    get: () => getState().uiValues?.skillsWidget?.soulPoints,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'speed', {
    get: () => getState().uiValues?.skillsWidget?.speed,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'xpRate', {
    get: () => getState().uiValues?.skillsWidget?.xpGainRate,
    enumerable: true,
  });

  Object.defineProperty(shortcuts, 'food', {
    get: () => getState().uiValues?.skillsWidget?.food,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isChatOff', {
    get: () => getState().gameState?.isChatOff,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'monsterNum', {
    get: () => getState().battleList.entries.length,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'playerNum', {
    get: () => getState().uiValues.players.length,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'battleList', {
    get: () => ({
      entries:
        getState().regionCoordinates.regions.battleList?.children?.entries
          ?.list || [],
    }),
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'partyNum', {
    get: () => getState().gameState?.partyNum,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isTyping', {
    get: () => getState().gameState?.isTyping,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isOnline', {
    get: () => !!getState().regionCoordinates?.regions?.onlineMarker,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'stowText', {
    get: () => getState().regionCoordinates?.regions?.stowText,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'stashIcon', {
    get: () => getState().regionCoordinates?.regions?.stashIcon,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'pk', {
    get: () =>
      getState().regionCoordinates?.regions?.playerList?.children?.whiteSkull,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'activeTab', {
    get: () => getState().uiValues?.chatboxTabs?.activeTab || 'unknown',
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'actionItems', {
    get: () => {
      const hotkeyBarChildren =
        getState().regionCoordinates?.regions?.hotkeyBar?.children || {};
      return new Proxy(
        {},
        {
          get(target, prop) {
            const child = hotkeyBarChildren[prop];
            return !!(child && child.x !== undefined && child.y !== undefined);
          },
          has(target, prop) {
            return true;
          },
          ownKeys() {
            return Object.keys(hotkeyBarChildren);
          },
        },
      );
    },
    enumerable: true,
  });

  const charStatus = getState().gameState?.characterStatus;
  if (charStatus) {
    for (const status in charStatus) {
      Object.defineProperty(shortcuts, status, {
        get: () => getState().gameState.characterStatus[status],
        enumerable: true,
      });
    }
  }

  Object.defineProperty(shortcuts, 'pos', {
    get: () => {
      const pos = getState().gameState?.playerMinimapPosition || {};
      return { x: pos.x, y: pos.y, z: pos.z };
    },
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'wpt', {
    get: () => {
      const cavebotState = getState().cavebot;
      const currentWaypoints =
        cavebotState?.waypointSections[cavebotState?.currentSection]
          ?.waypoints || [];
      const currentWptIndex = currentWaypoints.findIndex(
        (wp) => wp.id === cavebotState?.wptId,
      );
      const currentWpt =
        currentWptIndex !== -1 ? currentWaypoints[currentWptIndex] : null;
      if (currentWpt) {
        return {
          id: currentWptIndex + 1,
          x: currentWpt.x,
          y: currentWpt.y,
          z: currentWpt.z,
          type: currentWpt.type,
          label: currentWpt.label,
          distance: cavebotState.wptDistance,
        };
      }
      return null;
    },
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'cavebot', {
    get: () => getState().cavebot?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'section', {
    get: () =>
      getState().cavebot?.waypointSections[getState().cavebot?.currentSection]
        ?.name,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'healing', {
    get: () => getState().rules?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'targeting', {
    get: () => getState().targeting?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'scripts', {
    get: () => getState().lua?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'players', {
    get: () => getState().uiValues?.players || [],
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'standTime', {
    get: () => {
      const lastMoveTime = getState().gameState?.lastMoveTime;
      if (lastMoveTime) {
        return Date.now() - lastMoveTime;
      }
      return 0;
    },
    enumerable: true,
  });
  return shortcuts;
};

/**
 * Creates a consolidated API (functions and state object) to be exposed to a Lua environment.
 * @param {object} context - The context object from the calling worker.
 * @returns {{api: object, asyncFunctionNames: string[], stateObject: object, sharedGlobalsProxy: object}}
 */
export const createLuaApi = async (context) => {
  const { onAsyncStart, onAsyncEnd, sharedLuaGlobals, lua } = context;
  const { type, getState, postSystemMessage, logger, id } = context;
  const scriptName = type === 'script' ? `Script ${id}` : 'Cavebot';
  const asyncFunctionNames = [
    'wait',
    'keyPress',
    'keyPressMultiple',
    'typeText',
    'typeSequence',
    'rotate',
    'clickTile',
    'clickAbsolute',
    'mapClick',
    'drag',
    'dragAbsolute',
    'focusTab',
    'login',
    'waitFor',
  ];
  const getWindowId = () => getState()?.global?.windowId;
  const getDisplay = () => getState()?.global?.display || ':0';

  const waitFor = async (
    path,
    comparison = 'exists',
    value = null,
    timeout = 5000,
    interval = 200,
  ) => {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      await context.refreshLuaGlobalState();
      const state = getState();
      const actualValue = getNested(state, path);

      let conditionMet = false;
      switch (comparison) {
        case 'equals':
          conditionMet = actualValue === value;
          break;
        case 'notEquals':
          conditionMet = actualValue !== value;
          break;
        case 'greaterThan':
          conditionMet = actualValue > value;
          break;
        case 'lessThan':
          conditionMet = actualValue < value;
          break;
        case 'exists':
          conditionMet = actualValue !== undefined && actualValue !== null;
          break;
        case 'notExists':
          conditionMet = actualValue === undefined || actualValue === null;
          break;
        default:
          logger(
            'warn',
            `[Lua/${scriptName}] waitFor: unknown comparison '${comparison}'`,
          );
          return false;
      }

      if (conditionMet) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
    logger('info', `[Lua/${scriptName}] waitFor timed out for path: '${path}'`);
    return false;
  };

  const closeAllModals = async (timeout = 10000) => {
    const modalsToClose = [
      { name: 'pleaseWaitModal' },
      { name: 'ipChangedModal' },
      { name: 'wrongPasswordModal' },
      { name: 'connectionLostModal' },
      { name: 'connectionFailedModal' },
      { name: 'warningModal' },
      { name: 'notLoggedInAnymoreModal' },
    ];
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      await context.refreshLuaGlobalState();
      const state = getState();
      const regions = state.regionCoordinates?.regions;
      if (!regions) {
        await new Promise((r) => setTimeout(r, 200));
        continue;
      }

      let foundModal = false;
      for (const modalInfo of modalsToClose) {
        const modal = regions[modalInfo.name];
        const button =
          modal?.children?.abort ||
          modal?.children?.close ||
          modal?.children?.ok;

        if (button?.x && button?.y) {
          logger('info', `[Lua/${scriptName}] Closing '${modalInfo.name}'`);
          if (
            modalInfo.name === 'ipChangedModal' ||
            modalInfo.name === 'notLoggedInAnymoreModal'
          ) {
            await keyPress(getDisplay(), 'Escape');
            await wait(500);
            await keyPress(getDisplay(), 'Escape');
            await wait(500);
          } else {
            mouseController.leftClick(
              parseInt(String(getWindowId())),
              button.x,
              button.y,
              getDisplay(),
            );
            await wait(500);
          }
          foundModal = true;
          break; // Restart the scan for modals
        }
      }

      if (!foundModal) {
        return true; // No modals found, we are done.
      }
    }
    logger('warn', `[Lua/${scriptName}] closeAllModals timed out.`);
    return false; // Timed out
  };

  const baseApi = {
    getDistanceTo: (x, y, z) => {
      const state = getState();
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!playerPos) return 9999;
      if (z !== undefined && playerPos.z !== z) return 9999;
      return Math.max(Math.abs(playerPos.x - x), Math.abs(playerPos.y - y));
    },
    isLocation: (range = 0) => {
      const state = getState();
      const playerPos = state.gameState?.playerMinimapPosition;
      const { waypointSections, currentSection, wptId } = state.cavebot || {};

      if (
        !playerPos ||
        wptId == null ||
        !waypointSections ||
        !waypointSections[currentSection]
      ) {
        console.log('isLocation failed, missing data.', {
          playerPos,
          wptId,
          currentSection,
        });
        return false;
      }

      const targetWpt = waypointSections[currentSection].waypoints.find(
        (wp) => wp.id === wptId,
      );
      if (!targetWpt) {
        console.log('isLocation: target waypoint not found for wptId', wptId);
        return false;
      }
      if (playerPos.z !== targetWpt.z) {
        console.log('isLocation: z mismatch', playerPos.z, targetWpt.z);
        return false;
      }

      const px = Number(playerPos.x);
      const py = Number(playerPos.y);
      const tx = Number(targetWpt.x);
      const ty = Number(targetWpt.y);

      if ([px, py, tx, ty].some(Number.isNaN)) {
        console.log('isLocation: numeric conversion failed', {
          px,
          py,
          tx,
          ty,
        });
        return false;
      }

      if (px === tx && py === ty) {
        return true; // exact match fast-path
      }

      const dist = Math.max(Math.abs(px - tx), Math.abs(py - ty));
      return dist <= range;
    },
    log: (level, ...messages) =>
      logger(
        String(level).toLowerCase(),
        `[Lua/${scriptName}] ${messages.map(String).join(' ')}`,
      ),
    print: (...messages) => {
      const message = messages.map(String).join(' ');
      logger('info', `[Lua/${scriptName}] print: ${message}`);
      if (type === 'cavebot') {
        const state = getState();
        const scriptId = state.cavebot.wptId;
        context.postStoreUpdate('cavebot/addWaypointLogEntry', {
          id: scriptId,
          message: message,
        });
      } else {
        context.postStoreUpdate('lua/addLogEntry', {
          id: id,
          message: message,
        });
      }
    },
    alert: () => postSystemMessage({ type: 'play_alert' }),
    wait: (min_ms, max_ms) =>
      wait(min_ms, max_ms, context.refreshLuaGlobalState),
    keyPress: (key, modifier = null) =>
      keyPress(getDisplay(), key, { modifier }),
    keyPressMultiple: (key, count = 1, modifier = null, delayMs = 50) =>
      keyPressMultiple(getDisplay(), key, {
        count,
        modifier,
        delayMs,
      }),
    typeText: async (...args) => {
      const display = getDisplay();
      if (args.length === 0) {
        logger(
          'warn',
          `[Lua/${scriptName}] 'type' function called with no arguments.`,
        );
        return false;
      }

      let texts = [];
      let startAndEndWithEnter = true;

      const lastArg = args[args.length - 1];
      if (typeof lastArg === 'boolean') {
        startAndEndWithEnter = lastArg;
        texts = args.slice(0, -1);
      } else {
        texts = args;
      }

      const stringArgs = texts.map(String);

      if (stringArgs.length === 0) {
        logger(
          'warn',
          `[Lua/${scriptName}] 'type' function called without any text to type.`,
        );
        return false;
      }

      try {
        await typeArray(display, stringArgs, startAndEndWithEnter);
        return true;
      } catch (error) {
        logger(
          'error',
          `[Lua/${scriptName}] Error in 'type' function: ${error.message}`,
        );
        throw error;
      }
    },
    typeSequence: async (texts, delayBetween = 100) => {
      for (const text of texts) {
        await typeArray(getDisplay(), [text], true);
        if (delayBetween > 0) {
          await wait(delayBetween);
        }
      }
    },
    rotate: (direction) => rotate(getDisplay(), direction),
    isTyping: () => getIsTyping(),
    clickTile: async (button, x, y, position = 'center') => {
      const windowId = String(getWindowId());
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform game click: missing region data or player position`,
        );
        return false;
      }
      const clickCoords = getAbsoluteGameWorldClickCoordinates(
        x,
        y,
        playerPos,
        gameWorld,
        tileSize,
        position,
      );
      if (!clickCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform game click: invalid coordinates`,
        );
        return false;
      }

      if (button === 'right') {
        mouseController.rightClick(
          parseInt(windowId),
          clickCoords.x,
          clickCoords.y,
          getDisplay(),
        );
      } else {
        mouseController.leftClick(
          parseInt(windowId),
          clickCoords.x,
          clickCoords.y,
          getDisplay(),
        );
      }
      await wait(100);
      return true;
    },
    clickAbsolute: async (button, x, y) => {
      const windowId = String(getWindowId());
      if (button === 'right') {
        mouseController.rightClick(parseInt(windowId), x, y, getDisplay());
      } else {
        mouseController.leftClick(parseInt(windowId), x, y, getDisplay());
      }
      await wait(100);
      return true;
    },
    mapClick: async (x, y, position = 'center') => {
      const windowId = String(getWindowId());
      const state = getState();
      const minimapRegionDef = state.regionCoordinates?.regions?.minimapFull;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!minimapRegionDef || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform minimap click: missing region data or player position`,
        );
        return false;
      }
      const clickCoords = getAbsoluteClickCoordinates(
        x,
        y,
        playerPos,
        minimapRegionDef,
      );
      if (!clickCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform minimap click: invalid coordinates`,
        );
        return false;
      }
      mouseController.leftClick(
        parseInt(windowId),
        clickCoords.x,
        clickCoords.y,
        getDisplay(),
      );
      await wait(100);
      return true;
    },
    drag: async (startX, startY, endX, endY, button = 'left') => {
      const windowId = String(getWindowId());
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform drag: missing region data or player position`,
        );
        return false;
      }
      const startCoords = getAbsoluteGameWorldClickCoordinates(
        startX,
        startY,
        playerPos,
        gameWorld,
        tileSize,
        'bottomRight',
      );
      const endCoords = getAbsoluteGameWorldClickCoordinates(
        endX,
        endY,
        playerPos,
        gameWorld,
        tileSize,
        'bottomRight',
      );
      if (!startCoords || !endCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform drag: invalid coordinates`,
        );
        return false;
      }
      mouseController.mouseMove(
        parseInt(windowId),
        startCoords.x,
        startCoords.y,
        getDisplay(),
      );
      await wait(50);
      if (button === 'right') {
        mouseController.rightMouseDown(
          parseInt(windowId),
          startCoords.x,
          startCoords.y,
        );
      } else {
        mouseController.mouseDown(
          parseInt(windowId),
          startCoords.x,
          startCoords.y,
        );
      }
      await wait(100);
      mouseController.mouseMove(
        parseInt(windowId),
        endCoords.x,
        endCoords.y,
        getDisplay(),
      );
      await wait(100);
      if (button === 'right') {
        mouseController.rightMouseUp(
          parseInt(windowId),
          endCoords.x,
          endCoords.y,
        );
      } else {
        mouseController.mouseUp(
          parseInt(windowId),
          endCoords.x,
          endCoords.y,
          getDisplay(),
        );
      }
      await wait(100);
      return true;
    },
    dragAbsolute: async (startX, startY, endX, endY, button = 'left') => {
      const windowId = String(getWindowId());
      mouseController.mouseMove(
        parseInt(windowId),
        startX,
        startY,
        getDisplay(),
      );
      await wait(50);
      if (button === 'right') {
        mouseController.rightMouseDown(
          parseInt(windowId),
          startX,
          startY,
          getDisplay(),
        );
      } else {
        mouseController.mouseDown(
          parseInt(windowId),
          startX,
          startY,
          getDisplay(),
        );
      }
      await wait(100);
      mouseController.mouseMove(parseInt(windowId), endX, endY, getDisplay());
      await wait(100);
      if (button === 'right') {
        mouseController.rightMouseUp(
          parseInt(windowId),
          endX,
          endY,
          getDisplay(),
        );
      } else {
        mouseController.mouseUp(parseInt(windowId), endX, endY, getDisplay());
      }
      await wait(100);
      return true;
    },
    tileToCoordinate: (tileX, tileY, position = 'bottomRight') => {
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot convert tile to coordinate: missing region data`,
        );
        return null;
      }
      const coords = getAbsoluteGameWorldClickCoordinates(
        tileX,
        tileY,
        playerPos,
        gameWorld,
        tileSize,
        position,
      );
      return coords ? { x: coords.x, y: coords.y } : null;
    },
    coordinateToTile: (screenX, screenY) => {
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot convert coordinate to tile: missing region data`,
        );
        return null;
      }
      const relX = screenX - gameWorld.x;
      const relY = screenY - gameWorld.y;
      const tileX =
        Math.floor(relX / tileSize.width) +
        playerPos.x -
        Math.floor(gameWorld.width / tileSize.width / 2);
      const tileY =
        Math.floor(relY / tileSize.height) +
        playerPos.y -
        Math.floor(gameWorld.height / tileSize.height / 2);
      return { x: tileX, y: tileY };
    },
    focusTab: async (tabName) => {
      const state = getState();
      const tabs = state.uiValues?.chatboxTabs?.tabs;
      if (!tabs || !tabName) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot focus tab: missing tab data or tab name`,
        );
        return false;
      }
      const tab = tabs[tabName];
      if (!tab || !tab.tabPosition) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot focus tab: tab "${tabName}" not found or missing position`,
        );
        return false;
      }
      const windowId = String(getWindowId());
      const { x, y } = tab.tabPosition;
      mouseController.leftClick(parseInt(windowId), x, y, getDisplay());
      await wait(100);
      return true;
    },
    setTargeting: (enabled) => {
      context.postStoreUpdate('targeting/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Targeting ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    setHealing: (enabled) => {
      context.postStoreUpdate('rules/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Healing (rules) ${
          enabled ? 'enabled' : 'disabled'
        }`,
      );
    },
    setCavebot: (enabled) => {
      context.postStoreUpdate('cavebot/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Cavebot ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    isCreatureOnTile: (x, y, z) => {
      const creatures = getCreatures(getState);
      return creatures.some(
        (creature) => creature.x === x && creature.y === y && creature.z === z,
      );
    },
    setScripts: (enabled) => {
      context.postStoreUpdate('lua/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Scripts ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    setScript: (name, status) => {
      const enabled = status === 'enabled';
      postSystemMessage({
        type: 'lua_set_script_enabled',
        payload: { name, enabled },
      });
      logger(
        'info',
        `[Lua/${scriptName}] Setting script "${name}" to ${status}`,
      );
    },
    pauseWalking: (ms) => {
      const duration = parseInt(ms, 10);
      if (!isNaN(duration)) {
        postSystemMessage({ type: 'lua-pause-walking', payload: duration });
        logger('info', `[Lua/${scriptName}] Pausing walking for ${duration}ms`);
      }
    },
    pauseTargeting: (ms) => {
      const duration = parseInt(ms, 10);
      if (!isNaN(duration)) {
        postSystemMessage({ type: 'lua-pause-targeting', payload: duration });
        logger(
          'info',
          `[Lua/${scriptName}] Pausing targeting for ${duration}ms`,
        );
      }
    },
    waitFor,
    login: async (email, password, character) => {
      const windowId = String(getWindowId());
      const display = getDisplay();

      if (
        await waitFor(
          'regionCoordinates.regions.onlineMarker',
          'exists',
          null,
          100,
        )
      ) {
        logger(
          'info',
          `[Lua/${scriptName}] Player is already online, skipping login.`,
        );
        return false;
      }

      await closeAllModals(15000);

      const isAtCharSelect = await waitFor(
        'regionCoordinates.regions.selectCharacterModal',
        'exists',
        null,
        100,
      );

      if (isAtCharSelect) {
        logger(
          'info',
          `[Lua/${scriptName}] Already at character selection, skipping login form.`,
        );
      } else {
        logger(
          'info',
          `[Lua/${scriptName}] Starting login process for character: ${character}`,
        );

        const loginModalExists = await waitFor(
          'regionCoordinates.regions.loginModal',
          'exists',
          null,
          1000,
        );
        if (!loginModalExists) {
          logger('warn', `[Lua/${scriptName}] loginModal not found`);
          return false;
        }

        const state = getState(); // We know it exists now.
        const loginModal = state.regionCoordinates.regions.loginModal;

        await keyPress(display, 'Escape');
        await wait(100);
        await keyPress(display, 'Escape');
        await wait(100);

        const emailInput = loginModal.children?.emailInput;
        if (!emailInput) {
          logger('warn', `[Lua/${scriptName}] emailInput not found`);
          return false;
        }
        mouseController.leftClick(
          parseInt(windowId),
          emailInput.x,
          emailInput.y,
          display,
        );
        await wait(50);
        await typeArray(display, [email], false);
        await wait(100);

        const passwordInput = loginModal.children?.passwordInput;
        if (!passwordInput) {
          logger('warn', `[Lua/${scriptName}] passwordInput not found`);
          return false;
        }
        mouseController.leftClick(
          parseInt(windowId),
          passwordInput.x,
          passwordInput.y,
          display,
        );
        await wait(50);
        await typeArray(display, [password], false);
        await wait(100);
        await keyPress(display, 'Enter');
      }

      const charSelectAppeared = await waitFor(
        'regionCoordinates.regions.selectCharacterModal',
        'exists',
        null,
        10000,
      );

      if (!charSelectAppeared) {
        logger(
          'warn',
          `[Lua/${scriptName}] selectCharacterModal not found after login attempt.`,
        );
        // Try to recover by closing any new modals
        await closeAllModals(5000);
        return false;
      }

      // Wait for character data to be parsed by OCR
      const charDataExists = await waitFor(
        'uiValues.selectCharacterModal.characters',
        'exists',
        null,
        5000,
      );
      if (!charDataExists) {
        logger(
          'warn',
          `[Lua/${scriptName}] No character data available for selection after 5s.`,
        );
        return false;
      }

      const characters = getState().uiValues.selectCharacterModal.characters;
      const characterNames = Object.keys(characters);
      const targetCharacterLower = character.toLowerCase();
      const targetCharacterFound = characterNames.find((name) =>
        name.toLowerCase().includes(targetCharacterLower),
      );

      if (!targetCharacterFound) {
        logger(
          'warn',
          `[Lua/${scriptName}] Target character '${character}' not found in list: [${characterNames.join(
            ', ',
          )}]`,
        );
        return false;
      }

      const characterItem = characters[targetCharacterFound];
      if (!characterItem || !characterItem.position) {
        logger(
          'warn',
          `[Lua/${scriptName}] Could not find coordinates for character '${targetCharacterFound}'`,
        );
        return false;
      }

      mouseController.leftClick(
        parseInt(windowId),
        characterItem.position.x,
        characterItem.position.y,
        display,
      );
      await wait(100);
      await keyPress(display, 'Enter');

      const isOnline = await waitFor(
        'regionCoordinates.regions.onlineMarker',
        'exists',
        null,
        10000,
      );

      if (isOnline) {
        logger(
          'info',
          `[Lua/${scriptName}] Login successful, player is online.`,
        );
        return true;
      } else {
        logger(
          'warn',
          `[Lua/${scriptName}] Login timeout, player did not come online.`,
        );
        return false;
      }
    },
  };
  let navigationApi = {};
  if (type === 'cavebot') {
    navigationApi = {
      skipWaypoint: context.advanceToNextWaypoint,
      goToLabel: context.goToLabel,
      goToSection: context.goToSection,
      goToWpt: context.goToWpt,
      pauseActions: (paused) =>
        context.postStoreUpdate('cavebot/setActionPaused', !!paused),
      setCavebotEnabled: (enabled) =>
        context.postStoreUpdate('cavebot/setenabled', !!enabled),
    };
  } else {
    navigationApi = {
      skipWaypoint: () => {
        const state = getState();
        const { waypointSections, currentSection, wptId } = state.cavebot;
        const waypoints = waypointSections[currentSection]?.waypoints || [];
        const currentIndex = waypoints.findIndex((wp) => wp.id === wptId);
        if (currentIndex === -1) return;
        const nextIndex = (currentIndex + 1) % waypoints.length;
        if (waypoints[nextIndex])
          context.postStoreUpdate('cavebot/setwptId', waypoints[nextIndex].id);
      },
      goToLabel: (label) => {
        const state = getState();
        const { waypointSections, currentSection } = state.cavebot;
        const targetWpt = waypointSections[currentSection]?.waypoints.find(
          (wp) => wp.label === label,
        );
        if (targetWpt)
          context.postStoreUpdate('cavebot/setwptId', targetWpt.id);
      },
      goToSection: (sectionName) => {
        const state = getState();
        const { waypointSections } = state.cavebot;
        const foundEntry = Object.entries(waypointSections).find(
          ([, s]) => s.name === sectionName,
        );
        if (foundEntry) {
          const [targetSectionId, targetSection] = foundEntry;
          if (targetSection.waypoints?.length > 0) {
            context.postStoreUpdate(
              'cavebot/setCurrentWaypointSection',
              targetSectionId,
            );
            context.postStoreUpdate(
              'cavebot/setwptId',
              targetSection.waypoints[0].id,
            );
          }
        }
      },
      goToWpt: (index) => {
        const arrayIndex = parseInt(index, 10) - 1;
        if (isNaN(arrayIndex) || arrayIndex < 0) return;
        const state = getState();
        const { waypointSections, currentSection } = state.cavebot;
        const waypoints = waypointSections[currentSection]?.waypoints || [];
        if (arrayIndex < waypoints.length)
          context.postStoreUpdate('cavebot/setwptId', waypoints[arrayIndex].id);
      },
      pauseActions: (paused) =>
        context.postStoreUpdate('cavebot/setActionPaused', !!paused),
    };
  }
  const api = { ...baseApi, ...navigationApi };
  const stateObject = createStateShortcutObject(getState, type);
  const asyncApiFunctionSet = new Set(asyncFunctionNames);
  const apiProxy = new Proxy(api, {
    get(target, prop, receiver) {
      const originalMember = target[prop];
      if (
        typeof originalMember === 'function' &&
        asyncApiFunctionSet.has(prop)
      ) {
        return async (...args) => {
          if (onAsyncStart) {
            onAsyncStart();
          }
          try {
            // NEW: Auto-refresh state before executing async function
            if (typeof context.refreshLuaGlobalState === 'function') {
              await context.refreshLuaGlobalState(true);
            }
            return await originalMember.apply(target, args);
          } finally {
            if (onAsyncEnd) {
              onAsyncEnd();
            }
          }
        };
      }
      return Reflect.get(target, prop, receiver);
    },
  });

  // NEW: Create a Lua table that proxies access to the sharedLuaGlobals JS object
  lua.global.set('__automaton_index_handler', (table, key) => {
    return sharedLuaGlobals[key];
  });
  lua.global.set('__automaton_newindex_handler', (table, key, value) => {
    sharedLuaGlobals[key] = value;
    if (context.postGlobalVarUpdate) {
      context.postGlobalVarUpdate(key, value);
    }
  });
  await lua.doString(`
    local metatable = {
      __index = __automaton_index_handler,
      __newindex = __automaton_newindex_handler
    }
    SharedGlobals = {}
    setmetatable(SharedGlobals, metatable)
  `);
  const sharedGlobalsProxy = lua.global.get('SharedGlobals');
  lua.global.set('__automaton_index_handler', undefined);
  lua.global.set('__automaton_newindex_handler', undefined);

  return { api: apiProxy, asyncFunctionNames, stateObject, sharedGlobalsProxy }; // NEW: Return sharedGlobalsProxy
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaScriptProcessor.js
//start file
/**
 * @fileoverview Centralized processor for preparing Lua scripts for execution.
 * This module contains utility functions for manipulating Lua script code before
 * it is run by the wasmoon engine.
 */

/**
 * Replaces convenient '$' prefixed variables with their valid, secret internal counterparts.
 * This uses a regular expression to safely replace `$var` with `__BOT_STATE__.var`
 * to avoid conflicts with user-defined variables.
 *
 * @param {string} code - The raw Lua code from the user.
 * @returns {string} The processed code with valid Lua syntax.
 */
const replaceShortcutVariables = (code) => {
  // This regex finds a literal '$' followed by a valid Lua identifier
  // (starts with a letter or underscore, followed by letters, numbers, or underscores).
  const regex = /\$([a-zA-Z_][a-zA-Z0-9_]*)/g;
  // The replacement string '__BOT_STATE__.$1' uses the captured group ($1)
  // to construct the valid Lua code, e.g., '$hp' becomes '__BOT_STATE__.hp'.
  return code.replace(regex, '__BOT_STATE__.$1');
};

/**
 * Preprocesses a raw Lua script string to handle custom syntax.
 * This now runs as a two-step process:
 * 1. Replaces '$' shortcut variables (e.g., `$hp`) with their valid form (`__BOT_STATE__.hp`).
 * 2. Appends `:await()` to specified async function calls for wasmoon compatibility.
 *
 * @param {string} scriptCode - The raw Lua script to preprocess.
 * @param {string[]} asyncFunctionNames - A list of function names that are asynchronous and return Promises.
 * @returns {string} The fully processed script with valid syntax, ready for execution.
 */
export function preprocessLuaScript(scriptCode, asyncFunctionNames) {
  // Step 1: Replace $ variables
  let processedCode = replaceShortcutVariables(scriptCode);

  if (!asyncFunctionNames || asyncFunctionNames.length === 0) {
    return processedCode;
  }

  // Build regex for async functions
  const funcNamePattern = asyncFunctionNames.join('|');

  // This regex matches function calls that don't already have :await()
  const regex = new RegExp(
    `\\b(${funcNamePattern})\\s*\\((?:[^()]*|\\([^)]*\\))*\\)(?!:await\\(\\))`,
    'g',
  );

  processedCode = processedCode.replace(regex, (match) => {
    return `${match}:await()`;
  });

  return processedCode;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaScriptWorker.js
//start file
// luaScriptWorker.js

import { parentPort, workerData, threadId } from 'worker_threads';
import { LuaFactory } from 'wasmoon';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createLogger } from '../utils/logger.js';
import { createLuaApi } from './luaApi.js';
import { createStateShortcutObject } from './luaApi.js';
import { preprocessLuaScript } from './luaScriptProcessor.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const log = createLogger({ info: true, error: true, debug: false });
let lua;
let currentState = {};
let scriptConfig = {};
let loopInterval = null;
let asyncFunctionNames = [];
let keepAliveInterval = null;
let apiInitialized = false;

// --- State machine to prevent shutdown during init ---
let workerState = 'pending'; // 'pending' | 'initializing' | 'running'
let shutdownRequested = false;

// --- Active async operation counter ---
let activeAsyncOperations = 0;
const onAsyncStart = () => activeAsyncOperations++;
const onAsyncEnd = () => activeAsyncOperations--;

const getFreshState = () =>
  new Promise((res, rej) => {
    const timeout = setTimeout(() => {
      parentPort.off('message', onSnap);
      rej(new Error('Timeout waiting for state snapshot from main thread.'));
    }, 5000); // 5 second timeout

    const onSnap = (msg) => {
      if (msg.type === 'state_snapshot') {
        clearTimeout(timeout);
        parentPort.off('message', onSnap);
        res(msg.payload);
      }
    };
    parentPort.on('message', onSnap);
    parentPort.postMessage({ type: 'request_state_snapshot' });
  });

const postStoreUpdate = (type, payload) => {
  parentPort.postMessage({ storeUpdate: true, type, payload });
};

const postGlobalVarUpdate = (key, value) => {
  parentPort.postMessage({
    type: 'lua_global_update',
    payload: { key, value },
  });
};

const keepAlive = () => {
  if (keepAliveInterval) return;
  keepAliveInterval = setInterval(() => {}, 60 * 60 * 1000);
};

const cleanupAndExit = async () => {
  log(
    'info',
    `[Lua Script Worker ${scriptConfig.id}] Cleaning up and exiting.`,
  );
  stopScriptLoop();
  if (keepAliveInterval) clearInterval(keepAliveInterval);

  const maxWait = 5000;
  const start = Date.now();
  while (activeAsyncOperations > 0 && Date.now() - start < maxWait) {
    // Silently wait for operations to finish, checking less frequently to throttle.
    await new Promise((r) => setTimeout(r, 250));
  }

  if (activeAsyncOperations > 0) {
    log(
      'warn',
      `[Lua Script Worker ${scriptConfig.id}] Exiting with ${activeAsyncOperations} async operations still pending after timeout.`,
    );
  }

  if (lua) {
    try {
      lua.global.close();
    } catch (e) {
      log(
        'error',
        `[Lua Script Worker ${scriptConfig.id}] close error: ${e.message}`,
      );
    }
  }
  process.exit(0);
};

const loadLuaLibraries = async () => {
  if (!lua) return;
  const libPath = path.join(__dirname, 'lua', 'lib');
  try {
    const files = await fs.readdir(libPath);
    for (const file of files) {
      if (path.extname(file) === '.lua') {
        const filePath = path.join(libPath, file);
        const content = await fs.readFile(filePath, 'utf8');
        await lua.doString(content);
        log('info', `[Lua Script Worker ${scriptConfig.id}] Loaded Lua library: ${file}`);
      }
    }
  } catch (error) {
    if (error.code !== 'ENOENT') {
      log('error', `[Lua Script Worker ${scriptConfig.id}] Error loading Lua libraries:`, error);
    } else {
      log('info', `[Lua Script Worker ${scriptConfig.id}] No Lua libraries found to load.`);
    }
  }
};

const initializeLuaVM = async () => {
  log('info', `[Lua Script Worker ${scriptConfig.id}] Initializing Lua VM`);
  try {
    const factory = new LuaFactory();
    lua = await factory.createEngine();
    await loadLuaLibraries();
    log('info', `[Lua Script Worker ${scriptConfig.id}] Lua VM ready.`);
  } catch (error) {
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] VM init failed:`,
      error,
    );
    throw error;
  }
};

const initializeLuaApi = async () => {
  if (!lua) {
    log(
      'warn',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: Lua VM not available.`,
    );
    return;
  }
  if (apiInitialized) {
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: API already initialized.`,
    );
    return;
  }

  try {
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: Requesting fresh state.`,
    );
    currentState = await getFreshState();
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: Fresh state received.`,
    );

    const { api, asyncFunctionNames: newNames } = await createLuaApi({
      type: 'script',
      getState: () => currentState,
      postSystemMessage: (m) => parentPort.postMessage(m),
      logger: log,
      id: scriptConfig.id,
      postStoreUpdate,
      postGlobalVarUpdate,
      refreshLuaGlobalState: syncDynamicStateToLua, // Pass the sync function
      onAsyncStart,
      onAsyncEnd,
      sharedLuaGlobals: workerData.sharedLuaGlobals,
      lua: lua,
    });

    asyncFunctionNames = newNames;
    for (const fn in api) {
      lua.global.set(fn, api[fn]);
    }

    apiInitialized = true;
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: API setup complete.`,
    );
  } catch (error) {
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: Error during API initialization: ${error.message}`,
      error,
    );
    throw error; // Re-throw to be caught by the init handler's try/catch
  }
};

const syncDynamicStateToLua = async () => {
  if (!lua || !apiInitialized) return;

  try {
    const freshState = await getFreshState();
    if (freshState) {
      currentState = freshState;
      const stateObject = createStateShortcutObject(
        () => currentState,
        'script',
      );
      lua.global.set('__BOT_STATE__', stateObject);
    }
  } catch (e) {
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] Failed to get fresh state: ${e.message}`,
    );
  }
};

const executeOneShot = async () => {
  log(
    'info',
    `[Lua Script Worker ${scriptConfig.id}] Executing one-shot script.`,
  );

  if (!lua) {
    const errorMsg = 'Lua VM not ready.';
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] one-shot error: ${errorMsg}`,
    );
    parentPort.postMessage({
      type: 'scriptExecutionResult',
      payload: {
        id: scriptConfig.id,
        success: false,
        error: errorMsg,
        isCavebotScript: workerData.isCavebotScript,
      },
    });
    return; // Still return if Lua VM is not ready, as API init will fail
  }

  // Initialize API even for empty scripts to ensure SharedGlobals are set up
  await initializeLuaApi();
  log(
    'debug',
    `[Lua Script Worker ${scriptConfig.id}] Lua API initialized for one-shot script.`,
  );

  if (!scriptConfig.code?.trim()) {
    const infoMsg = 'No script code provided. Script will do nothing.';
    log('info', `[Lua Script Worker ${scriptConfig.id}] one-shot: ${infoMsg}`);
    parentPort.postMessage({
      type: 'scriptExecutionResult',
      payload: {
        id: scriptConfig.id,
        success: true, // An empty script is not an error, it just does nothing.
        error: null,
        isCavebotScript: workerData.isCavebotScript,
      },
    });
    return; // Return after sending result for empty script
  }

  try {
    await syncDynamicStateToLua();
    // Log SharedGlobals.asd before execution
    const sharedAsdValue = workerData.sharedLuaGlobals.asd;
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] Lua script sees SharedGlobals.asd as: ${sharedAsdValue}`,
    );

    const processedCode = preprocessLuaScript(
      scriptConfig.code,
      asyncFunctionNames,
    );
    await lua.doString(processedCode);
    parentPort.postMessage({
      type: 'scriptExecutionResult',
      payload: {
        id: scriptConfig.id,
        success: true,
        isCavebotScript: workerData.isCavebotScript,
      },
    });
  } catch (error) {
    const msg = error.message || String(error);
    log('error', `[Lua Script Worker ${scriptConfig.id}] one-shot error:`, msg);
    postStoreUpdate('lua/addLogEntry', {
      id: scriptConfig.id,
      message: `[ERROR] ${msg}`,
    });
    parentPort.postMessage({
      type: 'scriptExecutionResult',
      payload: {
        id: scriptConfig.id,
        success: false,
        error: msg,
        isCavebotScript: workerData.isCavebotScript,
      },
    });
  }
};

const executeScriptLoop = async () => {
  if (!lua) return stopScriptLoop();
  if (!scriptConfig.code?.trim()) {
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] Script empty; skipping.`,
    );
  } else {
    try {
      await syncDynamicStateToLua();
      // Log SharedGlobals.asd before execution
      const sharedAsdValue = workerData.sharedLuaGlobals.asd;
      log(
        'debug',
        `[Lua Script Worker ${scriptConfig.id}] Lua script sees SharedGlobals.asd as: ${sharedAsdValue}`,
      );

      await lua.doString(
        preprocessLuaScript(scriptConfig.code, asyncFunctionNames),
      );
    } catch (error) {
      const msg = error.message || String(error);
      log('error', `[Lua Script Worker ${scriptConfig.id}] loop error:`, msg);
      postStoreUpdate('lua/addLogEntry', {
        id: scriptConfig.id,
        message: `[ERROR] ${msg}`,
      });
    }
  }
  const min = scriptConfig.loopMin || 100;
  const max = scriptConfig.loopMax || 200;
  const delay = Math.floor(Math.random() * (max - min + 1)) + min;
  loopInterval = setTimeout(executeScriptLoop, delay);
};

const startScriptLoop = () => {
  if (loopInterval) clearTimeout(loopInterval);
  log('info', `[Lua Script Worker ${scriptConfig.id}] Starting script loop.`);
  executeScriptLoop();
};

const stopScriptLoop = () => {
  if (loopInterval) {
    log('info', `[Lua Script Worker ${scriptConfig.id}] Stopping script loop.`);
    clearTimeout(loopInterval);
    loopInterval = null;
  }
};

/* ------------ message router ------------ */
parentPort.on('message', async (message) => {
  if (message.type === 'shutdown') {
    shutdownRequested = true;
    if (workerState === 'running') await cleanupAndExit();
    return;
  }

  if (message.type === 'lua_global_broadcast') {
    const { key, value } = message.payload;
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] Received lua_global_broadcast: key=${key}, value=${value}`,
    );
    if (workerData.sharedLuaGlobals) {
      workerData.sharedLuaGlobals[key] = value;
      log(
        'debug',
        `[Lua Script Worker ${scriptConfig.id}] workerData.sharedLuaGlobals.${key} updated to: ${workerData.sharedLuaGlobals[key]}`,
      );
    }
    return;
  }

  if (message.type === 'init') {
    workerState = 'initializing';
    scriptConfig = message.script;
    log(
      'info',
      `[Lua Script Worker ${scriptConfig.id}] Init received. Script config:`,
      scriptConfig,
    );

    await initializeLuaVM();
    if (shutdownRequested) {
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] Shutdown requested during initialization. Exiting.`,
      );
      await cleanupAndExit();
      return;
    }

    await initializeLuaApi();
    log('info', `[Lua Script Worker ${scriptConfig.id}] Lua API initialized.`);

    workerState = 'running';
    log(
      'info',
      `[Lua Script Worker ${scriptConfig.id}] Worker state set to running.`,
    );

    if (scriptConfig.type === 'oneshot') {
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] Executing one-shot script.`,
      );
      await executeOneShot();
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] One-shot script execution finished.`,
      );
      // For one-shot scripts, we should exit after execution
      await cleanupAndExit();
    } else {
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] Starting script loop.`,
      );
      startScriptLoop();
      keepAlive();
    }
    return;
  }

  if (message.type === 'update') {
    scriptConfig = message.script;
    return;
  }

  if (message.type === 'state_snapshot') {
    currentState = message.payload;
  } else if (message.type === 'state_diff') {
    // Apply partial state updates
    if (!currentState) currentState = {};
    Object.assign(currentState, message.payload);
  }
});

parentPort.on('close', async () => {
  log('info', `[Lua Script Worker ${scriptConfig.id}] Parent port closed.`);
  await cleanupAndExit();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/config.js
//start file
import { PALETTE_DATA } from '../../constants/palette.js';

// --- Worker Timing ---


// --- Performance Logging ---
export const PERFORMANCE_LOGGING_ENABLED = false; // Set to false to disable logging
export const PERFORMANCE_LOG_INTERVAL_MS = 10000; // Log stats every 10 seconds

// --- SharedArrayBuffer (SAB) Indices ---
export const FRAME_COUNTER_INDEX = 0;
// ... (rest of the file is unchanged)
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

// --- Image Buffer Constants ---
export const HEADER_SIZE = 8;
export const BYTES_PER_PIXEL = 4;

// --- Minimap Specifics ---
export const MINIMAP_WIDTH = 106;
export const MINIMAP_HEIGHT = 109;
export const LANDMARK_SIZE = 3;
/**
 * A pre-computed map for fast lookups of a color's 8-bit palette index.
 * Key: An integer representing an RGB color (e.g., (r << 16) | (g << 8) | b).
 * Value: The 8-bit index from the palette.
 */
export const colorToIndexMap = new Map();
PALETTE_DATA.forEach((color, index) => {
  const intKey = (color.r << 16) | (color.g << 8) | color.b;
  colorToIndexMap.set(intKey, index);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/core.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/core.js
import { parentPort, workerData } from 'worker_threads';
import {
  MinimapMatcher,
  setMinimapResourcesPath,
} from '../../utils/minimapMatcher.js';
import * as config from './config.js';
import { extractBGRA } from './helpers.js';
import { processMinimapData } from './processing.js';
import { LANDMARK_SIZE } from './config.js';

let currentState = null;
let isShuttingDown = false;
let isInitialized = false;
let minimapMatcher = null;
let isProcessing = false;
let needsReProcessing = false;
let dirtyRectsQueue = [];

const { imageSAB, syncSAB } = workerData.sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

async function initialize() {
  console.log('[MinimapCore] Initializing...');
  setMinimapResourcesPath(workerData.paths.minimapResources);

  const LANDMARK_PATTERN_BYTES = Math.ceil((LANDMARK_SIZE * LANDMARK_SIZE) / 2);

  minimapMatcher = new MinimapMatcher({
    LANDMARK_SIZE: LANDMARK_SIZE,
    LANDMARK_PATTERN_BYTES: LANDMARK_PATTERN_BYTES,
  });
  await minimapMatcher.loadMapData();
  isInitialized = true;
  console.log('[MinimapCore] Initialized successfully.');
}

async function performOperation(dirtyRects) {
  if (!isInitialized || !currentState?.regionCoordinates?.regions) {
    return;
  }

  const { minimapFull, minimapFloorIndicatorColumn } =
    currentState.regionCoordinates.regions;
  const screenWidth = Atomics.load(syncArray, config.WIDTH_INDEX);
  if (!minimapFull || !minimapFloorIndicatorColumn || screenWidth <= 0) return;

  const minimapData = extractBGRA(sharedBufferView, screenWidth, minimapFull);
  const floorIndicatorData = extractBGRA(
    sharedBufferView,
    screenWidth,
    minimapFloorIndicatorColumn,
  );

  if (minimapData && floorIndicatorData) {
    await processMinimapData(
      minimapData,
      floorIndicatorData,
      minimapMatcher,
      workerData,
    );
  }
}

async function processFrames() {
  if (isProcessing) {
    needsReProcessing = true;
    return;
  }
  isProcessing = true;

  try {
    while (dirtyRectsQueue.length > 0) {
      const currentDirtyRects = dirtyRectsQueue.shift();
      await performOperation(currentDirtyRects);
    }
  } catch (error) {
    console.error('[MinimapCore] Error during frame processing:', error);
  } finally {
    isProcessing = false;
    if (needsReProcessing) {
      needsReProcessing = false;
      setTimeout(processFrames, 0);
    }
  }
}

function handleMessage(message) {
  if (message.type === 'frame-update') {
    if (message.payload.dirtyRects && message.payload.dirtyRects.length > 0) {
      dirtyRectsQueue.push(message.payload.dirtyRects);
    }
    processFrames();
    return;
  }

  if (message.type === 'shutdown') {
    console.log('[MinimapCore] Received shutdown command.');
    isShuttingDown = true;
  } else if (message.type === 'state_diff') {
    if (!currentState) currentState = {};
    Object.assign(currentState, message.payload);
  } else if (typeof message === 'object' && !message.type) {
    currentState = message;
    if (!isInitialized) {
      initialize().catch((err) => {
        console.error('[MinimapCore] Initialization failed:', err);
        process.exit(1);
      });
    }
  }
}

export function start() {
  console.log('[MinimapCore] Worker starting up.');
  parentPort.on('message', handleMessage);
}
//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/helpers.js
//start file
import { HEADER_SIZE, BYTES_PER_PIXEL } from './config.js';

/**
 * Checks if two rectangle objects intersect.
 * @returns {boolean} True if the rectangles overlap.
 */
export function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

/**
 * Extracts a rectangular region of raw BGRA pixel data from a larger buffer.
 * @param {Buffer} sourceBuffer - The full screen capture buffer.
 * @param {number} sourceWidth - The width of the full screen capture.
 * @param {object} rect - The {x, y, width, height} of the region to extract.
 * @returns {Buffer|null} A new Buffer containing the extracted region, or null on error.
 */
export function extractBGRA(sourceBuffer, sourceWidth, rect) {
  if (!rect || rect.width <= 0 || rect.height <= 0) {
    return null;
  }

  const targetSize = rect.width * rect.height * BYTES_PER_PIXEL;
  const targetBuffer = Buffer.alloc(targetSize);

  for (let y = 0; y < rect.height; y++) {
    const sourceY = rect.y + y;
    const sourceRowStart =
      HEADER_SIZE + (sourceY * sourceWidth + rect.x) * BYTES_PER_PIXEL;
    const targetRowStart = y * rect.width * BYTES_PER_PIXEL;

    if (
      sourceRowStart < 0 ||
      sourceRowStart + rect.width * BYTES_PER_PIXEL > sourceBuffer.length
    ) {
      console.error('[MinimapHelpers] Buffer copy out of bounds.');
      return null;
    }

    sourceBuffer.copy(
      targetBuffer,
      targetRowStart,
      sourceRowStart,
      sourceRowStart + rect.width * BYTES_PER_PIXEL,
    );
  }

  return targetBuffer;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  /**
   * Resets all statistics to their initial state.
   */
  reset() {
    this.times = [];
    this.minTime = Infinity;
    this.maxTime = 0;
    this.totalTime = 0;
  }

  /**
   * Adds a new duration measurement to the tracker.
   * @param {number} duration - The time in milliseconds for an operation.
   */
  addMeasurement(duration) {
    this.times.push(duration);
    this.totalTime += duration;
    if (duration < this.minTime) this.minTime = duration;
    if (duration > this.maxTime) this.maxTime = duration;
  }

  /**
   * Calculates the median from the collected times.
   * @returns {number} The median value.
   */
  _calculateMedian() {
    const sorted = [...this.times].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    }
    return sorted[mid];
  }

  /**
   * Generates a formatted string of the current performance statistics.
   * @returns {string|null} A report string or null if no data is available.
   */
  getReport() {
    const iterations = this.times.length;
    if (iterations === 0) {
      return '[MinimapPerformance] No successful operations in the last period.';
    }

    const avg = this.totalTime / iterations;
    const median = this._calculateMedian();

    const report = [
      '[MinimapPerformance] Stats:',
      `${iterations} iterations |`,
      `Avg: ${avg.toFixed(2)}ms |`,
      `Median: ${median.toFixed(2)}ms |`,
      `Min: ${this.minTime.toFixed(2)}ms |`,
      `Max: ${this.maxTime.toFixed(2)}ms`,
    ].join(' ');

    return report;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/processing.js
//start file
// minimap/processing.js (Updated)

import { parentPort } from 'worker_threads';
import { performance } from 'perf_hooks';
import findSequences from 'find-sequences-native';
import { floorLevelIndicators } from '../../constants/index.js';
import {
  MINIMAP_WIDTH,
  MINIMAP_HEIGHT,
  HEADER_SIZE,
  colorToIndexMap,
} from './config.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
} from '../sharedConstants.js';

let lastWrittenPosition = null;

// Pre-allocate the buffer for minimap processing to avoid re-allocation on every frame.
const minimapIndexData = new Uint8Array(MINIMAP_WIDTH * MINIMAP_HEIGHT);

/**
 * Analyzes minimap and floor indicator data to determine player position.
 * @returns {Promise<number|null>} The processing duration in ms if successful, otherwise null.
 */
export async function processMinimapData(
  minimapBuffer,
  floorIndicatorBuffer,
  minimapMatcher,
  workerData,
) {
  const startTime = performance.now();
  const { playerPosSAB } = workerData;
  const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;

  try {
    const floorIndicatorSearchBuffer = Buffer.alloc(
      HEADER_SIZE + floorIndicatorBuffer.length,
    );
    floorIndicatorSearchBuffer.writeUInt32LE(2, 0);
    floorIndicatorSearchBuffer.writeUInt32LE(63, 4);
    floorIndicatorBuffer.copy(floorIndicatorSearchBuffer, HEADER_SIZE);

    const searchResults = await findSequences.findSequencesNativeBatch(
      floorIndicatorSearchBuffer,
      {
        floor: {
          sequences: floorLevelIndicators,
          searchArea: { x: 0, y: 0, width: 2, height: 63 },
          occurrence: 'first',
        },
      },
    );

    const foundFloor = searchResults.floor || {};
    const floorKey = Object.keys(foundFloor).reduce(
      (lowest, key) =>
        foundFloor[key] !== null && foundFloor[key].y < lowest.y
          ? { key, y: foundFloor[key].y }
          : lowest,
      { key: null, y: Infinity },
    ).key;
    const detectedZ = floorKey !== null ? parseInt(floorKey, 10) : null;

    if (detectedZ === null) return null;

    for (let i = 0; i < minimapIndexData.length; i++) {
      const p = i * 4;
      // BGRA to RGB integer key
      const key =
        (minimapBuffer[p + 2] << 16) |
        (minimapBuffer[p + 1] << 8) |
        minimapBuffer[p];
      minimapIndexData[i] = colorToIndexMap.get(key) ?? 0;
    }

    const result = await minimapMatcher.findPosition(
      minimapIndexData,
      MINIMAP_WIDTH,
      MINIMAP_HEIGHT,
      detectedZ,
    );

    if (result?.position) {
      const newPos = result.position;

      if (
        !lastWrittenPosition ||
        newPos.x !== lastWrittenPosition.x ||
        newPos.y !== lastWrittenPosition.y ||
        newPos.z !== lastWrittenPosition.z
      ) {
        // --- FIX START: Directly update Redux from minimapMonitor ---
        // Post a message to the main thread to update the global Redux store.
        parentPort.postMessage({
          type: 'batch-update',
          payload: [
            {
              type: 'gameState/setPlayerMinimapPosition',
              payload: newPos,
            },
            {
              type: 'gameState/setLastMoveTime',
              payload: Date.now(),
            },
          ],
        });
        // --- FIX END ---

        // Update SharedArrayBuffer for other workers (like targetMonitor) to consume.
        if (playerPosArray) {
          Atomics.store(playerPosArray, PLAYER_X_INDEX, newPos.x);
          Atomics.store(playerPosArray, PLAYER_Y_INDEX, newPos.y);
          Atomics.store(playerPosArray, PLAYER_Z_INDEX, newPos.z);
          Atomics.add(playerPosArray, PLAYER_POS_UPDATE_COUNTER_INDEX, 1);
          Atomics.notify(playerPosArray, PLAYER_POS_UPDATE_COUNTER_INDEX);
        }

        lastWrittenPosition = newPos;
      }

      return performance.now() - startTime;
    }
  } catch (err) {
    console.error(`[MinimapProcessing] Error: ${err.message}`);
  }

  return null;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimapMonitor.js
//start file
/**
 * @file minimap-monitor.js
 * @summary A dedicated worker for analyzing minimap data to determine player position.
 * @description This file is the entry point for the minimap worker. It delegates
 * all logic to the modules in the /minimap sub-directory.
 */

import { start } from './minimap/core.js';

try {
  start();
} catch (error) {
  console.error('[MinimapMonitor] Failed to start worker core:', error);
  process.exit(1);
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/config.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/config.js
// --- MODIFIED ---

import { regionParsers } from './parsers.js';
import regionDefinitions from '../../constants/regionDefinitions.js';

export const MAIN_LOOP_INTERVAL = 5;

export const FRAME_COUNTER_INDEX = 0;
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

export const CHAR_PRESETS = {
  LOWERCASE: 'abcdefghijklmnopqrstuvwxyz',
  UPPERCASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  NUMERIC: '0123456789',
  SPECIAL: `~!@#$%^&*()_+{}|":?><-=[];'./ `,
};
CHAR_PRESETS.ALL =
  CHAR_PRESETS.LOWERCASE +
  CHAR_PRESETS.NUMERIC +
  CHAR_PRESETS.SPECIAL +
  CHAR_PRESETS.UPPERCASE;
CHAR_PRESETS.ALPHA = CHAR_PRESETS.LOWERCASE + CHAR_PRESETS.UPPERCASE;
CHAR_PRESETS.ALPHANUMERIC = CHAR_PRESETS.ALPHA + CHAR_PRESETS.NUMERIC;

export const OCR_REGION_CONFIGS = {
  skillsWidget: {
    colors: regionDefinitions.skillsWidget?.ocrColors,
    parser: regionParsers.skillsWidget,
    storeAction: 'uiValues/setSkillsWidget',
    allowedChars: CHAR_PRESETS.ALPHANUMERIC + ' .:,',
    throttleMs: 250, // NEW
  },
  chatBoxTabRow: {
    colors: regionDefinitions.chatBoxTabRow?.ocrColors,
    parser: regionParsers.chatBoxTabRow,
    storeAction: 'uiValues/setChatTabs',
    allowedChars: CHAR_PRESETS.ALPHA + ' ',
    throttleMs: 500, // NEW
  },
  selectCharacterModal: {
    colors: regionDefinitions.selectCharacterModal?.ocrColors,
    parser: regionParsers.selectCharacterModal,
    storeAction: 'uiValues/setSelectCharacterModal',
    allowedChars: CHAR_PRESETS.ALPHA + ' ',
    throttleMs: 100, // NEW
  },
  vipWidget: {
    colors: regionDefinitions.vipWidget?.ocrColors,
    parser: regionParsers.vipWidget,
    storeAction: 'uiValues/setVipWidget',
    allowedChars: CHAR_PRESETS.ALPHA + ' ',
    throttleMs: 2000, // NEW
  },
  // REMOVED BATTLE LIST FROM GENERIC CONFIG
  gameWorld: {
    colors: regionDefinitions.gameWorld?.ocrColors,
    parser: regionParsers.gameWorld,
    storeAction: 'ocr/setOcrRegionsText',
    allowedChars: CHAR_PRESETS.ALPHA + ' ',
    throttleMs: 0, // NEW
  },
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/core.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/core.js
// --- REFACTORED ---

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import * as config from './config.js';
import {
  rectsIntersect,
  processOcrRegions,
  processBattleListOcr, // Import the new dedicated function
} from './processing.js';

// --- Worker Configuration & Setup ---
const { sharedData } = workerData;
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

// --- State ---
let currentState = null;
let isShuttingDown = false;
let isInitialized = false;
let lastProcessedFrameCounter = -1;
let lastRegionHash = null;
let oneTimeInitializedRegions = new Set();
const pendingThrottledRegions = new Map();

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function hashRegionCoordinates(regionCoordinates) {
  if (!regionCoordinates || typeof regionCoordinates !== 'object') {
    return JSON.stringify(regionCoordinates);
  }
  const replacer = (key, value) =>
    value instanceof Object && !(value instanceof Array)
      ? Object.keys(value)
          .sort()
          .reduce((sorted, key) => {
            sorted[key] = value[key];
            return sorted;
          }, {})
      : value;
  return JSON.stringify(regionCoordinates, replacer);
}

async function processPendingRegions() {
  if (pendingThrottledRegions.size === 0) return;
  const now = Date.now();
  const regionsToProcessNow = new Set();
  for (const [regionKey, startTime] of pendingThrottledRegions.entries()) {
    const regionConfig = config.OCR_REGION_CONFIGS[regionKey];
    if (now - startTime >= (regionConfig.throttle || 0)) {
      regionsToProcessNow.add(regionKey);
    }
  }
  if (regionsToProcessNow.size > 0) {
    await processOcrRegions(
      sharedBufferView,
      currentState.regionCoordinates.regions,
      regionsToProcessNow,
    );
    for (const regionKey of regionsToProcessNow) {
      pendingThrottledRegions.delete(regionKey);
    }
  }
}

async function performOperation() {
  try {
    if (!isInitialized || !currentState || !currentState.regionCoordinates)
      return;

    const newFrameCounter = Atomics.load(syncArray, config.FRAME_COUNTER_INDEX);
    if (
      newFrameCounter <= lastProcessedFrameCounter ||
      Atomics.load(syncArray, config.IS_RUNNING_INDEX) !== 1
    ) {
      return;
    }

    const width = Atomics.load(syncArray, config.WIDTH_INDEX);
    const height = Atomics.load(syncArray, config.HEIGHT_INDEX);
    const { regions } = currentState.regionCoordinates;
    if (Object.keys(regions).length === 0 || width <= 0 || height <= 0) return;

    lastProcessedFrameCounter = newFrameCounter;

    const dirtyRegionCount = Atomics.load(
      syncArray,
      config.DIRTY_REGION_COUNT_INDEX,
    );
    const dirtyRects = [];
    for (let i = 0; i < dirtyRegionCount; i++) {
      const offset = config.DIRTY_REGIONS_START_INDEX + i * 4;
      dirtyRects.push({
        x: Atomics.load(syncArray, offset + 0),
        y: Atomics.load(syncArray, offset + 1),
        width: Atomics.load(syncArray, offset + 2),
        height: Atomics.load(syncArray, offset + 3),
      });
    }

    const processingTasks = [];
    const immediateGenericRegions = new Set();

    // --- MODIFIED LOGIC ---
    // 1. Handle Battle List with its dedicated, specialized processor first.
    if (regions.battleList) {
      const isDirty = dirtyRects.some((dirtyRect) =>
        rectsIntersect(regions.battleList, dirtyRect),
      );
      if (isDirty || !oneTimeInitializedRegions.has('battleList')) {
        processingTasks.push(processBattleListOcr(sharedBufferView, regions));
        oneTimeInitializedRegions.add('battleList');
      }
    }

    // 2. Handle all other generic OCR regions.
    for (const regionKey in config.OCR_REGION_CONFIGS) {
      const region = regions[regionKey];
      if (!region) continue;

      const isDirty = dirtyRects.some((dirtyRect) =>
        rectsIntersect(region, dirtyRect),
      );
      const needsOneTimeInit = !oneTimeInitializedRegions.has(regionKey);

      if (isDirty || needsOneTimeInit) {
        const regionConfig = config.OCR_REGION_CONFIGS[regionKey];
        if (regionConfig.throttle && !needsOneTimeInit) {
          if (!pendingThrottledRegions.has(regionKey)) {
            pendingThrottledRegions.set(regionKey, Date.now());
          }
        } else {
          immediateGenericRegions.add(regionKey);
          if (needsOneTimeInit) {
            oneTimeInitializedRegions.add(regionKey);
          }
        }
      }
    }

    if (immediateGenericRegions.size > 0) {
      processingTasks.push(
        processOcrRegions(sharedBufferView, regions, immediateGenericRegions),
      );
    }
    // --- END MODIFICATION ---

    if (processingTasks.length > 0) {
      await Promise.all(processingTasks);
    }
  } catch (error) {
    console.error('[OcrCore] Error in operation:', error);
  }
}

async function mainLoop() {
  console.log('[OcrCore] Starting main loop...');
  while (!isShuttingDown) {
    const loopStart = performance.now();
    if (isInitialized) {
      await performOperation();
      await processPendingRegions();
    }
    const elapsedTime = performance.now() - loopStart;
    const delayTime = Math.max(0, config.MAIN_LOOP_INTERVAL - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  console.log('[OcrCore] Main loop stopped.');
}

function handleMessage(message) {
  try {
    if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      const payload = message.payload;
      if (payload.regionCoordinates) {
        const newHash = hashRegionCoordinates(payload.regionCoordinates);
        if (newHash !== lastRegionHash) {
          lastRegionHash = newHash;
          oneTimeInitializedRegions.clear();
        }
      }
      Object.assign(currentState, payload);
    } else if (message.type === 'shutdown') {
      isShuttingDown = true;
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
      lastRegionHash = hashRegionCoordinates(message.regionCoordinates || {});
      oneTimeInitializedRegions.clear();
      if (!isInitialized) {
        isInitialized = true;
        console.log('[OcrCore] Initial state received. Worker is now active.');
      }
    }
  } catch (error) {
    console.error('[OcrCore] Error handling message:', error);
  }
}

export async function start() {
  console.log('[OcrCore] Worker starting up...');
  if (!workerData?.sharedData) {
    throw new Error('[OcrCore] Shared data not provided');
  }
  parentPort.on('message', handleMessage);
  mainLoop().catch((error) => {
    console.error('[OcrCore] Fatal error in main loop:', error);
    process.exit(1);
  });
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/parsers.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/parsers.js
// --- MODIFIED ---

/**
 * @file parsers.js
 * @summary The single source of truth for parsing all OCR data.
 * @description This module contains powerful parsers that transform raw OCR text
 * into the final, structured objects ready for the Redux state.
 */

function timeStringToMinutes(timeStr) {
  if (typeof timeStr !== 'string') {
    return null;
  }
  const normalizedTime = timeStr.replace('.', ':');
  const parts = normalizedTime.split(':');
  if (parts.length !== 2) return null;
  const hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);
  if (isNaN(hours) || isNaN(minutes)) return null;
  return hours * 60 + minutes;
}

function parseSkillsWidget(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0) return null;
  const result = {};
  const skills = {};
  const combat = {};
  const validData = ocrData.filter(
    (item) =>
      item.text &&
      item.text.trim() &&
      !item.text.match(/^[-\s]*$/) &&
      item.text !== 'alue',
  );
  const rows = new Map();
  validData.forEach((item) => {
    let rowKey = Array.from(rows.keys()).find(
      (key) => Math.abs(item.y - key) <= 5,
    );
    if (rowKey === undefined) rowKey = item.y;
    if (!rows.has(rowKey)) rows.set(rowKey, []);
    rows.get(rowKey).push(item);
  });
  Array.from(rows.values()).forEach((row) => {
    row.sort((a, b) => a.x - b.x);
    for (let i = 0; i < row.length - 1; i++) {
      const label = row[i].text.trim().toLowerCase();
      const value = row[i + 1]?.text?.trim();
      if (!value) continue;
      switch (label) {
        case 'level':
          result.level = parseInt(value) || null;
          break;
        case 'experience':
          result.experience = parseInt(value.replace(/,/g, '')) || null;
          break;
        case 'xp gain rate':
          result.xpGainRate = parseFloat(value.replace('%', '')) || null;
          break;
        case 'hit points':
          result.hitPoints = parseInt(value) || null;
          break;
        case 'mana':
          result.mana = parseInt(value) || null;
          break;
        case 'soul points':
          result.soulPoints = parseInt(value) || null;
          break;
        case 'capacity':
          result.capacity = parseInt(value.replace(/,/g, '')) || null;
          break;
        case 'speed':
          result.speed = parseInt(value) || null;
          break;
        case 'food':
          result.food = timeStringToMinutes(value);
          break;
        case 'stamina':
          result.stamina = timeStringToMinutes(value);
          break;
        case 'offline training':
          result.offlineTraining = value;
          break;
        case 'magic':
          skills.magic = parseInt(value) || null;
          break;
        case 'fist':
          skills.fist = parseInt(value) || null;
          break;
        case 'club':
          skills.club = parseInt(value) || null;
          break;
        case 'sword':
          skills.sword = parseInt(value) || null;
          break;
        case 'axe':
          skills.axe = parseInt(value) || null;
          break;
        case 'distance':
          skills.distance = parseInt(value) || null;
          break;
        case 'shielding':
          skills.shielding = parseInt(value) || null;
          break;
        case 'fishing':
          skills.fishing = parseInt(value) || null;
          break;
        case 'damage/healing':
          combat.damageHealing = parseInt(value) || null;
          break;
        case 'attack':
          if (value.endsWith('V'))
            combat.attack = parseInt(value.replace('V', '')) || null;
          break;
        case 'defence':
          if (value.endsWith('V'))
            combat.defence = parseInt(value.replace('V', '')) || null;
          break;
        case 'armor':
          if (value.endsWith('V'))
            combat.armor = parseInt(value.replace('V', '')) || null;
          break;
        case 'mantra':
          if (value.endsWith('V'))
            combat.mantra = parseInt(value.replace('V', '')) || null;
          break;
        case 'mitigation':
          if (value.includes('%'))
            combat.mitigation = parseFloat(value.replace(/[+%]/g, '')) || null;
          break;
      }
    }
  });
  return { ...result, skills, combat };
}

function parseChatData(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0) return [];
  return ocrData.filter((item) => item && typeof item === 'object');
}

function parseChatBoxTabRow(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { activeTab: null, tabs: {} };
  const tabs = {};
  let activeTab = null;
  ocrData.forEach((item) => {
    const tabName = item.text.trim();
    if (!tabName) return;
    tabs[tabName] = {
      tabName,
      tabPosition: { x: item.click.x, y: item.click.y },
      originalPosition: { x: item.x, y: item.y },
    };
    if (
      item.color &&
      item.color.r === 223 &&
      item.color.g === 223 &&
      item.color.b === 223
    ) {
      activeTab = tabName;
    }
  });
  return { activeTab, tabs };
}

function parseSelectCharacterModal(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { selectedCharacter: null, characters: {}, accountStatus: null };
  const characters = {};
  let selectedCharacter = null;
  let accountStatus = null;
  ocrData.forEach((item) => {
    const text = item.text.trim();
    if (!text) return;
    if (text.includes('Account Status:')) {
      const nextItem = ocrData.find(
        (next) => next.y > item.y && Math.abs(next.x - item.x) < 50,
      );
      if (nextItem) accountStatus = nextItem.text.trim();
      return;
    }
    if (text === 'Free Account' || text === 'Premium Account') {
      if (!accountStatus) accountStatus = text;
      return;
    }
    const characterName = text.replace(/(?!^)(?<!\s)([A-Z])/g, ' $1');
    characters[characterName] = {
      name: characterName,
      position: { x: item.click.x, y: item.click.y },
      originalPosition: { x: item.x, y: item.y },
      color: item.color,
    };
    if (
      item.color &&
      item.color.r === 244 &&
      item.color.g === 244 &&
      item.color.b === 244
    ) {
      selectedCharacter = characterName;
    }
  });
  return { selectedCharacter, characters, accountStatus };
}

function parseVipWidget(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { online: [], offline: [] };
  const online = [];
  const offline = [];
  ocrData.forEach((item) => {
    if (!item?.text) return;
    const isOnline =
      item.color &&
      item.color.r === 96 &&
      item.color.g === 248 &&
      item.color.b === 96;
    if (isOnline) online.push(item.text);
    else offline.push(item.text);
  });
  online.sort((a, b) => a.localeCompare(b));
  offline.sort((a, b) => a.localeCompare(b));
  return { online, offline };
}

function parseGameWorldOcr(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0) return [];
  return ocrData.filter((item) => {
    if (
      !item ||
      typeof item !== 'object' ||
      !item.text ||
      typeof item.text !== 'string'
    ) {
      return false;
    }
    const text = item.text.trim();
    // Exclude entries that start with lowercase letters
    if (
      text.length > 0 &&
      text[0] === text[0].toLowerCase() &&
      text[0].match(/[a-z]/i)
    ) {
      return false;
    }
    // Exclude entries that length is shorter than 3 letters
    if (text.length < 3) {
      return false;
    }
    return true;
  });
}

export const regionParsers = {
  skillsWidget: parseSkillsWidget,
  chatboxMain: parseChatData,
  chatboxSecondary: parseChatData,
  chatBoxTabRow: parseChatBoxTabRow,
  selectCharacterModal: parseSelectCharacterModal,
  vipWidget: parseVipWidget,
  gameWorld: parseGameWorldOcr,
  // REMOVED battleList parser
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report OCR performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  reset() {
    this.operationTimes = [];
    this.totalOperationTime = 0;
    this.regionsProcessedCounts = [];
    this.totalRegionsProcessed = 0;
  }

  /**
   * Adds a new measurement from a single performOperation cycle.
   * @param {number} duration - The time in milliseconds for the operation.
   * @param {number} regionCount - The number of regions processed in the operation.
   */
  addMeasurement(duration, regionCount) {
    this.operationTimes.push(duration);
    this.totalOperationTime += duration;
    this.regionsProcessedCounts.push(regionCount);
    this.totalRegionsProcessed += regionCount;
  }

  getReport() {
    const operationCount = this.operationTimes.length;
    if (operationCount === 0) {
      return '[OcrPerformance] No OCR operations in the last period.';
    }

    const avgOpTime = this.totalOperationTime / operationCount;
    const maxOpTime = Math.max(...this.operationTimes);
    const avgRegions = this.totalRegionsProcessed / operationCount;

    const report = [
      '[OcrPerformance] Stats:',
      `${operationCount} ops |`,
      `Avg Time: ${avgOpTime.toFixed(2)}ms |`,
      `Max Time: ${maxOpTime.toFixed(2)}ms |`,
      `Avg Regions/Op: ${avgRegions.toFixed(1)}`,
    ].join(' ');

    return report;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/processing.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/processing.js
// --- CORRECTED ---

import { parentPort } from 'worker_threads';
import pkg from 'font-ocr';
import { OCR_REGION_CONFIGS, CHAR_PRESETS } from './config.js';
import regionDefinitions from '../../constants/regionDefinitions.js';

const { recognizeText, findText } = pkg;
const lastPostedResults = new Map();

// --- UTILITIES ---

export function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

function postUpdateOnce(type, payload) {
  const key = type;
  const prev = lastPostedResults.get(key);
  const payloadString = JSON.stringify(payload);

  if (prev === payloadString) return;

  lastPostedResults.set(key, payloadString);
  parentPort.postMessage({
    storeUpdate: true,
    type,
    payload,
  });
}

// --- SPECIALIZED REGION PROCESSORS ---

/**
 * Performs a single, bulk OCR scan on the battle list and dispatches the final
 * list of creature names directly to the battleList slice.
 */
export async function processBattleListOcr(buffer, regions) {
  const entriesRegion = regions.battleList?.children?.entries;
  if (!entriesRegion || entriesRegion.height <= 0) {
    // --- CORRECTED ACTION TYPE ---
    postUpdateOnce('battleList/setBattleListEntries', []);
    return;
  }

  try {
    const ocrConfig = {
      colors: regionDefinitions.battleList?.ocrColors || [],
      allowedChars: CHAR_PRESETS.ALPHA + ' ',
    };

    const ocrResults =
      recognizeText(
        buffer,
        entriesRegion,
        ocrConfig.colors,
        ocrConfig.allowedChars,
      ) || [];

    // Create a simple array of names, sorted by their vertical position.
    const creatureNames = ocrResults
      .sort((a, b) => a.y - b.y)
      .map((result) => result.text.trim())
      .filter(Boolean);

    // --- CORRECTED ACTION TYPE ---
    // This now correctly matches the reducer in battleListSlice.js
    postUpdateOnce('battleList/setBattleListEntries', creatureNames);
  } catch (ocrError) {
    console.error(
      '[OcrProcessing] OCR failed for battleList region:',
      ocrError,
    );
  }
}

/**
 * Processes the player list region to extract player names.
 */
export async function processPlayerList(buffer, regions) {
  const playerListRegion = regions.playerList;
  if (
    !playerListRegion ||
    !playerListRegion.x ||
    !playerListRegion.y ||
    playerListRegion.width <= 0 ||
    playerListRegion.height <= 0
  ) {
    postUpdateOnce('uiValues/setPlayers', []);
    return;
  }

  try {
    const playerOcrColors = regionDefinitions.playerList?.ocrColors || [];
    const allowedCharsForPlayerList = CHAR_PRESETS.ALPHA + ' ';

    const ocrResults =
      recognizeText(
        buffer,
        playerListRegion,
        playerOcrColors,
        allowedCharsForPlayerList,
      ) || [];

    const playerNames = ocrResults
      .map((result) => result.text.trim())
      .filter((name) => name.length > 0);

    postUpdateOnce('uiValues/setPlayers', playerNames);
  } catch (ocrError) {
    console.error(
      '[OcrProcessing] OCR failed for playerList entries:',
      ocrError,
    );
  }
}

// --- GENERIC OCR REGION PROCESSING ---

export async function processOcrRegions(buffer, regions, regionKeys) {
  const ocrRawUpdates = {};
  const processingPromises = [];

  if (regionKeys.has('playerList')) {
    processingPromises.push(processPlayerList(buffer, regions));
  }

  for (const regionKey of regionKeys) {
    if (regionKey === 'playerList') continue;

    const cfg = OCR_REGION_CONFIGS[regionKey];
    const region = regions[regionKey];
    if (!region || !cfg) continue;

    const processRegion = async () => {
      try {
        let rawData = [];
        const colors = cfg.colors || [];

        if (cfg.dictionary && Array.isArray(cfg.dictionary)) {
          rawData = findText(buffer, region, colors, cfg.dictionary) || [];
        } else {
          rawData =
            recognizeText(buffer, region, colors, cfg.allowedChars) || [];
        }

        if (regionKey === 'gameWorld') {
          ocrRawUpdates[regionKey] = rawData;
        }

        if (cfg.parser && cfg.storeAction.startsWith('uiValues/')) {
          const parsedData = cfg.parser(rawData);
          if (parsedData) {
            postUpdateOnce(cfg.storeAction, parsedData);
          }
        }
      } catch (ocrError) {
        console.error(`[OcrProcessing] OCR failed for ${regionKey}:`, ocrError);
      }
    };

    processingPromises.push(processRegion());
  }

  await Promise.all(processingPromises);

  if (Object.keys(ocrRawUpdates).length > 0) {
    postUpdateOnce('ocr/setOcrRegionsText', ocrRawUpdates);
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocrWorker.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocrWorker.js
// --- UNCHANGED ---

import { workerData } from 'worker_threads';
import { start } from './ocr/core.js';
import { IS_RUNNING_INDEX } from './ocr/config.js';

start().catch((err) => {
  console.error(
    '[OcrWorker] A fatal, unhandled error occurred during startup:',
    err,
  );

  try {
    const { sharedData } = workerData;
    if (sharedData?.syncSAB) {
      const syncArray = new Int32Array(sharedData.syncSAB);
      Atomics.store(syncArray, IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, IS_RUNNING_INDEX);
      console.log(
        '[OcrWorker] Successfully signaled shutdown to other workers.',
      );
    } else {
      console.error(
        '[OcrWorker] Could not signal shutdown: sharedData or syncSAB not available.',
      );
    }
  } catch (e) {
    console.error(
      '[OcrWorker] An error occurred while trying to signal shutdown:',
      e,
    );
  }

  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/config.js
//start file
import path from 'path';

// --- Performance Logging ---
export const PERFORMANCE_LOGGING_ENABLED = true;
export const PERFORMANCE_LOG_INTERVAL_MS = 10000;

// --- File Paths ---
export const PREPROCESSED_BASE_DIR = path.join(
  process.cwd(),
  'resources',
  'preprocessed_minimaps',
);

console.log('PREPROCESSED_BASE_DIR:', process.cwd());
// --- Logic Constants ---
// Maps a waypoint type to the type of special avoidance area it should respect.
export const WAYPOINT_AVOIDANCE_MAP = {
  Node: 'cavebot',
  Stand: 'cavebot',
  Ladder: 'cavebot',
  Script: 'cavebot',
  Lure: 'targeting',
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/core.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/core.js

import { parentPort, workerData } from 'worker_threads';
import Pathfinder from 'pathfinder-native';
import { createLogger } from '../../utils/logger.js';
import * as config from './config.js';
import { loadAllMapData } from './dataLoader.js';
import { runPathfindingLogic } from './logic.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
} from '../sharedConstants.js';

const logger = createLogger({ info: true, error: true, debug: false });

let state = null;
let pathfinderInstance = null;

const logicContext = {
  lastPlayerPosKey: null,
  lastTargetWptId: null,
  lastJsonForType: new Map(),
  lastCreatureDataHash: null, // NEW: Cache based on creature data hash
};

const { playerPosSAB, pathDataSAB } = workerData; // creaturePosSAB is removed
const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const pathDataArray = pathDataSAB ? new Int32Array(pathDataSAB) : null;

const REDUX_UPDATE_INTERVAL_MS = 25;
let lastReduxUpdateTime = 0;
let reduxUpdateTimeout = null;
let pendingReduxUpdatePayload = null;

function postThrottledUpdate() {
  if (pendingReduxUpdatePayload) {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'pathfinder/setPathfindingFeedback',
      payload: pendingReduxUpdatePayload,
    });
    lastReduxUpdateTime = Date.now();
    pendingReduxUpdatePayload = null;
  }
  if (reduxUpdateTimeout) {
    clearTimeout(reduxUpdateTimeout);
    reduxUpdateTimeout = null;
  }
}

function throttleReduxUpdate(payload) {
  pendingReduxUpdatePayload = payload;
  const now = Date.now();
  const timeSinceLastUpdate = now - lastReduxUpdateTime;
  if (timeSinceLastUpdate >= REDUX_UPDATE_INTERVAL_MS) {
    postThrottledUpdate();
  } else if (!reduxUpdateTimeout) {
    reduxUpdateTimeout = setTimeout(
      postThrottledUpdate,
      REDUX_UPDATE_INTERVAL_MS - timeSinceLastUpdate,
    );
  }
}

function handleMessage(message) {
  try {
    if (message.type === 'state_diff') {
      state = { ...state, ...message.payload };
    } else if (message.type === undefined) {
      state = message;
    } else if (message.type === 'shutdown') {
      if (reduxUpdateTimeout) clearTimeout(reduxUpdateTimeout);
      return;
    } else {
      return;
    }

    if (!state || !state.gameState || !state.targeting || !state.cavebot) {
      // Ensure necessary slices exist
      return;
    }

    // NEW: Guard against running pathfinder if both modules are disabled
    if (pathDataArray && !state.cavebot.enabled && !state.targeting.enabled) {
      // If pathfinder is already idle, no need to update SAB again.
      if (
        Atomics.load(pathDataArray, PATHFINDING_STATUS_INDEX) ===
        PATH_STATUS_IDLE
      ) {
        return;
      }
      // Set status to idle and update counter to notify consumers.
      Atomics.store(pathDataArray, PATHFINDING_STATUS_INDEX, PATH_STATUS_IDLE);
      Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0);
      Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
      return;
    }

    let playerMinimapPosition = null;
    if (playerPosArray) {
      playerMinimapPosition = {
        x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
      };
    } else {
      playerMinimapPosition = state.gameState.playerMinimapPosition;
    }

    if (!playerMinimapPosition || typeof playerMinimapPosition.x !== 'number') {
      return;
    }

    // REMOVED: All logic reading from creaturePosSAB is gone.

    const synchronizedState = {
      ...state,
      gameState: { ...state.gameState, playerMinimapPosition },
    };

    runPathfindingLogic({
      logicContext: logicContext,
      state: synchronizedState,
      pathfinderInstance,
      logger,
      pathDataArray,
      throttleReduxUpdate,
    });

  } catch (error) {
    logger(
      'error',
      '[PathfinderCore] Unhandled error in message handler:',
      error,
    );
  }
}

export async function start() {
  logger('info', 'Pathfinder worker starting up...');
  try {
    pathfinderInstance = new Pathfinder.Pathfinder();
    logger('info', 'Native Pathfinder addon loaded successfully.');
    loadAllMapData(pathfinderInstance, logger);
  } catch (err) {
    logger(
      'error',
      `Pathfinder worker fatal error on startup: ${err.message}`,
      err,
    );
    if (parentPort) {
      parentPort.postMessage({
        fatalError: err.message || 'Unknown fatal error in worker',
      });
    }
    process.exit(1);
  }
  parentPort.on('message', handleMessage);
  parentPort.on('close', () => {
    logger('info', 'Parent port closed. Stopping pathfinder worker.');
    process.exit(0);
  });
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/dataLoader.js
//start file
import fs from 'fs';
import path from 'path';
import { PREPROCESSED_BASE_DIR } from './config.js';

/**
 * Reads all preprocessed map data from disk and loads it into the pathfinder instance.
 * @param {object} pathfinderInstance - The native Pathfinder addon instance.
 * @param {function} logger - The logger utility.
 */
export function loadAllMapData(pathfinderInstance, logger) {
  if (pathfinderInstance.isLoaded) return;

  logger('info', 'Loading pathfinding data for all Z-levels...');
  const mapDataForAddon = {};
  try {
    const zLevelDirs = fs
      .readdirSync(PREPROCESSED_BASE_DIR, { withFileTypes: true })
      .filter((d) => d.isDirectory() && d.name.startsWith('z'))
      .map((d) => d.name);

    for (const zDir of zLevelDirs) {
      const zLevel = parseInt(zDir.substring(1), 10);
      const zLevelPath = path.join(PREPROCESSED_BASE_DIR, zDir);
      try {
        const metadata = JSON.parse(
          fs.readFileSync(path.join(zLevelPath, 'walkable.json'), 'utf8'),
        );
        const grid = fs.readFileSync(path.join(zLevelPath, 'walkable.bin'));
        mapDataForAddon[zLevel] = { ...metadata, grid };
      } catch (e) {
        if (e.code !== 'ENOENT') {
          logger(
            'warn',
            `Could not load pathfinding data for Z=${zLevel}: ${e.message}`,
          );
        }
      }
    }

    pathfinderInstance.loadMapData(mapDataForAddon);

    if (pathfinderInstance.isLoaded) {
      logger(
        'info',
        'Pathfinding data successfully loaded into native module.',
      );
    } else {
      throw new Error(
        'Failed to load data into native module after reading files.',
      );
    }
  } catch (e) {
    logger('error', `Critical error during map data loading: ${e.message}`);
    throw e; // Re-throw to be caught by the worker's main error handler
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/logic.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/logic.js
// --- Full file with fix for controlState logic ---

import {
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_WAYPOINTS_START_INDEX,
  PATH_WAYPOINT_SIZE,
  MAX_PATH_WAYPOINTS,
  PATH_CHEBYSHEV_DISTANCE_INDEX,
  PATH_START_X_INDEX,
  PATH_START_Y_INDEX,
  PATH_START_Z_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
  PATH_STATUS_PATH_FOUND,
  PATH_STATUS_WAYPOINT_REACHED,
  PATH_STATUS_NO_PATH_FOUND,
  PATH_STATUS_DIFFERENT_FLOOR,
  PATH_STATUS_ERROR,
  PATH_STATUS_NO_VALID_START_OR_END,
} from '../sharedConstants.js';

let lastWrittenPathSignature = '';

function hashCreatureData(creatures) {
  if (!creatures || creatures.length === 0) return 0;
  const first = creatures[0].gameCoords;
  const last = creatures[creatures.length - 1].gameCoords;
  return (
    creatures.length ^
    (first.x << 8) ^
    (first.y << 16) ^
    (last.x << 4) ^
    (last.y << 24)
  );
}

export function runPathfindingLogic(context) {
  const {
    logicContext,
    state,
    pathfinderInstance,
    logger,
    pathDataArray,
    throttleReduxUpdate,
  } = context;

  try {
    const { cavebot, gameState, targeting } = state;
    const { playerMinimapPosition } = gameState;

    if (!playerMinimapPosition) {
      return;
    }

    const { x, y, z } = playerMinimapPosition;
    if (
      typeof x !== 'number' ||
      typeof y !== 'number' ||
      typeof z !== 'number'
    ) {
      logger('error', `Invalid player position: {x: ${x}, y: ${y}, z: ${z}}`);
      return;
    }

    const creaturePositions = (targeting.creatures || []).map(
      (c) => c.gameCoords,
    );

    // --- NEW: Implicit Mode Detection ---
    // Instead of reading a mode flag, we infer the mode from the available data.
    // If a dynamicTarget exists, we are in 'targeting' mode. Otherwise, 'cavebot' mode.
    const isTargetingMode = !!cavebot.dynamicTarget;
    const effectiveMode = isTargetingMode ? 'targeting' : 'cavebot';

    let result = null;
    let targetIdentifier = null;

    const allSpecialAreas = state.cavebot?.specialAreas || [];
    const activeSpecialAreas = allSpecialAreas.filter((area) => {
      if (!area.enabled) return false;
      // 'all' type areas are always active.
      // Otherwise, the area type must match the current effective mode.
      return area.type === 'all' || area.type === effectiveMode;
    });

    const currentJson = JSON.stringify(activeSpecialAreas);
    if (currentJson !== logicContext.lastJsonForType.get(effectiveMode)) {
      const areasForNative = activeSpecialAreas.map((area) => ({
        x: area.x,
        y: area.y,
        z: area.z,
        avoidance: area.avoidance,
        width: area.sizeX,
        height: area.sizeY,
      }));
      pathfinderInstance.updateSpecialAreas(areasForNative, z);
      logicContext.lastJsonForType.set(effectiveMode, currentJson);
    }

    if (isTargetingMode) {
      targetIdentifier = JSON.stringify(cavebot.dynamicTarget);
    } else if (cavebot.wptId) {
      // Cavebot mode
      const { waypointSections, currentSection, wptId } = cavebot;
      const targetWaypoint = waypointSections[currentSection]?.waypoints.find(
        (wp) => wp.id === wptId,
      );
      if (targetWaypoint) {
        targetIdentifier = targetWaypoint.id;
      }
    }

    const currentPosKey = `${x},${y},${z}`;
    const currentCreatureDataHash = hashCreatureData(targeting.creatures);

    if (
      logicContext.lastPlayerPosKey === currentPosKey &&
      logicContext.lastTargetWptId === targetIdentifier &&
      logicContext.lastCreatureDataHash === currentCreatureDataHash
    ) {
      return; // No change in inputs, skip pathfinding.
    }

    logicContext.lastPlayerPosKey = currentPosKey;
    logicContext.lastTargetWptId = targetIdentifier;
    logicContext.lastCreatureDataHash = currentCreatureDataHash;

    if (isTargetingMode) {
      const targetInstanceId = cavebot.dynamicTarget.targetInstanceId;

      if (!targetInstanceId) {
        // Fallback for old dynamicTarget format, but still solve Problem B.
        const obstacles = creaturePositions.filter((pos) => {
          return (
            pos.x !== cavebot.dynamicTarget.targetCreaturePos.x ||
            pos.y !== cavebot.dynamicTarget.targetCreaturePos.y ||
            pos.z !== cavebot.dynamicTarget.targetCreaturePos.z
          );
        });
        result = pathfinderInstance.findPathToGoal(
          playerMinimapPosition,
          cavebot.dynamicTarget,
          obstacles,
        );
      } else {
        const targetCreature = (targeting.creatures || []).find(
          (c) => c.instanceId === targetInstanceId,
        );

        if (targetCreature) {
          // State is consistent, target found. Use its fresh position.
          const correctedDynamicTarget = {
            ...cavebot.dynamicTarget,
            targetCreaturePos: targetCreature.gameCoords,
          };

          // Filter the fresh position from the list of obstacles.
          const obstacles = creaturePositions.filter((pos) => {
            return (
              pos.x !== correctedDynamicTarget.targetCreaturePos.x ||
              pos.y !== correctedDynamicTarget.targetCreaturePos.y ||
              pos.z !== correctedDynamicTarget.targetCreaturePos.z
            );
          });

          result = pathfinderInstance.findPathToGoal(
            playerMinimapPosition,
            correctedDynamicTarget,
            obstacles,
          );
        } else {
          // Target has disappeared. Path to its last known position.
          // `creaturePositions` is already correct (doesn't contain the disappeared target).
          result = pathfinderInstance.findPathToGoal(
            playerMinimapPosition,
            cavebot.dynamicTarget,
            creaturePositions,
          );
        }
      }
    } else if (targetIdentifier) {
      // Cavebot mode with a valid waypoint
      const { waypointSections, currentSection, wptId } = cavebot;
      const targetWaypoint = waypointSections[currentSection]?.waypoints.find(
        (wp) => wp.id === wptId,
      );
      if (targetWaypoint) {
        if (z !== targetWaypoint.z) {
          throttleReduxUpdate({
            pathWaypoints: [],
            wptDistance: null,
            pathfindingStatus: 'DIFFERENT_FLOOR',
          });
          if (pathDataArray) {
            Atomics.store(
              pathDataArray,
              PATHFINDING_STATUS_INDEX,
              PATH_STATUS_DIFFERENT_FLOOR,
            );
            Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0);
            Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
          }
          return;
        }
        result = pathfinderInstance.findPathSync(
          playerMinimapPosition,
          { x: targetWaypoint.x, y: targetWaypoint.y, z: targetWaypoint.z },
          creaturePositions,
        );
      }
    }

    if (targetIdentifier && !result) {
      result = {
        path: [],
        reason: 'NO_PATH_FOUND'
      };
    }

    if (!result) {
      if (pathDataArray) {
        Atomics.store(
          pathDataArray,
          PATHFINDING_STATUS_INDEX,
          PATH_STATUS_IDLE,
        );
        Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0);
        Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
      }
      return;
    }

    const rawPath = result.path || [];
    const statusString = result.reason;

    const normalizedPath = Array.isArray(rawPath) ? rawPath.slice() : [];
    

    let statusCode = PATH_STATUS_IDLE;
    switch (statusString) {
      case 'PATH_FOUND':
        statusCode = PATH_STATUS_PATH_FOUND;
        break;
      case 'WAYPOINT_REACHED':
        statusCode = PATH_STATUS_WAYPOINT_REACHED;
        break;
      case 'NO_PATH_FOUND':
        statusCode = PATH_STATUS_NO_PATH_FOUND;
        break;
      case 'NO_VALID_START':
      case 'NO_VALID_END':
        statusCode = PATH_STATUS_NO_VALID_START_OR_END;
        break;
      default:
        statusCode = PATH_STATUS_ERROR;
        break;
    }

    const pathSignature = `${statusCode}:${normalizedPath.map((p) => `${p.x},${p.y}`).join(';')}`;
    if (pathSignature !== lastWrittenPathSignature) {
      if (pathDataArray) {
        const pathLength = Math.min(normalizedPath.length, MAX_PATH_WAYPOINTS);
        const targetX =
          normalizedPath.length > 0
            ? normalizedPath[normalizedPath.length - 1].x
            : x;
        const targetY =
          normalizedPath.length > 0
            ? normalizedPath[normalizedPath.length - 1].y
            : y;
        const chebyshevDistance = Math.max(
          Math.abs(x - targetX),
          Math.abs(y - targetY),
        );

        Atomics.store(pathDataArray, PATH_LENGTH_INDEX, pathLength);
        Atomics.store(
          pathDataArray,
          PATH_CHEBYSHEV_DISTANCE_INDEX,
          chebyshevDistance,
        );
        Atomics.store(pathDataArray, PATH_START_X_INDEX, x);
        Atomics.store(pathDataArray, PATH_START_Y_INDEX, y);
        Atomics.store(pathDataArray, PATH_START_Z_INDEX, z);
        Atomics.store(pathDataArray, PATHFINDING_STATUS_INDEX, statusCode);

        for (let i = 0; i < pathLength; i++) {
          const waypoint = normalizedPath[i];
          const offset = PATH_WAYPOINTS_START_INDEX + i * PATH_WAYPOINT_SIZE;
          Atomics.store(pathDataArray, offset + 0, waypoint.x);
          Atomics.store(pathDataArray, offset + 1, waypoint.y);
          Atomics.store(pathDataArray, offset + 2, waypoint.z);
        }

        Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
      }
      lastWrittenPathSignature = pathSignature;
    }

    const distance =
      statusString === 'NO_PATH_FOUND' ? null : normalizedPath.length;

    throttleReduxUpdate({
      pathWaypoints: normalizedPath,
      wptDistance: distance,
      pathfindingStatus: statusString,
    });

  } catch (error) {
    logger('error', `Pathfinding error: ${error.message}`);
    throttleReduxUpdate({
      pathWaypoints: [],
      wptDistance: null,
      pathfindingStatus: 'ERROR',
    });
    if (pathDataArray) {
      Atomics.store(pathDataArray, PATHFINDING_STATUS_INDEX, PATH_STATUS_ERROR);
      Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0);
      Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
    }
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinderWorker.js
//start file
import { start } from './pathfinder/core.js';

start().catch((err) => {
  console.error('[PathfinderWorker] Failed to start worker core:', err);
  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/regionMonitor.js
//start file
import { parentPort, workerData } from 'worker_threads';
import regionDefinitions from '../constants/regionDefinitions.js';
import { setAllRegions } from '../../frontend/redux/slices/regionCoordinatesSlice.js';
import findSequences from 'find-sequences-native';
import { FrameUpdateManager } from '../utils/frameUpdateManager.js';

// --- Worker Configuration & Setup ---
const { sharedData } = workerData;
const FULL_SCAN_INTERVAL_MS = 500;
const MIN_LOOP_DELAY_MS = 200;

if (!sharedData) throw new Error('[RegionMonitor] Shared data not provided.');
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

// --- SharedArrayBuffer Indices ---
const WIDTH_INDEX = 1;
const HEIGHT_INDEX = 2;
const IS_RUNNING_INDEX = 3;

// --- State variables ---
let lastKnownRegions = {};
let lastWidth = 0;
let lastHeight = 0;
let isShuttingDown = false;
let isScanning = false;
const frameUpdateManager = new FrameUpdateManager();

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// --- Recursive Region Finding Logic ---
async function findRegionsRecursive(
  buffer,
  definitions,
  searchArea,
  baseOffset,
  parentResult,
  metadata,
) {
  const discoveryTasks = {};
  const boundingBoxDefs = {};
  const fixedDefs = {};
  const defEntries = Object.entries(definitions);
  if (defEntries.length === 0) return;

  for (const [name, def] of defEntries) {
    switch (def.type) {
      case 'single':
        discoveryTasks[name] = {
          sequences: { [name]: def },
          searchArea,
          occurrence: 'first',
        };
        break;
      case 'boundingBox':
        discoveryTasks[`${name}_start`] = {
          sequences: { [`${name}_start`]: def.start },
          searchArea,
          occurrence: 'first',
        };
        boundingBoxDefs[name] = def;
        break;
      case 'fixed':
        fixedDefs[name] = def;
        break;
    }
  }

  for (const [name, def] of Object.entries(fixedDefs)) {
    parentResult[name] = {
      x: baseOffset.x + def.x,
      y: baseOffset.y + def.y,
      width: def.width,
      height: def.height,
    };
  }

  if (!Object.keys(discoveryTasks).length) return;

  const discoveryResults = await findSequences.findSequencesNativeBatch(
    buffer,
    discoveryTasks,
  );
  const endpointTasks = {};
  const foundStarts = {};
  const childInvocations = [];

  for (const [name, def] of defEntries) {
    if (def.type === 'single' && discoveryResults[name]?.[name]) {
      const result = discoveryResults[name][name];
      const region = {
        x: result.x,
        y: result.y,
        width: def.width,
        height: def.height,
        rawPos: {
          x: result.x - (def.offset?.x || 0),
          y: result.y - (def.offset?.y || 0),
        },
      };
      parentResult[name] = region;
      if (def.children) {
        parentResult[name].children = {};
        childInvocations.push(() =>
          findRegionsRecursive(
            buffer,
            def.children,
            region,
            { x: region.x, y: region.y },
            parentResult[name].children,
            metadata,
          ),
        );
      }
    }
  }

  for (const [name, def] of Object.entries(boundingBoxDefs)) {
    const startResult = discoveryResults[`${name}_start`]?.[`${name}_start`];
    if (!startResult) continue;
    foundStarts[name] = startResult;
    const maxW = def.maxRight === 'fullWidth' ? metadata.width : def.maxRight;
    const maxH = def.maxDown === 'fullHeight' ? metadata.height : def.maxDown;
    const endSearchArea = {
      x: startResult.x,
      y: startResult.y,
      width: Math.min(maxW, searchArea.x + searchArea.width - startResult.x),
      height: Math.min(maxH, searchArea.y + searchArea.height - startResult.y),
    };
    if (endSearchArea.width > 0 && endSearchArea.height > 0) {
      endpointTasks[`${name}_end`] = {
        sequences: { [`${name}_end`]: def.end },
        searchArea: endSearchArea,
        occurrence: 'first',
      };
    }
  }

  let endpointResults = {};
  if (Object.keys(endpointTasks).length > 0) {
    endpointResults = await findSequences.findSequencesNativeBatch(
      buffer,
      endpointTasks,
    );
  }

  for (const [name, startPos] of Object.entries(foundStarts)) {
    const def = boundingBoxDefs[name];
    const endPos = endpointResults[`${name}_end`]?.[`${name}_end`];
    const absStartPos = { x: startPos.x, y: startPos.y };
    const rawStartPos = {
      x: absStartPos.x - (def.start.offset?.x || 0),
      y: absStartPos.y - (def.start.offset?.y || 0),
    };
    if (!endPos) {
      parentResult[name] = {
        ...absStartPos,
        width: 0,
        height: 0,
        startFound: true,
        endFound: false,
        rawStartPos,
      };
      continue;
    }
    const rectWidth = endPos.x - startPos.x + 1;
    const rectHeight = endPos.y - startPos.y + 1;
    const region = {
      ...absStartPos,
      width: rectWidth > 0 ? rectWidth : 0,
      height: rectHeight > 0 ? rectHeight : 0,
      startFound: true,
      endFound: true,
      rawStartPos,
      rawEndPos: {
        x: endPos.x - (def.end.offset?.x || 0),
        y: endPos.y - (def.end.offset?.y || 0),
      },
    };
    parentResult[name] = region;
    if (def.children) {
      parentResult[name].children = {};
      childInvocations.push(() =>
        findRegionsRecursive(
          buffer,
          def.children,
          region,
          { x: region.x, y: region.y },
          parentResult[name].children,
          metadata,
        ),
      );
    }
  }

  if (childInvocations.length > 0) {
    await Promise.all(childInvocations.map((invoke) => invoke()));
  }
}

/**
 * Processes special regions after the main recursive find.
 * This is now only responsible for calculating the tile size from the gameWorld region.
 * All battle list logic has been removed.
 */
async function processSpecialRegions(buffer, regions, metadata) {
  if (regions.gameWorld?.endFound) {
    const { gameWorld } = regions;
    regions.tileSize = {
      width: Math.round(gameWorld.width / 15),
      height: Math.round(gameWorld.height / 11),
    };
  }
}

async function performFullScan(buffer, metadata) {
  const foundRegions = {};
  await findRegionsRecursive(
    buffer,
    regionDefinitions,
    { x: 0, y: 0, width: metadata.width, height: metadata.height },
    { x: 0, y: 0 },
    foundRegions,
    metadata,
  );
  await processSpecialRegions(buffer, foundRegions, metadata);
  return foundRegions;
}

async function mainLoop() {
  while (!isShuttingDown) {
    const loopStartTime = Date.now();
    try {
      if (isScanning) {
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      const width = Atomics.load(syncArray, WIDTH_INDEX);
      const height = Atomics.load(syncArray, HEIGHT_INDEX);
      const dimensionsChanged = width !== lastWidth || height !== lastHeight;

      if (!frameUpdateManager.shouldProcess() && !dimensionsChanged) {
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      if (Atomics.load(syncArray, IS_RUNNING_INDEX) !== 1) {
        if (Object.keys(lastKnownRegions).length > 0) {
          lastKnownRegions = {};
          parentPort.postMessage({
            storeUpdate: true,
            type: setAllRegions.type,
            payload: {},
          });
        }
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      if (width <= 0 || height <= 0) {
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      isScanning = true;
      try {
        const metadata = { width, height };
        const newRegions = await performFullScan(sharedBufferView, metadata);

        lastWidth = width;
        lastHeight = height;
        lastKnownRegions = newRegions;

        parentPort.postMessage({
          storeUpdate: true,
          type: setAllRegions.type,
          payload: newRegions,
        });
      } catch (err) {
        console.error('[RegionMonitor] Error during scan:', err);
        lastKnownRegions = {};
      } finally {
        isScanning = false;
      }
    } catch (err) {
      console.error('[RegionMonitor] Error in main loop:', err);
      lastKnownRegions = {};
    }

    const elapsedTime = Date.now() - loopStartTime;
    const delayTime = Math.max(0, FULL_SCAN_INTERVAL_MS - elapsedTime);
    if (delayTime > 0) {
      await delay(delayTime);
    }
  }
}

parentPort.on('message', (message) => {
  try {
    if (message.type === 'frame-update') {
      frameUpdateManager.addDirtyRects(message.payload.dirtyRects);
      return;
    }

    if (message.type === 'shutdown') {
      isShuttingDown = true;
    }
  } catch (err) {
    console.error('[RegionMonitor] Error handling message:', err);
  }
});

async function startWorker() {
  mainLoop().catch((err) => {
    console.error('[RegionMonitor] Fatal error in main loop:', err);
    process.exit(1);
  });
}

startWorker();

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/CooldownManager.js
//start file
import { performance as perf } from 'perf_hooks';

// Configuration Section
const CONFIG = {
  ENABLE_COOLDOWN_LOGGING: false,
  DEBOUNCE_DURATION: 50,
  HISTORY_LENGTH: 3,
  MAX_COOLDOWN_DURATIONS: {
    attack: 2000,
    healing: 1000,
    support: 500,
  },
};

const COOLDOWN_DURATIONS = {
  healing: 1000,
  attack: 1950,
  support: 500,
};

export class CooldownManager {
  constructor() {
    this.cooldowns = {
      healing: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
      attack: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
      support: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
    };
  }

  forceDeactivate(type) {
    const cooldown = this.cooldowns[type];
    const now = perf.now();

    cooldown.active = false;
    cooldown.startTime = 0;
    cooldown.debounceEndTime = now + CONFIG.DEBOUNCE_DURATION;
    cooldown.history = [];

    if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
      console.log(`${type} cooldown force-deactivated by UI state`);
    }
  }

  updateCooldown(type, isActive) {
    const now = perf.now();
    const cooldown = this.cooldowns[type];

    // Update state history
    cooldown.history.push(isActive);
    if (cooldown.history.length > CONFIG.HISTORY_LENGTH) {
      cooldown.history.shift();
    }

    // Determine consistent state
    const activeCount = cooldown.history.filter((state) => state).length;
    const consistentActive = activeCount >= Math.ceil(CONFIG.HISTORY_LENGTH / 2);

    // Activation logic
    if (consistentActive && !cooldown.active && now >= cooldown.debounceEndTime) {
      cooldown.active = true;
      cooldown.startTime = now;
      cooldown.debounceEndTime = now + COOLDOWN_DURATIONS[type] - CONFIG.DEBOUNCE_DURATION;

      if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
        console.log(`${type} cooldown activated`);
      }
    }

    // Deactivation logic
    if (!consistentActive && cooldown.active && now >= cooldown.debounceEndTime) {
      const elapsedTime = now - cooldown.startTime;
      const maxDuration = CONFIG.MAX_COOLDOWN_DURATIONS[type];

      if (elapsedTime >= COOLDOWN_DURATIONS[type] || elapsedTime >= maxDuration) {
        cooldown.active = false;
        cooldown.debounceEndTime = now + CONFIG.DEBOUNCE_DURATION;

        if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
          console.log(`${type} cooldown naturally deactivated after ${elapsedTime.toFixed(1)}ms`);
        }
      }
    }

    return cooldown.active;
  }

  getCooldownState(type) {
    const cooldown = this.cooldowns[type];
    if (cooldown.active) {
      const elapsedTime = perf.now() - cooldown.startTime;
      const maxDuration = CONFIG.MAX_COOLDOWN_DURATIONS[type];

      // Force expiration if beyond maximum allowed duration
      if (elapsedTime >= maxDuration) {
        cooldown.active = false;
        cooldown.debounceEndTime = perf.now() + CONFIG.DEBOUNCE_DURATION;

        if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
          console.log(`${type} cooldown forced expiration after ${elapsedTime.toFixed(2)}ms`);
        }
      }
    }
    return cooldown.active;
  }

  getStats() {
    if (!CONFIG.ENABLE_COOLDOWN_LOGGING) return null;

    const stats = {};
    const now = perf.now();

    for (const [type, data] of Object.entries(this.cooldowns)) {
      const currentDuration = data.active ? now - data.startTime : 0;
      stats[type] = {
        isActive: data.active,
        currentActiveDuration: currentDuration,
        debounceEndTime: data.debounceEndTime,
        history: [...data.history],
      };
    }

    return stats;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/constants.js
//start file
export const OPTIONS = {
  globalDelay: 0,
  categoryDelays: {
    Healing: 200,
    Potion: 975,
    Support: 475,
    Attack: 1975,
    Equip: 250,
    Others: 50,
  },
  cooldownStateMapping: {
    Healing: 'healingCd',
    Support: 'supportCd',
    Attack: 'attackCd',
  },
  logsEnabled: false,
};

export const PARTY_MEMBER_STATUS = {
  active: {
    sequence: [
      [192, 192, 192],
      [192, 192, 192],
    ],
    direction: 'horizontal',
  },
  activeHover: {
    sequence: [
      [247, 247, 247],
      [247, 247, 247],
    ],
    direction: 'horizontal',
  },
  // inactive: {
  //   sequence: [
  //     [128, 128, 128],
  //     [128, 128, 128],
  //   ],
  //   direction: 'horizontal',
  // },
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/ruleFilterUtils.js
//start file
import parseMathCondition from '../../utils/parseMathCondition.js';
import areCharStatusConditionsMet from '../../utils/areStatusConditionsMet.js';
import { OPTIONS } from './constants.js';

let lastRuleExecutionTimes = {};
let lastCategoriesExecutionTimes = {};

export const filterEnabledRules = (rules) => rules.filter((rule) => rule.enabled);

export const filterRulesNotOnDelay = (rules) =>
  rules.filter(
    (rule) =>
      Date.now() - (lastRuleExecutionTimes[rule.id] || 0) >= (rule.delay || 0) &&
      Date.now() -
        Math.max(
          ...rules
            .filter((r) => r.category === rule.category)
            .map((r) => lastRuleExecutionTimes[r.id] || 0),
        ) >=
        OPTIONS.categoryDelays[rule.category],
  );

export const filterRulesByActiveCooldowns = (rules, directGameState) =>
  rules.filter((rule) => {
    const cooldownStateKey = OPTIONS.cooldownStateMapping[rule.category];
    return !cooldownStateKey || !directGameState[cooldownStateKey];
  });

export const filterRulesByConditions = (rules, directGameState) =>
  rules.filter((rule) => {
    return (
      parseMathCondition(
        rule.hpTriggerCondition,
        parseInt(rule.hpTriggerPercentage, 10),
        directGameState.hppc,
      ) &&
      parseMathCondition(
        rule.manaTriggerCondition,
        parseInt(rule.manaTriggerPercentage, 10),
        directGameState.mppc,
      ) &&
      areCharStatusConditionsMet(rule, directGameState) &&
      parseMathCondition(
        rule.monsterNumCondition,
        parseInt(rule.monsterNum, 10),
        directGameState.monsterNum,
      )
    );
  });

export const getAllValidRules = (rules, directGameState) => {
  const enabledRules = filterEnabledRules(rules);
  const rulesWithoutActiveCooldowns = filterRulesByActiveCooldowns(enabledRules, directGameState);
  const rulesNotOnDelay = filterRulesNotOnDelay(rulesWithoutActiveCooldowns);
  return filterRulesByConditions(rulesNotOnDelay, directGameState).sort(
    (a, b) => b.priority - a.priority,
  );
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/ruleProcessor.js
//start file
import parseMathCondition from '../../utils/parseMathCondition.js';
import areCharStatusConditionsMet from '../../utils/areStatusConditionsMet.js';
import {
  keyPress,
  keyPressMultiple,
  getIsTyping,
} from '../../keyboardControll/keyPress.js';
import { createLogger } from '../../utils/logger.js';

const log = createLogger({ info: true, error: true, warn: true });

import useItemOnCoordinates from '../../mouseControll/useItemOnCoordinates.js';
import { getRandomNumber } from '../../utils/getRandomNumber.js';
import { OPTIONS } from './constants.js';

class RuleProcessor {
  constructor() {
    this.lastSuccessfulRuleActionTime = {}; // PRIMARY FOR DELAY on non-ManaSync rules
    this.lastCategoryExecutionTime = {};
    this.lastPartyHealActionTime = 0;
    this.lastAttackCooldownState = false;
    this.attackCooldownStartTime = null;
    this.lastKeypressTime = 0;
    this.effectiveCooldownEndTime = 0;

    // ManaSync specific state
    this.manaSyncWatchList = new Map();
    this.executedManaSyncThisCooldown = new Set();
    this.forcedManaSyncExecutedThisCooldown = new Set();

    this.pendingActionConfirmations = new Map(); // For item disappearance check

    // Attack CD Exclusivity state
    this.actionTakenThisAttackCooldown = false;
    this.healFriendRuneExecutionsThisAttackCooldown = 0;

    // Constants
    this.KEYPRESS_COOLDOWN_MS = 50;
    this.PARTY_HEAL_MIN_INTERVAL_MS = 50;
    this.MANASYNC_FORCED_EXECUTION_DELAY_MS = 740;
    this.MANASYNC_FORCED_EXECUTION_WINDOW_MS = 100;
    this.MANA_SYNC_WATCH_DURATION_MS = 800;
    this.ACTION_CONFIRMATION_TIMEOUT_MS = 300;

    this.RULE_PREFIX = {
      USER: 'userRule',
      ACTION_BAR: 'actionBarItem',
      MANA_SYNC: 'manaSync',
      PARTY_HEAL: 'healFriend',
      ROTATION: 'rotationRule',
      EQUIP: 'equipRule',
    };
    this.PARTY_HEAL_RUNE_ITEMS = new Set([
      'ultimateHealingRune',
      'intenseHealingRune',
    ]);
  }

  async processRules(activePreset, gameState, globalConfig) {
    const now = Date.now();

    if (getIsTyping()) {
      return;
    }

    if (!globalConfig.isOnline) {
      return;
    }

    if (!gameState.rulesEnabled) {
      return;
    }

    // --- ManaSync Processing ---
    const attackCdChanged = this._handleAttackCooldownTransitions(
      now,
      gameState,
      activePreset,
      globalConfig,
    );
    let manaSyncRuleExecutedImmediately = attackCdChanged.executed;

    let manaSyncRuleExecutedFromWatch = false;
    if (
      !manaSyncRuleExecutedImmediately &&
      gameState.attackCd &&
      this.manaSyncWatchList.size > 0 &&
      !this.actionTakenThisAttackCooldown
    ) {
      manaSyncRuleExecutedFromWatch = this._processManaSyncWatch(
        now,
        gameState,
        activePreset,
        globalConfig,
      );
    }

    let manaSyncRuleForcedExecution = false;
    if (
      gameState.attackCd &&
      !this.actionTakenThisAttackCooldown &&
      !manaSyncRuleExecutedImmediately &&
      !manaSyncRuleExecutedFromWatch
    ) {
      manaSyncRuleForcedExecution = this._processForcedManaSyncExecution(
        now,
        gameState,
        activePreset,
        globalConfig,
      );
    }

    // --- Action Confirmation Processing ---
    this._processActionConfirmations(now, gameState);

    let ruleActionTriggeredThisCycle =
      manaSyncRuleExecutedImmediately ||
      manaSyncRuleExecutedFromWatch ||
      manaSyncRuleForcedExecution;

    // --- Standard Rule Processing (User, Equip, ActionBar, PartyHeal non-rune) ---
    if (!ruleActionTriggeredThisCycle) {
      const nonManaSyncPreset = activePreset.filter(
        (r) => !r.id.startsWith(this.RULE_PREFIX.MANA_SYNC),
      );
      const eligibleRules = this._filterEligibleRules(
        now,
        nonManaSyncPreset,
        gameState,
      );

      if (eligibleRules.length > 0) {
        const ruleToExecute = eligibleRules[0];
        const nonManaSyncActionSuccess = this._attemptExecutionAndHandleOutcome(
          now,
          ruleToExecute,
          gameState,
          globalConfig,
        );

        if (nonManaSyncActionSuccess) {
          ruleActionTriggeredThisCycle = true;
        }
      }
    }
  }

  // --- Filtering Logic ---
  _filterEligibleRules(now, rules, gameState) {
    let eligibleRules = rules.filter((rule) => rule.enabled);

    eligibleRules = this._filterRulesByActiveCooldowns(
      eligibleRules,
      gameState,
    );

    eligibleRules = this._filterRulesNotOnDelay(now, eligibleRules);

    eligibleRules = this._filterRulesByWalkingState(eligibleRules, gameState);

    eligibleRules = eligibleRules.filter((rule) => {
      /* PartyHeal Interval Filter */
      if (rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        const timeSinceLastHeal = now - this.lastPartyHealActionTime;
        return timeSinceLastHeal >= this.PARTY_HEAL_MIN_INTERVAL_MS;
      }
      return true;
    });

    eligibleRules = eligibleRules.filter((rule) => {
      /* HealFriend Rune Exclusivity */
      if (
        rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem)
      ) {
        if (gameState.attackCd) {
          if (this.actionTakenThisAttackCooldown) {
            return false;
          }
          if (this.healFriendRuneExecutionsThisAttackCooldown >= 2) {
            return false;
          }
        }
      }
      return true;
    });

    eligibleRules = this._filterRulesByBasicConditions(
      eligibleRules,
      gameState,
    );

    eligibleRules = this._filterRulesByItemAvailability(
      eligibleRules,
      gameState,
    );

    eligibleRules = eligibleRules.filter((rule) => {
      /* Equip Rule Specifics */
      if (rule.id.startsWith(this.RULE_PREFIX.EQUIP)) {
        if (
          typeof rule.actionItem !== 'string' ||
          rule.actionItem.trim() === '' ||
          !rule.targetSlot
        )
          return false;
        if (typeof rule.equipOnlyIfSlotIsEmpty !== 'boolean') return false;

        const currentItemInSlot = gameState.equippedItems?.[rule.targetSlot];
        const itemToBeEquippedName =
          rule.itemToBeEquippedName || rule.actionItem;

        if (rule.equipOnlyIfSlotIsEmpty) {
          let expectedEmptyItemKey;
          // {{change 1}}
          if (rule.targetSlot === 'amulet') {
            expectedEmptyItemKey = 'Empty';
          } else if (rule.targetSlot === 'ring') {
            expectedEmptyItemKey = 'Empty';
          } else if (rule.targetSlot === 'boots') {
            expectedEmptyItemKey = 'Empty';
          } else {
            return false;
          }
          if (currentItemInSlot !== expectedEmptyItemKey) {
            return false;
          }
        }
        // Avoid re-equipping if the item is already in the slot
        if (currentItemInSlot === itemToBeEquippedName) {
          return false;
        }
        return true;
      }
      return true;
    });

    eligibleRules = eligibleRules.filter((rule) => {
      /* PartyHeal Final Condition */
      if (rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        return this._shouldHealFriend(rule, gameState);
      }
      return true;
    });

    eligibleRules.sort((a, b) => (b.priority || 0) - (a.priority || 0));
    return eligibleRules;
  }

  _filterRulesNotOnDelay(now, rules) {
    return rules.filter((rule) => {
      const ruleId = rule.id;
      const ruleDelay = rule.delay ?? 0;
      const category = rule.category;

      // INDIVIDUAL DELAY
      const timeSinceLastSuccessfulTrigger =
        now - (this.lastSuccessfulRuleActionTime[ruleId] || 0);
      if (timeSinceLastSuccessfulTrigger < ruleDelay) {
        return false;
      }

      // CATEGORY DELAY
      if (rule.id.startsWith(this.RULE_PREFIX.USER) && category) {
        const categoryDelay = OPTIONS.categoryDelays?.[category] ?? 0;
        if (categoryDelay > 0) {
          const timeSinceCategoryLastTrigger =
            now - (this.lastCategoryExecutionTime[category] || 0);
          if (timeSinceCategoryLastTrigger < categoryDelay) {
            return false;
          }
        }
      }
      return true;
    });
  }

  _filterRulesByActiveCooldowns(rules, gameState) {
    return rules.filter((rule) => {
      if (rule.id.startsWith(this.RULE_PREFIX.USER)) {
        const cooldownStateKey = rule.category
          ? OPTIONS.cooldownStateMapping?.[rule.category]
          : null;
        return !cooldownStateKey || !gameState[cooldownStateKey];
      }
      return true;
    });
  }

  _filterRulesByWalkingState(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.USER) ||
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR)
      ) {
        return !rule.isWalking || (rule.isWalking && gameState.isWalking);
      }
      return true;
    });
  }

  _filterRulesByBasicConditions(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.USER) ||
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR) ||
        rule.id.startsWith(this.RULE_PREFIX.EQUIP)
      ) {
        const hpMet = parseMathCondition(
          rule.hpTriggerCondition,
          parseInt(rule.hpTriggerPercentage, 10),
          gameState.hppc,
        );
        const manaMet = parseMathCondition(
          rule.manaTriggerCondition,
          parseInt(rule.manaTriggerPercentage, 10),
          gameState.mppc,
        );
        let monsterMet = true;
        if (rule.monsterNumCondition != null && rule.monsterNum != null) {
          monsterMet = parseMathCondition(
            rule.monsterNumCondition,
            parseInt(rule.monsterNum, 10),
            gameState.monsterNum,
          );
        }
        const statusMet = areCharStatusConditionsMet(rule, gameState);
        return hpMet && manaMet && statusMet && monsterMet;
      }
      return true;
    });
  }

  _filterRulesByItemAvailability(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR) ||
        rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) ||
        rule.id.startsWith(this.RULE_PREFIX.EQUIP)
      ) {
        const requiredItemToClick = rule.actionItem;
        if (
          typeof requiredItemToClick !== 'string' ||
          requiredItemToClick.trim() === ''
        ) {
          return false;
        }

        const isCreateRuneAction =
          requiredItemToClick.includes('create') &&
          requiredItemToClick.includes('Rune');

        if (isCreateRuneAction) {
          if (!gameState.activeActionItems?.['blankRune']) {
            return false;
          }
        }

        if (!gameState.activeActionItems?.[requiredItemToClick]) {
          return false;
        }
        return true;
      }
      return true;
    });
  }

  // --- ManaSync Logic ---
  _handleAttackCooldownTransitions(now, gameState, activePreset, globalConfig) {
    const attackCdIsCurrentlyActive = gameState.attackCd;
    const attackCdJustStarted =
      attackCdIsCurrentlyActive && !this.lastAttackCooldownState;
    const attackCdJustEnded =
      !attackCdIsCurrentlyActive && this.lastAttackCooldownState;
    let executedManaSyncNow = false;

    if (attackCdJustEnded) {
      this.manaSyncWatchList.clear();
      this.executedManaSyncThisCooldown.clear();
      this.forcedManaSyncExecutedThisCooldown.clear();
      this.attackCooldownStartTime = null;
    }

    if (attackCdJustStarted) {
      this.attackCooldownStartTime = now;
      this.manaSyncWatchList.clear();
      this.executedManaSyncThisCooldown.clear();
      this.forcedManaSyncExecutedThisCooldown.clear();
      this.actionTakenThisAttackCooldown = false;
      this.healFriendRuneExecutionsThisAttackCooldown = 0;

      const manaSyncRules = activePreset
        .filter((r) => r.enabled && r.id.startsWith(this.RULE_PREFIX.MANA_SYNC))
        .sort((a, b) => (b.priority || 0) - (a.priority || 0));

      for (const rule of manaSyncRules) {
        if (executedManaSyncNow || this.actionTakenThisAttackCooldown) break;
        const conditionsMet = this._checkManaSyncConditions(rule, gameState);
        const itemIsActive = !!gameState.activeActionItems?.[rule.actionItem];
        if (conditionsMet.all) {
          if (!rule.actionItem) {
            console.warn(`[RuleProc] ManaSync ${rule.id} no actionItem.`);
            continue;
          }
          if (itemIsActive) {
            if (
              !this._hasHigherPriorityEligibleHealFriend(
                gameState,
                activePreset,
                rule.priority || 0,
                now,
              )
            ) {
              const keypressSent = this._tryExecuteAction(
                now,
                rule,
                gameState,
                globalConfig,
                'manaSyncNormal',
              );
              if (keypressSent) {
                this.executedManaSyncThisCooldown.add(rule.id);
                this.actionTakenThisAttackCooldown = true;
                executedManaSyncNow = true;
              }
            }
          } else {
            this.manaSyncWatchList.set(rule.id, {
              startTime: now,
              checkedConditions: conditionsMet,
            });
          }
        }
      }
    }
    this.lastAttackCooldownState = attackCdIsCurrentlyActive;
    return {
      changed: attackCdJustStarted || attackCdJustEnded,
      executed: executedManaSyncNow,
    };
  }

  _processManaSyncWatch(now, gameState, activePreset, globalConfig) {
    if (this.manaSyncWatchList.size === 0 || this.actionTakenThisAttackCooldown)
      return false;
    let executedFromWatch = false;
    const rulesToRemoveFromWatch = [];
    const sortedWatchKeys = Array.from(this.manaSyncWatchList.keys())
      .sort
      /* by prio */
      ();

    for (const ruleId of sortedWatchKeys) {
      if (executedFromWatch || this.actionTakenThisAttackCooldown) break;
      const watchData = this.manaSyncWatchList.get(ruleId);
      const rule = activePreset.find((r) => r.id === ruleId);
      if (
        !rule ||
        !rule.actionItem ||
        this.executedManaSyncThisCooldown.has(ruleId) ||
        now - watchData.startTime > this.MANA_SYNC_WATCH_DURATION_MS
      ) {
        rulesToRemoveFromWatch.push(ruleId);
        continue;
      }
      const itemIsNowActive = !!gameState.activeActionItems?.[rule.actionItem];
      if (itemIsNowActive) {
        const conditionsStillMet = this._checkManaSyncConditions(
          rule,
          gameState,
        );
        if (conditionsStillMet.all) {
          if (
            !this._hasHigherPriorityEligibleHealFriend(
              gameState,
              activePreset,
              rule.priority || 0,
              now,
            )
          ) {
            const keypressSent = this._tryExecuteAction(
              now,
              rule,
              gameState,
              globalConfig,
              'manaSyncNormal',
            );
            if (keypressSent) {
              this.executedManaSyncThisCooldown.add(ruleId);
              this.actionTakenThisAttackCooldown = true;
              executedFromWatch = true;
            }
          }
        }
        rulesToRemoveFromWatch.push(ruleId);
      }
    }
    rulesToRemoveFromWatch.forEach((id) => this.manaSyncWatchList.delete(id));
    return executedFromWatch;
  }

  _processForcedManaSyncExecution(now, gameState, activePreset, globalConfig) {
    if (
      !gameState.attackCd ||
      !this.attackCooldownStartTime ||
      this.actionTakenThisAttackCooldown
    )
      return false;
    const timeSinceCdStart = now - this.attackCooldownStartTime;
    const isInForcedWindow =
      timeSinceCdStart >= this.MANASYNC_FORCED_EXECUTION_DELAY_MS &&
      timeSinceCdStart <=
        this.MANASYNC_FORCED_EXECUTION_DELAY_MS +
          this.MANASYNC_FORCED_EXECUTION_WINDOW_MS;
    if (!isInForcedWindow) return false;

    const manaSyncRules = activePreset
      .filter((r) => r.enabled && r.id.startsWith(this.RULE_PREFIX.MANA_SYNC))
      .sort((a, b) => (b.priority || 0) - (a.priority || 0));
    for (const rule of manaSyncRules) {
      if (this.actionTakenThisAttackCooldown) break;
      if (
        this.executedManaSyncThisCooldown.has(rule.id) ||
        this.forcedManaSyncExecutedThisCooldown.has(rule.id)
      )
        continue;
      const conditionsMet = this._checkManaSyncConditions(rule, gameState);
      if (conditionsMet.all) {
        if (
          !this._hasHigherPriorityEligibleHealFriend(
            gameState,
            activePreset,
            rule.priority || 0,
            now,
          )
        ) {
          const keypressSent = this._tryExecuteAction(
            now,
            rule,
            gameState,
            globalConfig,
            'manaSyncForced',
          );
          if (keypressSent) {
            this.forcedManaSyncExecutedThisCooldown.add(rule.id);
            this.actionTakenThisAttackCooldown = true;
            return true;
          }
        }
      }
    }
    return false;
  }

  _checkManaSyncConditions(rule, gameState) {
    const hpMet = parseMathCondition(
      rule.hpTriggerCondition ?? '>=',
      parseInt(rule.hpTriggerPercentage ?? 0, 10),
      gameState.hppc,
    );
    const manaMet = parseMathCondition(
      rule.manaTriggerCondition ?? '<=',
      parseInt(rule.manaTriggerPercentage ?? 100, 10),
      gameState.mppc,
    );
    const statusMet = areCharStatusConditionsMet(rule, gameState);
    return { hpMet, manaMet, statusMet, all: hpMet && manaMet && statusMet };
  }

  _hasHigherPriorityEligibleHealFriend(
    gameState,
    activePreset,
    manaSyncPriority,
    now,
  ) {
    if (this.actionTakenThisAttackCooldown) return false;
    const competingHealFriends = activePreset.filter(
      (r) =>
        r.enabled &&
        r.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        r.requireAttackCooldown === true &&
        (r.priority || 0) > manaSyncPriority,
    );
    if (competingHealFriends.length === 0) return false;
    for (const healRule of competingHealFriends) {
      if (
        this.PARTY_HEAL_RUNE_ITEMS.has(healRule.actionItem) &&
        this.healFriendRuneExecutionsThisAttackCooldown >= 2
      )
        continue;
      const healRuleDelay = healRule.delay ?? 0;
      const timeSinceHealRuleLastTrigger =
        now - (this.lastSuccessfulRuleActionTime[healRule.id] || 0);
      if (timeSinceHealRuleLastTrigger < healRuleDelay) continue;
      if (this._shouldHealFriend(healRule, gameState) && healRule.actionItem)
        return true;
    }
    return false;
  }

  // --- Action Execution and Confirmation ---
  _processActionConfirmations(now, gameState) {
    if (this.pendingActionConfirmations.size === 0) return;
    const ruleIdsToRemove = [];
    for (const [ruleId, data] of this.pendingActionConfirmations) {
      if (
        !gameState.activeActionItems?.[data.actionItem] ||
        now - data.attemptTimestamp > this.ACTION_CONFIRMATION_TIMEOUT_MS
      ) {
        ruleIdsToRemove.push(ruleId);
      }
    }
    ruleIdsToRemove.forEach((id) => this.pendingActionConfirmations.delete(id));
  }

  _attemptExecutionAndHandleOutcome(
    now,
    ruleToExecute,
    gameState,
    globalConfig,
  ) {
    const ruleId = ruleToExecute.id;

    if (this.pendingActionConfirmations.has(ruleId)) {
      return false;
    }

    const actionSuccess = this._tryExecuteAction(
      now,
      ruleToExecute,
      gameState,
      globalConfig,
      'standard',
    );

    if (actionSuccess) {
      this.lastSuccessfulRuleActionTime[ruleId] = now;

      if (ruleToExecute.category && ruleId.startsWith(this.RULE_PREFIX.USER)) {
        this.lastCategoryExecutionTime[ruleToExecute.category] = now;
      }
      if (ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        this.lastPartyHealActionTime = now;
        if (
          this.PARTY_HEAL_RUNE_ITEMS.has(ruleToExecute.actionItem) &&
          gameState.attackCd
        ) {
          this.actionTakenThisAttackCooldown = true;
          this.healFriendRuneExecutionsThisAttackCooldown++;
        }
      }
      if (
        typeof ruleToExecute.actionItem === 'string' &&
        ruleToExecute.actionItem.length > 0
      ) {
        this.pendingActionConfirmations.set(ruleId, {
          attemptTimestamp: now,
          actionItem: ruleToExecute.actionItem,
        });
      }
      return true;
    }
    return false;
  }

  _tryExecuteAction(now, rule, gameState, globalConfig, executionType) {
    const ruleId = rule.id;
    const isManaSync = executionType.startsWith('manaSync');
    const isPriorityRuleForCooldown =
      isManaSync ||
      (ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem) &&
        gameState.attackCd);

    if (!isPriorityRuleForCooldown && now < this.effectiveCooldownEndTime) {
      return false;
    }

    if (!rule.key) {
      console.warn(`[RuleProc] Cannot execute ${ruleId}: Missing 'key'.`);
      return false;
    }

    let actionSent = false;
    try {
      if (
        ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem)
      ) {
        const targetMember = this._findPartyHealTarget(rule, gameState);
        if (targetMember?.uhCoordinates) {
          useItemOnCoordinates(
            globalConfig.windowId,
            globalConfig.display,
            targetMember.uhCoordinates.x + getRandomNumber(0, 130),
            targetMember.uhCoordinates.y + getRandomNumber(0, 11),
            rule.key,
          );
          actionSent = true;
        } else {
          console.warn(
            `[RuleProc] PartyHeal Rune ${ruleId}: No valid target found.`,
          );
        }
      } else {
        keyPress(globalConfig.display, rule.key);
        actionSent = true;
      }

      if (actionSent) {
        this.lastKeypressTime = now;
        this.effectiveCooldownEndTime =
          now + (isPriorityRuleForCooldown ? 25 : this.KEYPRESS_COOLDOWN_MS);
      }
      return actionSent;
    } catch (error) {
      console.error(
        `[RuleProcessor] Error during action execution for ${ruleId} (Type: ${executionType}):`,
        error,
      );
      return false;
    }
  }

  // --- Party Heal Specific Logic ---
  _shouldHealFriend(rule, gameState) {
    if (!gameState?.partyMembers || rule.friendHpTriggerPercentage == null)
      return false;
    if (rule.requireAttackCooldown && !gameState.attackCd) return false;
    const hpTriggerPercentage = parseInt(rule.friendHpTriggerPercentage, 10);
    const partyPositionIndex = parseInt(rule.partyPosition, 10);
    if (
      isNaN(partyPositionIndex) ||
      partyPositionIndex < 0 ||
      isNaN(hpTriggerPercentage)
    )
      return false;
    if (partyPositionIndex === 0) {
      return gameState.partyMembers.some(
        (m) =>
          m.isActive &&
          m.hppc != null &&
          m.hppc > 0 &&
          m.hppc <= hpTriggerPercentage,
      );
    } else {
      const targetMember = gameState.partyMembers?.[partyPositionIndex - 1];
      return (
        !!targetMember &&
        targetMember.isActive &&
        targetMember.hppc != null &&
        targetMember.hppc > 0 &&
        targetMember.hppc <= hpTriggerPercentage
      );
    }
  }

  _findPartyHealTarget(rule, gameState) {
    const hpTriggerPercentage = parseInt(rule.friendHpTriggerPercentage, 10);
    const partyPositionIndex = parseInt(rule.partyPosition, 10);
    if (
      isNaN(partyPositionIndex) ||
      partyPositionIndex < 0 ||
      isNaN(hpTriggerPercentage)
    )
      return null;
    if (partyPositionIndex === 0) {
      const potentialTargets = gameState.partyMembers
        .filter(
          (m) =>
            m.isActive &&
            m.hppc != null &&
            m.hppc > 0 &&
            m.hppc <= hpTriggerPercentage,
        )
        .sort((a, b) => a.hppc - b.hppc);
      return potentialTargets[0] || null;
    } else {
      const targetMember = gameState.partyMembers?.[partyPositionIndex - 1];
      if (
        targetMember &&
        targetMember.isActive &&
        targetMember.hppc != null &&
        targetMember.hppc > 0 &&
        targetMember.hppc <= hpTriggerPercentage
      ) {
        return targetMember;
      }
      return null;
    }
  }
}

export default RuleProcessor;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor.js
// --- CORRECTED ---

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import { resourceBars } from '../constants/index.js';
import calculatePercentages from '../screenMonitor/calcs/calculatePercentages.js';
import RuleProcessor from './screenMonitor/ruleProcessor.js';
import { CooldownManager } from './screenMonitor/CooldownManager.js';
import { FrameUpdateManager } from '../utils/frameUpdateManager.js';

const { sharedData } = workerData;
const SCAN_INTERVAL_MS = 50;

if (!sharedData) throw new Error('[ScreenMonitor] Shared data not provided.');
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

const WIDTH_INDEX = 1;
const HEIGHT_INDEX = 2;
const IS_RUNNING_INDEX = 3;

let currentState = null;
let isShuttingDown = false;
let isInitialized = false;
let hasScannedInitially = false;

const cooldownManager = new CooldownManager();
const ruleProcessorInstance = new RuleProcessor();
const frameUpdateManager = new FrameUpdateManager();

let lastCalculatedState = {
  hppc: null,
  mppc: null,
  healingCd: false,
  supportCd: false,
  attackCd: false,
  characterStatus: {},
  partyMembers: [],
  isWalking: false,
  activeActionItems: {},
  equippedItems: {},
  lastMovementTimestamp: 0,
  lastKnownPlayerMinimapPosition: null,
  monsterNum: 0,
};

const reusableGameStateUpdate = {
  storeUpdate: true,
  type: 'gameState/updateGameStateFromMonitorData',
  payload: {},
};

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function initializeWorker() {
  console.log('[ScreenMonitor] Initializing worker...');
  isInitialized = true;
}

function runRules(ruleInput) {
  const { rules, global, regionCoordinates } = currentState;
  if (!rules?.enabled) return;
  const currentPreset = rules.presets?.[rules.activePresetIndex];
  if (!currentPreset) return;
  try {
    ruleProcessorInstance.processRules(currentPreset, ruleInput, {
      ...global,
      isOnline: regionCoordinates?.regions?.onlineMarker ?? false,
    });
  } catch (error) {
    console.error('[ScreenMonitor] Rule processing error:', error);
  }
}

function calculateHealthBar(bufferToUse, metadata, healthBarRegion) {
  if (!healthBarRegion) return lastCalculatedState.hppc;
  return calculatePercentages(
    bufferToUse,
    metadata,
    healthBarRegion,
    resourceBars.healthBar,
    94,
  );
}
function calculateManaBar(bufferToUse, metadata, manaBarRegion) {
  if (!manaBarRegion) return lastCalculatedState.mppc;
  return calculatePercentages(
    bufferToUse,
    metadata,
    manaBarRegion,
    resourceBars.manaBar,
    94,
  );
}
function calculateCooldowns(cooldownsRegion) {
  const activeCooldowns = cooldownsRegion?.children || {};
  const healingCd = cooldownManager.updateCooldown(
    'healing',
    !!activeCooldowns.healing,
  );
  const supportCd = cooldownManager.updateCooldown(
    'support',
    !!activeCooldowns.support,
  );
  const attackCd = cooldownManager.updateCooldown(
    'attack',
    !!activeCooldowns.attack,
  );
  if (activeCooldowns.attackInactive) cooldownManager.forceDeactivate('attack');
  if (activeCooldowns.healingInactive)
    cooldownManager.forceDeactivate('healing');
  if (activeCooldowns.supportInactive)
    cooldownManager.forceDeactivate('support');
  return { healingCd, supportCd, attackCd };
}
function calculateCharacterStatus(statusBarRegion) {
  const characterStatus = {};
  if (statusBarRegion?.children) {
    Object.keys(statusBarRegion.children).forEach((key) => {
      characterStatus[key] = !!statusBarRegion.children[key].x;
    });
  }
  return characterStatus;
}
function calculateEquippedItems(amuletSlot, ringSlot, bootsSlot) {
  const getEquippedItem = (slotRegion) => {
    if (!slotRegion?.children) return 'Unknown';
    const foundItems = Object.keys(slotRegion.children);
    if (foundItems.length === 0) return 'Empty';
    const actualItem = foundItems.find((item) => !item.includes('empty'));
    return actualItem || 'Empty';
  };
  return {
    amulet: getEquippedItem(amuletSlot),
    ring: getEquippedItem(ringSlot),
    boots: getEquippedItem(bootsSlot),
  };
}
function calculateActiveActionItems(hotkeyBarRegion) {
  return hotkeyBarRegion?.children
    ? Object.fromEntries(
        Object.entries(hotkeyBarRegion.children).map(([key, child]) => [
          key,
          child,
        ]),
      )
    : {};
}
function calculateWalkingState() {
  const { gameState } = currentState;
  if (!gameState?.playerMinimapPosition) return lastCalculatedState.isWalking;
  const currentPos = gameState.playerMinimapPosition;
  const lastPos = lastCalculatedState.lastKnownPlayerMinimapPosition;
  const hasPositionChanged =
    !lastPos ||
    currentPos.x !== lastPos.x ||
    currentPos.y !== lastPos.y ||
    currentPos.z !== lastPos.z;
  if (hasPositionChanged) {
    lastCalculatedState.lastMovementTimestamp = performance.now();
    lastCalculatedState.lastKnownPlayerMinimapPosition = { ...currentPos };
    return true;
  }
  const timeSinceLastMove =
    performance.now() - (lastCalculatedState.lastMovementTimestamp || 0);
  return timeSinceLastMove < 750;
}

async function processGameState() {
  if (!isInitialized || !currentState?.regionCoordinates?.regions) return;

  try {
    if (!hasScannedInitially && !frameUpdateManager.shouldProcess()) {
      lastCalculatedState.isWalking = calculateWalkingState();
      if (currentState?.rules?.enabled && currentState.gameState) {
        runRules({
          ...currentState.gameState,
          ...lastCalculatedState,
          rulesEnabled: true,
        });
      }
      return;
    }

    if (Atomics.load(syncArray, IS_RUNNING_INDEX) === 0) return;

    const width = Atomics.load(syncArray, WIDTH_INDEX);
    const height = Atomics.load(syncArray, HEIGHT_INDEX);
    const { regions } = currentState.regionCoordinates;
    if (Object.keys(regions).length === 0 || width <= 0 || height <= 0) return;

    const metadata = { width, height };
    const bufferToUse = sharedBufferView;

    lastCalculatedState.hppc = calculateHealthBar(
      bufferToUse,
      metadata,
      regions.healthBar,
    );
    lastCalculatedState.mppc = calculateManaBar(
      bufferToUse,
      metadata,
      regions.manaBar,
    );
    Object.assign(lastCalculatedState, calculateCooldowns(regions.cooldownBar));
    lastCalculatedState.characterStatus = calculateCharacterStatus(
      regions.statusBar,
    );
    lastCalculatedState.equippedItems = calculateEquippedItems(
      regions.amuletSlot,
      regions.ringSlot,
      regions.bootsSlot,
    );
    lastCalculatedState.activeActionItems = calculateActiveActionItems(
      regions.hotkeyBar,
    );

    // This worker now ONLY READS the monster count from the state populated by the ocrWorker.
    lastCalculatedState.monsterNum =
      currentState.battleList?.entries?.length || 0;
    lastCalculatedState.isWalking = calculateWalkingState();

    reusableGameStateUpdate.payload = {
      hppc: lastCalculatedState.hppc,
      mppc: lastCalculatedState.mppc,
      monsterNum: lastCalculatedState.monsterNum,
      partyMembers: lastCalculatedState.partyMembers,
      healingCd: lastCalculatedState.healingCd,
      supportCd: lastCalculatedState.supportCd,
      attackCd: lastCalculatedState.attackCd,
      characterStatus: lastCalculatedState.characterStatus,
      isWalking: lastCalculatedState.isWalking,
      activeActionItems: lastCalculatedState.activeActionItems,
      equippedItems: lastCalculatedState.equippedItems,
    };
    parentPort.postMessage(reusableGameStateUpdate);

    hasScannedInitially = true;

    if (currentState?.rules?.enabled && currentState.gameState) {
      runRules({
        ...currentState.gameState,
        ...lastCalculatedState,
        rulesEnabled: true,
      });
    }
  } catch (error) {
    console.error('[ScreenMonitor] Error in processGameState:', error);
  }
}

async function mainLoop() {
  console.log('[ScreenMonitor] Starting main loop...');
  while (!isShuttingDown) {
    const loopStart = performance.now();
    try {
      await processGameState();
    } catch (error) {
      console.error('[ScreenMonitor] Error in main loop:', error);
      await delay(Math.max(SCAN_INTERVAL_MS * 2, 100));
      continue;
    }
    const elapsedTime = performance.now() - loopStart;
    const delayTime = Math.max(0, SCAN_INTERVAL_MS - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  console.log('[ScreenMonitor] Main loop stopped.');
}

parentPort.on('message', (message) => {
  try {
    if (message.type === 'frame-update') {
      frameUpdateManager.addDirtyRects(message.payload.dirtyRects);
      return;
    }

    if (message.type === 'shutdown') {
      isShuttingDown = true;
    } else if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      Object.assign(currentState, message.payload);
      if (message.payload.regionCoordinates) {
        hasScannedInitially = false;
      }
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
      if (!isInitialized) initializeWorker();
    }
  } catch (error) {
    console.error('[ScreenMonitor] Error handling message:', error);
  }
});

async function startWorker() {
  console.log('[ScreenMonitor] Worker starting up...');
  mainLoop().catch((error) => {
    console.error('[ScreenMonitor] Fatal error in main loop:', error);
    process.exit(1);
  });
}

startWorker();

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/sharedConstants.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/sharedConstants.js

// --- SharedArrayBuffer (SAB) Indices for Player Position ---
export const PLAYER_X_INDEX = 0;
export const PLAYER_Y_INDEX = 1;
export const PLAYER_Z_INDEX = 2;
export const PLAYER_POS_UPDATE_COUNTER_INDEX = 3;
export const PLAYER_POS_SAB_SIZE = 4; // x, y, z, counter

// --- SharedArrayBuffer (SAB) Indices for Pathfinder Data ---
export const PATH_LENGTH_INDEX = 0;
export const PATH_CHEBYSHEV_DISTANCE_INDEX = 1;
export const PATH_START_X_INDEX = 2;
export const PATH_START_Y_INDEX = 3;
export const PATH_START_Z_INDEX = 4;
export const PATHFINDING_STATUS_INDEX = 5;
export const PATH_UPDATE_COUNTER_INDEX = 6;
export const PATH_WAYPOINTS_START_INDEX = 7;

// --- Path Data Configuration ---
export const MAX_PATH_WAYPOINTS = 1000;
export const PATH_WAYPOINT_SIZE = 3; // Each waypoint is x, y, z
export const PATH_DATA_SAB_SIZE =
  PATH_WAYPOINTS_START_INDEX + MAX_PATH_WAYPOINTS * PATH_WAYPOINT_SIZE;

// --- REMOVED: All constants related to creaturePosSAB are gone ---

// --- Pathfinder Status Codes ---
export const PATH_STATUS_IDLE = 0;
export const PATH_STATUS_PATH_FOUND = 1;
export const PATH_STATUS_WAYPOINT_REACHED = 2;
export const PATH_STATUS_NO_PATH_FOUND = 3;
export const PATH_STATUS_DIFFERENT_FLOOR = 4;
export const PATH_STATUS_ERROR = 5;
export const PATH_STATUS_NO_VALID_START_OR_END = 6;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/targeting/actions.js
//start file
import keypress from 'keypress-native';
import mouseController from 'mouse-controller';
import { createLogger } from '../../utils/logger.js';

// These constants are specific to the targeting logic.
const MOVEMENT_COOLDOWN_MS = 50;
const CLICK_POLL_INTERVAL_MS = 50;
const MOVE_CONFIRM_TIMEOUT_STRAIGHT_MS = 400;
const MOVE_CONFIRM_TIMEOUT_DIAGONAL_MS = 750;
const MOVE_CONFIRM_GRACE_DIAGONAL_MS = 150;
const TARGET_CLICK_DELAY_MS = 400;
const TARGET_CONFIRMATION_TIMEOUT_MS = 450;
const SHORT_CLICK_DELAY_MS = 50;
const MELEE_DISTANCE_THRESHOLD = 1.5;

/**
 * Creates a set of targeting action functions that close over the provided worker-specific dependencies.
 * This avoids polluting the worker's global scope and makes dependencies explicit.
 * @param {object} workerContext - An object containing dependencies from the worker.
 * @param {Int32Array} workerContext.playerPosArray - The SharedArrayBuffer for player position.
 * @param {Int32Array} workerContext.pathDataArray - The SharedArrayBuffer for path data.
 * @param {MessagePort} workerContext.parentPort - The parent port for sending messages.
 * @returns {object} An object containing the modularized targeting functions.
 */
export function createTargetingActions(workerContext) {
  const { playerPosArray, pathDataArray, parentPort } = workerContext;
  const logger = createLogger({ info: false, error: true, debug: false });
  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  let acquisitionTimes = [];
  let maxAcquisitionTime = 0;
  let avgAcquisitionTime = 0;

  const getDirectionKey = (current, target) => {
    const dx = target.x - current.x;
    const dy = target.y - current.y;
    if (dy < 0) {
      if (dx < 0) return 'q';
      if (dx === 0) return 'w';
      if (dx > 0) return 'e';
    } else if (dy === 0) {
      if (dx < 0) return 'a';
      if (dx > 0) return 'd';
    } else if (dy > 0) {
      if (dx < 0) return 'z';
      if (dx === 0) return 's';
      if (dx > 0) return 'c';
    }
    return null;
  };

  const awaitWalkConfirmation = (
    posCounterBeforeMove,
    pathCounterBeforeMove,
    timeoutMs,
  ) => {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        clearInterval(intervalId);
        reject(
          new Error(`awaitWalkConfirmation timed out after ${timeoutMs}ms`),
        );
      }, timeoutMs);
      const intervalId = setInterval(() => {
        const posChanged =
          playerPosArray &&
          Atomics.load(playerPosArray, 3) > posCounterBeforeMove;
        const pathChanged =
          pathDataArray &&
          Atomics.load(pathDataArray, 4) > pathCounterBeforeMove;
        if (posChanged || pathChanged) {
          clearTimeout(timeoutId);
          clearInterval(intervalId);
          resolve(true);
        }
      }, CLICK_POLL_INTERVAL_MS);
    });
  };

  const selectBestTargetFromGameWorld = (
    globalState,
    playerMinimapPosition,
  ) => {
    const { creatures, targetingList } = globalState.targeting;
    if (
      !creatures ||
      creatures.length === 0 ||
      !targetingList ||
      targetingList.length === 0
    ) {
      return null;
    }

    const reachableCreatures = creatures.filter((c) => c.isReachable);
    const pathfinderTargetInstanceId =
      globalState.cavebot?.dynamicTarget?.targetInstanceId;

    if (pathfinderTargetInstanceId) {
      const currentPathfinderTarget = reachableCreatures.find(
        (c) => c.instanceId === pathfinderTargetInstanceId,
      );
      if (currentPathfinderTarget) {
        const rule = targetingList.find(
          (r) =>
            r.name.startsWith(currentPathfinderTarget.name) &&
            r.action === 'Attack',
        );
        if (rule) {
          const stickiness = rule.stickiness || 0;
          return {
            ...currentPathfinderTarget,
            rule,
            effectivePriority: rule.priority + stickiness,
          };
        }
      }
    }

    const targetableCreatures = reachableCreatures
      .map((creature) => {
        const rule = targetingList.find(
          (r) =>
            r.name.startsWith(creature.name) &&
            r.action === 'Attack' &&
            (r.healthRange === 'Any' || r.healthRange === creature.healthTag),
        );
        if (!rule) return null;
        return { ...creature, rule, effectivePriority: rule.priority };
      })
      .filter(Boolean);

    if (targetableCreatures.length === 0) {
      return null;
    }

    targetableCreatures.sort((a, b) => {
      if (a.effectivePriority !== b.effectivePriority) {
        return b.effectivePriority - a.effectivePriority;
      }
      if (a.gameCoords && b.gameCoords && playerMinimapPosition) {
        const distA = Math.max(
          Math.abs(a.gameCoords.x - playerMinimapPosition.x),
          Math.abs(a.gameCoords.y - playerMinimapPosition.y),
        );
        const distB = Math.max(
          Math.abs(b.gameCoords.x - playerMinimapPosition.x),
          Math.abs(b.gameCoords.y - playerMinimapPosition.y),
        );
        return distA - distB;
      }
      return a.distance - b.distance;
    });

    return targetableCreatures[0];
  };

  const manageTargetAcquisition = async (
    targetingContext,
    globalState,
    pathfindingTarget,
    currentGameTarget,
  ) => {
    if (!pathfindingTarget) {
      targetingContext.lastClickedBattleListIndex = -1;
      return;
    }

    if (currentGameTarget?.instanceId === pathfindingTarget.instanceId) {
      targetingContext.lastClickedBattleListIndex = -1;
      return;
    }

    const now = Date.now();
    if (now - targetingContext.lastClickTime < TARGET_CLICK_DELAY_MS) {
      return;
    }

    const battleList = globalState.battleList.entries;
    const KEY_PRESS_LIMIT = 2;

    const logAcquisition = (startTime) => {
      const acquisitionTime = Date.now() - startTime;
      acquisitionTimes.push(acquisitionTime);
      if (acquisitionTime > maxAcquisitionTime) {
        maxAcquisitionTime = acquisitionTime;
      }
      const sum = acquisitionTimes.reduce((a, b) => a + b, 0);
      avgAcquisitionTime = Math.round(sum / acquisitionTimes.length);
    };

    const performActionAndWait = async (
      action,
      clickRegion = null,
      presses = 1,
    ) => {
      let currentClickDelay = TARGET_CLICK_DELAY_MS;
      let isMultiTabOrGrave = false;

      if (action === 'tab' || action === 'grave') {
        if (presses > 1) {
          isMultiTabOrGrave = true;
        }
      }

      if (action === 'click' || isMultiTabOrGrave) {
        currentClickDelay = SHORT_CLICK_DELAY_MS;
      }

      targetingContext.acquisitionUnlockTime = Date.now() + currentClickDelay;
      const actionTriggerTime = Date.now();

      const checkTargetAndAcceptSubstitute = () => {
        const currentTarget = globalState.targeting.target;
        if (!currentTarget) return false;

        // 1. Check for perfect instanceId match
        if (currentTarget.instanceId === pathfindingTarget.instanceId) {
          return true;
        }

        // 2. Check for acceptable substitute (same name and is adjacent)
        const isSameName =
          currentTarget.name &&
          pathfindingTarget.name &&
          currentTarget.name.startsWith(pathfindingTarget.name);
        const isAdjacent = currentTarget.distance < MELEE_DISTANCE_THRESHOLD;

        if (isSameName && isAdjacent) {
          logger(
            'info',
            `[Targeting] Original target not found, but accepted adjacent substitute: ${currentTarget.name}`,
          );
          // Update the main target to this new one to prevent re-targeting next tick.
          targetingContext.pathfindingTarget = {
            ...currentTarget,
            rule: pathfindingTarget.rule, // Keep the original rule for stance, etc.
          };
          return true;
        }
        return false;
      };

      if (action === 'tab') {
        await delay(50); // Delay before keypress
        keypress.sendKey('tab', globalState.global.display);
        await delay(50); // Delay after keypress
      } else if (action === 'grave') {
        await delay(50); // Delay before keypress
        keypress.sendKey('`', globalState.global.display);
        await delay(50); // Delay after keypress
      } else if (action === 'click' && clickRegion) {
        const clickX = clickRegion.x + 5;
        const clickY = clickRegion.y + 2;
        await delay(50); // Delay before mouse click
        mouseController.leftClick(
          parseInt(globalState.global.windowId),
          clickX,
          clickY,
          globalState.global.display,
        );
        await delay(50); // Delay after mouse click
      }

      if (action === 'tab' && presses === 2) {
        await delay(100); // Wait 100ms between clicks
        keypress.sendKey('tab', globalState.global.display);
        await delay(50); // Delay after second keypress
      }

      targetingContext.lastClickTime = Date.now();
      await delay(50);

      const startTime = Date.now();
      while (Date.now() - startTime < TARGET_CONFIRMATION_TIMEOUT_MS) {
        if (checkTargetAndAcceptSubstitute()) {
          logAcquisition(actionTriggerTime);
          return true;
        }
        await delay(CLICK_POLL_INTERVAL_MS);
      }

      if (checkTargetAndAcceptSubstitute()) {
        logAcquisition(actionTriggerTime);
        return true;
      }

      return false;
    };

    const currentIndex = battleList.findIndex((e) => e.isTarget);
    let bestKeyPlan = { action: null, presses: Infinity };

    if (currentIndex !== -1) {
      const potentialIndices = battleList
        .map((e, i) => i)
        .filter((i) => pathfindingTarget.name.startsWith(battleList[i].name));
      if (potentialIndices.length > 0) {
        for (const desiredIndex of potentialIndices) {
          const tabs =
            (desiredIndex - currentIndex + battleList.length) %
            battleList.length;
          if (tabs > 0 && tabs < bestKeyPlan.presses) {
            bestKeyPlan = { action: 'tab', presses: tabs };
          }
          const graves =
            (currentIndex - desiredIndex + battleList.length) %
            battleList.length;
          if (graves > 0 && graves < bestKeyPlan.presses) {
            bestKeyPlan = { action: 'grave', presses: graves };
          }
        }
      }
    }

    if (
      bestKeyPlan.action &&
      bestKeyPlan.presses <= KEY_PRESS_LIMIT &&
      Math.random() > 0.05
    ) {
      logger(
        'info',
        `[Targeting] Acquisition: Key plan is cheap (${bestKeyPlan.presses} <= ${KEY_PRESS_LIMIT}). Trying one '${bestKeyPlan.action}' press.`,
      );
      const acquired = await performActionAndWait(
        bestKeyPlan.action,
        null,
        bestKeyPlan.presses,
      );
      if (acquired) {
        // F8 press removed as per new requirement
      }
      return;
    } else if (bestKeyPlan.action && bestKeyPlan.presses <= KEY_PRESS_LIMIT) {
      logger(
        'info',
        '[Targeting] Acquisition: Key plan was cheap, but using mouse click due to random chance (5%).',
      );
    }

    if (currentIndex === -1) {
      logger(
        'info',
        "[Targeting] Acquisition: No current target. Trying one 'tab' press.",
      );
      const acquired = await performActionAndWait('tab', null, 1);
      if (acquired) {
        // F8 press removed as per new requirement
      }
      return;
    }

    logger(
      'info',
      `[Targeting] Acquisition: Key plan too expensive (cost ${bestKeyPlan.presses}). Falling back to mouse clicks.`,
    );
    const potentialBLTargets = battleList
      .map((entry, index) => ({ ...entry, index }))
      .filter((entry) => pathfindingTarget.name.startsWith(entry.name));

    if (potentialBLTargets.length === 0) {
      logger(
        'warn',
        `[Targeting] Target ${pathfindingTarget.name} not found in battle list.`,
      );
      return;
    }

    let startClickIndex = 0;
    const currentBLTarget = battleList[currentIndex];
    if (
      currentBLTarget &&
      pathfindingTarget.name.startsWith(currentBLTarget.name)
    ) {
      const lastTryIndex = potentialBLTargets.findIndex(
        (t) => t.index === currentIndex,
      );
      if (lastTryIndex !== -1) {
        startClickIndex = (lastTryIndex + 1) % potentialBLTargets.length;
      }
    }

    for (let i = 0; i < potentialBLTargets.length; i++) {
      const targetToClick =
        potentialBLTargets[(startClickIndex + i) % potentialBLTargets.length];
      logger(
        'info',
        `[Targeting] Acquisition: Attempting to click ${targetToClick.name} at index ${targetToClick.index}`,
      );
      const acquired = await performActionAndWait(
        'click',
        targetToClick.region,
        1,
      );
      if (acquired) {
        // F8 press removed as per new requirement
        return;
      }
    }

    logger(
      'error',
      `[Targeting] Failed to acquire target ${pathfindingTarget.name} after trying all methods.`,
    );
  };

  const manageMovement = async (
    targetingContext,
    globalState,
    pathfindingTarget,
    path,
    pathfindingStatus,
    playerMinimapPosition,
  ) => {
    if (
      !pathfindingTarget ||
      !pathfindingTarget.isReachable ||
      !pathfindingTarget.gameCoords
    ) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'cavebot/setDynamicTarget',
        payload: null,
      });
      return;
    }

    // If the target is already adjacent, do not attempt to move.
    if (pathfindingTarget.distance < MELEE_DISTANCE_THRESHOLD) {
      return;
    }

    const dynamicGoal = {
      stance: pathfindingTarget.rule.stance,
      distance: pathfindingTarget.rule.distance,
      targetCreaturePos: pathfindingTarget.gameCoords,
      targetInstanceId: pathfindingTarget.instanceId,
    };
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/setDynamicTarget',
      payload: dynamicGoal,
    });

    if (
      !targetingContext.lastDispatchedVisitedTile ||
      targetingContext.lastDispatchedVisitedTile.x !==
        playerMinimapPosition.x ||
      targetingContext.lastDispatchedVisitedTile.y !==
        playerMinimapPosition.y ||
      targetingContext.lastDispatchedVisitedTile.z !== playerMinimapPosition.z
    ) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'cavebot/addVisitedTile',
        payload: playerMinimapPosition,
      });
      targetingContext.lastDispatchedVisitedTile = { ...playerMinimapPosition };
    }

    const now = Date.now();
    if (pathfindingStatus !== 1 || path.length === 0) {
      // PATH_STATUS_PATH_FOUND = 1
      return;
    }

    if (now - targetingContext.lastMovementTime < MOVEMENT_COOLDOWN_MS) {
      return;
    }

    if (pathfindingTarget.rule.stance === 'Stand') {
      return;
    }

    if (pathfindingStatus === 1 && path.length > 1) {
      const nextStep = path[1];
      const dirKey = getDirectionKey(playerMinimapPosition, nextStep);
      if (dirKey) {
        const posCounterBeforeMove = Atomics.load(playerPosArray, 3);
        const pathCounterBeforeMove = Atomics.load(pathDataArray, 4);
        const isDiagonal = ['q', 'e', 'z', 'c'].includes(dirKey);
        const timeout = isDiagonal
          ? MOVE_CONFIRM_TIMEOUT_DIAGONAL_MS
          : MOVE_CONFIRM_TIMEOUT_STRAIGHT_MS;

        keypress.sendKey(dirKey, globalState.global.display);
        targetingContext.lastMovementTime = now;
        try {
          await awaitWalkConfirmation(
            posCounterBeforeMove,
            pathCounterBeforeMove,
            timeout,
          );
          if (isDiagonal) {
            await delay(MOVE_CONFIRM_GRACE_DIAGONAL_MS);
          }
        } catch (error) {}
      }
    }
  };

  return {
    selectBestTargetFromGameWorld,
    manageTargetAcquisition,
    manageMovement,
  };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/targetingWorker.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/targetingWorker.js
import { parentPort, workerData } from 'worker_threads';
import keypress from 'keypress-native';
import { createLogger } from '../utils/logger.js';
import { createTargetingActions } from './targeting/actions.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_WAYPOINTS_START_INDEX,
  PATH_WAYPOINT_SIZE,
  PATH_START_X_INDEX,
  PATH_START_Y_INDEX,
  PATH_START_Z_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
} from './sharedConstants.js';

const logger = createLogger({ info: false, error: true, debug: false });

// --- Worker State ---
let isInitialized = false;
let globalState = null;
let isShuttingDown = false;
let isProcessing = false;
let playerMinimapPosition = null;
let path = [];
let pathfindingStatus = 0;
let lastPlayerPosCounter = -1;
let lastPathDataCounter = -1;
const meleeRangeTimers = new Map();
let shouldRequestNewPath = false;
let justGainedControl = false;

// --- Targeting State & Context ---
// This object holds state that is mutated by the targeting actions module.
const targetingContext = {
  pathfindingTarget: null,
  lastPathfindingTargetSwitchTime: 0,
  acquisitionUnlockTime: 0,
  lastMovementTime: 0,
  lastDispatchedVisitedTile: null,
  lastClickTime: 0,
  lastClickedBattleListIndex: -1,
};

// --- Change Detection State ---
let lastBattleListHash = null;
let lastCreaturesHash = null;
let lastTargetInstanceId = null;
let lastTargetingListHash = null;
let lastPlayerPosKey = null;
let lastControlState = 'CAVEBOT';
let lastTargetingEnabled = false;
let lastCavebotEnabled = false;

const { playerPosSAB, pathDataSAB } = workerData;
const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const pathDataArray = pathDataSAB ? new Int32Array(pathDataSAB) : null;

// --- Factory for Modularized Actions ---
const targetingActions = createTargetingActions({
  playerPosArray,
  pathDataArray,
  parentPort,
});

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const updateSABData = () => {
  if (playerPosArray) {
    const newPlayerPosCounter = Atomics.load(
      playerPosArray,
      PLAYER_POS_UPDATE_COUNTER_INDEX,
    );
    if (newPlayerPosCounter > lastPlayerPosCounter) {
      playerMinimapPosition = {
        x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
      };
      lastPlayerPosCounter = newPlayerPosCounter;
    }
  }
  if (pathDataArray) {
    if (shouldRequestNewPath) {
      path = [];
      pathfindingStatus = PATH_STATUS_IDLE;
      lastPathDataCounter = -1;
      shouldRequestNewPath = false;
      return;
    }

    let consistentRead = false;
    let attempts = 0;
    do {
      const counterBeforeRead = Atomics.load(
        pathDataArray,
        PATH_UPDATE_COUNTER_INDEX,
      );
      if (counterBeforeRead === lastPathDataCounter) return;

      const pathStartX = Atomics.load(pathDataArray, PATH_START_X_INDEX);
      const pathStartY = Atomics.load(pathDataArray, PATH_START_Y_INDEX);
      const pathStartZ = Atomics.load(pathDataArray, PATH_START_Z_INDEX);

      if (
        !playerMinimapPosition ||
        playerMinimapPosition.x !== pathStartX ||
        playerMinimapPosition.y !== pathStartY ||
        playerMinimapPosition.z !== pathStartZ
      ) {
        lastPathDataCounter = counterBeforeRead;
        return;
      }

      pathfindingStatus = Atomics.load(pathDataArray, PATHFINDING_STATUS_INDEX);
      const pathLength = Atomics.load(pathDataArray, PATH_LENGTH_INDEX);
      const tempPath = [];
      const safePathLength = Math.min(pathLength, 50); // MAX_PATH_WAYPOINTS
      for (let i = 0; i < safePathLength; i++) {
        const offset = PATH_WAYPOINTS_START_INDEX + i * PATH_WAYPOINT_SIZE;
        tempPath.push({
          x: Atomics.load(pathDataArray, offset + 0),
          y: Atomics.load(pathDataArray, offset + 1),
          z: Atomics.load(pathDataArray, offset + 2),
        });
      }

      const counterAfterRead = Atomics.load(
        pathDataArray,
        PATH_UPDATE_COUNTER_INDEX,
      );
      if (counterAfterRead === counterBeforeRead) {
        if (tempPath.length > 0) {
          const pathStart = tempPath[0];
          const pathEnd = tempPath[tempPath.length - 1];
          const target = targetingContext.pathfindingTarget;

          if (
            pathStart.x !== playerMinimapPosition.x ||
            pathStart.y !== playerMinimapPosition.y ||
            pathStart.z !== playerMinimapPosition.z
          ) {
            path = []; // Invalidate: Path doesn't start at player's current position.
          } else if (
            target &&
            target.gameCoords &&
            (pathEnd.x !== target.gameCoords.x ||
              pathEnd.y !== target.gameCoords.y ||
              pathEnd.z !== target.gameCoords.z)
          ) {
            path = []; // Invalidate: Path doesn't end at the intended target.
          } else {
            path = tempPath; // Path is valid.
          }
        } else {
          path = tempPath; // Path is empty, accept it as is.
        }

        lastPathDataCounter = counterBeforeRead;
        consistentRead = true;
      } else {
        attempts++;
      }
    } while (!consistentRead && attempts < 3);
  }
};

async function performTargeting() {
  if (!globalState.regionCoordinates?.regions?.onlineMarker) {
    return;
  }
  if (
    !globalState.regionCoordinates ||
    !globalState.regionCoordinates.regions.gameWorld
  ) {
    // If gameWorld is not visible, do nothing.
    return;
  }
  if (isShuttingDown || !isInitialized || !globalState?.global?.display) {
    return;
  }

  if (globalState.targeting?.isPausedByScript) {
    return;
  }

  if (justGainedControl) {
    justGainedControl = false;
  }

  if (!globalState.targeting?.enabled) {
    if (globalState.cavebot?.controlState === 'TARGETING') {
      // F8 press removed as per new requirement
      parentPort.postMessage({
        storeUpdate: true,
        type: 'cavebot/releaseTargetingControl',
      });
    }
    return;
  }

  const { controlState, enabled: cavebotIsEnabled } = globalState.cavebot;

  if (!cavebotIsEnabled && controlState !== 'TARGETING') {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/confirmTargetingControl',
    });
    return;
  }

  // Throttle how often the main target can change.
  const newPathfindingTarget = targetingActions.selectBestTargetFromGameWorld(
    globalState,
    playerMinimapPosition,
  );

  if (!newPathfindingTarget) {
    // If no target is found, clear it immediately.
    targetingContext.pathfindingTarget = null;
  } else if (
    newPathfindingTarget.instanceId !==
    targetingContext.pathfindingTarget?.instanceId
  ) {
    // A switch between two different valid targets is requested.
    const now = Date.now();
    targetingContext.pathfindingTarget = newPathfindingTarget;
    targetingContext.lastPathfindingTargetSwitchTime = now;
  } else {
    // It's the same target instance, just update its data.
    targetingContext.pathfindingTarget = newPathfindingTarget;
  }

  if (controlState === 'CAVEBOT' && cavebotIsEnabled) {
    if (targetingContext.pathfindingTarget) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'cavebot/requestTargetingControl',
      });
    }
    return;
  }

  if (controlState === 'HANDOVER_TO_TARGETING') {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/confirmTargetingControl',
    });
    return;
  }

  if (globalState.cavebot.controlState !== 'TARGETING') {
    return;
  }

  updateSABData();
  if (!playerMinimapPosition) return;

  let effectiveTarget = targetingContext.pathfindingTarget;
  const now = Date.now();
  const allCreatures = globalState.targeting.creatures || [];

  // Melee Override Logic
  const meleeConflict = Array.from(meleeRangeTimers.entries()).find(
    ([instanceId, startTime]) =>
      now - startTime > 100 && effectiveTarget?.instanceId !== instanceId,
  );
  if (meleeConflict) {
    const [meleeInstanceId] = meleeConflict;
    const blockingCreature = allCreatures.find(
      (c) => c.instanceId === meleeInstanceId,
    );
    const blockingCreatureRule =
      blockingCreature &&
      globalState.targeting.targetingList?.find(
        (r) =>
          r.name.startsWith(blockingCreature.name) && r.action === 'Attack',
      );
    if (blockingCreature && blockingCreatureRule) {
      logger(
        'info',
        `[Targeting] Overriding target ${effectiveTarget?.name || 'None'} to attack ${blockingCreature.name} in melee range.`,
      );
      effectiveTarget = { ...blockingCreature, rule: blockingCreatureRule };
    }
  }

  await targetingActions.manageMovement(
    targetingContext,
    globalState,
    effectiveTarget,
    path,
    pathfindingStatus,
    playerMinimapPosition,
  );

  const currentGameTarget = globalState.targeting.target;
  if (effectiveTarget) {
    if (Date.now() > targetingContext.acquisitionUnlockTime) {
      targetingActions.manageTargetAcquisition(
        targetingContext,
        globalState,
        effectiveTarget,
        currentGameTarget,
      );
    }
  } else {
    if (cavebotIsEnabled) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'cavebot/releaseTargetingControl',
      });
    }
  }
  // Update lastEffectiveTarget for the next cycle
  targetingContext.lastEffectiveTarget = effectiveTarget;
}

// --- Main Worker Loop ---
parentPort.on('message', (message) => {
  if (isShuttingDown) return;

  try {
    if (message.type === 'shutdown') {
      isShuttingDown = true;
      return;
    } else if (message.type === 'state_diff') {
      if (!globalState) globalState = {};
      Object.assign(globalState, message.payload);
    } else if (typeof message === 'object' && !message.type) {
      globalState = message;
      if (!isInitialized) {
        isInitialized = true;
        logger(
          'info',
          '[TargetingWorker] Initial state received. Worker is now active.',
        );
      }
    }

    if (isProcessing || !globalState) return;

    const newBattleListHash = JSON.stringify(globalState.battleList?.entries);
    const newCreaturesHash = JSON.stringify(globalState.targeting?.creatures);
    const newTargetInstanceId = globalState.targeting?.target?.instanceId;
    const newTargetingListHash = JSON.stringify(
      globalState.targeting?.targetingList,
    );
    const newPlayerPosKey = playerMinimapPosition
      ? `${playerMinimapPosition.x},${playerMinimapPosition.y},${playerMinimapPosition.z}`
      : null;
    const newControlState = globalState.cavebot?.controlState;
    const newTargetingEnabled = globalState.targeting?.enabled;
    const newCavebotEnabled = globalState.cavebot?.enabled;

    const shouldProcess =
      newBattleListHash !== lastBattleListHash ||
      newCreaturesHash !== lastCreaturesHash ||
      newTargetInstanceId !== lastTargetInstanceId ||
      newTargetingListHash !== lastTargetingListHash ||
      newPlayerPosKey !== lastPlayerPosKey ||
      newControlState !== lastControlState ||
      newTargetingEnabled !== lastTargetingEnabled ||
      newCavebotEnabled !== lastCavebotEnabled;

    if (shouldProcess) {
      isProcessing = true;

      if (
        (newControlState === 'TARGETING' && lastControlState !== 'TARGETING') ||
        (newControlState === 'HANDOVER_TO_TARGETING' &&
          lastControlState !== 'HANDOVER_TO_TARGETING')
      ) {
        shouldRequestNewPath = true;
        justGainedControl = true;
      }

      lastBattleListHash = newBattleListHash;
      lastCreaturesHash = newCreaturesHash;
      lastTargetInstanceId = newTargetInstanceId;
      lastTargetingListHash = newTargetingListHash;
      lastPlayerPosKey = newPlayerPosKey;
      lastControlState = newControlState;
      lastTargetingEnabled = newTargetingEnabled;
      lastCavebotEnabled = newCavebotEnabled;

      performTargeting()
        .catch((err) =>
          logger(
            'error',
            '[TargetingWorker] Unhandled error in performTargeting:',
            err,
          ),
        )
        .finally(() => {
          isProcessing = false;
        });
    }
  } catch (error) {
    logger('error', '[TargetingWorker] Error handling message:', error);
    isProcessing = false;
  }
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/windowTitleMonitor.js
//start file
import { parentPort, workerData } from 'worker_threads';
import windowinfo from 'windowinfo-native';
import { createLogger } from '../utils/logger.js';

const log = createLogger({ info: true, debug: false });
log('info', '[WindowTitleMonitor] Worker file loaded.');

const POLLING_INTERVAL = 100;
const INITIAL_CHECK_DELAY_MS = 2500; // A one-time delay for the very first check.

let intervalId = null;
let isInitialized = false;
let isShuttingDown = false;
let currentState = null; // This worker's local copy of the Redux state.
let lastKnownLiveName = null; // An internal tracker to prevent spamming updates.

const CHARACTER_NAME_REGEX = /Tibia - (.+)/;
const getCharacterNameFromTitle = (title) => {
  const match = title.match(CHARACTER_NAME_REGEX);
  return match ? match[1] : null;
};

const reusableUpdate = {
  storeUpdate: true,
  type: 'gameState/updateCharacterNames',
  payload: {},
};

const monitorWindowTitle = async () => {
  if (!isInitialized || !currentState || isShuttingDown) {
    return;
  }

  const { windowId, display } = currentState.global;
  if (!windowId || !display) {
    return;
  }

  try {
    const windowInfo = await windowinfo.getAllInfo({ windowId, display });
    const liveCharacterName = windowInfo?.name
      ? getCharacterNameFromTitle(windowInfo.name)
      : null;

    // The core logic: We only act if the live name is different from the last live name we processed.
    if (liveCharacterName !== lastKnownLiveName) {
      log(
        'info',
        `[WindowTitleMonitor] Live name change detected: '${lastKnownLiveName || 'None'}' -> '${liveCharacterName || 'None'}'. Dispatching update.`,
      );

      const updatePayload = {
        characterName: liveCharacterName,
      };

      if (lastKnownLiveName) {
        updatePayload.lastCharacterName = lastKnownLiveName;
      }

      reusableUpdate.payload = updatePayload;
      parentPort.postMessage(reusableUpdate);

      // CRITICAL: Update our internal tracker immediately after sending.
      lastKnownLiveName = liveCharacterName;
    }

    if (!windowInfo) {
      stopMonitoring();
    }
  } catch (error) {
    log('error', '[WindowTitleMonitor] Critical error in monitor loop:', error);
    stopMonitoring();
    if (lastKnownLiveName !== null) {
      reusableUpdate.payload = {
        characterName: null,
        lastCharacterName: lastKnownLiveName,
      };
      parentPort.postMessage(reusableUpdate);
      lastKnownLiveName = null;
    }
  }
};

const startMonitoring = () => {
  if (intervalId) return;
  log(
    'info',
    `[WindowTitleMonitor] Scheduling first check in ${INITIAL_CHECK_DELAY_MS}ms.`,
  );

  // --- THIS IS THE FIX ---
  // We wait a moment before the first check to ensure the OS has registered the window title.
  setTimeout(() => {
    if (isShuttingDown) return;

    log('info', '[WindowTitleMonitor] Starting relentless polling loop.');
    // Run the check once immediately after the delay.
    monitorWindowTitle();
    // Then, start the regular interval for all subsequent checks.
    intervalId = setInterval(monitorWindowTitle, POLLING_INTERVAL);
  }, INITIAL_CHECK_DELAY_MS);
};

const stopMonitoring = () => {
  if (intervalId) {
    clearInterval(intervalId);
    intervalId = null;
    log('info', '[WindowTitleMonitor] Stopped polling loop.');
  }
};

parentPort.on('message', (message) => {
  try {
    if (message.type === 'shutdown') {
      isShuttingDown = true;
      log('info', '[WindowTitleMonitor] Received shutdown signal.');
      stopMonitoring();
      parentPort.close();
      return;
    }

    if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      Object.assign(currentState, message.payload);
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
      if (!isInitialized) {
        isInitialized = true;
        log(
          'info',
          '[WindowTitleMonitor] Received initial state. Starting monitor...',
        );
        // Initialize our tracker with the official state from the store, just once.
        lastKnownLiveName = currentState.gameState.characterName;
        startMonitoring();
      }
    }
  } catch (error) {
    log('error', '[WindowTitleMonitor] Error handling message:', error);
  }
});

log(
  'info',
  '[WindowTitleMonitor] Worker initialized and awaiting initial state.',
);

//endFile

