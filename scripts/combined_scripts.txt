// /home/feiron/Dokumenty/Automaton/electron/constants/actionBarItems.js
//start file
const actionBarItems = {
  exuraMaxVita: {
    name: 'Exura Max Vita',
    iconName: 'Restoration',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [240, 248, 255],
      [227, 241, 255],
      [215, 235, 255],
    ],
  },
  exuraVita: {
    name: 'Exura Vita',
    iconName: 'Ultimate_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [215, 235, 254],
      [223, 239, 255],
      [228, 242, 255],
    ],
  },
  exuraGran: {
    name: 'Exura Gran',
    iconName: 'Intense_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [235, 238, 243],
      [224, 227, 233],
      [233, 229, 233],
    ],
  },
  exura: {
    name: 'Exura',
    iconName: 'Light_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [228, 210, 216],
      [223, 209, 217],
      [229, 228, 234],
    ],
  },
  exuraInfir: {
    name: 'Exura Infir',
    iconName: 'Magic_Patch',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [222, 215, 223],
      [216, 210, 218],
      [210, 199, 209],
    ],
  },
  utetaResVen: {
    name: 'Uteta Res Ven',
    iconName: 'Avatar_Of_Storm',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [173, 152, 240],
      [153, 103, 253],
      [255, 255, 255],
    ],
  },
  cancelMagicShield: {
    name: 'Exana Vita',
    iconName: 'Cancel_Magic_Shield',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [249, 200, 193],
      [251, 210, 203],
      [213, 139, 198],
    ],
  },
  curePoison: {
    name: 'Exana Pox',
    iconName: 'Cure_Poison',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [211, 236, 243],
      [184, 217, 222],
      [229, 242, 243],
    ],
  },
  exposeWeakness: {
    name: 'Exori Moe',
    iconName: 'Expose_Weakness',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [59, 63, 40],
      [59, 63, 40],
      [103, 113, 69],
    ],
  },
  magicShield: {
    name: 'Utamo Vita',
    iconName: 'Magic_Shield',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [147, 115, 27],
      [182, 151, 28],
      [226, 129, 206],
    ],
  },
  sapStrength: {
    name: 'Exori Kor',
    iconName: 'Sap_Strength',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [153, 169, 101],
      [180, 187, 118],
      [27, 27, 27],
      [22, 22, 22],
      [22, 22, 22],
    ],
  },
  utaniGranHur: {
    name: 'Utani Gran Hur',
    iconName: 'Strong_Haste',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [38, 116, 112],
      [11, 37, 36],
      [7, 29, 28],
      [6, 29, 28],
      [6, 30, 28],
    ],
  },
  utaniHur: {
    name: 'Utani Hur',
    iconName: 'Haste',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [78, 173, 166],
      [69, 157, 151],
      [12, 32, 31],
      [11, 27, 26],
      [11, 27, 26],
      [18, 44, 42],
      [29, 74, 70],
    ],
  },
  ultimateManaPotion: {
    name: 'Ultimate Mana Potion',
    iconName: 'Ultimate_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [141, 53, 102],
      [152, 58, 109],
      [116, 39, 87],
      [171, 58, 129],
      [151, 47, 114],
      [48, 44, 44],
    ],
  },
  greatManaPotion: {
    name: 'Great Mana Potion',
    iconName: 'Great_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [141, 53, 102],
      [152, 58, 109],
      [116, 39, 87],
      [171, 58, 129],
      [151, 47, 114],
      [143, 43, 109],
    ],
  },
  strongManaPotion: {
    name: 'Strong Mana Potion',
    iconName: 'Strong_Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [169, 0, 131],
      [184, 0, 153],
      [143, 0, 89],
    ],
  },
  ManaPotion: {
    name: 'Mana Potion',
    iconName: 'Mana_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [125, 6, 111],
      [150, 25, 148],
      [136, 7, 121],
    ],
  },
  healthPotion: {
    name: 'Health Potion',
    iconName: 'Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 11, 0],
      [170, 16, 16],
      [193, 47, 54],
    ],
  },
  supremeHealthPotion: {
    name: 'Supreme Health Potion',
    iconName: 'Supreme_Health_Potion',
    categories: ['potion'],
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [[222, 3, 0], 'any', 'any', [53, 43, 40]],
  },
  ultimateHealthPotion: {
    name: 'Ultimate Health Potion',
    iconName: 'Ultimate_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [247, 49, 67],
      [240, 70, 85],
      [238, 55, 66],
    ],
  },
  greatHealthPotion: {
    name: 'Great Health Potion',
    iconName: 'Great_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [247, 49, 67],
      [240, 70, 85],
      [238, 55, 66],
      [208, 2, 0],
      [161, 1, 0],
      [168, 1, 0],
    ],
  },
  strongHealthPotion: {
    name: 'Strong Health Potion',
    iconName: 'Strong_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [228, 0, 17],
      [229, 0, 17],
      [229, 1, 15],
    ],
  },
  smallHealthPotion: {
    name: 'Small Health Potion',
    iconName: 'Small_Health_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [5, 2, 0],
      [67, 67, 67],
      [69, 69, 69],
      [109, 13, 0],
    ],
  },
  ultimateSpiritPotion: {
    name: 'Ultimate Spirit Potion',
    iconName: 'Ultimate_Spirit_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 35, 0],
      [92, 37, 0],
      [75, 30, 0],
      [111, 44, 0],
      [111, 44, 0],
      [48, 44, 44],
    ],
  },
  greatSpiritPotion: {
    name: 'Great Spirit Potion',
    iconName: 'Great_Spirit_Potion',
    categories: ['potion'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 35, 0],
      [92, 37, 0],
      [75, 30, 0],
      [111, 44, 0],
      [122, 59, 0],
    ],
  },
  avalancheRune: {
    name: 'Avalanche Rune',
    iconName: 'Avalanche',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [44, 81, 131],
      [45, 86, 135],
      [1, 2, 4],
      [0, 0, 0],
      [66, 129, 176],
    ],
  },
  thunderstormRune: {
    name: 'Thunderstorm Rune',
    iconName: 'Thunderstorm',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [124, 62, 162],
      [11, 5, 14],
      [9, 4, 9],
      [134, 62, 170],
    ],
  },
  greatFireballRune: {
    name: 'Great Fireball Rune',
    iconName: 'Great_Fireball',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [199, 71, 57],
      [237, 88, 72],
      [178, 73, 55],
    ],
  },
  stoneShowerRune: {
    name: 'Stone Shower Rune',
    iconName: 'Stone_Shower',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [181, 191, 133],
      [126, 166, 93],
      [116, 157, 85],
    ],
  },
  ultimateHealingRune: {
    name: 'Ultimate Healing Rune',
    iconName: 'Ultimate_Healing_Rune',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [18, 18, 18],
      [185, 185, 185],
      [255, 255, 255],
      [235, 235, 235],
      [233, 233, 233],
      [225, 225, 225],
      [209, 209, 209],
      [211, 211, 211],
      [210, 210, 210],
      [101, 101, 101],
    ],
  },
  suddenDeathRune: {
    name: 'Sudden Death Rune',
    iconName: 'Sudden_Death',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [148, 142, 132],
      [146, 137, 127],
      [79, 75, 70],
    ],
  },
  intenseHealingRune: {
    name: 'Intense Healing Rune',
    iconName: 'Intense_Healing_Rune',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [210, 210, 210],
      [100, 100, 100],
      [200, 200, 200],
    ],
  },
  explosionRune: {
    name: 'Explosion Rune',
    iconName: 'Explosion_Rune',
    categories: ['attack'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [13, 6, 16],
      [60, 30, 78],
      [142, 69, 182],
    ],
  },
  stoneSkinAmulet: {
    name: 'Stone Skin Amulet',
    iconName: 'Stone_Skin_Amulet',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [115, 115, 115],
      [65, 65, 65],
      [73, 73, 73],
      [73, 74, 73],
      [69, 69, 69],
      [68, 68, 68],
      [68, 69, 69],
      [73, 73, 73],
      [67, 67, 67],
      [73, 73, 73],
      [67, 67, 67],
      [74, 74, 74],
      [65, 65, 65],
      [67, 68, 68],
      [70, 71, 71],
      [0, 0, 0],
      [59, 59, 59],
      [135, 135, 135],
    ],
  },
  mightRing: {
    name: 'Might Ring',
    iconName: 'Might_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [115, 115, 115],
      [65, 65, 65],
      [73, 73, 73],
      [73, 74, 73],
      [69, 69, 69],
      [68, 68, 68],
      [68, 69, 69],
      [73, 73, 73],
      [67, 67, 67],
      [73, 73, 73],
      [67, 67, 67],
      [74, 74, 74],
      [65, 65, 65],
      [67, 68, 68],
      [0, 0, 0],
      [205, 172, 69],
    ],
  },
  mastermindPotion: {
    name: 'Mastermind Potion',
    iconName: 'Mastermind_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [67, 68, 68],
      [0, 0, 3],
      [87, 142, 92],
      [90, 160, 98],
    ],
  },
  bullseyePotion: {
    name: 'Bullseye Potion',
    iconName: 'Bullseye_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [57, 49, 44],
      [93, 80, 72],
      [115, 98, 87],
    ],
  },
  berserkPotion: {
    name: 'Berserk Potion',
    iconName: 'Berserk_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [116, 76, 36],
      [147, 91, 34],
      [137, 80, 19],
    ],
  },
  transcendencePotion: {
    name: 'Transcendence Potion',
    iconName: 'Transcendence_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [109, 82, 36],
      [109, 82, 36],
      [59, 43, 16],
      [59, 43, 16],
    ],
  },
  magicShieldPotion: {
    name: 'Magic Shield Potion',
    iconName: 'Magic_Shield_Potion',
    categories: ['other'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [67, 67, 67],
      [69, 69, 69],
      [0, 0, 0],
      [239, 244, 253],
    ],
  },
  createThunderstormRune: {
    name: 'Create Thunderstorm Rune',
    iconName: 'Create_Thunderstorm_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [136, 68, 159],
      [63, 37, 64],
      [57, 34, 57],
    ],
  },
  createGreatFireballRune: {
    name: 'Create Great Fireball Rune',
    iconName: 'Create_Great_Fireball_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [89, 39, 17],
      [80, 32, 13],
      [61, 24, 8],
    ],
  },
  createSuddenDeathRune: {
    name: 'Create Sudden Death Rune',
    iconName: 'Create_Sudden_Death_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [134, 128, 122],
      [93, 90, 87],
      [50, 50, 50],
    ],
  },
  createMagicWallRune: {
    name: 'Create Magic Wall Rune',
    iconName: 'Create_Magic_Wall_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [138, 143, 93],
      [93, 106, 77],
      [100, 124, 90],
    ],
  },
  createExplosionRune: {
    name: 'Create Explosion Rune',
    iconName: 'Create_Explosion_Rune',
    categories: ['runemaking'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [39, 27, 46],
      [180, 98, 181],
      [108, 59, 133],
    ],
  },
  energyRing: {
    name: 'Energy Ring',
    iconName: 'Energy_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [88, 227, 177],
      [200, 255, 255],
      [57, 149, 118],
      [0, 0, 0],
    ],
  },
  lifeRing: {
    name: 'Life Ring',
    iconName: 'Life_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [91, 206, 68],
      [175, 253, 171],
      [60, 137, 45],
      [0, 0, 0],
    ],
  },
  dwarvenRing: {
    name: 'Dwarven Ring',
    iconName: 'Dwarven_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [196, 196, 196],
      [255, 255, 255],
      [150, 150, 150],
      [0, 0, 0],
    ],
  },
  axeRing: {
    name: 'Axe Ring',
    iconName: 'Axe_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [137, 137, 137],
      [212, 212, 212],
      [91, 91, 91],
      [0, 0, 0],
    ],
  },
  clubRing: {
    name: 'Club Ring',
    iconName: 'Club_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [206, 68, 172],
      [253, 171, 221],
      [137, 45, 114],
      [0, 0, 0],
    ],
  },
  powerRing: {
    name: 'Power Ring',
    iconName: 'Power_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [124, 53, 197],
      [214, 147, 253],
      [79, 39, 119],
      [0, 0, 0],
    ],
  },
  stealthRing: {
    name: 'Stealth Ring',
    iconName: 'Stealth_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [68, 114, 206],
      [171, 186, 253],
      [45, 75, 137],
      [0, 0, 0],
    ],
  },
  swordRing: {
    name: 'Sword Ring',
    iconName: 'Sword_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [226, 122, 0],
      [255, 212, 121],
      [134, 73, 0],
      [0, 0, 0],
    ],
  },
  timeRing: {
    name: 'Time Ring',
    iconName: 'Time_Ring',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [74, 74, 74],
      [63, 64, 64],
      [70, 70, 70],
      [0, 0, 0],
      [66, 66, 66],
      [141, 141, 141],
      [20, 20, 20],
      [0, 0, 0],
    ],
  },
  collarOfGreenPlasma: {
    name: 'Collar of Green Plasma',
    iconName: 'Collar_Of_Green_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [14, 107, 68],
      [120, 255, 198],
      [14, 107, 68],
    ],
  },
  collarOfOrangePlasma: {
    name: 'Collar of Orange Plasma',
    iconName: 'Collar_Of_Orange_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [107, 57, 14],
      [255, 182, 120],
      [107, 57, 14],
    ],
  },
  collarOfRedPlasma: {
    name: 'Collar of Red Plasma',
    iconName: 'Collar_Of_Red_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [107, 14, 53],
      [255, 120, 177],
      [107, 14, 53],
    ],
  },
  collarOfBluePlasma: {
    name: 'Collar of Blue Plasma',
    iconName: 'Collar_Of_Blue_Plasma',
    categories: ['equipment'],
    slot: 'amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [14, 51, 107],
      [120, 175, 255],
      [14, 51, 107],
    ],
  },
  ringOfGreenPlasma: {
    name: 'Ring of Green Plasma',
    iconName: 'Ring_Of_Green_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [14, 107, 68],
      [210, 255, 236],
      [14, 107, 68],
    ],
  },
  ringOfRedPlasma: {
    name: 'Ring of Red Plasma',
    iconName: 'Ring_Of_Red_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [107, 14, 53],
      [255, 210, 229],
      [107, 14, 53],
    ],
  },
  ringOfOrangePlasma: {
    name: 'Ring of Orange Plasma',
    iconName: 'Ring_Of_Orange_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [107, 57, 14],
      [255, 231, 210],
      [107, 57, 14],
    ],
  },
  ringOfBluePlasma: {
    name: 'Ring of Blue Plasma',
    iconName: 'Ring_Of_Blue_Plasma',
    categories: ['equipment'],
    slot: 'ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 118],
      [69, 69, 69],
      [69, 69, 69],
      [63, 64, 63],
      [68, 69, 69],
      [71, 71, 71],
      [77, 77, 77],
      [72, 72, 73],
      [69, 69, 69],
      [14, 51, 107],
      [210, 228, 255],
      [14, 51, 107],
    ],
  },
  softBoots: {
    name: 'Soft Boots',
    iconName: 'Soft_Boots',
    categories: ['equipment'],
    slot: 'boots',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [117, 117, 117],
      [70, 70, 70],
      [71, 71, 71],
      [83, 84, 83],
      [69, 70, 69],
      [72, 72, 72],
      [74, 74, 74],
      [72, 73, 72],
      [0, 0, 0],
      [77, 62, 145],
      [124, 109, 195],
      [17, 0, 54],
    ],
  },
  blankRune: {
    name: 'Blank Rune',
    iconName: 'Blank_Rune',
    categories: ['others'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [143, 136, 127],
      [167, 161, 153],
      [180, 173, 164],
    ],
  },
  exuraSio: {
    name: 'Exura Sio',
    iconName: 'Heal_Friend',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [179, 228, 247],
      [201, 232, 245],
      [208, 239, 247],
      [27, 111, 135],
      [8, 33, 39],
    ],
  },
  exuraGranSio: {
    name: 'Exura Gran Sio',
    iconName: 'Natures_Embrace',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [198, 232, 247],
      [196, 232, 248],
      [201, 235, 247],
      [11, 110, 172],
      [44, 60, 79],
      [94, 108, 131],
    ],
  },
  uturaMasSio: {
    name: 'Utura Mas Sio',
    iconName: 'Heal_Party',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [31, 14, 16],
      [46, 19, 22],
      [125, 78, 84],
      [243, 236, 238],
      [243, 241, 245],
    ],
  },
  utanaVid: {
    name: 'Utana Vid',
    iconName: 'Invisible',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [59, 107, 107],
      [91, 98, 228],
      [52, 99, 98],
      [41, 94, 91],
    ],
  },
  exuraGranMasRes: {
    name: 'Exura Gran Mas Res',
    iconName: 'Mass_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [220, 241, 250],
      [199, 229, 240],
      [208, 234, 248],
      [196, 213, 218],
      [192, 205, 204],
    ],
  },
  exanaKor: {
    name: 'Exana Kor',
    iconName: 'Cure_Bleeding',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [213, 231, 242],
      [190, 203, 216],
      [232, 237, 240],
      [116, 35, 48],
    ],
  },
  exanaFlam: {
    name: 'Exana Flam',
    iconName: 'Cure_Burning',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [151, 99, 80],
      [185, 137, 102],
      [227, 166, 128],
      [213, 192, 138],
    ],
  },
  exanaVis: {
    name: 'Exana Vis',
    iconName: 'Cure_Electrification',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [87, 114, 163],
      [214, 232, 253],
      [203, 224, 252],
      [90, 108, 172],
    ],
  },
  exanaMort: {
    name: 'Exana Mort',
    iconName: 'Cure_Curse',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [219, 241, 250],
      [209, 236, 247],
      [242, 251, 254],
      [229, 246, 252],
      [209, 238, 248],
    ],
  },
  utevoLux: {
    name: 'Utevo Lux',
    iconName: 'Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [253, 245, 204],
      [252, 228, 148],
      [244, 189, 99],
      [249, 201, 118],
    ],
  },
  utevoGranLux: {
    name: 'Utevo Gran Lux',
    iconName: 'Great_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [255, 252, 225],
      [255, 247, 195],
      [253, 232, 143],
      [254, 237, 164],
    ],
  },
  utevoVisLux: {
    name: 'Utevo Vis Lux',
    iconName: 'Ultimate_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [254, 253, 242],
      [255, 253, 249],
      [246, 240, 177],
      [232, 215, 104],
    ],
  },
  exuraSan: {
    name: 'Exura San',
    iconName: 'Divine_Healing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [180, 97, 48],
      [245, 248, 221],
      [231, 243, 231],
      [204, 229, 232],
    ],
  },
  uturaGran: {
    name: 'Utura Gran',
    iconName: 'Intense_Recovery',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [51, 77, 91],
      [147, 183, 204],
      [188, 205, 209],
      [179, 179, 164],
    ],
  },
  exuraGranSan: {
    name: 'Exura Gran San',
    iconName: 'Salvation',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [199, 119, 32],
      [239, 212, 120],
      [236, 204, 117],
      [232, 199, 107],
      [201, 126, 42],
    ],
  },
  utetaResSac: {
    name: 'Uteta Res Sac',
    iconName: 'Avatar_Of_Light',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [161, 108, 50],
      [199, 174, 147],
      [199, 174, 147],
      [27, 16, 17],
    ],
  },
  exanaIna: {
    name: 'Exana Ina',
    iconName: 'Cancel_Invisibility',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [12, 178, 167],
      [99, 99, 255],
      [9, 209, 201],
      [8, 212, 203],
    ],
  },
  utevoGravSan: {
    name: 'Utevo Grav San',
    iconName: 'Cancel_Invisibility',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [248, 247, 204],
      [247, 246, 199],
      [175, 161, 123],
    ],
  },
  utamoMasSio: {
    name: 'Utamo Mas Sio',
    iconName: 'Protect_Party',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [215, 245, 251],
      [13, 22, 21],
      [13, 22, 21],
      [13, 22, 21],
      [20, 30, 29],
      [189, 226, 232],
    ],
  },
  utitoTempoSan: {
    name: 'Utito Tempo San',
    iconName: 'Sharpshooter',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [23, 24, 25],
      [48, 50, 51],
      [48, 50, 51],
      [48, 50, 51],
      [112, 116, 118],
      [154, 159, 162],
    ],
  },
  utamoTempoSan: {
    name: 'Utamo Tempo San',
    iconName: 'Swift_Foot',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [21, 86, 81],
      [27, 91, 87],
      [47, 89, 83],
      [48, 93, 88],
    ],
  },
  exuraInfirIco: {
    name: 'Exura Infir Ico',
    iconName: 'Bruise_Bane',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [237, 219, 187],
      [244, 236, 212],
      [237, 242, 237],
      [219, 241, 250],
      [201, 232, 245],
      [207, 236, 247],
    ],
  },
  exuraMedIco: {
    name: 'Exura Med Ico',
    iconName: 'Fair_Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [240, 223, 188],
      [244, 233, 201],
      [240, 219, 181],
      [213, 152, 106],
    ],
  },
  exuraGranIco: {
    name: 'Exura Gran Ico',
    iconName: 'Intense_Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [244, 233, 197],
      [248, 241, 209],
      [246, 235, 198],
      [235, 215, 179],
    ],
  },
  woundCleansing: {
    name: 'Exura Ico',
    iconName: 'Wound_Cleansing',
    categories: ['healing'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [236, 217, 183],
      [241, 229, 196],
      [236, 212, 174],
      [201, 129, 98],
    ],
  },
  utetaResEq: {
    name: 'Uteta Res Sac',
    iconName: 'Avatar_Of_Steel',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [42, 55, 70],
      [15, 15, 15],
      [46, 55, 71],
      [37, 46, 60],
    ],
  },
  utitoTempo: {
    name: 'Utito Tempo',
    iconName: 'Blood_Rage',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [219, 123, 119],
      [228, 172, 172],
      [236, 197, 197],
      [239, 167, 164],
    ],
  },
  utaniTempoHur: {
    name: 'Utani Tempo Hur',
    iconName: 'Charge',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [143, 80, 56],
      [196, 161, 147],
      [139, 105, 96],
      [66, 79, 65],
    ],
  },
  utamoTempo: {
    name: 'Utamo Tempo',
    iconName: 'Protector',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [41, 68, 62],
      [127, 136, 114],
      [122, 163, 141],
      [82, 108, 100],
    ],
  },
  utitoMasSio: {
    name: 'Utito Mas Sio',
    iconName: 'Train_Party',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [64, 189, 58],
      [122, 151, 106],
      [27, 111, 135],
      [8, 33, 39],
    ],
  },
  utetaResDru: {
    name: 'Utera Res Dru',
    iconName: 'Avatar_Of_Nature',
    categories: ['support'],
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [21, 12, 8],
      [0, 0, 0],
      [0, 0, 0],
      [25, 25, 25],
      [0, 0, 0],
      [33, 33, 33],
    ],
  },
};

Object.freeze(actionBarItems);

export default actionBarItems;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/battleListSequences.js
//start file
const battleListSequences = {
  // Border detection sequences for battle entries
  targetBorder: {
    offset: { x: 0, y: 0 },
    direction: 'horizontal',
    sequence: [
      [255, 0, 0], // Red target indicator
    ],
  },
  attackBorder: {
    offset: { x: 1, y: 1 },
    direction: 'horizontal',
    sequence: [
      [0, 0, 0], // Black attack indicator
    ],
  },
  healthBarValidation: {
    offset: { x: 0, y: 0 },
    direction: 'horizontal',
    sequence: [
      [0, 0, 0], // Black border validation
    ],
  },
  // Legacy sequences (can be removed if not used)
  battleEntry: {
    offset: { x: 0, y: 0 },
    direction: 'vertical',
    sequence: [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
  partyEntry: {
    offset: { x: 0, y: 0 },
    direction: 'vertical',
    sequence: [
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
};

export default battleListSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/cooldownColorSequences.js
//start file
const cooldownColorSequences = {
  attack: {
    direction: 'vertical',
    sequence: [
      [0, 0, 6],
      [70, 13, 1],
      [171, 42, 9],
      [255, 255, 255],
    ],
    backupSequence: [
      [0, 0, 6],
      [70, 13, 1],
      [171, 42, 9],
      [255, 255, 255],
    ],
  },
  healing: {
    direction: 'vertical',
    sequence: [
      [1, 37, 102],
      [77, 111, 158],
      [39, 75, 116],
      [255, 255, 255],
    ],
  },
  support: {
    direction: 'vertical',
    sequence: [
      [0, 61, 52],
      [0, 109, 99],
      [52, 179, 172],
      [255, 255, 255],
    ],
  },
  attackInactive: {
    direction: 'vertical',
    sequence: [
      [71, 13, 2],
      [53, 10, 3],
      [0, 0, 0],
    ],
    backupSequence: [
      [72, 13, 2],
      [53, 11, 3],
      [0, 0, 0],
    ],
  },
  healingInactive: {
    direction: 'vertical',
    sequence: [
      [17, 29, 45],
      [6, 16, 30],
      [0, 0, 0],
    ],
  },
  supportInactive: {
    direction: 'vertical',
    sequence: [
      [42, 74, 73],
      [28, 50, 48],
      [0, 0, 0],
    ],
  },
};

export default cooldownColorSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/equippedItems.js
//start file
const equippedItems = {
  emptyRingSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [53, 56, 59],
      [35, 39, 42],
      [36, 39, 42],
      [66, 69, 72],
      [79, 81, 84],
      [37, 40, 43],
    ],
  },
  emptyAmuletSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [30, 33, 36],
      [65, 67, 70],
      [70, 73, 75],
      [82, 84, 87],
      [71, 73, 75],
      [67, 69, 72],
      [32, 35, 37],
    ],
  },
  emptyBootsSlot: {
    name: 'Empty',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [76, 78, 81],
      [61, 64, 66],
      [61, 64, 66],
      [52, 54, 57],
    ],
  },
  softBoots: {
    name: 'Soft Boots',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [36, 9, 93],
      [119, 92, 176],
      [115, 88, 172],
      [79, 52, 136],
    ],
  },
  mightRing: {
    name: 'Might Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [250, 237, 117],
      [246, 219, 98],
      [200, 166, 65],
      [221, 184, 71],
    ],
  },
  stoneSkinAmulet: {
    name: 'Stone Skin Amulet',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [60, 60, 60],
      [110, 110, 110],
      [119, 119, 119],
      [110, 110, 110],
      [60, 60, 60],
    ],
  },
  energyRing: {
    name: 'Energy Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [88, 227, 177],
      [200, 255, 255],
      [57, 149, 118],
      [0, 0, 0],
      [0, 0, 0],
    ],
  },
  lifeRing: {
    name: 'Life Ring',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [91, 206, 68],
      [175, 253, 171],
      [60, 137, 45],
    ],
  },
};

export default equippedItems;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/floorLevelIndicators.js
//start file
const floorLevelIndicators = {
  0: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[115, 182, 212]],
  },
  1: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[104, 165, 193]],
  },
  2: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[95, 152, 177]],
  },
  3: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[88, 140, 163]],
  },
  4: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[82, 130, 151]],
  },
  5: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[76, 121, 141]],
  },
  6: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[71, 114, 132]],
  },
  7: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[120, 147, 79]],
  },
  8: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[147, 100, 79]],
  },
  9: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[134, 90, 72]],
  },
  10: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[122, 83, 66]],
  },
  11: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[113, 76, 61]],
  },
  12: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[105, 71, 57]],
  },
  13: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[98, 66, 53]],
  },
  14: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[92, 62, 49]],
  },
  15: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [[86, 58, 47]],
  },
};

export default floorLevelIndicators;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/index.js
//start file
export { default as regionColorSequences } from './regionColorSequeces.js';
export { default as regionDefinitions } from './regionDefinitions.js';
export { default as cooldownColorSequences } from './cooldownColorSequences.js';
export { default as battleListSequences } from './battleListSequences.js';
export { default as statusBarSequences } from './statusBarSequences.js';
export { default as resourceBars } from './resourceBars.js';
export { default as actionBarItems } from './actionBarItems.js';
export { default as equippedItems } from './equippedItems.js';
export { default as floorLevelIndicators } from './floorLevelIndicators.js';

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/palette.js
//start file
export const PALETTE_DATA = [
  { r: 0, g: 0, b: 0 },
  { r: 0, g: 102, b: 0 },
  { r: 0, g: 204, b: 0 },
  { r: 51, g: 102, b: 153 },
  { r: 102, g: 102, b: 102 },
  { r: 153, g: 51, b: 0 },
  { r: 153, g: 102, b: 51 },
  { r: 153, g: 153, b: 153 },
  { r: 153, g: 255, b: 102 },
  { r: 204, g: 255, b: 255 },
  { r: 255, g: 51, b: 0 },
  { r: 255, g: 102, b: 0 },
  { r: 255, g: 204, b: 153 },
  { r: 255, g: 255, b: 0 },
  { r: 255, g: 255, b: 255 },
];

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/regionColorSequeces.js
//start file
const regionColorSequences = {
  healthBar: {
    direction: 'horizontal',
    offset: { x: 5, y: 0 },
    sequence: [
      [241, 97, 97],
      [219, 91, 91],
      [103, 55, 55],
      'any',
      'any',
      [120, 61, 64],
    ],
  },
  manaBar: {
    direction: 'horizontal',
    offset: { x: 9, y: 0 },
    sequence: [
      [99, 96, 248],
      [95, 92, 219],
      [80, 79, 140],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [61, 61, 125],
    ],
  },
  minimap: {
    direction: 'horizontal',
    offset: { x: -117, y: 35 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  minimapFloorIndicatorColumn: {
    direction: 'horizontal',
    offset: { x: 33, y: 25 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  minimapFull: {
    direction: 'horizontal',
    offset: { x: -117, y: -20 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
  },
  cooldownBar: {
    direction: 'horizontal',
    offset: { x: -154, y: 8 },
    sequence: [
      [76, 75, 67],
      [77, 76, 71],
      [67, 66, 59],
    ],
    backupSequence: [
      [76, 75, 67],
      [76, 75, 71],
      [66, 65, 58],
    ],
  },
  // cooldownBarFallback: {
  //   direction: 'horizontal',
  //   offset: { x: -154, y: 8 },
  //   sequence: [
  //     [76, 75, 67],
  //     [77, 76, 71],
  //     [67, 66, 59],
  //   ],
  // },
  statusBar: {
    direction: 'horizontal',
    offset: { x: -99, y: 1 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  amuletSlot: {
    direction: 'horizontal',
    offset: { x: -100, y: -130 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  ringSlot: {
    direction: 'horizontal',
    offset: { x: -100, y: -58 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  bootsSlot: {
    direction: 'horizontal',
    offset: { x: -63, y: -36 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
  },
  // weaponSlot: {
  //   direction: 'horizontal',
  //   offset: { x: -100, y: -58 },
  //   sequence: [
  //     [41, 42, 42],
  //     [28, 28, 29],
  //     [44, 45, 45],
  //     [40, 40, 41],
  //     [44, 44, 44],
  //     [46, 46, 46],
  //     [112, 112, 113],
  //   ],
  // },
  chatOn: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [108, 108, 108],
      [110, 110, 110],
      [192, 192, 192],
      [161, 161, 161],
      [175, 175, 175],
      [185, 185, 185],
      [81, 81, 81],
    ],
  },
  chatOff: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [174, 174, 174],
      [183, 183, 183],
      [136, 136, 136],
      [174, 174, 174],
      [183, 183, 183],
      [128, 128, 128],
      [62, 62, 62],
    ],
  },

  hotkeyBarBottomStart: {
    direction: 'horizontal',
    offset: { x: 19, y: 0 },
    sequence: [
      [75, 75, 75],
      [68, 68, 68],
      [76, 76, 76],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [46, 46, 47],
      [53, 54, 54],
    ],
  },
  hotkeyBarBottomEnd: {
    direction: 'horizontal',
    offset: { x: -2, y: 0 },
    sequence: [
      [40, 40, 40],
      [43, 43, 43],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [66, 66, 66],
    ],
  },
  battleListStart: {
    direction: 'horizontal',
    offset: { x: 11, y: 17 },
    sequence: [
      [49, 49, 49],
      [129, 79, 41],
      [113, 91, 70],
      [56, 56, 56],
    ],
  },
  battleListEnd: {
    direction: 'horizontal',
    offset: { x: -137, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  partyListStart: {
    direction: 'horizontal',
    offset: { x: 13, y: 13 },
    sequence: [
      [30, 115, 255],
      [55, 55, 55],
      [113, 91, 70],
      [56, 56, 56],
    ],
  },
  partyListEnd: {
    direction: 'horizontal',
    offset: { x: -7, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  playerListStart: {
    direction: 'horizontal',
    offset: { x: 11, y: 17 },
    sequence: [
      [135, 86, 41],
      [159, 136, 40],
      [75, 74, 55],
      [61, 61, 61],
      [128, 193, 84],
      [128, 193, 84],
    ],
  },
  playerListEnd: {
    direction: 'horizontal',
    offset: { x: -137, y: 0 },
    sequence: [
      [67, 67, 67],
      [78, 78, 78],
      [104, 104, 104],
      [67, 67, 67],
    ],
  },
  onlineMarker: {
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [
      [118, 54, 54],
      [74, 74, 75],
      [72, 72, 72],
      [68, 66, 99],
    ],
  },
  gameWorldStart: {
    direction: 'horizontal',
    offset: { x: 1, y: 1 },
    sequence: [
      [22, 22, 22],
      [24, 24, 24],
      [23, 23, 23],
      [22, 22, 22],
      [21, 21, 21],
      [24, 24, 24],
      [23, 24, 23],
      [24, 24, 24],
      [27, 27, 26],
      [24, 24, 24],
      [22, 22, 22],
    ],
  },
  gameWorldEnd: {
    direction: 'horizontal',
    offset: { x: 9, y: -1 },
    sequence: [
      [111, 111, 111],
      [117, 117, 117],
      [116, 116, 116],
      [116, 116, 116],
      [113, 113, 113],
      [115, 115, 115],
      [116, 116, 115],
      [115, 115, 115],
      [118, 118, 117],
      [115, 115, 115],
      [114, 114, 114],
    ],
  },
  chatboxMainStart: {
    direction: 'vertical',
    offset: { x: 1, y: 5 },
    sequence: [
      [112, 112, 113],
      [116, 116, 117],
      'any',
      'any',
      [117, 117, 117],
      'any',
      [27, 27, 28],
    ],
  },
  chatboxSecondaryStart: {
    direction: 'horizontal',
    offset: { x: -1, y: 1 },
    sequence: [
      [63, 63, 63],
      [27, 27, 28],
      'any',
      'any',
      [117, 117, 117],
      [63, 63, 63],
      [27, 27, 28],
    ],
  },
  chatboxMainEnd: {
    direction: 'vertical',
    offset: { x: -7, y: 3 },
    sequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [54, 54, 54],
      [54, 54, 54],
    ],
    backupSequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      [115, 116, 115],
      [75, 75, 75],
    ],
  },
  chatboxSecondaryEnd: {
    direction: 'vertical',
    offset: { x: -7, y: 3 },
    sequence: [
      [159, 159, 159],
      [160, 160, 160],
      [104, 104, 104],
      [10, 10, 10],
      'any',
      'any',
      'any',
      'any',
      'any',
      [115, 116, 115],
      [75, 75, 75],
    ],
  },
  chatBoxTabRowStart: {
    direction: 'vertical',
    offset: { x: 13, y: -14 },
    sequence: [
      [112, 112, 113],
      [116, 116, 117],
      'any',
      'any',
      [117, 117, 117],
      'any',
      [27, 27, 28],
    ],
  },
  chatBoxTabRowEnd: {
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [89, 89, 89],
      [38, 38, 38],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [89, 89, 89],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [41, 41, 41],
      [66, 66, 66],
    ],
  },
  skillsWidgetStart: {
    direction: 'horizontal',
    offset: { x: -3, y: 13 },
    sequence: [
      [170, 143, 100],
      [188, 174, 103],
      [55, 55, 55],
      [65, 65, 65],
    ],
  },
  skillsWidgetEnd: {
    direction: 'horizontal',
    offset: { x: -11, y: 1 },
    sequence: [
      [108, 108, 108],
      [160, 160, 160],
      [81, 81, 81],
      [67, 67, 67],
      [67, 67, 67],
    ],
  },
  preyWindow: {
    direction: 'horizontal',
    offset: { x: -13, y: -6 },
    sequence: [
      [229, 169, 24],
      [25, 70, 10],
      [39, 103, 18],
    ],
  },
  connectionLostCloseButton: {
    direction: 'horizontal',
    offset: { x: 129, y: 117 },
    sequence: [
      [56, 56, 56],
      [144, 144, 144],
      [144, 144, 144],
      [52, 52, 52],
      [64, 64, 64],
      [55, 56, 56],
      [144, 144, 144],
      [144, 144, 144],
      [67, 67, 67],
      [52, 52, 52],
      [144, 144, 144],
      [144, 144, 144],
      [48, 48, 48],
    ],
  },
};

export default regionColorSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/regionDefinitions.js
//start file
import actionBarItems from './actionBarItems.js';

const actionBarEntries = Object.entries(actionBarItems);
const regionDefinitions = {
  healthBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 5, y: 0 },
    sequence: [
      [241, 97, 97],
      [219, 91, 91],
      [103, 55, 55],
      'any',
      'any',
      [120, 61, 64],
    ],
    width: 94,
    height: 14,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
  },
  manaBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 9, y: 0 },
    sequence: [
      [99, 96, 248],
      [95, 92, 219],
      [80, 79, 140],
      'any',
      'any',
      'any',
      'any',
      'any',
      'any',
      [61, 61, 125],
    ],
    width: 94,
    height: 14,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
  },
  minimap: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -117, y: 35 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 106,
    height: 109,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
  },
  minimapFloorIndicatorColumn: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 33, y: 25 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 2,
    height: 63,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
  },
  minimapFull: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -117, y: -20 },
    sequence: [
      [113, 113, 113],
      [199, 199, 199],
      [199, 199, 199],
      [199, 199, 199],
      [70, 70, 70],
      [36, 36, 36],
    ],
    width: 106,
    height: 109,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
  },
  cooldownBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -154, y: 8 },
    sequence: [
      [76, 75, 67],
      [77, 76, 71],
      [67, 66, 59],
    ],
    backupSequence: [
      [76, 75, 67],
      [76, 75, 71],
      [66, 65, 58],
    ],
    width: 56,
    height: 4,
    children: {
      healing: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [1, 37, 102],
          [77, 111, 158],
          [39, 75, 116],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      support: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [0, 61, 52],
          [0, 109, 99],
          [52, 179, 172],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      attack: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [0, 0, 6],
          [70, 13, 1],
          [171, 42, 9],
          [255, 255, 255],
        ],
        width: 1,
        height: 4,
      },
      healingInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [17, 29, 45],
          [6, 16, 30],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
      supportInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [42, 74, 73],
          [28, 50, 48],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
      attackInactive: {
        type: 'single',
        direction: 'vertical',
        offset: { x: 0, y: 0 }, // Placeholder, needs adjustment based on actual UI
        sequence: [
          [71, 13, 2],
          [53, 10, 3],
          [0, 0, 0],
        ],
        width: 1,
        height: 3,
      },
    },
  },
  statusBar: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -99, y: 1 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 104,
    height: 9,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
    children: {
      inRestingArea: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [101, 157, 101],
          [120, 34, 34],
          [26, 45, 27],
        ],
      },
      inProtectedZone: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [172, 201, 246],
          [29, 77, 155],
          [118, 165, 242],
        ],
      },
      hungry: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [246, 212, 143],
          [246, 212, 143],
          [239, 180, 63],
        ],
      },
      poisoned: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [52, 118, 62],
          [54, 168, 70],
          [52, 118, 62],
        ],
      },
      hasted: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [176, 139, 80],
          [72, 57, 33],
          [249, 249, 248],
        ],
      },
      battleSign: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [151, 151, 156],
          [182, 182, 185],
          [124, 124, 128],
        ],
      },
      redBattleSign: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [55, 8, 8],
          [127, 0, 0],
          [173, 0, 0],
        ],
      },
      whiteSkull: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [242, 242, 242],
          [235, 235, 235],
          [232, 232, 232],
        ],
      },
      redSkull: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [213, 206, 206],
          [255, 173, 173],
          [255, 171, 171],
        ],
      },
      burning: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [174, 16, 13],
          [253, 139, 0],
          [218, 32, 4],
          [174, 16, 13],
        ],
      },
      magicShield: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [211, 198, 27],
          [86, 97, 91],
          [154, 26, 55],
        ],
      },
      strengthened: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [37, 170, 21],
          [32, 56, 30],
          [243, 153, 32],
        ],
      },
      cursed: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [9, 9, 9],
          [164, 164, 164],
          [210, 210, 210],
        ],
      },
      electrified: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [67, 21, 70],
          [241, 173, 245],
          [67, 21, 70],
        ],
      },
      paralyzed: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [120, 24, 24],
          [213, 8, 8],
          [243, 2, 2],
        ],
      },
      drowning: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [75, 206, 222],
          [208, 220, 224],
          [48, 142, 170],
        ],
      },
      bleeding: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [54, 28, 32],
          [128, 42, 50],
          [54, 28, 32],
        ],
      },
      freezing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [128, 255, 255],
          [190, 252, 252],
          [128, 255, 255],
        ],
      },
      eRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [30, 32, 119],
          [42, 46, 148],
          [26, 28, 111],
        ],
      },
      drunk: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [95, 79, 54],
          [151, 121, 74],
          [145, 116, 70],
        ],
      },
    },
  },
  amuletSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -100, y: -130 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
    children: {
      emptyAmuletSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [30, 33, 36],
          [65, 67, 70],
          [70, 73, 75],
          [82, 84, 87],
          [71, 73, 75],
          [67, 69, 72],
          [32, 35, 37],
        ],
      },
      stoneSkinAmulet: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [60, 60, 60],
          [110, 110, 110],
          [119, 119, 119],
          [110, 110, 110],
          [60, 60, 60],
        ],
      },
    },
  },
  ringSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -100, y: -58 },
    sequence: [
      [41, 41, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
    children: {
      emptyRingSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [53, 56, 59],
          [35, 39, 42],
          [36, 39, 42],
          [66, 69, 72],
          [79, 81, 84],
          [37, 40, 43],
        ],
      },
      mightRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [250, 237, 117],
          [246, 219, 98],
          [200, 166, 65],
          [221, 184, 71],
        ],
      },
      energyRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [88, 227, 177],
          [200, 255, 255],
          [57, 149, 118],
          [0, 0, 0],
          [0, 0, 0],
        ],
      },
      lifeRing: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [91, 206, 68],
          [175, 253, 171],
          [60, 137, 45],
        ],
      },
    },
  },
  bootsSlot: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -63, y: -36 },
    sequence: [
      [41, 42, 42],
      [28, 28, 29],
      [44, 45, 45],
      [40, 40, 41],
      [44, 44, 44],
      [46, 46, 46],
      [112, 112, 113],
    ],
    width: 32,
    height: 32,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
    children: {
      emptyBootsSlot: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [76, 78, 81],
          [61, 64, 66],
          [61, 64, 66],
          [52, 54, 57],
        ],
      },
      softBoots: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [36, 9, 93],
          [119, 92, 176],
          [115, 88, 172],
          [79, 52, 136],
        ],
      },
    },
  },
  chatOn: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [108, 108, 108],
      [110, 110, 110],
      [192, 192, 192],
      [161, 161, 161],
      [175, 175, 175],
      [185, 185, 185],
      [81, 81, 81],
    ],
    width: 8,
    height: 1,
  },
  chatOff: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [174, 174, 174],
      [183, 183, 183],
      [136, 136, 136],
      [174, 174, 174],
      [183, 183, 183],
      [128, 128, 128],
      [62, 62, 62],
    ],
    width: 7,
    height: 1,
  },
  hotkeyBar: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 19, y: 0 },
      sequence: [
        [75, 75, 75],
        [68, 68, 68],
        [76, 76, 76],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [46, 46, 47],
        [53, 54, 54],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -2, y: 0 },
      sequence: [
        [40, 40, 40],
        [43, 43, 43],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [66, 66, 66],
      ],
    },
    maxRight: 2000,
    maxDown: 110,
    searchArea: {
      type: 'bottomHalf',
    },
  },
  battleList: {
    ocrColors: [
      [192, 192, 192],
      [247, 247, 247],
    ],
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -4, y: -9 },
      sequence: [
        [113, 75, 43],
        [135, 86, 41],
        [159, 136, 40],
        [65, 65, 65],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: 9, y: 7 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
      ],
    },
    maxRight: 165,
    maxDown: 9999,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 352,
    },
    children: {
      entries: {
        type: 'boundingBox',
        start: {
          direction: 'horizontal',
          offset: { x: -2, y: 4 },
          sequence: [
            [113, 75, 43],
            [135, 86, 41],
            [159, 136, 40],
            [65, 65, 65],
          ],
        },
        end: {
          direction: 'vertical',
          offset: { x: -7, y: -3 },
          sequence: [
            [159, 159, 159],
            [160, 160, 160],
            [104, 104, 104],
            [10, 10, 10],
          ],
        },
        maxRight: 180,
        maxDown: 9999,
      },
      close: {
        type: 'fixed',
        x: 164,
        y: 8,
        width: 3,
        height: 3,
      },
      minimize: {
        type: 'fixed',
        x: 151,
        y: 8,
        width: 3,
        height: 3,
      },
      types: {
        type: 'fixed',
        x: 136,
        y: 8,
        width: 3,
        height: 3,
      },
      order: {
        type: 'fixed',
        x: 125,
        y: 8,
        width: 3,
        height: 3,
      },
      new: {
        type: 'fixed',
        x: 112,
        y: 8,
        width: 3,
        height: 3,
      },
    },
  },
  partyList: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 13, y: 13 },
      sequence: [
        [30, 115, 255],
        [55, 55, 55],
        [113, 91, 70],
        [56, 56, 56],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -7, y: 0 },
      sequence: [
        [67, 67, 67],
        [78, 78, 78],
        [104, 104, 104],
        [67, 67, 67],
      ],
    },
    maxRight: 160,
    maxDown: 200,
  },

  playerList: {
    ocrColors: [
      [192, 192, 192],
      [247, 247, 247],
    ],
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -4, y: 4 },
      sequence: [
        [159, 136, 40],
        [75, 74, 55],
        [61, 61, 61],
        [128, 193, 84],
        [128, 193, 84],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -3, y: 12 },
      sequence: [
        [10, 10, 10],
        [103, 103, 103],
        [53, 53, 53],
        [11, 11, 11],
        [30, 30, 30],
      ],
    },
    children: {
      whiteSkull: {
        type: 'single',
        direction: 'horizontal',
        offset: { x: 0, y: 0 },
        sequence: [
          [0, 0, 0],
          [227, 227, 227],
          [138, 138, 138],
          [83, 83, 83],
        ],
      },
    },
    maxRight: 168,
    maxDown: 2000,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 352,
    },
  },
  npcList: {
    ocrColors: [
      [192, 192, 192],
      [247, 247, 247],
    ],
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -4, y: 4 },
      sequence: [
        [159, 136, 40],
        [75, 74, 55],
        [61, 61, 61],
        [128, 193, 84],
        [128, 193, 84],
        [128, 193, 84],
        [128, 193, 84],
        [128, 193, 84],
        [65, 65, 65],
        [56, 57, 57],
        [56, 56, 56],
        [59, 59, 59],
        [55, 55, 55],
        [144, 144, 144],
        [56, 56, 57],
        [49, 50, 50],
        [54, 54, 54],
        [51, 51, 51],
        [61, 61, 62],
        [144, 144, 144],
        [47, 48, 48],
        [49, 49, 49],
        [144, 144, 144],
        [144, 144, 144],
        [56, 56, 56],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -3, y: 12 },
      sequence: [
        [10, 10, 10],
        [103, 103, 103],
        [53, 53, 53],
        [11, 11, 11],
        [30, 30, 30],
      ],
    },
    maxRight: 168,
    maxDown: 2000,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 352,
    },
  },
  gameWorld: {
    ocrColors: [
      [192, 192, 192],
      [0, 192, 0],
      [96, 192, 96],
      [192, 192, 0],
      [192, 48, 48],
      [192, 0, 0],
      [96, 0, 0],
    ],
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: 1, y: 1 },
      sequence: [
        [22, 22, 22],
        [24, 24, 24],
        [23, 23, 23],
        [22, 22, 22],
        [21, 21, 21],
        [24, 24, 24],
        [23, 24, 23],
        [24, 24, 24],
        [27, 27, 26],
        [24, 24, 24],
        [22, 22, 22],
      ],
    },
    end: {
      direction: 'horizontal',
      // 200%
      // offset: { x: 9, y: -1 },
      // sequence: [
      //   [111, 111, 111],
      //   [117, 117, 117],
      //   [116, 116, 116],
      //   [116, 116, 116],
      //   [113, 113, 113],
      //   [115, 115, 115],
      //   [116, 116, 115],
      //   [115, 115, 115],
      //   [118, 118, 117],
      //   [115, 115, 115],
      //   [114, 114, 114],
      // ],
      // 245%
      offset: { x: 11, y: -1 },
      sequence: [
        [116, 117, 117],
        [116, 116, 116],
        [116, 116, 116],
        [116, 116, 117],
        [116, 116, 116],
        [115, 115, 115],
        [120, 120, 120],
        [117, 117, 117],
        [116, 116, 116],
        [117, 117, 117],
        [115, 115, 116],
        [116, 116, 116],
        [76, 75, 75],
      ],
    },
    maxRight: 'fullWidth',
    maxDown: 'fullHeight',
  },
  chatboxMain: {
    type: 'boundingBox',
    start: {
      direction: 'vertical',
      offset: { x: 1, y: 5 },
      sequence: [
        [112, 112, 113],
        [116, 116, 117],
        'any',
        'any',
        [117, 117, 117],
        'any',
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -7, y: 3 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [54, 54, 54],
        [54, 54, 54],
      ],
      backupSequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        [115, 116, 115],
        [75, 75, 75],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
    ocrColors: [
      [240, 240, 0],
      [248, 96, 96],
      [240, 240, 240],
      [96, 248, 248],
      [32, 160, 255],
      [160, 160, 255],
      [0, 240, 0],
    ],
    searchArea: {
      type: 'bottomHalf',
    },
  },
  chatboxSecondary: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -1, y: 1 },
      sequence: [
        [63, 63, 63],
        [27, 27, 28],
        'any',
        'any',
        [117, 117, 117],
        [63, 63, 63],
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: -7, y: 3 },
      sequence: [
        [159, 159, 159],
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
        'any',
        'any',
        'any',
        'any',
        'any',
        [115, 116, 115],
        [75, 75, 75],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
    ocrColors: [
      [240, 240, 0],
      [248, 96, 96],
      [240, 240, 240],
      [96, 248, 248],
      [32, 160, 255],
      [160, 160, 255],
      [0, 240, 0],
    ],
    searchArea: {
      type: 'bottomHalf',
    },
  },
  chatBoxTabRow: {
    ocrColors: [
      [223, 223, 223],
      [247, 95, 95],
      [127, 127, 127],
    ],
    type: 'boundingBox',
    start: {
      direction: 'vertical',
      offset: { x: 13, y: -14 },
      sequence: [
        [112, 112, 113],
        [116, 116, 117],
        'any',
        'any',
        [117, 117, 117],
        'any',
        [27, 27, 28],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: 0, y: 0 },
      sequence: [
        [89, 89, 89],
        [38, 38, 38],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [89, 89, 89],
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        'any',
        [41, 41, 41],
        [66, 66, 66],
      ],
    },
    maxRight: 1400,
    maxDown: 1000,
    searchArea: {
      type: 'bottomHalf',
    },
  },
  skillsWidget: {
    type: 'boundingBox',
    start: {
      direction: 'horizontal',
      offset: { x: -3, y: 13 },
      sequence: [
        [170, 143, 100],
        [188, 174, 103],
        [55, 55, 55],
        [65, 65, 65],
      ],
    },
    end: {
      direction: 'horizontal',
      offset: { x: -11, y: 1 },
      sequence: [
        [108, 108, 108],
        [160, 160, 160],
        [81, 81, 81],
        [67, 67, 67],
        [67, 67, 67],
      ],
    },
    maxRight: 170,
    maxDown: 1000,
    searchArea: {
      type: 'leftEdge',
      maxFromLeft: 174,
    },
    ocrColors: [
      [192, 192, 192],
      [68, 173, 37],
    ],
  },
  loginModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [74, 74, 74],
      [192, 192, 192],
      [192, 192, 192],
      [75, 75, 75],
      [69, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [76, 76, 75],
      [74, 74, 73],
      [73, 74, 73],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [82, 82, 82],
      [72, 73, 72],
      [71, 72, 71],
      [74, 75, 75],
      [192, 192, 192],
      [192, 192, 192],
      [74, 74, 74],
    ],
    width: 1,
    height: 1,
    searchArea: {
      type: 'center',
    },
    children: {
      emailInput: {
        type: 'fixed',
        x: 0,
        y: -76,
        width: 1,
        height: 1,
      },
      passwordInput: {
        type: 'fixed',
        x: 0,
        y: -43,
        width: 1,
        height: 1,
      },
      login: {
        type: 'fixed',
        x: 75,
        y: 39,
        width: 60,
        height: 3,
      },
      createNewAccount: {
        type: 'fixed',
        x: -71,
        y: 42,
        width: 60,
        height: 3,
      },
    },
  },
  connectionLostModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [144, 144, 144],
      [53, 53, 53],
      [55, 55, 55],
      [144, 144, 144],
      [144, 144, 144],
      [61, 61, 61],
      [49, 49, 49],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 57],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [62, 62, 62],
      [59, 60, 60],
      [61, 61, 61],
      [144, 144, 144],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    searchArea: {
      type: 'center',
    },
    children: {
      ok: {
        type: 'fixed',
        x: 101,
        y: 118,
        width: 1,
        height: 1,
      },
    },
  },
  warningModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [56, 56, 57],
      [144, 144, 144],
      [144, 144, 144],
      [51, 51, 51],
      [144, 144, 144],
      [144, 144, 144],
      [47, 48, 48],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    searchArea: {
      type: 'center',
    },
    children: {
      abort: {
        type: 'fixed',
        x: 93,
        y: 125,
        width: 1,
        height: 1,
      },
    },
  },
  connectionFailedModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [53, 53, 52],
      [144, 144, 144],
      [144, 144, 144],
      [49, 49, 49],
      [44, 44, 44],
      [144, 144, 144],
    ],
    width: 1,
    height: 1,
    searchArea: {
      type: 'center',
    },
    children: {
      ok: {
        type: 'fixed',
        x: 142,
        y: 166,
        width: 1,
        height: 1,
      },
    },
  },
  wrongPasswordModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [65, 65, 65],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [64, 64, 64],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [65, 65, 65],
      [62, 62, 62],
      [75, 76, 75],
      [76, 76, 76],
      [67, 67, 67],
      [65, 65, 65],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [70, 70, 70],
    ],
    width: 1,
    height: 1,
    searchArea: {
      type: 'center',
    },
    children: {
      ok: {
        type: 'fixed',
        x: 45,
        y: 40,
        width: 1,
        height: 1,
      },
    },
  },
  connectingModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [56, 57, 56],
      [144, 144, 144],
      [144, 144, 144],
      [67, 68, 67],
      [58, 59, 58],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [54, 54, 54],
      [50, 50, 49],
      [144, 144, 144],
      [144, 144, 144],
      [53, 53, 53],
      [55, 55, 55],
      [144, 144, 144],
      [144, 144, 144],
      [61, 61, 61],
      [49, 49, 49],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 57],
      [59, 59, 59],
      [144, 144, 144],
      [144, 144, 144],
      [53, 53, 53],
    ],
    width: 1,
    height: 1,
    searchArea: {
      type: 'center',
    },
    children: {
      cancel: {
        type: 'fixed',
        x: 192,
        y: 68,
        width: 1,
        height: 1,
      },
    },
  },
  pleaseWaitModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [192, 192, 192],
      [65, 64, 64],
      [67, 68, 68],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [72, 72, 72],
    ],
    width: 1,
    height: 1,
    children: {
      abort: {
        type: 'fixed',
        x: 125,
        y: 93,
        width: 1,
        height: 1,
      },
    },
  },
  ipChangedModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [144, 144, 144],
      [144, 144, 144],
      [56, 56, 56],
      [59, 59, 59],
      [59, 60, 59],
      [52, 52, 52],
      [144, 144, 144],
      [144, 144, 144],
      [49, 49, 49],
      [52, 52, 52],
      [67, 67, 67],
      [52, 52, 52],
      [52, 53, 53],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [56, 56, 56],
    ],
    width: 1,
    height: 1,
    children: {
      ok: {
        type: 'fixed',
        x: 220,
        y: 65,
        width: 1,
        height: 1,
      },
    },
  },
  selectCharacterModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -358, y: 48 },
    sequence: [
      [144, 144, 144],
      [144, 144, 144],
      [55, 55, 54],
      [56, 56, 55],
      [54, 54, 54],
      [65, 65, 65],
      [49, 49, 49],
      [56, 57, 56],
      [144, 144, 144],
      [144, 144, 144],
      [54, 54, 53],
    ],
    width: 263,
    height: 266,
    ocrColors: [
      [244, 244, 244],
      [192, 192, 192],
    ],
    searchArea: {
      type: 'center',
    },
    children: {
      ok: {
        type: 'fixed',
        x: 634,
        y: 345,
        width: 7,
        height: 7,
      },
      cancel: {
        type: 'fixed',
        x: 683,
        y: 347,
        width: 7,
        height: 7,
      },
    },
  },
  warningModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -99, y: -10 },
    sequence: [
      [52, 52, 51],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [58, 58, 58],
      [55, 55, 54],
      [144, 144, 144],
      [144, 144, 144],
      [144, 144, 144],
      [57, 57, 56],
      [52, 53, 52],
      [49, 49, 49],
      [144, 144, 144],
    ],
    width: 250,
    height: 157,
    searchArea: {
      type: 'center',
    },
    children: {
      abort: {
        type: 'fixed',
        x: 213,
        y: 137,
        width: 5,
        height: 5,
      },
    },
  },
  notLoggedInAnymoreModal: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: -271, y: -172 },
    sequence: [
      [192, 192, 192],
      [192, 192, 192],
      [67, 67, 66],
      [69, 70, 69],
      [192, 192, 192],
      [192, 192, 192],
      [73, 73, 73],
      [72, 73, 72],
      [70, 70, 70],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [192, 192, 192],
      [70, 70, 70],
      [61, 61, 61],
      [73, 73, 73],
      [192, 192, 192],
      [192, 192, 192],
      [76, 76, 76],
      [79, 79, 79],
      [192, 192, 192],
      [192, 192, 192],
      [65, 65, 65],
    ],
    width: 470,
    height: 100,
    searchArea: {
      type: 'center',
    },
    children: {
      ok: {
        type: 'fixed',
        x: 154,
        y: 36,
        width: 5,
        height: 5,
      },
    },
  },

  gameLog: {
    type: 'fixed',
    x: 808,
    y: 695,
    width: 125,
    height: 11,
    ocrColors: [[240, 240, 240]],
    searchArea: {
      type: 'bottomHalf',
    },
  },
  onlineMarker: {
    type: 'single',
    direction: 'vertical',
    offset: { x: 0, y: 0 },
    sequence: [
      [118, 54, 54],
      [74, 74, 75],
      [72, 72, 72],
      [68, 66, 99],
    ],
    width: 1,
    height: 1,
    searchArea: {
      type: 'rightEdge',
      maxFromRight: 174,
    },
  },
  stowText: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [247, 247, 247],
      [247, 247, 247],
      [0, 0, 0],
      [70, 70, 70],
      [65, 65, 65],
    ],
    width: 1,
    height: 1,
  },
  stashIcon: {
    type: 'single',
    direction: 'horizontal',
    offset: { x: 0, y: 0 },
    sequence: [
      [45, 13, 13],
      [45, 13, 13],
      [255, 213, 212],
      [206, 60, 57],
      [45, 13, 13],
      [116, 86, 62],
    ],
    width: 1,
    height: 1,
  },
  vipWidget: {
    type: 'boundingBox',
    maxRight: 176,
    maxDown: 99999,
    searchArea: {
      type: 'leftEdge',
      maxFromLeft: 176,
    },
    ocrColors: [
      [248, 96, 96],
      [96, 248, 96],
    ],
    start: {
      direction: 'horizontal',
      offset: { x: -9, y: -9 },
      sequence: [
        [118, 93, 57],
        [108, 80, 41],
        [102, 87, 38],
        [121, 114, 48],
      ],
    },
    end: {
      direction: 'vertical',
      offset: { x: 9, y: 6 },
      sequence: [
        [160, 160, 160],
        [104, 104, 104],
        [10, 10, 10],
      ],
    },
  },
};

export default regionDefinitions;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/resourceBars.js
//start file
const resourceBars = {
  healthBar: [
    [120, 61, 64],
    [211, 79, 79],
    [219, 79, 79],
    [194, 74, 74],
    [100, 46, 49],
  ],
  manaBar: [
    [83, 80, 218],
    [77, 74, 194],
    [45, 45, 105],
    [61, 61, 125],
    [82, 79, 211],
  ],
  partyEntryHpBar: [
    [0, 192, 0],
    [96, 192, 96],
    [192, 192, 0],
    [192, 48, 48],
    [96, 0, 0],
  ],
};

export default resourceBars;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/constants/statusBarSequences.js
//start file
const statusBarSequences = {
  inRestingArea: {
    direction: 'horizontal',
    sequence: [
      [101, 157, 101],
      [120, 34, 34],
      [26, 45, 27],
    ],
  },
  inProtectedZone: {
    direction: 'horizontal',
    sequence: [
      [172, 201, 246],
      [29, 77, 155],
      [118, 165, 242],
    ],
  },
  hungry: {
    direction: 'horizontal',
    sequence: [
      [246, 212, 143],
      [246, 212, 143],
      [239, 180, 63],
    ],
  },
  poisoned: {
    direction: 'horizontal',
    sequence: [
      [52, 118, 62],
      [54, 168, 70],
      [52, 118, 62],
    ],
  },
  hasted: {
    direction: 'horizontal',
    sequence: [
      [176, 139, 80],
      [72, 57, 33],
      [249, 249, 248],
    ],
  },
  battleSign: {
    direction: 'horizontal',
    sequence: [
      [151, 151, 156],
      [182, 182, 185],
      [124, 124, 128],
    ],
  },
  redBattleSign: {
    direction: 'horizontal',
    sequence: [
      [55, 8, 8],
      [127, 0, 0],
      [173, 0, 0],
    ],
  },
  whiteSkull: {
    direction: 'horizontal',
    sequence: [
      [242, 242, 242],
      [235, 235, 235],
      [232, 232, 232],
    ],
  },
  redSkull: {
    direction: 'horizontal',
    sequence: [
      [213, 206, 206],
      [255, 173, 173],
      [255, 171, 171],
    ],
  },
  burning: {
    direction: 'horizontal',
    sequence: [
      [174, 16, 13],
      [253, 139, 0],
      [218, 32, 4],
      [174, 16, 13],
    ],
  },
  magicShield: {
    direction: 'horizontal',
    sequence: [
      [211, 198, 27],
      [86, 97, 91],
      [154, 26, 55],
    ],
  },
  strengthened: {
    direction: 'horizontal',
    sequence: [
      [37, 170, 21],
      [32, 56, 30],
      [243, 153, 32],
    ],
  },
  cursed: {
    direction: 'horizontal',
    sequence: [
      [9, 9, 9],
      [164, 164, 164],
      [210, 210, 210],
    ],
  },
  electrified: {
    direction: 'horizontal',
    sequence: [
      [67, 21, 70],
      [241, 173, 245],
      [67, 21, 70],
    ],
  },
  paralyzed: {
    direction: 'horizontal',
    sequence: [
      [120, 24, 24],
      [213, 8, 8],
      [243, 2, 2],
    ],
  },
  drowning: {
    direction: 'horizontal',
    sequence: [
      [75, 206, 222],
      [208, 220, 224],
      [48, 142, 170],
    ],
  },
  bleeding: {
    direction: 'horizontal',
    sequence: [
      [54, 28, 32],
      [128, 42, 50],
      [54, 28, 32],
    ],
  },
  freezing: {
    direction: 'horizontal',
    sequence: [
      [128, 255, 255],
      [190, 252, 252],
      [128, 255, 255],
    ],
  },
  eRing: {
    direction: 'horizontal',
    sequence: [
      [30, 32, 119],
      [42, 46, 148],
      [26, 28, 111],
    ],
  },
  drunk: {
    direction: 'horizontal',
    sequence: [
      [95, 79, 54],
      [151, 121, 74],
      [145, 116, 70],
    ],
  },
};

export default statusBarSequences;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/createMainWindow.js
//start file
import {
  app,
  ipcMain,
  BrowserWindow,
  Tray,
  Menu,
  dialog,
  nativeImage,
} from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';

import { loadRulesFromFile, saveRulesToFile } from './saveManager.js';
import {
  toggleNotifications,
  setGlobalShortcutsEnabled,
} from '../frontend/redux/slices/globalSlice.js';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import {
  registerGlobalShortcuts,
  unregisterGlobalShortcuts,
} from './globalShortcuts.js';

const HTML_PATH = '../dist/index.html';

let mainWindow;
let tray;
let isNotificationEnabled = false;
let isTrayVisible = true;
let widgetWindow = null;
let isMainWindowVisible = false;
let isWidgetWindowVisible = false;
let isGlobalShortcutsEnabled = true;

const filename = fileURLToPath(import.meta.url);
const dirname = path.dirname(filename);

const WIDGET_HTML_PATH = path.join(dirname, 'widget', 'widget.html');
const WIDGET_PRELOAD_PATH = path.join(dirname, 'widget', 'preload.js');

const ICON_PATHS = {
  white: path.join(dirname, './icons/white_dot.png'),
  green: path.join(dirname, './icons/green_dot.png'),
  red: path.join(dirname, './icons/red_dot.png'),
  app: path.join(dirname, './icons/automaton.png'),
};

const updateTrayIcon = () => {
  if (!tray) return;

  const state = store.getState().global;
  let iconPath;

  if (!state.windowId) {
    iconPath = ICON_PATHS.white;
  } else {
    iconPath = state.isBotEnabled ? ICON_PATHS.green : ICON_PATHS.red;
  }

  const icon = nativeImage.createFromPath(iconPath);
  tray.setImage(icon);
};

export const toggleTrayVisibility = () => {
  isTrayVisible = !isTrayVisible;
  if (isTrayVisible) {
    createTray();
  } else {
    tray.destroy();
    tray = null;
  }
  Menu.setApplicationMenu(buildAppMenu());
};

const buildTrayContextMenu = () => {
  const state = store.getState().global;
  return Menu.buildFromTemplate([
    {
      label: state.windowName || 'Bot',
    },
    { type: 'separator' },
    {
      label: 'Show/Hide Main Window',
      type: 'checkbox',
      checked: isMainWindowVisible,
      click: toggleMainWindowVisibility,
    },
    {
      label: 'Show/Hide Controls Widget',
      type: 'checkbox',
      checked: isWidgetWindowVisible,
      click: toggleWidgetWindowVisibility,
    },
    {
      label: 'Notifications',
      type: 'checkbox',
      checked: isNotificationEnabled,
      click: () => store.dispatch(toggleNotifications()),
    },
    {
      label: 'Global Shortcuts',
      type: 'checkbox',
      checked: isGlobalShortcutsEnabled,
      click: () =>
        store.dispatch(setGlobalShortcutsEnabled(!isGlobalShortcutsEnabled)),
    },
    {
      label: isTrayVisible ? 'Hide Tray' : 'Show Tray',
      click: toggleTrayVisibility,
    },
    { type: 'separator' },
    { label: 'Close', click: closeAppFromTray },
  ]);
};

const buildAppMenu = () => {
  const template = [
    {
      label: 'File',
      submenu: [
        {
          label: 'Show/Hide Main Window',
          type: 'checkbox',
          checked: isMainWindowVisible,
          click: toggleMainWindowVisibility,
        },
        {
          label: 'Show/Hide Controls Widget',
          type: 'checkbox',
          checked: isWidgetWindowVisible,
          click: toggleWidgetWindowVisibility,
        },
        { type: 'separator' },
        {
          label: 'Load Settings...',
          click: () => loadRulesFromFile(() => {}),
          accelerator: 'CmdOrCtrl+O',
        },
        {
          label: 'Save Settings As...',
          click: () => saveRulesToFile(() => {}),
          accelerator: 'CmdOrCtrl+S',
        },
        { type: 'separator' },
        { label: 'Close', click: closeAppFromTray },
      ],
    },
    {
      label: 'View',
      submenu: [
        {
          label: 'Notifications',
          type: 'checkbox',
          checked: isNotificationEnabled,
          click: () => store.dispatch(toggleNotifications()),
        },
        {
          label: 'Global Shortcuts',
          type: 'checkbox',
          checked: isGlobalShortcutsEnabled,
          click: () =>
            store.dispatch(
              setGlobalShortcutsEnabled(!isGlobalShortcutsEnabled),
            ),
        },
        {
          label: isTrayVisible ? 'Hide Tray' : 'Show Tray',
          click: toggleTrayVisibility,
        },
      ],
    },
  ];

  template.push({
    label: 'Developer',
    submenu: [
      { role: 'reload' },
      { role: 'forceReload' },
      { role: 'toggleDevTools' },
    ],
  });

  return Menu.buildFromTemplate(template);
};

const createTray = () => {
  const state = store.getState().global;
  let initialIconPath = ICON_PATHS.white;
  if (state.windowId) {
    initialIconPath = state.isBotEnabled ? ICON_PATHS.green : ICON_PATHS.red;
  }

  tray = new Tray(initialIconPath);
  tray.setToolTip('Click to show/hide the bot');
  tray.setContextMenu(buildTrayContextMenu());

  tray.on('click', toggleMainWindowVisibility);
};

const handleMainWindowClose = (event) => {
  event.preventDefault();
  app.quit();
};

const closeAppFromTray = () => {
  app.quit();
};

export const createMainWindow = (selectedWindowId, display, windowName) => {
  mainWindow = new BrowserWindow({
    minWidth: 1200,
    minHeight: 640,
    height: 640,
    width: 1200,
    resizable: false,
    icon: ICON_PATHS.app,
    autoHideMenuBar: true,
    titleBarStyle: 'hidden',
    alwaysOnTop: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(dirname, '/preload.js'),
    },
  });

  mainWindow
    .loadURL(`file://${path.join(dirname, HTML_PATH)}`)
    .catch((err) => console.error('Failed to load URL:', err));

  mainWindow.on('ready-to-show', () => {
    mainWindow.show();
    isMainWindowVisible = true;
    createTray();
    Menu.setApplicationMenu(buildAppMenu());
    setGlobalState('global/setWindowId', selectedWindowId);
    setGlobalState('global/setDisplay', display);
    setGlobalState('global/setWindowName', windowName);
    createWidgetWindow();
    toggleWidgetWindowVisibility();
    // Register global shortcuts on app start
    const { isGlobalShortcutsEnabled: globalShortcutsState } =
      store.getState().global;
    if (globalShortcutsState) {
      registerGlobalShortcuts();
    }
  });

  mainWindow.on('show', () => {
    mainWindow.setMinimizable(false);
    isMainWindowVisible = true;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  mainWindow.on('hide', () => {
    isMainWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  mainWindow.on('close', handleMainWindowClose);
  return mainWindow;
};

export const toggleMainWindowVisibility = () => {
  if (!mainWindow) return;

  if (mainWindow.isVisible()) {
    mainWindow.hide();
  } else {
    mainWindow.show();
    mainWindow.focus();
  }
  isMainWindowVisible = mainWindow.isVisible();
  Menu.setApplicationMenu(buildAppMenu());
  if (tray) tray.setContextMenu(buildTrayContextMenu());
};

export const createWidgetWindow = () => {
  if (widgetWindow && !widgetWindow.isDestroyed()) {
    if (widgetWindow.isMinimized()) widgetWindow.restore();
    widgetWindow.focus();
    return;
  }

  widgetWindow = new BrowserWindow({
    width: 108,
    height: 320,
    x: 100,
    y: 100,
    frame: false,
    show: false,
    resizable: false,
    maximizable: false,
    fullscreenable: false,
    transparent: true,
    icon: ICON_PATHS.app,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: WIDGET_PRELOAD_PATH,
      devTools: false,
    },
  });

  widgetWindow.loadURL(`file://${WIDGET_HTML_PATH}`).catch((err) => {
    console.error('Failed to load widget URL:', err);
    widgetWindow = null;
  });

  widgetWindow.on('closed', () => {
    widgetWindow = null;
    isWidgetWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  widgetWindow.on('show', () => {
    isWidgetWindowVisible = true;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });

  widgetWindow.on('hide', () => {
    isWidgetWindowVisible = false;
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  });
};

export const toggleWidgetWindowVisibility = () => {
  if (!widgetWindow) {
    createWidgetWindow();
    widgetWindow.on('ready-to-show', () => {
      widgetWindow.show();
      widgetWindow.focus();
      isWidgetWindowVisible = true;
      Menu.setApplicationMenu(buildAppMenu());
      if (tray) tray.setContextMenu(buildTrayContextMenu());
    });
  } else {
    if (widgetWindow.isVisible()) {
      widgetWindow.hide();
    } else {
      widgetWindow.show();
      widgetWindow.focus();
    }
    isWidgetWindowVisible = widgetWindow.isVisible();
    Menu.setApplicationMenu(buildAppMenu());
    if (tray) tray.setContextMenu(buildTrayContextMenu());
  }
};

let lastState = {};
store.subscribe(() => {
  const state = store.getState().global;

  const newState = {
    windowName: state.windowName,
    isBotEnabled: state.isBotEnabled,
    windowId: state.windowId,
    notificationsEnabled: state.notificationsEnabled,
    isGlobalShortcutsEnabled: state.isGlobalShortcutsEnabled,
    isMainWindowVisible: mainWindow ? mainWindow.isVisible() : false,
    isWidgetWindowVisible: widgetWindow ? widgetWindow.isVisible() : false,
  };

  // Only update if the relevant state has changed
  const iconChanged =
    lastState.isBotEnabled !== newState.isBotEnabled ||
    lastState.windowId !== newState.windowId;

  const menuChanged =
    lastState.windowName !== newState.windowName ||
    lastState.isMainWindowVisible !== newState.isMainWindowVisible ||
    lastState.isWidgetWindowVisible !== newState.isWidgetWindowVisible ||
    lastState.notificationsEnabled !== newState.notificationsEnabled ||
    lastState.isGlobalShortcutsEnabled !== newState.isGlobalShortcutsEnabled;

  if (tray) {
    if (iconChanged) {
      updateTrayIcon();
    }
    if (menuChanged) {
      tray.setContextMenu(buildTrayContextMenu());
    }
  }

  if (menuChanged) {
    Menu.setApplicationMenu(buildAppMenu());
  }

  // Handle global shortcuts enable/disable
  if (
    lastState.isGlobalShortcutsEnabled !== newState.isGlobalShortcutsEnabled
  ) {
    if (newState.isGlobalShortcutsEnabled) {
      registerGlobalShortcuts();
    } else {
      unregisterGlobalShortcuts();
    }
  }

  // Update local module state
  isNotificationEnabled = newState.notificationsEnabled;
  isGlobalShortcutsEnabled = newState.isGlobalShortcutsEnabled;
  isMainWindowVisible = newState.isMainWindowVisible;
  isWidgetWindowVisible = newState.isWidgetWindowVisible;

  lastState = newState;
});

export const getMainWindow = () => mainWindow;
export const getWidgetWindow = () => widgetWindow;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/globalShortcuts.js
//start file
import { globalShortcut } from 'electron';
import setGlobalState from './setGlobalState.js';
import { getMainWindow } from './createMainWindow.js';

import { showNotification } from './notificationHandler.js';
import debounce from 'lodash/debounce.js';
import store from './store.js';
import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { exec } from 'child_process';
import { createLogger } from './utils/logger.js';

const log = createLogger();
const debounceTime = 25;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let windId = '';
let isBotEnabled = false;
let previousSectionStates = {};
let windowName = '';

store.subscribe(() => {
  const state = store.getState();
  const { global, rules, cavebot, lua, targeting } = state; // Destructure all relevant slices
  windId = global.windowId;
  isBotEnabled = global.isBotEnabled;
  previousSectionStates = global.previousSectionStates;
  windowName = global.windowName;

  // Log warnings if any slice is undefined, but don't prevent access
  if (!rules)
    log(
      'warn',
      '[Global Shortcuts] rules slice is undefined in store.getState()',
    );
  if (!cavebot)
    log(
      'warn',
      '[Global Shortcuts] cavebot slice is undefined in store.getState()',
    );
  if (!lua)
    log(
      'warn',
      '[Global Shortcuts] lua slice is undefined in store.getState()',
    );
  if (!targeting)
    log(
      'warn',
      '[Global Shortcuts] targeting slice is undefined in store.getState()',
    );
});

const soundCache = new Map();

export const playSound = (filePath) => {
  const asarPath = path.join(__dirname, 'sounds', filePath);
  if (soundCache.has(filePath)) {
    const cachedPath = soundCache.get(filePath);
    exec(`aplay '${cachedPath}'`);
  } else {
    const tempDir = path.join(os.tmpdir(), 'automaton-sounds');
    const tempFilePath = path.join(tempDir, filePath);
    fs.mkdirSync(tempDir, { recursive: true });
    fs.copyFileSync(asarPath, tempFilePath);
    soundCache.set(filePath, tempFilePath);
    exec(`aplay '${tempFilePath}'`);
  }
};

const getNotificationTitle = () => `Automaton - ${windowName}`;

const debouncedToggleisBotEnabled = debounce(() => {
  setGlobalState('global/toggleisBotEnabled');
  const status = isBotEnabled ? 'Disabled' : 'Enabled';
  showNotification(`Bot: ${status}`, getNotificationTitle());
  playSound(isBotEnabled ? 'disable.wav' : 'enable.wav');
}, debounceTime);

const debouncedToggleMainWindowVisibility = debounce(() => {
  const mainWindow = getMainWindow();
  if (mainWindow) {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
    }
  }
}, debounceTime);

const switchToPreset = debounce((presetIndex) => {
  setGlobalState('rules/setActivePresetIndex', presetIndex);
}, debounceTime);

const toggleSection = (sectionName, setEnabledAction) => {
  const state = store.getState();
  const currentEnabledState = state[sectionName]?.enabled ?? false;
  const newEnabledState = !currentEnabledState; // This is the state it will become

  console.log(
    `[DEBUG] Toggling ${sectionName}: current=${currentEnabledState}, new=${newEnabledState}, action=${setEnabledAction}`,
  );

  setGlobalState(setEnabledAction, newEnabledState); // Dispatch the action with the new state

  showNotification(
    `${sectionName.charAt(0).toUpperCase() + sectionName.slice(1)}: ${newEnabledState ? 'Enabled' : 'Disabled'}`, // Use newEnabledState for notification
    getNotificationTitle(),
  );
};

const debouncedToggleCavebot = debounce(
  () => toggleSection('cavebot', 'cavebot/setenabled'),
  debounceTime,
);
const debouncedToggleHealing = debounce(
  () => toggleSection('rules', 'rules/setenabled'),
  debounceTime,
);
const debouncedToggleScripts = debounce(
  () => toggleSection('lua', 'lua/setenabled'),
  debounceTime,
);
const debouncedToggleTargeting = debounce(
  () => toggleSection('targeting', 'targeting/setenabled'),
  debounceTime,
);

const debouncedToggleAllSections = debounce(() => {
  const state = store.getState();
  const allSections = {
    rules: state.rules?.enabled ?? false,
    cavebot: state.cavebot?.enabled ?? false,
    lua: state.lua?.enabled ?? false,
    targeting: state.targeting?.enabled ?? false,
  };

  const allEnabled = Object.values(allSections).every(Boolean);
  const allDisabled = Object.values(allSections).every((val) => !val);

  if (allEnabled) {
    // If all are enabled, disable all and store current states
    setGlobalState('global/setPreviousSectionStates', allSections);
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification('All sections disabled', getNotificationTitle());
  } else if (allDisabled) {
    // If all are disabled, restore previous states
    const restoredStates = previousSectionStates;
    setGlobalState('rules/setenabled', restoredStates.rules);
    setGlobalState('cavebot/setenabled', restoredStates.cavebot);
    setGlobalState('lua/setenabled', restoredStates.lua);
    setGlobalState('targeting/setenabled', restoredStates.targeting);
    showNotification(
      'Restored previous section states',
      getNotificationTitle(),
    );
  } else {
    // If mixed, disable all and store current states
    setGlobalState('global/setPreviousSectionStates', allSections);
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification(
      'Mixed states detected, all sections disabled',
      getNotificationTitle(),
    );
  }
}, debounceTime);

const debouncedToggleEverything = debounce(() => {
  const state = store.getState();
  const allSections = {
    rules: state.rules?.enabled ?? false,
    cavebot: state.cavebot?.enabled ?? false,
    lua: state.lua?.enabled ?? false,
    targeting: state.targeting?.enabled ?? false,
  };

  const allEnabled = Object.values(allSections).every(Boolean);
  const allDisabled = Object.values(allSections).every((val) => !val);

  if (!allEnabled) {
    // If not all enabled (mixed or all disabled), enable all
    setGlobalState('rules/setenabled', true);
    setGlobalState('cavebot/setenabled', true);
    setGlobalState('lua/setenabled', true);
    setGlobalState('targeting/setenabled', true);
    showNotification('All sections enabled', getNotificationTitle());
  } else {
    // If all are enabled, disable all
    setGlobalState('rules/setenabled', false);
    setGlobalState('cavebot/setenabled', false);
    setGlobalState('lua/setenabled', false);
    setGlobalState('targeting/setenabled', false);
    showNotification('All sections disabled', getNotificationTitle());
  }
}, debounceTime);

export const registerGlobalShortcuts = () => {
  try {
    if (globalShortcut.isRegistered('Alt+E')) {
      log('info', '[Global Shortcuts] already registered, skipping.');
      return;
    }
    log('info', '[Global Shortcuts] registering');
    globalShortcut.register('Alt+E', debouncedToggleisBotEnabled);
    globalShortcut.register('Alt+V', debouncedToggleMainWindowVisibility);

    globalShortcut.register('Alt+Escape', debouncedToggleAllSections);
    globalShortcut.register('Alt+C', debouncedToggleCavebot);
    globalShortcut.register('Alt+H', debouncedToggleHealing);
    globalShortcut.register('Alt+S', debouncedToggleScripts);
    globalShortcut.register('Alt+T', debouncedToggleTargeting);
    globalShortcut.register('Alt+B', debouncedToggleEverything);

    for (let i = 0; i < 5; i++) {
      const presetKey = `Alt+${i + 1}`;
      const debouncedSwitchToPreset = debounce(
        () => switchToPreset(i),
        debounceTime,
      );
      globalShortcut.register(presetKey, debouncedSwitchToPreset);
    }
    log('info', '[Global Shortcuts] registered');
  } catch (error) {
    log('error', `[Global Shortcuts] registration error: ${error}`);
  }
};

export const unregisterGlobalShortcuts = () => {
  try {
    log('info', '[Global Shortcuts] unregistering all');
    globalShortcut.unregisterAll();
  } catch (error) {
    log('error', `[Global Shortcuts] unregistration error: ${error}`);
  }
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/hardwareId.js
//start file
import { execSync } from 'child_process';
import { existsSync } from 'fs';

export function getLinuxHardwareId() {
  try {
    // Try machine-id first (most modern systems)
    if (existsSync('/etc/machine-id')) {
      const machineId = execSync('cat /etc/machine-id', {
        encoding: 'utf-8',
      }).trim();
      if (machineId.length >= 32) return machineId;
    }

    // Fallback to product_uuid (AWS/Azure/GCP and some VMs)
    if (existsSync('/sys/class/dmi/id/product_uuid')) {
      return execSync('cat /sys/class/dmi/id/product_uuid', {
        encoding: 'utf-8',
      }).trim();
    }

    // Final fallback using system information
    const fallbackId = execSync('uname -a | sha256sum | head -c 64', {
      encoding: 'utf-8',
    }).trim();
    return fallbackId || 'unknown-device';
  } catch (error) {
    console.error('Hardware ID detection failed:', error);
    return 'error-no-id';
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/ipcListeners.js
//start file
// /home/orimorfus/Documents/Automaton/electron/ipcListeners.js
import { ipcMain, BrowserWindow } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import store from './store.js';
import {
  saveRulesToFile,
  loadRulesFromFile,
  autoLoadRules,
} from './saveManager.js';
import { playSound, registerGlobalShortcuts } from './globalShortcuts.js';
import { getMainWindow } from './createMainWindow.js';
import luaSlice from '../frontend/redux/slices/luaSlice.js'; // Import the luaSlice
import setGlobalState from './setGlobalState.js';
const { updateScript, removeScript } = luaSlice.actions; // Destructure actions from the slice

const filename = fileURLToPath(import.meta.url);
const cwd = dirname(filename);
const preloadPath = path.join(cwd, '/preload.js');

ipcMain.on('state-change-batch', (_, serializedBatch) => {
  try {
    const batch = JSON.parse(serializedBatch);
    if (Array.isArray(batch)) {
      for (const action of batch) {
        if (action.origin === 'renderer') {
          setGlobalState(action.type, action.payload);
        }
      }
    }
  } catch (error) {
    console.error('Error handling state-change-batch from renderer:', error);
  }
});

ipcMain.on('save-rules', async () => {
  const mainWindow = getMainWindow();
  mainWindow.minimize();
  await saveRulesToFile(() => {
    mainWindow.restore();
  });
});

ipcMain.handle('load-rules', async () => {
  const mainWindow = getMainWindow();
  mainWindow.minimize();
  await loadRulesFromFile(() => {
    mainWindow.restore();
  });
});

ipcMain.on('renderer-ready', () => {
  autoLoadRules();
  registerGlobalShortcuts();
});

// IPC handler to provide current control states to the widget
ipcMain.handle('get-control-states', () => {
  const state = store.getState();
  return {
    isRulesEnabled: state.rules.enabled,
    isCavebotEnabled: state.cavebot.enabled,
    isTargetingEnabled: state.targeting.enabled,
    isLuaEnabled: state.lua.enabled,
  };
});

// IPC handler for widget to toggle main window visibility
ipcMain.handle('toggle-main-window', () => {
  const mainWindow = getMainWindow();
  if (mainWindow) {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
      mainWindow.focus();
    }
    return mainWindow.isVisible();
  }
  return false;
});

// IPC handler to check if main window is visible
ipcMain.handle('is-main-window-visible', () => {
  const mainWindow = getMainWindow();
  return mainWindow ? mainWindow.isVisible() : false;
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/keyboardControll/keyPress.js
//start file
import { parentPort } from 'worker_threads';

const post = (payload) => {
  parentPort.postMessage({
    type: 'inputAction',
    payload,
  });
};

export const keyPress = (key, { modifier = null, type = 'default' } = {}) => {
  post({
    type,
    action: {
      module: 'keypress',
      method: 'sendKey',
      args: [key, modifier],
    },
  });
};

export const keyPressMultiple = (
  key,
  { count = 1, modifier = null, delayMs = 50, type = 'default' } = {},
) => {
  for (let i = 0; i < count; i++) {
    setTimeout(() => {
      keyPress(key, { modifier, type });
    }, i * delayMs);
  }
};

export const typeArray = (
  texts,
  { startAndEndWithEnter = true, type = 'default' } = {},
) => {
  post({
    type,
    action: {
      module: 'keypress',
      method: 'typeArray',
      args: [texts, startAndEndWithEnter],
    },
  });
};

export const rotate = (direction, { type = 'default' } = {}) => {
  post({
    type,
    action: {
      module: 'keypress',
      method: 'rotate',
      args: [direction],
    },
  });
};

export const getIsTyping = () => false;

export const keyDown = (key, { modifier = null, type = 'default' } = {}) => {
  post({
    type,
    action: {
      module: 'keypress',
      method: 'keyDown',
      args: [key, modifier],
    },
  });
};

export const keyUp = (key, { modifier = null, type = 'default' } = {}) => {
  post({
    type,
    action: {
      module: 'keypress',
      method: 'keyUp',
      args: [key, modifier],
    },
  });
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/loginWindow/loginWindow.js
//start file
document.getElementById('login-form').addEventListener('submit', (e) => {
  e.preventDefault();
  attemptLogin();
});

let currentHardwareId = null;
let resetTimer = null;
let autoLoginTimeout = null;

function toggleCheckbox(checkboxId) {
  const checkbox = document.getElementById(checkboxId);
  if (checkbox) {
    checkbox.checked = !checkbox.checked;
  }
}

function setLoadingState(isLoading) {
  const loginButton = document.querySelector('button[type="submit"]');
  loginButton.disabled = isLoading;
  loginButton.style.opacity = isLoading ? '0.7' : '1';
  if (isLoading) {
    loginButton.textContent = 'Authenticating...';
  }
}

function showButtonMessage(message, color) {
  const loginButton = document.querySelector('button[type="submit"]');
  clearTimeout(resetTimer);
  loginButton.textContent = message;
  loginButton.style.color = color;
  resetTimer = setTimeout(() => {
    loginButton.textContent = 'Login';
    loginButton.style.color = '';
  }, 10000);
}

async function checkHardwareId() {
  const hardwareIdElement = document.getElementById('hardware-id');
  try {
    hardwareIdElement.classList.remove('valid', 'invalid');
    currentHardwareId =
      await window.electron.ipcRenderer.invoke('get-hardware-id');

    if (!currentHardwareId || currentHardwareId.includes('error')) {
      throw new Error('Invalid hardware ID');
    }

    const storedHardwareId = localStorage.getItem('validHardwareId');
    const shortId =
      currentHardwareId.length > 53
        ? `${currentHardwareId.slice(-10)}`
        : currentHardwareId;
    hardwareIdElement.textContent = shortId;
    hardwareIdElement.title = `Device Fingerprint: ${currentHardwareId}`;

    if (storedHardwareId) {
      const isMatch = currentHardwareId === storedHardwareId;
      hardwareIdElement.classList.toggle('valid', isMatch);
      hardwareIdElement.classList.toggle('invalid', !isMatch);
      if (!isMatch)
        showButtonMessage('New device detected', 'var(--error-message)');
    }
  } catch (error) {
    console.error('Hardware check failed:', error);
    hardwareIdElement.textContent = 'ID UNAVAILABLE';
    hardwareIdElement.classList.add('invalid');
    showButtonMessage('Device verification failed', 'var(--error-message)');
  }
}

async function attemptLogin() {
  if (autoLoginTimeout) {
    clearTimeout(autoLoginTimeout);
    autoLoginTimeout = null;
  }

  const loginButton = document.querySelector('button[type="submit"]');
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  const rememberMeCheckbox = document.getElementById('remember-me');
  const autoLoginCheckbox = document.getElementById('auto-login');

  const username = usernameInput.value;
  const password = passwordInput.value;
  const rememberMe = rememberMeCheckbox.checked;
  const autoLogin = autoLoginCheckbox.checked;

  setLoadingState(true);

  try {
    const response = await fetch(
      'https://automaton-login-server-h3kn.onrender.com/login',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Device-ID': currentHardwareId,
        },
        body: JSON.stringify({
          email: username,
          password: password,
          hardwareId: currentHardwareId,
        }),
      },
    );

    const data = await response.json();

    if (response.ok) {
      localStorage.setItem('validHardwareId', currentHardwareId);
      if (rememberMe) {
        localStorage.setItem(
          'credentials',
          JSON.stringify({ username, password }),
        );
        if (autoLogin) {
          localStorage.setItem('autoLoginEnabled', 'true');
        } else {
          localStorage.removeItem('autoLoginEnabled');
        }
      } else {
        localStorage.removeItem('credentials');
        localStorage.removeItem('autoLoginEnabled');
      }
      showButtonMessage(data.message || 'Login successful!', '#00ff00');
      await new Promise((resolve) => setTimeout(resolve, 1500));
      window.electron.ipcRenderer.send('login-success');
    } else {
      showButtonMessage(
        data.message || `Error: ${response.status}`,
        'var(--error-message)',
      );
    }
  } catch (error) {
    showButtonMessage(
      'Connection error. Please try again.',
      'var(--error-message)',
    );
  } finally {
    setLoadingState(false);
  }
}

function cancelAutoLogin() {
  if (autoLoginTimeout) {
    clearTimeout(autoLoginTimeout);
    autoLoginTimeout = null;
    console.log('Auto-login cancelled due to user interaction.');
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const usernameInput = document.getElementById('username');
  const passwordInput = document.getElementById('password');
  const rememberMeCheckbox = document.getElementById('remember-me');
  const autoLoginCheckbox = document.getElementById('auto-login');
  const loginButton = document.querySelector('button[type="submit"]');

  const credentials = JSON.parse(localStorage.getItem('credentials'));
  const autoLoginEnabled = localStorage.getItem('autoLoginEnabled') === 'true';

  if (credentials) {
    usernameInput.value = credentials.username;
    passwordInput.value = credentials.password;
    rememberMeCheckbox.checked = true;
    autoLoginCheckbox.checked = autoLoginEnabled;
  }

  checkHardwareId();

  if (credentials && autoLoginEnabled) {
    console.log('Auto-login enabled. Starting 1s timer...');
    autoLoginTimeout = setTimeout(() => {
      console.log('Auto-login timer expired. Attempting login...');
      autoLoginTimeout = null;
      attemptLogin();
    }, 1000);
  }

  usernameInput.addEventListener('input', cancelAutoLogin);
  passwordInput.addEventListener('input', cancelAutoLogin);
  loginButton.addEventListener('click', cancelAutoLogin);
  rememberMeCheckbox.addEventListener('change', cancelAutoLogin);
  autoLoginCheckbox.addEventListener('change', cancelAutoLogin);

  usernameInput.focus();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/main.js
//start file
import { app, ipcMain, BrowserWindow, dialog } from 'electron';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import path from 'path';
import { createMainWindow, getWidgetWindow } from './createMainWindow.js';
import './ipcListeners.js';
import { registerGlobalShortcuts } from './globalShortcuts.js';
import { getLinuxHardwareId } from './hardwareId.js';
// import { autoLoadRules } from './saveManager.js';
import { createLogger } from './utils/logger.js';
import workerManager from './workerManager.js';
import windowinfo from 'windowinfo-native';
import setGlobalState from './setGlobalState.js';
import store from './store.js';

const filename = fileURLToPath(import.meta.url);
const cwd = dirname(filename);
const log = createLogger();

let selectWindow;
let mainWindow;
let isQuitting = false;

const createSelectWindow = () => {
  selectWindow = new BrowserWindow({
    width: 600,
    height: 400,
    autoHideMenuBar: true,
    titleBarStyle: 'hidden',
    resizable: false,
    maximizable: false,
    fullscreenable: false,
    devTools: false,
    frame: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(cwd, 'selectWindow', 'preload.js'),
    },
  });

  const selectHtmlPath = path.join(cwd, 'selectWindow', 'selectWindow.html');
  selectWindow.loadFile(selectHtmlPath);

  selectWindow.on('closed', () => {
    selectWindow = null;
    if (!isQuitting && !mainWindow) {
      app.quit();
    }
  });
};

app.whenReady().then(async () => {
  try {
    // await autoLoadRules();
    createSelectWindow();

    workerManager.initialize(app, cwd, {});
    registerGlobalShortcuts(); // Register global shortcuts on startup
    setGlobalState('global/setGlobalShortcutsEnabled', true); // Set default to enabled
  } catch (error) {
    console.error('[Main] FATAL: Error during application startup:', error);
    dialog.showErrorBox(
      'Application Startup Error',
      `Failed to initialize critical components: ${error.message}\n\nPlease check logs for details. The application will now exit.`,
    );
    app.quit();
  }
});

app.on('before-quit', async (event) => {
  event.preventDefault();
  console.log('[Main] App is quitting. Terminating all workers...');
  await workerManager.stopAllWorkers();
  console.log('[Main] All workers terminated. Exiting now.');
  app.exit();
});
app.on('window-all-closed', () => {
  log('info', '[Main] All windows closed, initiating app quit.');
  app.quit();
});

ipcMain.handle('get-hardware-id', () => {
  try {
    return getLinuxHardwareId();
  } catch (error) {
    console.error('Hardware ID error:', error);
    return 'error-failed-retrieval';
  }
});

ipcMain.handle('get-tibia-window-list', async () => {
  try {
    const windowList = await windowinfo.getWindowList();
    return windowList;
  } catch (error) {
    console.error('[Main] Error getting Tibia window list:', error);
    return [];
  }
});

ipcMain.on('select-tibia-window', (event, windowId, display, windowName) => {
  if (selectWindow && !selectWindow.isDestroyed()) {
    selectWindow.close();
  }
  setGlobalState('global/setWindowId', windowId);
  setGlobalState('global/setDisplay', display);
  setGlobalState('global/setWindowName', windowName);

  mainWindow = createMainWindow(windowId, display, windowName);
});

ipcMain.on('exit-app', () => {
  isQuitting = true;
  app.quit();
});

ipcMain.on('update-bot-status', (event, { feature, isEnabled }) => {
  console.log(`[Main] Received update from widget: ${feature} - ${isEnabled}`);
  switch (feature) {
    case 'healing':
      setGlobalState('rules/setenabled', isEnabled);
      break;
    case 'cavebot':
      setGlobalState('cavebot/setenabled', isEnabled);
      break;
    case 'targeting':
      setGlobalState('targeting/setenabled', isEnabled);
      break;
    case 'scripts':
      setGlobalState('lua/setenabled', isEnabled);
      break;
    default:
      console.warn(`[Main] Unknown feature received from widget: ${feature}`);
  }
});

// Store subscription to send state updates to the widget window
let previousRulesEnabled = false;
let previousCavebotEnabled = false;
let previousTargetingEnabled = false;
let previousLuaEnabled = false;

store.subscribe(() => {
  const state = store.getState();
  const widgetWindow = getWidgetWindow();

  if (widgetWindow && !widgetWindow.isDestroyed()) {
    const currentRulesEnabled = state.rules.enabled;
    const currentCavebotEnabled = state.cavebot.enabled;
    const currentTargetingEnabled = state.targeting.enabled;
    const currentLuaEnabled = state.lua.enabled;

    if (currentRulesEnabled !== previousRulesEnabled) {
      widgetWindow.webContents.send('state-update', {
        type: 'rules/setenabled',
        payload: currentRulesEnabled,
      });
      previousRulesEnabled = currentRulesEnabled;
    }

    if (currentCavebotEnabled !== previousCavebotEnabled) {
      widgetWindow.webContents.send('state-update', {
        type: 'cavebot/setenabled',
        payload: currentCavebotEnabled,
      });
      previousCavebotEnabled = currentCavebotEnabled;
    }

    if (currentTargetingEnabled !== previousTargetingEnabled) {
      widgetWindow.webContents.send('state-update', {
        type: 'targeting/setenabled',
        payload: currentTargetingEnabled,
      });
      previousTargetingEnabled = currentTargetingEnabled;
    }

    if (currentLuaEnabled !== previousLuaEnabled) {
      widgetWindow.webContents.send('state-update', {
        type: 'lua/setenabled',
        payload: currentLuaEnabled,
      });
      previousLuaEnabled = currentLuaEnabled;
    }
  }
});

export default app;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/mouseControll/useItemOnCoordinates.js
//start file
import { parentPort } from 'worker_threads';
import { keyPress } from '../keyboardControll/keyPress.js';

const post = (payload) => {
  parentPort.postMessage({
    type: 'inputAction',
    payload,
  });
};

function useItemOnCoordinates(targetX, targetY, key, { type = 'default' } = {}) {
  keyPress(key, { type });

  post({
    type,
    action: {
      module: 'mouseController',
      method: 'leftClick',
      args: [parseInt(targetX), parseInt(targetY)],
    },
  });
}

export default useItemOnCoordinates;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/notificationHandler.js
//start file
import { Notification, nativeImage } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import store from './store.js';

let notiEnabled = false;

const __filenamePath = fileURLToPath(import.meta.url);
const __dirnamePath = path.dirname(__filenamePath);

const iconPath = path.join(__dirnamePath, 'icons', 'greenSkull.png');

let windowName = '';

store.subscribe(() => {
  const state = store.getState();
  notiEnabled = state.global.notificationsEnabled;
  windowName = state.global.windowName;
});

const createIconImage = () => {
  try {
    return nativeImage.createFromPath(iconPath);
  } catch (error) {
    console.error('Error creating icon image:', error);
    return null;
  }
};

export const showNotification = (body, customTitle) => {
  if (!notiEnabled) return;

  const title = customTitle || `Automaton - ${windowName}`;

  try {
    new Notification({
      title: title,
      body: body,
      icon: createIconImage(),
    }).show();
  } catch (error) {
    console.error('Error showing notification:', error);
  }
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/preload.js
//start file
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  ipcRenderer: {
    invoke: (channel, ...args) => ipcRenderer.invoke(channel, ...args),
    send: (channel, data) => ipcRenderer.send(channel, data),
    on: (channel, func) => ipcRenderer.on(channel, func),
  },
  saveRules: () => ipcRenderer.send('save-rules'),
  loadRules: () => ipcRenderer.invoke('load-rules'),
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/saveManager.js
//start file
import { app, dialog } from 'electron';
import fs from 'fs/promises';
import path from 'path';
import { showNotification } from './notificationHandler.js';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import throttle from 'lodash/throttle.js';
import omit from 'lodash/omit.js';

// ... (normalizeLuaScripts and STATE_SCHEMA are unchanged)
// Helper to normalize Lua scripts
const normalizeLuaScripts = (luaState) => {
  if (!luaState) return luaState;
  const normalizedState = { ...luaState };
  if (
    normalizedState.persistentScripts &&
    Array.isArray(normalizedState.persistentScripts)
  ) {
    normalizedState.persistentScripts = normalizedState.persistentScripts.map(
      (script) => ({ ...script, type: script.type || 'persistent' }),
    );
  }
  if (
    normalizedState.hotkeyScripts &&
    Array.isArray(normalizedState.hotkeyScripts)
  ) {
    normalizedState.hotkeyScripts = normalizedState.hotkeyScripts.map(
      (script) => ({ ...script, type: script.type || 'hotkey' }),
    );
  }
  return normalizedState;
};

// STATE PERSISTENCE SCHEMA
const STATE_SCHEMA = {
  global: {
    transformOnSave: (state) => ({
      notificationsEnabled: state.notificationsEnabled,
      isGlobalShortcutsEnabled: state.isGlobalShortcutsEnabled,
    }),
  },
  rules: {},
  lua: {
    transformOnSave: (state) => ({
      enabled: false,
      persistentScripts:
        state.persistentScripts?.map((script) => ({
          ...script,
          log: [],
        })) || [],
    }),
    transformOnLoad: (state) =>
      normalizeLuaScripts({ ...state, enabled: false }),
  },
  cavebot: {
    transformOnSave: (state) => ({
      enabled: false,
      waypointSections: state.waypointSections,
      specialAreas: state.specialAreas,
    }),
    transformOnLoad: (state) => ({ ...state, enabled: false }),
  },
  targeting: {
    transformOnSave: (state) => ({
      enabled: false,
      targetingList: state.targetingList,
    }),
    transformOnLoad: (state) => ({ ...state, enabled: false }),
  },
};

const PERSISTED_SLICES = Object.keys(STATE_SCHEMA);
const user_data_path = app.getPath('userData');
const auto_load_file_path = path.join(user_data_path, 'autoLoadRules.json');

// ============================================================================
// Schema-Driven Helper Functions
// ============================================================================

const prepareStateForSave = (fullState) => {
  const stateToSave = {};
  for (const sliceName of PERSISTED_SLICES) {
    if (fullState[sliceName]) {
      const sliceConfig = STATE_SCHEMA[sliceName];
      stateToSave[sliceName] = sliceConfig.transformOnSave
        ? sliceConfig.transformOnSave(fullState[sliceName])
        : fullState[sliceName];
    }
  }
  return stateToSave;
};

const applyLoadedState = (loadedState) => {
  if (!loadedState || typeof loadedState !== 'object') return;
  for (const sliceName of PERSISTED_SLICES) {
    if (loadedState[sliceName]) {
      let sliceData = loadedState[sliceName];
      const sliceConfig = STATE_SCHEMA[sliceName];
      if (sliceConfig.transformOnLoad) {
        sliceData = sliceConfig.transformOnLoad(sliceData);
      }
      setGlobalState(`${sliceName}/setState`, sliceData);
    }
  }
};

// ============================================================================
// Generic Save Function & Factory
// ============================================================================

/**
 * A generic function to handle the logic of saving data to a file.
 * @param {object} dataToSave - The JavaScript object to be stringified and saved.
 * @param {string} dialogTitle - The title for the save file dialog window.
 * @param {string} defaultFilename - The suggested filename in the dialog.
 * @param {function} [callback] - An optional callback to run after completion.
 */
const genericSaveToFile = async (
  dataToSave,
  dialogTitle,
  defaultFilename,
  callback,
) => {
  try {
    const dialog_result = await dialog.showSaveDialog({
      title: dialogTitle,
      defaultPath: defaultFilename,
      filters: [{ name: 'JSON Files', extensions: ['json'] }],
    });

    if (!dialog_result.canceled && dialog_result.filePath) {
      const save_file_path = dialog_result.filePath.endsWith('.json')
        ? dialog_result.filePath
        : `${dialog_result.filePath}.json`;

      await fs.writeFile(save_file_path, JSON.stringify(dataToSave, null, 2));
      showNotification(`📥 Saved | ${path.basename(save_file_path)}`);
    }
  } catch (err) {
    console.error(`Failed to save file for "${dialogTitle}":`, err);
    showNotification(`❌ Failed to save ${defaultFilename}`);
  } finally {
    if (callback) callback();
  }
};

/**
 * Factory function to create a dedicated save function for a specific state slice.
 * @param {string} sliceName - The key of the state slice (e.g., 'targeting').
 * @param {string} dialogTitle - The title for the save dialog.
 * @param {string} defaultFilename - The suggested filename.
 * @returns {function} An async function that takes an optional callback.
 */
const createSliceSaver = (sliceName, dialogTitle, defaultFilename) => {
  return async (callback) => {
    const sliceState = store.getState()[sliceName];
    if (!sliceState) {
      console.error(`Attempted to save non-existent slice: ${sliceName}`);
      showNotification(`❌ Cannot save ${sliceName}: state not found`);
      if (callback) callback();
      return;
    }

    // Use the schema to prepare the slice for saving, ensuring consistency.
    const sliceConfig = STATE_SCHEMA[sliceName];
    const stateToSave = sliceConfig.transformOnSave
      ? sliceConfig.transformOnSave(sliceState)
      : sliceState;

    await genericSaveToFile(
      stateToSave,
      dialogTitle,
      defaultFilename,
      callback,
    );
  };
};

// ============================================================================
// Public API (Save/Load Functions)
// ============================================================================

/** Saves the ENTIRE configured state to a file. */
export const saveRulesToFile = async (callback) => {
  const fullStateToSave = prepareStateForSave(store.getState());
  await genericSaveToFile(
    fullStateToSave,
    'Save Full Profile',
    'full_profile.json',
    callback,
  );
};

/** Loads state from a file. */
export const loadRulesFromFile = async (callback) => {
  try {
    const dialog_result = await dialog.showOpenDialog({
      title: 'Load Profile',
      filters: [{ name: 'JSON Files', extensions: ['json'] }],
      properties: ['openFile'],
    });

    if (!dialog_result.canceled && dialog_result.filePaths.length > 0) {
      const file_path = dialog_result.filePaths[0];
      const content = await fs.readFile(file_path, 'utf8');
      const loaded_state = JSON.parse(content);
      applyLoadedState(loaded_state);
      showNotification(`📤 Loaded | ${path.basename(file_path)}`);
    }
  } catch (err) {
    console.error('Failed to load state:', err);
    showNotification('❌ Failed to load state');
  } finally {
    if (callback) callback();
  }
};

// --- NEW SLICE-SPECIFIC SAVE FUNCTIONS ---

export const saveTargeting = createSliceSaver(
  'targeting',
  'Save Targeting Profile',
  'targeting_profile.json',
);

export const saveCavebot = createSliceSaver(
  'cavebot',
  'Save Cavebot Profile',
  'cavebot_profile.json',
);

export const saveRules = createSliceSaver(
  'rules',
  'Save Rules Profile',
  'rules_profile.json',
);

export const saveLua = createSliceSaver(
  'lua',
  'Save Lua Scripts Profile',
  'lua_profile.json',
);

// ============================================================================
// Auto Save / Load & Store Subscription (Unchanged)
// ============================================================================

const perform_auto_save = async () => {
  try {
    const stateToSave = prepareStateForSave(store.getState());
    if (Object.keys(stateToSave).length > 0) {
      await fs.writeFile(
        auto_load_file_path,
        JSON.stringify(stateToSave, null, 2),
      );
    }
  } catch (error) {
    console.error('Failed to auto-save rules:', error);
  }
};

const auto_save_rules = throttle(perform_auto_save, 1000, {
  leading: false,
  trailing: true,
});

export const autoLoadRules = async () => {
  try {
    await fs.access(auto_load_file_path);
    const content = await fs.readFile(auto_load_file_path, 'utf8');
    const loaded_state = JSON.parse(content);
    applyLoadedState(loaded_state);
  } catch (error) {
    if (error.code !== 'ENOENT') {
      console.error('Failed to auto-load rules:', error);
    }
  }
};

const previousStates = {};
const hasStateChanged = (newState, prevState) => {
  if (newState === prevState) return false;
  if (
    !prevState ||
    typeof newState !== 'object' ||
    typeof prevState !== 'object'
  )
    return true;
  return JSON.stringify(newState) !== JSON.stringify(prevState);
};

store.subscribe(() => {
  const currentState = store.getState();
  let hasChanged = false;

  for (const sliceName of PERSISTED_SLICES) {
    if (hasStateChanged(currentState[sliceName], previousStates[sliceName])) {
      hasChanged = true;
      previousStates[sliceName] = currentState[sliceName];
    }
  }

  // if (hasChanged) {
  //   auto_save_rules();
  // }
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePartyEntryRegions.js
//start file
export const calculatePartyEntryRegions = (partyListStart, entryCount) => {
  const regions = [];
  for (let i = 0; i < entryCount; i++) {
    regions.push({
      bar: {
        x: partyListStart.x + 1,
        y: partyListStart.y + 6 + i * 26,
        width: 130,
        height: 1,
      },
      name: {
        x: partyListStart.x + 1,
        y: partyListStart.y + i * 26,
        width: 15,
        height: 6,
      },
      uhCoordinates: {
        x: partyListStart.x,
        y: partyListStart.y + i * 26,
      },
    });
  }
  return regions;
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePartyHpPercentage.js
//start file
// screenMonitor/calcs/calculatePartyHpPercentage.js

/**
 * Calculates the percentage of matching pixels in a party member's HP bar.
 * This is now a convenience wrapper around the main calculatePercentages function.
 *
 * @param {Buffer} fullFrameBuffer - The full-frame image buffer, including its 8-byte header.
 * @param {object} fullFrameMeta - Metadata object { width, height } for the full frame.
 * @param {object} barAbsoluteCoords - The bar's absolute start {x, y} within the window.
 * @param {Array<Array<number>>} validColors - Array of valid [R, G, B] color arrays for the bar.
 * @param {number} barPixelWidth - The width of the bar in pixels to analyze.
 * @returns {number} The calculated HP percentage (0-100) or -1 on error.
 */
import calculatePercentages from './calculatePercentages.js'; // Assuming it's in the same folder

function calculatePartyHpPercentage(
  fullFrameBuffer,
  fullFrameMeta,
  barAbsoluteCoords,
  validColors,
  barPixelWidth,
) {
  // This function now just calls the main, more generic percentage calculator.
  // This reduces code duplication.
  return calculatePercentages(
    fullFrameBuffer,
    fullFrameMeta,
    barAbsoluteCoords,
    validColors,
    barPixelWidth,
  );
}

export default calculatePartyHpPercentage;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/screenMonitor/calcs/calculatePercentages.js
//start file
// screenMonitor/calcs/calculatePercentages.js

/**
 * Calculates the percentage of matching pixels horizontally for a bar (like HP/Mana)
 * at a specific ABSOLUTE position within the full-frame image buffer.
 *
 * @param {Buffer} fullFrameBuffer - The full-frame image buffer, including its 8-byte header.
 * @param {object} fullFrameMeta - Metadata object { width, height } for the full frame.
 * @param {object} barAbsoluteCoords - The bar's absolute start {x, y} within the window.
 * @param {Array<Array<number>>} validColors - Array of valid [R, G, B] color arrays for the bar.
 * @param {number} barPixelWidth - The width of the bar in pixels to analyze.
 * @returns {number} The calculated percentage (0-100) or -1 on error.
 */
function calculatePercentages(
  fullFrameBuffer,
  fullFrameMeta,
  barAbsoluteCoords,
  validColors,
  barPixelWidth,
) {
  try {
    // 1. Validate Inputs
    if (
      !fullFrameBuffer ||
      fullFrameBuffer.length < 8 ||
      !fullFrameMeta ||
      !barAbsoluteCoords ||
      !validColors ||
      barPixelWidth <= 0
    ) {
      return -1;
    }

    const { width: imageWidth, height: imageHeight } = fullFrameMeta;

    if (imageWidth <= 0 || imageHeight <= 0) {
      return -1;
    }

    // 2. Constants for BGRA format
    const bytesPerPixel = 4; // BGRA format
    const headerSize = 8;
    const imageStride = imageWidth * bytesPerPixel;

    // 3. Calculate Start Byte Index in the full buffer
    const { x: absoluteBarStartX, y: absoluteBarStartY } = barAbsoluteCoords;

    // Ensure coordinates are within the buffer dimensions
    if (
      absoluteBarStartX < 0 ||
      absoluteBarStartX >= imageWidth ||
      absoluteBarStartY < 0 ||
      absoluteBarStartY >= imageHeight
    ) {
      return -1;
    }

    const startIndexBytes =
      headerSize +
      absoluteBarStartY * imageStride +
      absoluteBarStartX * bytesPerPixel;

    // 4. Bounds Check
    const endIndexBytes = startIndexBytes + barPixelWidth * bytesPerPixel;
    if (
      absoluteBarStartX + barPixelWidth > imageWidth ||
      startIndexBytes < headerSize ||
      endIndexBytes > fullFrameBuffer.length
    ) {
      return -1;
    }

    // 5. Prepare color set for quick lookup
    const colorSet = new Set(validColors.map((color) => color.join(',')));

    // 6. Count matching pixels
    let matchingPixelsCount = 0;
    for (let i = 0; i < barPixelWidth; i++) {
      const currentPixelIndex = startIndexBytes + i * bytesPerPixel;

      // Read BGRA, but we only care about RGB for comparison
      // B = index + 0, G = index + 1, R = index + 2
      const r = fullFrameBuffer[currentPixelIndex + 2];
      const g = fullFrameBuffer[currentPixelIndex + 1];
      const b = fullFrameBuffer[currentPixelIndex];

      if (colorSet.has(`${r},${g},${b}`)) {
        matchingPixelsCount++;
      }
    }

    if (barPixelWidth === 0) return 0;
    return Math.round((matchingPixelsCount / barPixelWidth) * 100);
  } catch (error) {
    console.error('Error in calculatePercentages:', error);
    return -1;
  }
}

export default calculatePercentages;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/selectWindow/preload.js
//start file
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  getTibiaWindowList: () => ipcRenderer.invoke('get-tibia-window-list'),
  selectTibiaWindow: (windowId, display, windowName) =>
    ipcRenderer.send('select-tibia-window', windowId, display, windowName),
  exitApp: () => ipcRenderer.send('exit-app'),
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/selectWindow/selectWindow.js
//start file
document.addEventListener('DOMContentLoaded', async () => {
  const windowList = document.getElementById('window-list');
  const selectButton = document.getElementById('select-button');
  const refreshButton = document.getElementById('refresh-button');
  const exitButton = document.getElementById('exit-button');
  const messageElement = document.getElementById('message');

  let availableWindows = [];

  const fetchWindows = async () => {
    messageElement.textContent = 'Searching for Tibia windows...';
    selectButton.disabled = true;
    windowList.innerHTML = ''; // Clear previous list

    try {
      availableWindows = await window.electronAPI.getTibiaWindowList();
      if (availableWindows.length > 0) {
        availableWindows.forEach((win) => {
          const option = document.createElement('option');
          option.value = win.windowId;
          option.textContent = `${win.name} (ID: ${win.windowId}, Display: ${win.display})`; // Assuming display info is added
          windowList.appendChild(option);
        });
        windowList.selectedIndex = 0; // Select the first one by default
        selectButton.disabled = false;
        messageElement.textContent = `${availableWindows.length} Tibia window(s) found.`;
      } else {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No Tibia windows found.';
        windowList.appendChild(option);
        messageElement.textContent =
          'No Tibia windows found. Please ensure Tibia is running.';
      }
    } catch (error) {
      console.error('Failed to fetch window list:', error);
      messageElement.textContent = `Error: ${error.message}. Could not retrieve window list.`;
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'Error loading windows.';
      windowList.appendChild(option);
    }
  };

  selectButton.addEventListener('click', () => {
    const selectedIndex = windowList.selectedIndex;
    if (selectedIndex !== -1) {
      const selectedWindow = availableWindows[selectedIndex];
      if (selectedWindow) {
        window.electronAPI.selectTibiaWindow(
          selectedWindow.windowId,
          selectedWindow.display,
          selectedWindow.name,
        ); // Pass ID, display, and window title
      }
    }
  });

  refreshButton.addEventListener('click', fetchWindows);
  exitButton.addEventListener('click', () => {
    window.electronAPI.exitApp();
  });

  // Initial fetch
  fetchWindows();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/setGlobalState.js
//start file
import store from './store.js';
import { getMainWindow, getWidgetWindow } from './createMainWindow.js';

// A blacklist of action types that should NOT be forwarded to the renderer process.
// This is for state that is only relevant to the main process and workers.
const RENDERER_BLACKLIST = new Set(['regionCoordinates/setAllRegions']);

let actionQueue = [];
let isScheduled = false;

function sendBatch() {
  if (actionQueue.length === 0) {
    isScheduled = false;
    return;
  }

  const mainWindow = getMainWindow();
  const widgetWindow = getWidgetWindow();
  const batch = [...actionQueue];
  actionQueue = [];

  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send('state-update-batch', batch);
  }
  if (widgetWindow && !widgetWindow.isDestroyed()) {
    widgetWindow.webContents.send('state-update-batch', batch);
  }

  isScheduled = false;
}

function scheduleBatch() {
  if (!isScheduled) {
    isScheduled = true;
    // --- THIS IS THE FIX ---
    // Use setImmediate for high-throughput, non-UI-blocking batching.
    // It is more reliable than requestIdleCallback in a busy main process.
    setImmediate(sendBatch);
  }
}

/**
 * A centralized function to update the main process Redux store
 * and broadcast the change to the renderer process.
 * @param {string} type - The action type (e.g., 'cavebot/setEnabled').
 * @param {*} payload - The action payload.
 */
function setGlobalState(type, payload) {
  const action = {
    type,
    payload,
    origin: 'backend',
  };

  // 1. Dispatch the action to the main process store immediately.
  store.dispatch(action);

  // 2. Queue the action to be sent to the renderer in a batch, unless it's blacklisted.
  if (!RENDERER_BLACKLIST.has(type)) {
    actionQueue.push(action);
    scheduleBatch();
  }
}

export default setGlobalState;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/store.js
//start file
import { configureStore, combineReducers } from '@reduxjs/toolkit';
import globalSlice from '../frontend/redux/slices/globalSlice.js';
import ruleSlice from '../frontend/redux/slices/ruleSlice.js';
import gameStateSlice from '../frontend/redux/slices/gameStateSlice.js';
import luaSlice from '../frontend/redux/slices/luaSlice.js';
import cavebotSlice from '../frontend/redux/slices/cavebotSlice.js';
import targetingSlice from '../frontend/redux/slices/targetingSlice.js';
import statusMessagesSlice from '../frontend/redux/slices/statusMessagesSlice.js';
import regionCoordinatesSlice from '../frontend/redux/slices/regionCoordinatesSlice.js';
import ocrSlice from '../frontend/redux/slices/ocrSlice.js';
import uiValuesSlice from '../frontend/redux/slices/uiValuesSlice.js';
import battleListSlice from '../frontend/redux/slices/battleListSlice.js';
import pathfinderSlice from '../frontend/redux/slices/pathfinderSlice.js';

const rootReducer = combineReducers({
  global: globalSlice.reducer,
  gameState: gameStateSlice.reducer,
  rules: ruleSlice.reducer,
  lua: luaSlice.reducer,
  cavebot: cavebotSlice.reducer,
  targeting: targetingSlice.reducer,
  statusMessages: statusMessagesSlice.reducer,
  regionCoordinates: regionCoordinatesSlice.reducer,
  ocr: ocrSlice.reducer,
  uiValues: uiValuesSlice.reducer,
  battleList: battleListSlice.reducer,
  pathfinder: pathfinderSlice.reducer,
});

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      immutableCheck: false,
      serializableCheck: false,
    }),
});

export default store;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/areStatusConditionsMet.js
//start file
/**
 * Check if character status conditions are met.
 * @param {Object} rule - The rule object.
 * @param {Object} gameState - The game state object.
 * @returns {boolean} - True if all conditions are met, false otherwise.
 */
const areCharStatusConditionsMet = (rule, gameState) => {
  // If there are no conditions, the check passes.
  if (!rule.conditions || rule.conditions.length === 0) {
    return true;
  }

  // Check each condition in the rule's conditions array.
  return rule.conditions.every((condition) => {
    // Treat a missing status as false. This is the key fix.
    const charStatusValue = gameState.characterStatus[condition.name] ?? false;
    return charStatusValue === condition.value;
  });
};

export default areCharStatusConditionsMet;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/compareUtils.js
//start file
// electron/utils/compareUtils.js

/**
 * Performs a shallow comparison of two arrays of special area objects.
 * It checks for changes in length and relevant properties of each object.
 *
 * @param {Array<object>} arr1 - The first array of special area objects.
 * @param {Array<object>} arr2 - The second array of special area objects.
 * @returns {boolean} True if the arrays are considered equal, false otherwise.
 */
export function areSpecialAreasEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0; i < arr1.length; i++) {
    const a1 = arr1[i];
    const a2 = arr2[i];

    // Compare relevant properties. 'id' is ignored as it's an internal identifier.
    if (
      a1.x !== a2.x ||
      a1.y !== a2.y ||
      a1.z !== a2.z ||
      a1.sizeX !== a2.sizeX ||
      a1.sizeY !== a2.sizeY ||
      a1.avoidance !== a2.avoidance ||
      a1.type !== a2.type ||
      a1.enabled !== a2.enabled
    ) {
      return false;
    }
  }
  return true;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/deepHash.js
//start file
// electron/utils/deepHash.js

/**
 * Computes a deep hash of an object or array.
 * This function is designed to be more efficient than JSON.stringify for hashing,
 * especially for nested structures, by avoiding string conversion overhead.
 * It handles primitives, objects, and arrays.
 *
 * @param {any} obj - The object or value to hash.
 * @returns {number} A 32-bit unsigned integer hash.
 */
export function deepHash(obj) {
  let hash = 0x811c9dc5; // FNV-1a 32-bit offset basis

  const processString = (str) => {
    for (let i = 0; i < str.length; i++) {
      hash ^= str.charCodeAt(i);
      hash = (hash * 0x01000193) >>> 0; // FNV-1a 32-bit prime
    }
  };

  const processValue = (value) => {
    const type = typeof value;

    if (value === null) {
      processString('null');
    } else if (type === 'object') {
      if (Array.isArray(value)) {
        processString('array');
        for (let i = 0; i < value.length; i++) {
          processValue(value[i]);
        }
      } else {
        processString('object');
        const keys = Object.keys(value).sort(); // Ensure consistent order
        for (let i = 0; i < keys.length; i++) {
          processString(keys[i]); // Hash the key
          processValue(value[keys[i]]); // Hash the value
        }
      }
    } else if (
      type === 'function' ||
      type === 'symbol' ||
      type === 'undefined'
    ) {
      // Ignore functions, symbols, and undefined values for hashing
      processString(type);
    } else {
      processString(String(value)); // Convert primitives to string and hash
    }
  };

  processValue(obj);
  return hash;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/distance.js
//start file
export function chebyshevDistance(pos1, pos2) {
  return Math.max(Math.abs(pos1.x - pos2.x), Math.abs(pos1.y - pos2.y));
}

export function calculateDistance(pos1, pos2) {
  if (!pos1 || !pos2) return Infinity;
  const dx = pos1.x - pos2.x;
  const dy = pos1.y - pos2.y;
  const dz = pos1.z - pos2.z;
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

export const getDistance = (p1, p2) =>
  Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/frameUpdateManager.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/utils/frameUpdateManager.js
/**
 * Manages the accumulation of dirty rectangles for a worker.
 * This class acts as a simple flag. If a worker receives dirty rects,
 * shouldProcess() will return true once and then reset.
 */
export class FrameUpdateManager {
  constructor() {
    this.accumulatedDirtyRects = [];
  }

  /**
   * This is now a no-op, as region interest is handled by the workerManager.
   * It's kept for API compatibility to prevent errors from existing calls.
   * @param {Array<object>|object} regions - Ignored.
   */
  setRegionsOfInterest(regions) {
    // Intentionally empty.
  }

  /**
   * Adds new dirty rectangles to the internal accumulator.
   * @param {Array<object>} rects - An array of dirty rectangles.
   */
  addDirtyRects(rects) {
    if (rects && rects.length > 0) {
      this.accumulatedDirtyRects.push(...rects);
    }
  }

  /**
   * Determines if the worker should perform its main processing logic.
   * Returns true if any dirty rectangles have been accumulated since the last check.
   * This method also clears the accumulator.
   * @returns {boolean} True if processing is needed, false otherwise.
   */
  shouldProcess() {
    if (this.accumulatedDirtyRects.length === 0) {
      return false;
    }
    // Atomically check, clear, and return true.
    this.accumulatedDirtyRects.length = 0;
    return true;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/gameWorldClickTranslator.js
//start file
// Player's fixed position on the screen within the game world window (0-indexed).
// This is a design constant representing the center of the viewport.
export const PLAYER_SCREEN_TILE_X = 7; // 8th tile from the left
export const PLAYER_SCREEN_TILE_Y = 5; // 6th tile from the top

/**
 * Translates absolute in-game world coordinates to absolute screen coordinates for clicking.
 * This function is pure and relies on dynamically detected region data passed as arguments.
 *
 * @param {number} targetGameX - The target absolute X coordinate in the game world.
 * @param {number} targetGameY - The target absolute Y coordinate in the game world.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current absolute position.
 * @param {object} gameWorldRegion - The dynamically found gameWorld region object {x, y, width, height}.
 * @param {object} tileSize - The dynamically calculated tile size object {width, height}.
 * @param {'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight' | 'center'} [targetPoint='center'] - The specific point within the tile to target.
 * @returns {{x: number, y: number}|null} The absolute screen coordinates for the click, or null if inputs are invalid.
 */
export function getAbsoluteGameWorldClickCoordinates(
  targetGameX,
  targetGameY,
  playerMinimapPosition,
  gameWorldRegion,
  tileSize,
  targetPoint = 'center',
) {
  // --- Input Validation ---
  if (!playerMinimapPosition) {
    console.error(
      '[ClickTranslator] Missing playerMinimapPosition for coordinate translation.',
    );
    return null;
  }
  if (!gameWorldRegion || !gameWorldRegion.width || !gameWorldRegion.height) {
    console.error(
      '[ClickTranslator] Missing or invalid gameWorldRegion for coordinate translation.',
    );
    return null;
  }
  if (!tileSize || !tileSize.width || !tileSize.height) {
    console.error(
      '[ClickTranslator] Missing or invalid tileSize for coordinate translation.',
    );
    return null;
  }

  // Calculate the difference in global game coordinates (in tiles)
  const deltaTilesX = targetGameX - playerMinimapPosition.x;
  const deltaTilesY = targetGameY - playerMinimapPosition.y;

  // Calculate the top-left pixel of the player's tile on screen using dynamic data
  const playerScreenPixelX_topLeft =
    gameWorldRegion.x + PLAYER_SCREEN_TILE_X * tileSize.width;
  const playerScreenPixelY_topLeft =
    gameWorldRegion.y + PLAYER_SCREEN_TILE_Y * tileSize.height;

  // Calculate the top-left pixel of the target tile on screen
  const targetTileScreenPixelX =
    playerScreenPixelX_topLeft + deltaTilesX * tileSize.width;
  const targetTileScreenPixelY =
    playerScreenPixelY_topLeft + deltaTilesY * tileSize.height;

  // Adjust based on targetPoint within the tile
  let finalClickX = targetTileScreenPixelX;
  let finalClickY = targetTileScreenPixelY;

  switch (targetPoint) {
    case 'topRight':
      finalClickX += tileSize.width;
      break;
    case 'bottomLeft':
      finalClickY += tileSize.height;
      break;
    case 'bottomRight':
      // Subtract a couple of pixels to ensure the click is inside the boundary
      finalClickX += tileSize.width - 2;
      finalClickY += tileSize.height - 2;
      break;
    case 'center':
    default: // Default to center for safety
      finalClickX += tileSize.width / 2;
      finalClickY += tileSize.height / 2;
      break;
  }

  // Return the final, rounded coordinates to ensure they are integers
  return { x: Math.round(finalClickX), y: Math.round(finalClickY) };
}

/**
 * Translates absolute screen coordinates to in-game world coordinates.
 *
 * @param {number} screenX - The absolute X coordinate on the screen.
 * @param {number} screenY - The absolute Y coordinate on the screen.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current absolute position.
 * @param {object} gameWorldRegion - The dynamically found gameWorld region object {x, y, width, height}.
 * @param {object} tileSize - The dynamically calculated tile size object {width, height}.
 * @returns {{x: number, y: number, z: number}|null} The absolute game world coordinates, or null if inputs are invalid.
 */
export function getGameCoordinatesFromScreen(
  screenX,
  screenY,
  playerMinimapPosition,
  gameWorldRegion,
  tileSize,
) {
  // --- Input Validation ---
  if (!playerMinimapPosition) {
    console.error(
      '[ClickTranslator] Missing playerMinimapPosition for coordinate translation.',
    );
    return null;
  }
  if (!gameWorldRegion || !gameWorldRegion.width || !gameWorldRegion.height) {
    console.error(
      '[ClickTranslator] Missing or invalid gameWorldRegion for coordinate translation.',
    );
    return null;
  }
  if (!tileSize || !tileSize.width || !tileSize.height) {
    console.error(
      '[ClickTranslator] Missing or invalid tileSize for coordinate translation.',
    );
    return null;
  }

  // --- Corrected Logic ---

  // 1. Calculate the entity's pixel position relative to the gameWorld region's origin.
  const relativeX = screenX - gameWorldRegion.x;
  const relativeY = screenY - gameWorldRegion.y;

  // 2. Convert the relative pixel position to a tile position within the gameWorld grid.
  const entityTileX = Math.floor(relativeX / tileSize.width);
  const entityTileY = Math.floor(relativeY / tileSize.height);

  // 3. Calculate the difference in tiles between the entity and the player's fixed screen position.
  const deltaTilesX = entityTileX - PLAYER_SCREEN_TILE_X;
  const deltaTilesY = entityTileY - PLAYER_SCREEN_TILE_Y;

  // 4. Add this tile difference to the player's absolute game world coordinates.
  const gameX = playerMinimapPosition.x + deltaTilesX;
  const gameY = playerMinimapPosition.y + deltaTilesY;

  return {
    x: gameX,
    y: gameY,
    z: playerMinimapPosition.z, // Z-level is the same as the player's
  };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/getDirectionKey.js
//start file
const getDirectionKey = (current, target) => {
  const dx = target.x - current.x;
  const dy = target.y - current.y;
  if (dy < 0) {
    if (dx < 0) return 'q';
    if (dx === 0) return 'w';
    if (dx > 0) return 'e';
  } else if (dy === 0) {
    if (dx < 0) return 'a';
    if (dx > 0) return 'd';
  } else if (dy > 0) {
    if (dx < 0) return 'z';
    if (dx === 0) return 's';
    if (dx > 0) return 'c';
  }
  return null;
};

export default getDirectionKey;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/getRandomNumber.js
//start file
export const getRandomNumber = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/getWindowDimensions.js
//start file
import { spawn } from 'child_process';

class XdotoolManager {
  constructor() {
    this.process = null;
    this.commandQueue = [];
    this.isProcessing = false;
  }

  init() {
    if (this.process) return;

    this.process = spawn('xdotool', ['-']);

    // Handle process output
    this.process.stdout.on('data', (data) => {
      const result = data.toString().trim();
      if (this.commandQueue.length > 0) {
        const { resolve } = this.commandQueue.shift();
        resolve(result);
        this.processNextCommand();
      }
    });

    this.process.stderr.on('data', (data) => {
      if (this.commandQueue.length > 0) {
        const { reject } = this.commandQueue.shift();
        reject(new Error(data.toString()));
        this.processNextCommand();
      }
    });

    // Clean up on exit
    process.on('exit', () => {
      if (this.process) {
        this.process.kill();
      }
    });
  }

  async executeCommand(command) {
    return new Promise((resolve, reject) => {
      this.commandQueue.push({ command, resolve, reject });
      if (!this.isProcessing) {
        this.processNextCommand();
      }
    });
  }

  async processNextCommand() {
    if (this.commandQueue.length === 0) {
      this.isProcessing = false;
      return;
    }

    this.isProcessing = true;
    const { command } = this.commandQueue[0];

    try {
      // Send command through stdin
      this.process.stdin.write(`${command}\n`);
    } catch (error) {
      const { reject } = this.commandQueue.shift();
      reject(error);
      this.processNextCommand();
    }
  }
}

// Singleton instance
const xdotoolManager = new XdotoolManager();

async function getWindowDimensions(windowId) {
  xdotoolManager.init();

  try {
    const output = await xdotoolManager.executeCommand(
      `getwindowgeometry ${windowId}`,
    );
    const dimensions = output.match(/Geometry: (\d+)x(\d+)/);

    if (!dimensions) {
      throw new Error('Failed to parse window dimensions');
    }

    return {
      width: parseInt(dimensions[1]),
      height: parseInt(dimensions[2]),
    };
  } catch (error) {
    console.error('Error:', error);
    return null;
  }
}

export { getWindowDimensions, xdotoolManager };

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/logger.js
//start file
// electron/utils/logger.js
/**
 * Creates a configured logger function.
 *
 * @param {object} config - Logging configuration.
 * @param {boolean} [config.error=true] - Enable error logs.
 * @param {boolean} [config.warn=false] - Enable warning logs.
 * @param {boolean} [config.info=false] - Enable info logs.
 * @param {boolean} [config.debug=false] - Enable debug logs.
 * @param {boolean} [config.colors=true] - Enable colored output.
 * @returns {function(string, string, ...any): void} - The logging function.
 *   The function takes (level, message, ...optionalParams).
 */
export function createLogger(config = {}) {
  const defaultConfig = {
    error: true,
    warn: false,
    info: false,
    debug: false,
    colors: true,
  };

  // Merge provided config with default config
  const loggerConfig = { ...defaultConfig, ...config };

  const levels = {
    error: { tag: 'ERROR', color: 31, consoleMethod: 'error' }, // Red
    warn: { tag: 'WARN', color: 33, consoleMethod: 'warn' }, // Yellow
    info: { tag: 'INFO', color: 34, consoleMethod: 'log' }, // Blue
    debug: { tag: 'DEBUG', color: 32, consoleMethod: 'log' }, // Green
  };

  /**
   * Logs a message with a specific level.
   *
   * @param {string} level - The logging level ('error', 'warn', 'info', 'debug').
   * @param {string} message - The message to log.
   * @param {...any} optionalParams - Optional parameters to log (e.g., objects, variables).
   */
  return function log(level, message, ...optionalParams) {
    // Normalize level to lowercase for config lookup
    const lowerLevel = level.toLowerCase();
    const levelDetails = levels[lowerLevel];

    // Check if the level exists and is enabled in the config
    if (!levelDetails || !loggerConfig[lowerLevel]) {
      return; // Don't log if level is not configured or invalid
    }

    const now = new Date();
    // Format timestamp as YYYY-MM-DD HH:MM:SS.sss
    const timestamp = now.toISOString().replace('T', ' ').slice(0, 23);
    const tag = levelDetails.tag;
    const consoleMethod = levelDetails.consoleMethod;

    let formattedMessage;
    if (loggerConfig.colors) {
      const colorCode = levelDetails.color;
      // --- FIX: Apply color once at the start and reset once at the end ---
      // This ensures the tag, timestamp, and message are all the same color.
      // OLD: `\x1b[${colorCode}m[${tag}] [\x1b[90m${timestamp}\x1b[0m]\x1b[0m ${message}`
      formattedMessage = `\x1b[${colorCode}m[${tag}] [${timestamp}] ${message}\x1b[0m`;
    } else {
      // Format: [TAG] [TIMESTAMP] Message
      formattedMessage = `[${tag}] [${timestamp}] ${message}`;
    }

    // Use the appropriate console method to maintain console output streams (stdout vs stderr)
    console[consoleMethod](formattedMessage, ...optionalParams);
  };
}

// Example usage (can be removed or kept for testing)
// const defaultLogger = createLogger();
// defaultLogger('error', 'This is an error message.');
// defaultLogger('warn', 'This is a warning message.'); // Won't show with default config
// defaultLogger('info', 'This is an info message.');   // Won't show with default config
// defaultLogger('debug', 'This is a debug message.'); // Won't show with default config

// const verboseLogger = createLogger({ info: false, warn: true, debug: false });
// verboseLogger('error', 'This is an error message (verbose).');
// verboseLogger('warn', 'This is a warning message (verbose).');
// verboseLogger('info', 'This is an info message (verbose).');
// verboseLogger('debug', 'This is a debug message (verbose).', { data: 123 });

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/minimapClickTranslator.js
//start file
const MINIMAP_WIDTH = 106; // From preprocessMinimaps.js
const MINIMAP_HEIGHT = 109; // From preprocessMinimaps.js

/**
 * Translates global minimap coordinates to absolute screen coordinates for clicking.
 * @param {number} targetMapX - The target X coordinate on the global minimap.
 * @param {number} targetMapY - The target Y coordinate on the global minimap.
 * @param {{x: number, y: number, z: number}} playerMinimapPosition - The player's current position on the global minimap.
 * @param {{x: number, y: number, width: number, height: number}} minimapRegionDef - The screen coordinates and dimensions of the visible minimap.
 * @returns {{x: number, y: number}|null} The absolute screen coordinates for the click, or null if inputs are invalid.
 */
export function getAbsoluteClickCoordinates(
  targetMapX,
  targetMapY,
  playerMinimapPosition,
  minimapRegionDef,
) {
  if (!playerMinimapPosition || !minimapRegionDef) {
    console.error(
      'Missing playerMinimapPosition or minimapRegionDef for coordinate translation.',
    );
    return null;
  }

  // Calculate relative pixel position on the visible minimap
  const relativePixelX =
    targetMapX - playerMinimapPosition.x + MINIMAP_WIDTH / 2;
  const relativePixelY =
    targetMapY - playerMinimapPosition.y + MINIMAP_HEIGHT / 2;

  // Bounds check: Ensure the calculated relative pixel is within the visible minimap area
  if (
    relativePixelX < 0 ||
    relativePixelX >= minimapRegionDef.width ||
    relativePixelY < 0 ||
    relativePixelY >= minimapRegionDef.height
  ) {
    return null; // Target is outside the visible minimap
  }

  // Calculate absolute screen coordinates
  const absoluteClickX = minimapRegionDef.x + relativePixelX;
  const absoluteClickY = minimapRegionDef.y + relativePixelY;

  return { x: absoluteClickX, y: absoluteClickY };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/minimapMatcher.js
//start file
import fs from 'fs/promises';
import path from 'path';
import { createLogger } from './logger.js';
import MinimapMatcherNative from 'minimap_matcher-native';

const logger = createLogger({ info: false, error: true, debug: false });

let PREPROCESSED_BASE_DIR = null;

// Allow setting the base directory externally (e.g., from workerData)
export const setMinimapResourcesPath = (basePath) => {
  PREPROCESSED_BASE_DIR = basePath;
};

const getPreprocessedBaseDir = () => {
  if (!PREPROCESSED_BASE_DIR) {
    // Fallback for backward compatibility
    const getResourcesPath = () => {
      if (process.resourcesPath) {
        return process.resourcesPath;
      }
      return process.cwd();
    };
    return path.join(getResourcesPath(), 'resources', 'preprocessed_minimaps');
  }
  return PREPROCESSED_BASE_DIR;
};

const LANDMARK_SIZE = 3;
// The landmark pattern is now packed at 4-bits per pixel.
// The C++ addon will now work with 25-byte keys instead of 49-byte keys.
const LANDMARK_PATTERN_BYTES = Math.ceil((LANDMARK_SIZE * LANDMARK_SIZE) / 2); // 25

const EXCLUDED_COLORS_RGB = [
  { r: 51, g: 102, b: 153 },
  { r: 0, g: 0, b: 0 },
  { r: 255, g: 255, b: 255 },
  { r: 153, g: 153, b: 153 },
  { r: 0, g: 204, b: 0 },
  { r: 102, g: 102, b: 102 },
  { r: 255, g: 204, b: 153 },
  { r: 153, g: 102, b: 51 },
  { r: 255, g: 102, b: 0 },
];

class MinimapMatcher {
  constructor() {
    try {
      this.nativeMatcher = new MinimapMatcherNative.MinimapMatcher({
        LANDMARK_SIZE,
        LANDMARK_PATTERN_BYTES,
        EXCLUDED_COLORS_RGB,
      });
    } catch (error) {
      logger(
        'error',
        `Failed to load native minimap matcher module: ${error.message}`,
      );
      throw error;
    }

    this.isLoaded = false;
    this.lastKnownPositionByZ = new Map();
  }

  async loadMapData() {
    if (this.isLoaded) return;
    try {
      const baseDir = getPreprocessedBaseDir();
      const paletteFilePath = path.join(baseDir, 'palette.json');
      const palette = JSON.parse(await fs.readFile(paletteFilePath, 'utf8'));

      const artificialLandmarkData = new Map();
      const naturalLandmarkData = new Map();

      const zLevelDirs = (await fs.readdir(baseDir, { withFileTypes: true }))
        .filter((d) => d.isDirectory() && d.name.startsWith('z'))
        .map((d) => parseInt(d.name.substring(1), 10));

      const landmarkEntrySize = 8 + LANDMARK_PATTERN_BYTES;

      const parseLandmarks = (buffer) => {
        const landmarks = [];
        for (let i = 0; i < buffer.length; i += landmarkEntrySize) {
          landmarks.push({
            x: buffer.readUInt32LE(i),
            y: buffer.readUInt32LE(i + 4),
            pattern: buffer.subarray(i + 8, i + landmarkEntrySize),
          });
        }
        return landmarks;
      };

      for (const z of zLevelDirs) {
        const zLevelDir = path.join(baseDir, `z${z}`);

        // Load artificial landmarks
        try {
          const artificialBuffer = await fs.readFile(
            path.join(zLevelDir, 'landmarks_artificial.bin'),
          );
          artificialLandmarkData.set(z, parseLandmarks(artificialBuffer));
        } catch (e) {
          if (e.code !== 'ENOENT') {
            logger('error', `Could not load landmarks_artificial.bin for Z=${z}: ${e.message}`);
          }
          artificialLandmarkData.set(z, []);
        }

        // Load natural landmarks
        try {
          const naturalBuffer = await fs.readFile(
            path.join(zLevelDir, 'landmarks_natural.bin'),
          );
          naturalLandmarkData.set(z, parseLandmarks(naturalBuffer));
        } catch (e) {
          if (e.code !== 'ENOENT') {
            logger('error', `Could not load landmarks_natural.bin for Z=${z}: ${e.message}`);
          }
          naturalLandmarkData.set(z, []);
        }

        if (!artificialLandmarkData.get(z).length && !naturalLandmarkData.get(z).length) {
            logger('warn', `No landmarks found for Z=${z}. Position finding will be unavailable for this floor.`);
        }
      }

      // Sync data to the native module once on load
      this.nativeMatcher.palette = palette;
      this.nativeMatcher.artificialLandmarkData = Object.fromEntries(artificialLandmarkData);
      this.nativeMatcher.naturalLandmarkData = Object.fromEntries(naturalLandmarkData);
      this.nativeMatcher.isLoaded = true;
      this.isLoaded = true;

      logger('info', `All minimap data loaded and synced to native module.`);
    } catch (error) {
      logger('error', `Failed to load minimap data: ${error.message}`);
      this.isLoaded = false;
      this.nativeMatcher.isLoaded = false;
    }
  }

  /**
   * Finds the player position asynchronously.
   * This method returns a promise that resolves with the position or rejects on error/cancellation.
   * It will automatically cancel any previously running search.
   * @param {Buffer} unpackedMinimap - A buffer of 8-bit palette indices.
   * @param {number} minimapWidth
   * @param {number} minimapHeight
   * @param {number} targetZ
   * @returns {Promise<object|null>} A promise that resolves with the result object.
   */
  async findPosition(unpackedMinimap, minimapWidth, minimapHeight, targetZ) {
    if (!this.isLoaded) {
      throw new Error(
        'MinimapMatcher is not loaded. Call loadMapData() first.',
      );
    }

    const resultPromise = this.nativeMatcher.findPosition(
      unpackedMinimap,
      minimapWidth,
      minimapHeight,
      targetZ,
    );

    resultPromise
      .then((result) => {
        if (result && result.position) {
          this.lastKnownPositionByZ.set(targetZ, {
            x: result.mapViewX,
            y: result.mapViewY,
          });
        }
      })
      .catch((err) => {
        if (err.message !== 'Search cancelled') {
          logger('error', `Native findPosition error: ${err.message}`);
        }
      });

    return resultPromise;
  }

  /**
   * Explicitly cancels any ongoing search.
   */
  cancelCurrentSearch() {
    this.nativeMatcher.cancelSearch();
  }
}

export { MinimapMatcher };

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/nameMatcher.js
//start file
function longestCommonSubstring(str1, str2) {
  const s1 = str1.toLowerCase().replace(/\s/g, '');
  const s2 = str2.toLowerCase().replace(/\s/g, '');
  let maxLength = 0;
  let endIndex = 0;

  const matrix = Array(s1.length + 1)
    .fill(0)
    .map(() => Array(s2.length + 1).fill(0));

  for (let i = 1; i <= s1.length; i++) {
    for (let j = 1; j <= s2.length; j++) {
      if (s1[i - 1] === s2[j - 1]) {
        matrix[i][j] = matrix[i - 1][j - 1] + 1;
        if (matrix[i][j] > maxLength) {
          maxLength = matrix[i][j];
          endIndex = i;
        }
      }
    }
  }
  return s1.substring(endIndex - maxLength, endIndex);
}

export function findBestNameMatch(ocrName, canonicalNames, logger) {
  if (!ocrName) {
    return null;
  }

  // First, check for a perfect, case-insensitive match. This is the highest confidence scenario.
  const perfectMatch = canonicalNames.find(
    (name) => name.toLowerCase() === ocrName.toLowerCase(),
  );
  if (perfectMatch) {
    return perfectMatch;
  }

  // If no perfect match, proceed with fuzzy matching for partial names.
  if (ocrName.length < 4) {
    return ocrName; // Not enough info for a confident fuzzy match, return raw.
  }

  let bestMatch = null;
  let highestScore = 0;

  for (const canonicalName of canonicalNames) {
    const commonSubstring = longestCommonSubstring(ocrName, canonicalName);
    const score = commonSubstring.length;

    if (score > highestScore) {
      highestScore = score;
      bestMatch = canonicalName;
    }
  }

  // Confidence check: The match must be at least 4 characters long
  // and represent a significant portion of the OCR'd name.
  if (highestScore >= 4 && highestScore > ocrName.length * 0.6) {
    if (ocrName !== bestMatch) {
      logger(
        'debug',
        `[NameMatcher] Matched OCR name "${ocrName}" to canonical name "${bestMatch}" (Score: ${highestScore})`,
      );
    }
    return bestMatch;
  }

  // If no high-confidence match is found, return the original OCR name for debugging.
  return ocrName;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/parseMathCondition.js
//start file
/**
 * Parse mathematical conditions for HP and mana triggers.
 * @param {string} condition - The mathematical condition to check.
 * @param {number} triggerPercentage - The trigger percentage value.
 * @param {number} actualPercentage - The actual percentage value to check against.
 * @returns {boolean} - True if the condition is met, false otherwise.
 */
const parseMathCondition = (condition, triggerPercentage, actualPercentage) => {
  switch (condition) {
    case '<':
      return actualPercentage < triggerPercentage;
    case '<=':
      return actualPercentage <= triggerPercentage;
    case '=':
      return actualPercentage === triggerPercentage;
    case '>':
      return actualPercentage > triggerPercentage;
    case '>=':
      return actualPercentage >= triggerPercentage;
    case '!=':
      return actualPercentage !== triggerPercentage;
    default:
      return false;
  }
};

export default parseMathCondition;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/utils/rectsIntersect.js
//start file
/**
 * Checks if two rectangle objects intersect.
 * @param {object} rectA - The first rectangle {x, y, width, height}.
 * @param {object} rectB - The second rectangle {x, y, width, height}.
 * @returns {boolean} True if the rectangles overlap.
 */
export const rectsIntersect = (rectA, rectB) => {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}
//endFile

// /home/feiron/Dokumenty/Automaton/electron/widget/preload.js
//start file
// Automaton/electron/widget/preload.js
const { contextBridge, ipcRenderer } = require('electron');

// Expose controlled functions to the renderer process
contextBridge.exposeInMainWorld('electronAPI', {
  // Send messages to the main process
  send: (channel, ...args) => {
    ipcRenderer.send(channel, ...args);
  },
  // Receive messages from the main process
  on: (channel, listener) => {
    ipcRenderer.on(channel, listener);
  },
  // Invoke functions in the main process and wait for a response
  invoke: (channel, ...args) => {
    return ipcRenderer.invoke(channel, ...args);
  },
  // Remove a listener
  removeListener: (channel, listener) => {
    ipcRenderer.removeListener(channel, listener);
  },
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/widget/renderer.js
//start file
// Automaton/electron/widget/renderer.js

// Function to get current state from main process
async function getInitialStates() {
  try {
    const states = await window.electronAPI.invoke('get-control-states');
    if (states) {
      document.getElementById('healing-switch').checked = states.isRulesEnabled;
      document.getElementById('cavebot-switch').checked =
        states.isCavebotEnabled;
      document.getElementById('targeting-switch').checked =
        states.isTargetingEnabled;
      document.getElementById('scripts-switch').checked = states.isLuaEnabled;
    }
  } catch (error) {
    console.error('Error getting initial states:', error);
  }
}

// Function to handle switch changes
function handleSwitchChange(switchId, feature) {
  const switchElement = document.getElementById(switchId);
  switchElement.addEventListener('change', () => {
    window.electronAPI.send('update-bot-status', {
      feature,
      isEnabled: switchElement.checked,
    });
  });
}

// Function to handle state updates from main process
function handleStateUpdates() {
  window.electronAPI.on('state-update', (event, action) => {
    // Update switches based on state changes from main process
    switch (action.type) {
      case 'rules/setenabled':
        document.getElementById('healing-switch').checked = action.payload;
        break;
      case 'cavebot/setenabled':
        document.getElementById('cavebot-switch').checked = action.payload;
        break;
      case 'targeting/setenabled':
        document.getElementById('targeting-switch').checked = action.payload;
        break;
      case 'lua/setenabled':
        document.getElementById('scripts-switch').checked = action.payload;
        break;
      case 'rules/setState':
        if (action.payload) {
          document.getElementById('healing-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'cavebot/setState':
        if (action.payload) {
          document.getElementById('cavebot-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'targeting/setState':
        if (action.payload) {
          document.getElementById('targeting-switch').checked =
            action.payload.enabled;
        }
        break;
      case 'lua/setState':
        if (action.payload) {
          document.getElementById('scripts-switch').checked =
            action.payload.enabled;
        }
        break;
    }
  });
}

// Function to update main window toggle button
async function updateMainWindowToggle() {
  const isVisible = await window.electronAPI.invoke('is-main-window-visible');
  const toggleIcon = document.getElementById('toggle-main-icon');

  if (isVisible) {
    toggleIcon.textContent = '🗔';
  } else {
    toggleIcon.textContent = '🗔';
  }
}

// Function to handle main window toggle
function handleMainWindowToggle() {
  const toggleBtn = document.getElementById('toggle-main-btn');
  toggleBtn.addEventListener('click', async () => {
    await window.electronAPI.invoke('toggle-main-window');
    await updateMainWindowToggle();
  });
}

// Initialize the widget when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
  // Get initial states
  await getInitialStates();
  await updateMainWindowToggle();

  // Set up switch change handlers
  handleSwitchChange('healing-switch', 'healing');
  handleSwitchChange('cavebot-switch', 'cavebot');
  handleSwitchChange('targeting-switch', 'targeting');
  handleSwitchChange('scripts-switch', 'scripts');

  // Set up state update listener
  handleStateUpdates();

  // Set up main window toggle
  handleMainWindowToggle();
});

// Clean up listeners when window is closed
window.addEventListener('beforeunload', () => {
  window.electronAPI.removeListener('state-update', handleStateUpdates);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workerManager.js
//start file
import { Worker } from 'worker_threads';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import store from './store.js';
import setGlobalState from './setGlobalState.js';
import { showNotification } from './notificationHandler.js';
import { createLogger } from './utils/logger.js';
import { BrowserWindow } from 'electron';
import { playSound } from './globalShortcuts.js';
import { deepHash } from './utils/deepHash.js';
import { rectsIntersect } from './utils/rectsIntersect.js';

import {
  PLAYER_POS_SAB_SIZE,
  PATH_DATA_SAB_SIZE,
  BATTLE_LIST_SAB_SIZE,
  CREATURES_SAB_SIZE,
  LOOTING_SAB_SIZE,
  TARGETING_LIST_SAB_SIZE,
  TARGET_SAB_SIZE,
} from './workers/sharedConstants.js';

const log = createLogger();

const DEFAULT_WORKER_CONFIG = {
  captureWorker: true,
  regionMonitor: true,
  screenMonitor: true,
  minimapMonitor: true,
  ocrWorker: true,
  creatureMonitor: true,
  cavebotWorker: true,
  targetingWorker: true,
  pathfinderWorker: true,
  windowTitleMonitor: true,
  inputOrchestrator: true,
  enableLuaScriptWorkers: true,
};

const MAX_RESTART_ATTEMPTS = 5;
const RESTART_COOLDOWN = 500;
const RESTART_LOCK_TIMEOUT = 5000;
const DEBOUNCE_INTERVAL = 16;

function quickHash(obj) {
  return deepHash(obj);
}

const WORKER_STATE_DEPENDENCIES = {
  // cavebotWorker needs the full state, so it's handled separately
  // luaScriptWorker also needs the full state, handled separately

  targetingWorker: [
    'targeting',
    'global',
    'gameState',
    'pathfinder',
    'cavebot',
    'regionCoordinates',
    'battleList',
  ],
  regionMonitor: ['global'],
  screenMonitor: [
    'global',
    'regionCoordinates',
    'gameState',
    'rules',
    'uiValues',
  ],
  minimapMonitor: ['gameState', 'regionCoordinates'],
  ocrWorker: ['global', 'regionCoordinates', 'gameState', 'ocr'],
  creatureMonitor: [
    'global',
    'regionCoordinates',
    'gameState',
    'ocr',
    'cavebot',
    'targeting',
  ],
  captureWorker: ['global'],
  pathfinderWorker: ['targeting', 'cavebot', 'gameState'],
  windowTitleMonitor: ['global', 'gameState'],
  inputOrchestrator: ['global'],
};

const GRACEFUL_SHUTDOWN_WORKERS = new Set([
  'regionMonitor',
  'screenMonitor',
  'minimapMonitor',
  'ocrWorker',
  'creatureMonitor',
  'cavebotWorker',
  'targetingWorker',
  'pathfinderWorker',
]);



const WORKER_REGION_DEPENDENCIES = {
  screenMonitor: [
    'healthBar',
    'manaBar',
    'cooldownBar',
    'statusBar',
    'amuletSlot',
    'ringSlot',
    'bootsSlot',
    'hotkeyBar',
    'battleList',
  ],
  minimapMonitor: ['minimapFull', 'minimapFloorIndicatorColumn'],
  ocrWorker: [
    'skillsWidget',
    'chatBoxTabRow',
    'selectCharacterModal',
    'vipWidget',
    'gameWorld',
    'battleList',
  ],
  creatureMonitor: ['gameWorld','battleList','playerList','npcList'],
  // `null` is a special case: regionMonitor needs an update on ANY screen change.
  regionMonitor: null,
};

let inspectorPort = 9230; // Base port for worker inspection

class WorkerManager {
  constructor() {
    const filename = fileURLToPath(import.meta.url);
    this.electronDir = dirname(filename);
    this.workers = new Map();
    this.workerInitialized = new Map();
    this.workerPaths = new Map();
    this.restartLocks = new Map();
    this.restartAttempts = new Map();
    this.restartTimeouts = new Map();
    this.sharedData = null;
    this.workerConfig = {};
    this.paths = { workers: null, minimapResources: null };
    this.previousState = null;
    this.storeUpdateTimeout = null;
    this.updateCount = 0;
    this.lastPerfReport = Date.now();
    this.reusableChangedSlices = {};
    this.workerStateCache = new Map();
    this.debounceTimeout = null;
    this.sharedLuaGlobals = {}; // NEW: Centralized object for shared Lua globals
    this.handleWorkerError = this.handleWorkerError.bind(this);
    this.handleWorkerExit = this.handleWorkerExit.bind(this);
    this.handleWorkerMessage = this.handleWorkerMessage.bind(this);
    this.handleStoreUpdate = this.handleStoreUpdate.bind(this);
    this.debouncedStoreUpdate = this.debouncedStoreUpdate.bind(this);
    this.precalculatedWorkerPayloads = new Map(); // New map for pre-calculated payloads
  }

  setupPaths(app, cwd) {
    if (app.isPackaged) {
      this.paths.minimapResources = path.join(
        app.getAppPath(),
        '..',
        'resources',
        'preprocessed_minimaps',
      );
    } else {
      this.paths.minimapResources = path.join(
        cwd,
        '..',
        'resources',
        'preprocessed_minimaps',
      );
    }
    if (!app.isPackaged) {
      log('info', '[Worker Manager] Paths initialized:', this.paths);
    }
  }

  resetRestartState(name) {
    this.restartLocks.set(name, false);
    this.restartAttempts.set(name, 0);
    clearTimeout(this.restartTimeouts.get(name));
    this.restartTimeouts.delete(name);
  }

  async clearRestartLockWithTimeout(name) {
    const timeout = setTimeout(() => {
      log('warn', `[Worker Manager] Force clearing restart lock: ${name}`);
      this.resetRestartState(name);
    }, RESTART_LOCK_TIMEOUT);
    this.restartTimeouts.set(name, timeout);
  }

  getWorkerPath(workerName) {
    const isUUID = /^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/.test(
      workerName,
    );
    if (isUUID) {
      return resolve(this.electronDir, './workers', 'luaScriptWorker.js');
    }
    if (workerName === 'cavebotWorker') {
      return resolve(this.electronDir, './workers', 'cavebot', 'index.js');
    }
    return resolve(this.electronDir, './workers', `${workerName}.js`);
  }

  createSharedBuffers() {
    const maxImageSize = 3840 * 2160 * 4;
    const imageSAB = new SharedArrayBuffer(maxImageSize);
    const MAX_DIRTY_REGIONS = 100;
    const SYNC_BUFFER_SIZE = 5 + 1 + MAX_DIRTY_REGIONS * 4;
    const syncSAB = new SharedArrayBuffer(
      SYNC_BUFFER_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const playerPosSAB = new SharedArrayBuffer(
      PLAYER_POS_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const pathDataSAB = new SharedArrayBuffer(
      PATH_DATA_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const battleListSAB = new SharedArrayBuffer(
      BATTLE_LIST_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const creaturesSAB = new SharedArrayBuffer(
      CREATURES_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const lootingSAB = new SharedArrayBuffer(
      LOOTING_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const targetingListSAB = new SharedArrayBuffer(
      TARGETING_LIST_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );
    const targetSAB = new SharedArrayBuffer(
      TARGET_SAB_SIZE * Int32Array.BYTES_PER_ELEMENT,
    );

    this.sharedData = {
      imageSAB,
      syncSAB,
      playerPosSAB,
      pathDataSAB,
      battleListSAB,
      creaturesSAB,
      lootingSAB,
      targetingListSAB,
      targetSAB,
    };
    log('info', '[Worker Manager] Created SharedArrayBuffers.');
  }

  handleWorkerError(name, error) {
    log('error', `[Worker Manager] Worker error: ${name}`, error);
    if (!name.startsWith('script-') && !this.restartLocks.get(name)) {
      this.restartWorker(name).catch((err) =>
        log(
          'error',
          `[Worker Manager] Restart failed after error: ${name}`,
          err,
        ),
      );
    } else if (name.startsWith('script-')) {
      log(
        'info',
        `[Worker Manager] Script worker ${name} encountered an error. Lifecycle managed by store updates.`,
      );
      this.workers.delete(name);
    }
  }

  handleWorkerExit(name, code) {
    log('info', `[Worker Manager] Worker exited: ${name}, code ${code}`);
    this.workers.delete(name);
    this.workerPaths.delete(name);
    this.workerInitialized.delete(name);
    const isUUID = /^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/.test(
      name,
    );
    if (!isUUID && code !== 0) {
      const attempts = this.restartAttempts.get(name) || 0;
      if (!this.restartLocks.get(name) && attempts < MAX_RESTART_ATTEMPTS) {
        log(
          'error',
          `[Worker Manager] Non-script worker exited with error: ${name}, code ${code}, attempt ${attempts + 1}/${MAX_RESTART_ATTEMPTS}`,
        );
        setTimeout(
          () => {
            this.restartWorker(name).catch((err) =>
              log('error', `Failed to restart worker ${name} after exit:`, err),
            );
          },
          RESTART_COOLDOWN * (attempts + 1),
        );
      } else if (attempts >= MAX_RESTART_ATTEMPTS) {
        log(
          'error',
          `[Worker Manager] Max restart attempts reached for non-script worker: ${name}`,
        );
        this.resetRestartState(name);
      }
    }
  }

  handleWorkerMessage(message, workerName) {
    if (message.type === 'request_state_snapshot') {
      const worker = this.workers.get(workerName)?.worker;
      if (worker) {
        worker.postMessage({
          type: 'state_snapshot',
          payload: store.getState(),
        });
      }
      return;
    }

    if (message.type === 'inputAction') {
      const inputOrchestrator = this.workers.get('inputOrchestrator');
      if (inputOrchestrator && inputOrchestrator.worker) {
        inputOrchestrator.worker.postMessage(message);
      }
      return;
    }

    // --- MODIFIED: Centralized Frame Update Distribution ---
    if (message.type === 'frame-update') {
      const dirtyRects = message.payload.dirtyRects;
      if (!dirtyRects || dirtyRects.length === 0) return;

      const allRegions = store.getState().regionCoordinates.regions;
      if (!allRegions) return;

      for (const [name, workerEntry] of this.workers.entries()) {
        if (name === 'captureWorker' || !workerEntry.worker) continue;

        const dependencies = WORKER_REGION_DEPENDENCIES[name];

        // Special case for regionMonitor: it needs an update on ANY screen change.
        if (dependencies === null) {
          workerEntry.worker.postMessage(message);
          continue;
        }

        if (dependencies) {
          let needsUpdate = false;
          for (const regionKey of dependencies) {
            const region = allRegions[regionKey];
            if (region) {
              for (const dirtyRect of dirtyRects) {
                if (rectsIntersect(region, dirtyRect)) {
                  workerEntry.worker.postMessage(message);
                  needsUpdate = true;
                  break; // Break from inner loop (dirtyRects)
                }
              }
            }
            if (needsUpdate) break; // Break from outer loop (dependencies)
          }
        }
      }
      return;
    }
    // --- END MODIFICATION ---

    if (message.notification) {
      showNotification(message.notification.title, message.notification.body);
    } else if (message.storeUpdate) {
      this.incomingActionQueue.push({
        type: message.type,
        payload: message.payload,
      });
    } else if (message.type === 'batch-update') {
      for (const action of message.payload) {
        setGlobalState(action.type, action.payload);
      }
    } else if (message.command === 'requestRegionRescan') {
      const regionWorkerEntry = this.workers.get('regionMonitor');
      if (regionWorkerEntry?.worker) {
        regionWorkerEntry.worker.postMessage({ command: 'forceRegionSearch' });
      }
    } else if (message.command === 'executeLuaScript') {
      const state = store.getState();
      const { enabled: luaEnabled } = state.lua;
      const { script, id } = message.payload;
      if (!luaEnabled) {
        const cavebotWorkerEntry = this.workers.get('cavebotWorker');
        if (cavebotWorkerEntry?.worker) {
          cavebotWorkerEntry.worker.postMessage({
            type: 'script-finished',
            id,
            success: false,
            error: 'Lua scripts are disabled',
          });
        }
        return;
      }
      this.startWorker(id, { id, code: script, type: 'oneshot' }, this.paths);
    } else if (message.type === 'scriptExecutionResult') {
      const { id, success, error } = message;
      if (error)
        log(
          'error',
          `[Worker Manager] Script ${id} failed with error: ${error}`,
        );
      const cavebotWorkerEntry = this.workers.get('cavebotWorker');
      if (cavebotWorkerEntry?.worker) {
        cavebotWorkerEntry.worker.postMessage({ type: 'script-finished', id });
      }
      this.stopWorker(id);
    } else if (
      ['scriptError', 'luaPrint', 'luaStatusUpdate'].includes(message.type)
    ) {
      const { scriptId, message: logMessage } = message;
      if (scriptId) {
        setGlobalState('lua/addLogEntry', {
          id: scriptId,
          message: logMessage,
        });
        BrowserWindow.getAllWindows().forEach((win) => {
          if (!win.isDestroyed())
            win.webContents.send('script-log-update', {
              scriptId,
              message: logMessage,
            });
        });
      }
    } else if (message.type === 'lua_global_update') {
      const { key, value } = message.payload;
      log(
        'debug',
        `[Worker Manager] Received lua_global_update: key=${key}, value=${value}`,
      );
      this.sharedLuaGlobals[key] = value; // Update the master copy

      // Broadcast to all other workers, including cavebotWorker
      for (const [name, workerEntry] of this.workers) {
        // The `workerName` is the sender, so don't send it back to the sender
        if (
          name !== workerName &&
          (/^[0-9a-fA-F]{8}-/.test(name) || name === 'cavebotWorker')
        ) {
          workerEntry.worker.postMessage({
            type: 'lua_global_broadcast',
            payload: { key, value },
          });
        }
      }
      return; // Message handled
    } else if (message.type === 'play_alert') {
      const soundFile = message.payload?.soundFile || 'alert.wav';
      playSound(soundFile);
      return;
    } else if (message.type === 'lua-pause-walking') {
      store.dispatch(setWalkingPause(message.payload));
      return;
    } else if (message.type === 'lua-pause-targeting') {
      store.dispatch(setTargetingPause(message.payload));
      return;
    } else if (message.type === 'lua_set_script_enabled') {
      const { name, enabled } = message.payload;
      setGlobalState('lua/setScriptEnabledByName', { name, enabled });
    }
  }

  startWorker(name, scriptConfig = null, paths = null) {
    if (this.workers.has(name)) return this.workers.get(name).worker;
    try {
      const workerPath = this.getWorkerPath(name);
      const needsSharedScreen = [
        'captureWorker',
        'screenMonitor',
        'minimapMonitor',
        'regionMonitor',
        'ocrWorker',
        'creatureMonitor',
      ].includes(name);
      const needsPlayerPosSAB = [
        'minimapMonitor',
        'pathfinderWorker',
        'cavebotWorker',
        'targetingWorker',
        'creatureMonitor',
      ].includes(name);
      const needsPathDataSAB = [
        'pathfinderWorker',
        'cavebotWorker',
        'targetingWorker',
      ].includes(name);
      const needsBattleListSAB = [
        'creatureMonitor',
        'cavebotWorker',
        'targetingWorker',
      ].includes(name);
      const needsCreaturesSAB = [
        'creatureMonitor',
        'cavebotWorker',
        'targetingWorker',
      ].includes(name);
      const needsLootingSAB = [
        'creatureMonitor',
        'cavebotWorker',
        'targetingWorker',
      ].includes(name);
      const needsTargetingListSAB = [
        'creatureMonitor',
        'targetingWorker',
      ].includes(name);
      const needsTargetSAB = [
        'creatureMonitor',
        'cavebotWorker',
        'targetingWorker',
      ].includes(name);

      const workerData = {
        paths: paths || this.paths,
        sharedData: needsSharedScreen ? this.sharedData : null,
        playerPosSAB: needsPlayerPosSAB ? this.sharedData.playerPosSAB : null,
        pathDataSAB: needsPathDataSAB ? this.sharedData.pathDataSAB : null,
        battleListSAB: needsBattleListSAB
          ? this.sharedData.battleListSAB
          : null,
        creaturesSAB: needsCreaturesSAB ? this.sharedData.creaturesSAB : null,
        lootingSAB: needsLootingSAB ? this.sharedData.lootingSAB : null,
        targetingListSAB: needsTargetingListSAB
          ? this.sharedData.targetingListSAB
          : null,
        targetSAB: needsTargetSAB ? this.sharedData.targetSAB : null,
        sharedLuaGlobals: this.sharedLuaGlobals, // NEW: Pass the shared Lua globals object
        enableMemoryLogging: true,
      };
      if (needsSharedScreen) {
        workerData.display = store.getState().global.display;
      }

      const execArgv = [`--inspect=${inspectorPort++}`];
      const worker = new Worker(workerPath, {
        name,
        workerData,
        execArgv,
      });

      this.workers.set(name, { worker, config: scriptConfig });
      this.workerInitialized.set(name, false);
      worker.on('message', (msg) => this.handleWorkerMessage(msg, name));
      worker.on('error', (error) => this.handleWorkerError(name, error));
      worker.on('exit', (code) => this.handleWorkerExit(name, code));
      log('info', `[Worker Manager] Worker ${name} started successfully.`);

      if (scriptConfig) {
        setTimeout(() => {
          worker.postMessage({ type: 'init', script: scriptConfig });
        }, 16);
      }

      // NEW: Immediately send global state to inputOrchestrator upon start
      if (name === 'inputOrchestrator') {
        const currentState = store.getState();
        worker.postMessage({
          type: 'state_full_sync',
          payload: { global: currentState.global },
        });
      }

      return worker;
    } catch (error) {
      log('error', `[Worker Manager] Failed to start worker: ${name}`, error);
      return null;
    }
  }

  async restartWorker(name, scriptConfig = null) {
    if (this.restartLocks.get(name)) return null;
    this.restartLocks.set(name, true);
    this.restartAttempts.set(name, (this.restartAttempts.get(name) || 0) + 1);
    this.clearRestartLockWithTimeout(name);
    try {
      await this.stopWorker(name);
      const newWorker = this.startWorker(name, scriptConfig, this.paths);
      if (!newWorker) throw new Error(`Failed to create new worker: ${name}`);
      log('info', `[Worker Manager] Worker ${name} restarted successfully.`);
      this.resetRestartState(name);
      return newWorker;
    } catch (error) {
      log('error', `[Worker Manager] Error during restart: ${name}`, error);
    } finally {
      this.restartLocks.set(name, false);
    }
  }

  stopWorker(name) {
    const workerEntry = this.workers.get(name);
    // FIX: If worker doesn't exist or is already stopping, do nothing.
    if (!workerEntry?.worker || workerEntry.stopping) {
      return Promise.resolve();
    }
    // FIX: Mark the worker as stopping to prevent duplicate shutdown commands.
    workerEntry.stopping = true;

    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        if (this.workers.has(name) && !workerEntry.worker.killed) {
          log(
            'warn',
            `[Worker Manager] Worker ${name} did not exit gracefully. Forcing termination.`,
          );
          workerEntry.worker.terminate();
        }
        resolve();
      }, 5000);

      workerEntry.worker.once('exit', () => {
        clearTimeout(timeout);
        resolve();
      });

      if (
        /^[0-9a-fA-F]{8}-/.test(name) ||
        GRACEFUL_SHUTDOWN_WORKERS.has(name)
      ) {
        workerEntry.worker.postMessage({ type: 'shutdown' });
      } else {
        workerEntry.worker.terminate();
      }
    });
  }

  async stopAllWorkers() {
    log('info', '[Worker Manager] Stopping all workers...');
    if (this.incomingActionInterval) {
      clearInterval(this.incomingActionInterval);
      this.incomingActionInterval = null;
    }
    await Promise.all(
      Array.from(this.workers.keys()).map((name) => this.stopWorker(name)),
    );
    log('info', '[Worker Manager] All workers have been terminated.');
  }

  getStateChanges(currentState, previousState) {
    const changedSlices = {};
    let hasChanges = false;
    for (const key in currentState) {
      if (currentState[key] !== previousState[key]) {
        changedSlices[key] = currentState[key];
        hasChanges = true;
      }
    }

    // Optimization: For pathfinder, only consider it "changed" if the path length is different.
    // This avoids deep hashing the large path array on every minor change.
    if (
      changedSlices.pathfinder &&
      previousState.pathfinder &&
      currentState.pathfinder.path?.length ===
        previousState.pathfinder.path?.length
    ) {
      delete changedSlices.pathfinder;
    }

    return hasChanges ? changedSlices : null;
  }

  syncReduxToSAB(currentState) {
    // Sync targeting list to SAB for creatureMonitor
    const creatureMonitorEntry = this.workers.get('creatureMonitor');
    if (creatureMonitorEntry && currentState.targeting?.targetingList) {
      creatureMonitorEntry.worker.postMessage({
        type: 'sab_sync_targeting_list',
        payload: currentState.targeting.targetingList,
      });
    }
  }

  broadcastStateUpdate(changedSlices, currentState) {
    // Sync specific Redux data to SAB before broadcasting
    this.syncReduxToSAB(currentState);

    this.precalculatedWorkerPayloads.clear();
    for (const workerName in WORKER_STATE_DEPENDENCIES) {
      const workerDeps = WORKER_STATE_DEPENDENCIES[workerName];
      const relevantPayload = {};
      let hasRelevantChanges = false;
      for (const k of Object.keys(changedSlices)) {
        if (workerDeps.includes(k)) {
          relevantPayload[k] = changedSlices[k];
          hasRelevantChanges = true;
        }
      }
      if (hasRelevantChanges) {
        this.precalculatedWorkerPayloads.set(workerName, relevantPayload);
      }
    }

    for (const [name, workerEntry] of this.workers) {
      if (!workerEntry.worker || name === 'captureWorker') continue;

      const isLuaWorker =
        /^[0-9a-fA-F]{8}-/.test(name) || name === 'cavebotWorker';

      if (!this.workerInitialized.get(name) || isLuaWorker) {
        // For initial setup or Lua workers, always send the full state
        workerEntry.worker.postMessage(currentState);
        this.workerInitialized.set(name, true);
        if (isLuaWorker) {
          // For Lua workers, we don't use state_diff, so clear cache
          this.workerStateCache.delete(name);
        }
        log('info', `[Worker Manager] Sent full state to ${name}.`);
        continue;
      }

      const relevant = this.precalculatedWorkerPayloads.get(name);

      if (relevant && Object.keys(relevant).length) {
        const hash = quickHash(relevant);
        if (this.workerStateCache.get(name) !== hash) {
          this.workerStateCache.set(name, hash);
          workerEntry.worker.postMessage({
            type: 'state_diff',
            payload: relevant,
          });
        }
      }
    }
  }

  logPerformanceStats() {
    const now = Date.now();
    if (now - this.lastPerfReport >= 10000) {
      const ups = (
        (this.updateCount / (now - this.lastPerfReport)) *
        1000
      ).toFixed(1);
      log(
        'debug',
        `[Worker Manager] Performance: ${ups} store updates/sec, ${this.workers.size} active workers`,
      );
      this.updateCount = 0;
      this.lastPerfReport = now;
    }
  }

  debouncedStoreUpdate() {
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout);
    }
    this.debounceTimeout = setTimeout(() => {
      this.handleStoreUpdate();
    }, DEBOUNCE_INTERVAL);
  }

  async handleStoreUpdate() {
    const perfStart = performance.now();
    this.updateCount++;
    try {
      const currentState = store.getState();
      const { windowId, display } = currentState.global;

      if (windowId && display) {
        if (!this.sharedData) this.createSharedBuffers();
        if (
          !this.previousState ||
          currentState.global.windowId !== this.previousState.global.windowId
        ) {
          const syncArray = new Int32Array(this.sharedData.syncSAB);
          Atomics.store(syncArray, 4, parseInt(windowId, 10) || 0);
        }

        if (
          this.workerConfig.captureWorker &&
          !this.workers.has('captureWorker')
        )
          this.startWorker('captureWorker');
        if (
          this.workerConfig.regionMonitor &&
          !this.workers.has('regionMonitor')
        )
          this.startWorker('regionMonitor');
        if (
          this.workerConfig.screenMonitor &&
          !this.workers.has('screenMonitor')
        )
          this.startWorker('screenMonitor');
        if (
          this.workerConfig.minimapMonitor &&
          !this.workers.has('minimapMonitor')
        )
          this.startWorker('minimapMonitor');
        if (this.workerConfig.ocrWorker && !this.workers.has('ocrWorker'))
          this.startWorker('ocrWorker');
        if (
          this.workerConfig.creatureMonitor &&
          !this.workers.has('creatureMonitor')
        )
          this.startWorker('creatureMonitor');
        if (
          this.workerConfig.pathfinderWorker &&
          !this.workers.has('pathfinderWorker')
        )
          this.startWorker('pathfinderWorker');
        if (
          this.workerConfig.cavebotWorker &&
          !this.workers.has('cavebotWorker')
        )
          this.startWorker('cavebotWorker');
        if (
          this.workerConfig.targetingWorker &&
          !this.workers.has('targetingWorker')
        )
          this.startWorker('targetingWorker');
        if (
          this.workerConfig.windowTitleMonitor &&
          !this.workers.has('windowTitleMonitor')
        )
          this.startWorker('windowTitleMonitor');

        if (
          this.workerConfig.inputOrchestrator &&
          !this.workers.has('inputOrchestrator')
        )
          this.startWorker('inputOrchestrator');
      } else {
        if (this.workers.size > 0) {
          log(
            'info',
            '[Worker Manager] Window not detected, stopping all workers...',
          );
          await this.stopAllWorkers();
        }
        if (this.sharedData) {
          log('info', '[Worker Manager] Clearing SharedArrayBuffers.');
          this.sharedData = null;
        }
      }

      await this.manageLuaWorkers(currentState, currentState.lua.enabled);

      if (this.previousState) {
        const changed = this.getStateChanges(currentState, this.previousState);
        if (changed) this.broadcastStateUpdate(changed, currentState);
      }
      this.previousState = currentState;
      this.logPerformanceStats();
    } catch (error) {
      log('error', '[Worker Manager] Error in handleStoreUpdate:', error);
    }
    const updateTime = performance.now() - perfStart;
    if (updateTime > 16) {
      log(
        'warn',
        `[Worker Manager] Slow store update: ${updateTime.toFixed(2)}ms`,
      );
    }
  }

  async manageLuaWorkers(currentState, luaEnabled) {
    const allPersistentScripts = currentState.lua.persistentScripts;
    const runningScriptWorkerIds = new Set(
      Array.from(this.workers.keys()).filter((n) => /^[0-9a-fA-F]{8}-/.test(n)),
    );
    if (this.workerConfig.enableLuaScriptWorkers && luaEnabled) {
      const activeScripts = allPersistentScripts.filter((s) => s.enabled);
      const activeScriptIds = new Set(activeScripts.map((s) => s.id));
      const workersToStop = Array.from(runningScriptWorkerIds).filter(
        (id) => !activeScriptIds.has(id),
      );
      if (workersToStop.length)
        await Promise.all(workersToStop.map((id) => this.stopWorker(id)));
      for (const script of activeScripts) {
        const entry = this.workers.get(script.id);
        if (!entry) {
          this.startWorker(script.id, script, this.paths);
        } else if (
          entry.config &&
          (entry.config.code !== script.code ||
            entry.config.loopMin !== script.loopMin ||
            entry.config.loopMax !== script.loopMax)
        ) {
          await this.restartWorker(script.id, script);
        } else {
          entry.config = script;
        }
      }
    } else {
      if (runningScriptWorkerIds.size > 0) {
        await Promise.all(
          Array.from(runningScriptWorkerIds).map((id) => this.stopWorker(id)),
        );
      }
    }
  }

  initialize(app, cwd, config = {}) {
    this.setupPaths(app, cwd);
    this.workerConfig = { ...DEFAULT_WORKER_CONFIG, ...config };
    log('info', '[Worker Manager] Initializing with debounced store updates.');
    this.previousState = store.getState();
    store.subscribe(this.debouncedStoreUpdate);

    this.incomingActionQueue = [];
    this.incomingActionInterval = setInterval(() => {
      if (this.incomingActionQueue.length > 0) {
        const batch = this.incomingActionQueue.splice(
          0,
          this.incomingActionQueue.length,
        );
        for (const action of batch) {
          setGlobalState(action.type, action.payload);
        }
      }
    }, 5);
  }
}

const workerManager = new WorkerManager();
export default workerManager;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/config.js
//start file
export const TARGET_FPS = 30;

// --- SharedArrayBuffer (SAB) Indices ---
export const FRAME_COUNTER_INDEX = 0;
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const WINDOW_ID_INDEX = 4;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

// --- Capture Limits ---
// This must match the value used when creating the SharedArrayBuffer
export const MAX_DIRTY_REGIONS = 100;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/core.js
//start file
// capture/core.js (Final Corrected Version)

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import X11RegionCapture from 'x11-region-capture-native';
import * as config from './config.js';
import { PerformanceTracker } from './performanceTracker.js';

// --- Worker State & Setup ---
const { sharedData, display } = workerData;
if (!sharedData) throw new Error('[CaptureCore] Shared data not provided.');

const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const imageBuffer = Buffer.from(imageSAB);

const captureInstance = X11RegionCapture
  ? new X11RegionCapture.X11RegionCapture(display)
  : null;
let isCapturing = false;

// --- Performance Tracking ---
const perfTracker = new PerformanceTracker();
let lastPerfReportTime = Date.now();

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function logPerformanceReport() {
  // This function is disabled in the provided code, but left for completeness.
  // if (!config.PERFORMANCE_LOGGING_ENABLED) return;

  const now = Date.now();
  const PERFORMANCE_LOG_INTERVAL_MS = 5000; // Example value
  if (now - lastPerfReportTime >= PERFORMANCE_LOG_INTERVAL_MS) {
    console.log(perfTracker.getReport());
    perfTracker.reset();
    lastPerfReportTime = now;
  }
}

async function captureLoop() {
  if (!captureInstance) {
    console.error(
      '[CaptureCore] X11 native module is not available. Cannot start capture.',
    );
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  const windowId = Atomics.load(syncArray, config.WINDOW_ID_INDEX);
  if (!windowId) {
    console.error('[CaptureCore] No Window ID provided. Cannot start capture.');
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  try {
    captureInstance.startMonitorInstance(windowId, config.TARGET_FPS);
    isCapturing = true;
    console.log(
      `[CaptureCore] Started monitoring window: ${windowId} at ${config.TARGET_FPS} FPS.`,
    );
  } catch (err) {
    console.error(
      '[CaptureCore] Failed to start native capture instance:',
      err,
    );
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
    return;
  }

  Atomics.store(syncArray, config.IS_RUNNING_INDEX, 1);

  while (Atomics.load(syncArray, config.IS_RUNNING_INDEX) === 1) {
    const loopStartTime = performance.now();

    try {
      // This call writes the new frame's pixel data directly into imageBuffer (our view over imageSAB).
      // This is the critical non-atomic operation that takes time.
      const frameResult = captureInstance.getLatestFrame(imageBuffer);

      if (frameResult) {
        // --- START OF SYNCHRONIZED UPDATE ---
        // All data related to the new frame is written to the syncSAB first.
        // The frame counter is only updated at the very end.

        const regionsToWrite = frameResult.changedRegions
          ? Math.min(
              frameResult.changedRegions.length,
              config.MAX_DIRTY_REGIONS,
            )
          : 0;

        // 1. Write all metadata (dirty rects, width, height).
        Atomics.store(
          syncArray,
          config.DIRTY_REGION_COUNT_INDEX,
          regionsToWrite,
        );

        if (frameResult.changedRegions) {
          for (let i = 0; i < regionsToWrite; i++) {
            const rect = frameResult.changedRegions[i];
            const offset = config.DIRTY_REGIONS_START_INDEX + i * 4;
            Atomics.store(syncArray, offset + 0, rect.x);
            Atomics.store(syncArray, offset + 1, rect.y);
            Atomics.store(syncArray, offset + 2, rect.width);
            Atomics.store(syncArray, offset + 3, rect.height);
          }
        }

        Atomics.store(syncArray, config.WIDTH_INDEX, frameResult.width);
        Atomics.store(syncArray, config.HEIGHT_INDEX, frameResult.height);

        // 2. *** THE "COMMIT" STEP ***
        // Only after the image data AND all metadata are fully written,
        // we increment and notify the frame counter. This signals to all
        // other workers that a new, complete frame is ready for reading.
        const newFrameCounter = Atomics.add(
          syncArray,
          config.FRAME_COUNTER_INDEX,
          1,
        );
        Atomics.notify(syncArray, config.FRAME_COUNTER_INDEX);

        // --- END OF SYNCHRONIZED UPDATE ---

        // This message is sent after the commit, so it's safe.
        if (
          frameResult.changedRegions &&
          frameResult.changedRegions.length > 0
        ) {
          parentPort.postMessage({
            type: 'frame-update',
            payload: {
              frameCounter: newFrameCounter,
              dirtyRects: frameResult.changedRegions,
            },
          });
        }

        const loopDuration = performance.now() - loopStartTime;
        perfTracker.addFrameMeasurement(loopDuration, regionsToWrite);
      }
    } catch (err) {
      console.error('[CaptureCore] Error in capture loop, stopping:', err);
      Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, config.IS_RUNNING_INDEX);
      break;
    }

    const loopDuration = performance.now() - loopStartTime;
    const delayTime = Math.max(0, 1000 / config.TARGET_FPS - loopDuration);
    await delay(delayTime);
  }

  if (isCapturing) {
    captureInstance.stopMonitorInstance();
    isCapturing = false;
    console.log('[CaptureCore] Stopped capture instance.');
  }
}

function handleMessage(message) {
  if (message.command === 'stop') {
    Atomics.store(syncArray, config.IS_RUNNING_INDEX, 0);
  }
}

export async function start() {
  console.log('[CaptureCore] Worker starting up...');
  parentPort.on('message', handleMessage);
  await captureLoop();
  console.log(
    '[CaptureCore] Worker has finished its capture loop and is shutting down.',
  );
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/capture/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report capture performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  /**
   * Resets all statistics to their initial state.
   */
  reset() {
    this.frameTimes = [];
    this.totalFrameTime = 0;
    this.minFrameTime = Infinity;
    this.maxFrameTime = 0;

    this.dirtyRegionCounts = [];
    this.totalDirtyRegions = 0;
    this.minDirtyRegions = Infinity;
    this.maxDirtyRegions = 0;
  }

  /**
   * Adds a new frame measurement to the tracker.
   * @param {number} duration - The time in milliseconds for the frame capture loop.
   * @param {number} regionCount - The number of dirty regions in the frame.
   */
  addFrameMeasurement(duration, regionCount) {
    // Frame time stats
    this.frameTimes.push(duration);
    this.totalFrameTime += duration;
    if (duration < this.minFrameTime) this.minFrameTime = duration;
    if (duration > this.maxFrameTime) this.maxFrameTime = duration;

    // Dirty region stats
    this.dirtyRegionCounts.push(regionCount);
    this.totalDirtyRegions += regionCount;
    if (regionCount < this.minDirtyRegions) this.minDirtyRegions = regionCount;
    if (regionCount > this.maxDirtyRegions) this.maxDirtyRegions = regionCount;
  }

  /**
   * Generates a formatted string of the current performance statistics.
   * @returns {string|null} A report string or null if no data is available.
   */
  getReport() {
    const frameCount = this.frameTimes.length;
    if (frameCount === 0) {
      return '[CapturePerformance] No frames captured in the last period.';
    }

    const avgFrameTime = this.totalFrameTime / frameCount;
    const avgDirtyRegions = this.totalDirtyRegions / frameCount;

    const frameReport = `Frames: ${frameCount} | Avg Time: ${avgFrameTime.toFixed(2)}ms | Min: ${this.minFrameTime.toFixed(2)}ms | Max: ${this.maxFrameTime.toFixed(2)}ms`;
    const regionReport = `Dirty Regions: Avg: ${avgDirtyRegions.toFixed(1)} | Min: ${this.minDirtyRegions} | Max: ${this.maxDirtyRegions}`;

    return `[CapturePerformance] ${frameReport} | ${regionReport}`;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/captureWorker.js
//start file
/**
 * @file captureWorker.js
 * @summary A dedicated worker for capturing screen frames from a specific window.
 * @description This file is the entry point for the capture worker. It delegates
 * all logic to the modules in the /capture sub-directory for maintainability.
 */

import { workerData } from 'worker_threads';
import { start } from './capture/core.js';
import { IS_RUNNING_INDEX } from './capture/config.js';

start().catch((err) => {
  console.error(
    '[CaptureWorker] A fatal, unhandled error occurred during startup:',
    err,
  );

  // Attempt to notify other workers that we are not running.
  // This is a "best effort" signal in case of a catastrophic startup failure.
  try {
    // workerData is available synchronously at the top level of a worker module.
    const { sharedData } = workerData;
    if (sharedData?.syncSAB) {
      const syncArray = new Int32Array(sharedData.syncSAB);
      Atomics.store(syncArray, IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, IS_RUNNING_INDEX);
      console.log(
        '[CaptureWorker] Successfully signaled shutdown to other workers.',
      );
    } else {
      console.error(
        '[CaptureWorker] Could not signal shutdown: sharedData or syncSAB not available.',
      );
    }
  } catch (e) {
    console.error(
      '[CaptureWorker] An error occurred while trying to signal shutdown:',
      e,
    );
  }

  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/actionHandlers.js
//start file
// /workers/cavebot/actionHandlers.js

import { parentPort } from 'worker_threads';
import { keyPress } from '../../keyboardControll/keyPress.js';

// ====================== MODIFICATION START ======================
// Corrected paths to go up two directories to the electron root
import useItemOnCoordinates from '../../mouseControll/useItemOnCoordinates.js';
import getDirectionKey from '../../utils/getDirectionKey.js';
import { getDistance } from '../../utils/distance.js';
// ======================= MODIFICATION END =======================
import { getAbsoluteClickCoordinatesForAction } from './helpers/actionUtils.js';
import {
  delay,
  awaitWalkConfirmation,
  awaitZLevelChange,
  awaitStandConfirmation,
} from './helpers/asyncUtils.js';
import { advanceToNextWaypoint } from './helpers/navigation.js';

const post = (payload) => {
  parentPort.postMessage({
    type: 'inputAction',
    payload,
  });
};

const leftClick = (x, y, { type = 'default' } = {}) => {
  post({
    type,
    action: {
      module: 'mouseController',
      method: 'leftClick',
      args: [x, y],
    },
  });
};

async function performWalk(
  workerState,
  config,
  targetPos,
  timeout,
  isDiagonal,
) {
  const posCounterBeforeMove = workerState.lastPlayerPosCounter;
  const pathCounterBeforeMove = workerState.lastPathDataCounter;
  const dirKey = getDirectionKey(workerState.playerMinimapPosition, targetPos);
  if (!dirKey) {
    workerState.logger(
      'warn',
      '[handleWalkAction] Could not determine direction key.',
    );
    return;
  }

  workerState.logger(
    'debug',
    `[performWalk] Attempting to walk. Direction: ${dirKey}, Diagonal: ${isDiagonal}.`,
  );
  keyPress(dirKey, { type: 'movement' });
  await awaitWalkConfirmation(
    workerState,
    config,
    posCounterBeforeMove,
    pathCounterBeforeMove,
    timeout,
  );
  if (isDiagonal) {
    await delay(config.postDiagonalMoveDelayMs);
  }
}

export async function handleWalkAction(workerState, config) {
  if (!workerState.path || workerState.path.length < 2) {
    workerState.logger(
      'debug',
      `[handleWalkAction] Aborted: Path is too short (${
        workerState.path?.length || 0
      }).`,
    );
    return;
  }

  const nextStep = workerState.path[1];

  const dirKey = getDirectionKey(workerState.playerMinimapPosition, nextStep);
  if (!dirKey) {
    workerState.logger(
      'warn',
      '[handleWalkAction] Could not determine direction key for next step.',
    );
    return;
  }

  const isDiagonal = ['q', 'e', 'z', 'c'].includes(dirKey);
  const timeout = isDiagonal
    ? config.moveConfirmTimeoutDiagonalMs
    : config.moveConfirmTimeoutMs;

  await performWalk(workerState, config, nextStep, timeout, isDiagonal);
}

export async function handleStandAction(workerState, config, targetWaypoint) {
  const { waypointSections = {} } = workerState.globalState.cavebot;
  const allWaypoints = Object.values(waypointSections).flatMap(
    (section) => section.waypoints || [],
  );
  const waypointIndex = allWaypoints.findIndex(
    (wpt) => wpt.id === targetWaypoint.id,
  );
  workerState.logger(
    'debug',
    `[handleStandAction] Executing for waypoint index ${waypointIndex + 1}.`,
  );
  const initialPos = { ...workerState.playerMinimapPosition };

  // Safety check: Don't attempt action if there's no valid path and we're not on the waypoint
  if (
    initialPos.x !== targetWaypoint.x ||
    initialPos.y !== targetWaypoint.y ||
    initialPos.z !== targetWaypoint.z
  ) {
    if (!workerState.path || workerState.path.length === 0) {
      workerState.logger(
        'warn',
        `[handleStandAction] No valid path to waypoint and not on waypoint. Aborting action.`,
      );
      return false;
    }
  }

  const dirKey = getDirectionKey(initialPos, targetWaypoint);
  if (!dirKey) {
    workerState.logger(
      'warn',
      `[handleStandAction] Could not determine direction for stand action at waypoint index ${
        waypointIndex + 1
      }.`,
    );
    return false;
  }

  keyPress(dirKey, { type: 'movement' });

  try {
    const { finalPos } = await awaitStandConfirmation(
      workerState,
      config,
      initialPos,
      config.defaultAwaitStateChangeTimeoutMs,
    );

    if (finalPos.z !== initialPos.z) {
      workerState.floorChangeGraceUntil =
        Date.now() + config.floorChangeGraceMs;
    }
    if (getDistance(initialPos, finalPos) >= config.teleportDistanceThreshold) {
      // Grace is handled by the caller, this just confirms success
    }
    return true;
  } catch (error) {
    workerState.logger(
      'warn',
      `[handleStandAction] Await confirmation failed: ${error.message}`,
    );
    return false;
  }
}

async function handleToolAction(
  workerState,
  config,
  targetCoords,
  hotkey,
  useType,
  clickOffset,
) {
  const { logger, globalState } = workerState;
  logger(
    'debug',
    `[handleToolAction] Executing tool '${useType}' with hotkey '${hotkey}'.`,
  );
  const initialPos = { ...workerState.playerMinimapPosition };
  if (!initialPos) {
    logger('error', `[handleToolAction:${useType}] No initial position found.`);
    return false;
  }

  // Use the standardized animation delay for these tools
  if (useType === 'shovel' || useType === 'rope') {
    await delay(config.animationArrivalTimeoutMs);
  }

  const clickCoords = getAbsoluteClickCoordinatesForAction(
    globalState,
    targetCoords,
    initialPos,
    clickOffset,
  );

  if (!clickCoords) {
    logger(
      'error',
      `[handleToolAction:${useType}] Could not calculate click coordinates.`,
    );
    return false;
  }

  const windowId = parseInt(globalState.global.windowId, 10);
  const display = globalState.global.display || ':0';

  if (useType === 'ladder') {
    leftClick(clickCoords.x, clickCoords.y, { type: 'movement' });
  } else if (useType === 'rope') {
    keyPress(hotkey, { type: 'movement' });
    await delay(50); // Small delay between hotkey and click
    leftClick(clickCoords.x, clickCoords.y, { type: 'movement' });
  } else if (useType === 'shovel') {
    useItemOnCoordinates(clickCoords.x, clickCoords.y, hotkey, {
      type: 'movement',
    });
  }

  const zChanged = await awaitZLevelChange(
    workerState,
    config,
    initialPos.z,
    config.defaultAwaitStateChangeTimeoutMs,
  );

  if (zChanged) {
    logger(
      'debug',
      `[handleToolAction:${useType}] Z-level change confirmed. Action successful.`,
    );
    workerState.floorChangeGraceUntil = Date.now() + config.floorChangeGraceMs;
    return true;
  }
  logger(
    'warn',
    `[handleToolAction:${useType}] Failed to confirm Z-level change.`,
  );
  return false;
}

export const handleLadderAction = (workerState, config, targetCoords) =>
  handleToolAction(
    workerState,
    config,
    targetCoords,
    null,
    'ladder',
    'bottomRight',
  );
export const handleRopeAction = (workerState, config, targetCoords) =>
  handleToolAction(
    workerState,
    config,
    targetCoords,
    config.toolHotkeys.rope,
    'rope',
    'bottomRight',
  );
export const handleShovelAction = (workerState, config, targetCoords) =>
  handleToolAction(
    workerState,
    config,
    targetCoords,
    config.toolHotkeys.shovel,
    'shovel',
    'center',
  );

export async function handleMacheteAction(workerState, config, targetWaypoint) {
  const { logger, globalState } = workerState;
  const { waypointSections = {} } = workerState.globalState.cavebot;
  const allWaypoints = Object.values(waypointSections).flatMap(
    (section) => section.waypoints || [],
  );
  const waypointIndex = allWaypoints.findIndex(
    (wpt) => wpt.id === targetWaypoint.id,
  );
  logger(
    'debug',
    `[handleMacheteAction] Executing for waypoint index ${waypointIndex + 1}.`,
  );
  const hotkey = config.toolHotkeys.machete;
  if (!hotkey) {
    logger('error', '[handleMacheteAction] Machete hotkey not configured.');
    return false;
  }

  const initialPos = { ...workerState.playerMinimapPosition };
  const clickCoords = getAbsoluteClickCoordinatesForAction(
    globalState,
    targetWaypoint,
    initialPos,
    'center',
  );
  if (!clickCoords) {
    logger(
      'error',
      '[handleMacheteAction] Could not calculate click coordinates.',
    );
    return false;
  }

  const windowId = parseInt(globalState.global.windowId, 10);
  const display = globalState.global.display || ':0';

  for (let i = 0; i < config.maxMacheteRetries; i++) {
    try {
      // First, try to just walk
      logger(
        'debug',
        `[handleMacheteAction] Attempt ${i + 1}: Trying to walk first.`,
      );
      await performWalk(
        workerState,
        config,
        targetWaypoint,
        config.moveConfirmTimeoutMs,
        false,
      );
      logger(
        'debug',
        `[handleMacheteAction] Attempt ${
          i + 1
        }: Walk succeeded, no machete needed.`,
      );
      return true; // Walk succeeded, no need for machete
    } catch (error) {
      logger(
        'debug',
        `[handleMacheteAction] Walk failed (attempt ${
          i + 1
        }), trying to use machete.`,
      );
    }

    // Walk failed, use tool
    logger(
      'debug',
      `[handleMacheteAction] Attempt ${i + 1}: Using machete.`,
    );
    useItemOnCoordinates(clickCoords.x, clickCoords.y, hotkey, {
      type: 'movement',
    });
    await delay(config.actionFailureRetryDelayMs);

    try {
      // Try to walk again after using the tool
      logger(
        'debug',
        `[handleMacheteAction] Attempt ${i + 1}: Trying to walk after using machete.`,
      );
      await performWalk(
        workerState,
        config,
        targetWaypoint,
        config.moveConfirmTimeoutMs,
        false,
      );
      logger(
        'debug',
        `[handleMacheteAction] Attempt ${
          i + 1
        }: Walk after machete succeeded.`,
      );
      return true; // Success after using tool
    } catch (error) {
      logger(
        'debug',
        `[handleMacheteAction] Walk after machete also failed (attempt ${
          i + 1
        }).`,
      );
    }
  }

  logger(
    'warn',
    `[handleMacheteAction] Failed to clear path after ${config.maxMacheteRetries} attempts.`,
  );
  return false;
}

export async function handleDoorAction(workerState, config, targetWaypoint) {
  const { logger, globalState } = workerState;
  const { waypointSections = {} } = workerState.globalState.cavebot;
  const allWaypoints = Object.values(waypointSections).flatMap(
    (section) => section.waypoints || [],
  );
  const waypointIndex = allWaypoints.findIndex(
    (wpt) => wpt.id === targetWaypoint.id,
  );
  logger(
    'debug',
    `[handleDoorAction] Executing for waypoint index ${waypointIndex + 1}.`,
  );

  // First, try to just walk in case door is already open
  try {
    logger('debug', '[handleDoorAction] Trying to walk through first.');
    await performWalk(
      workerState,
      config,
      targetWaypoint,
      config.moveConfirmTimeoutMs,
      false,
    );
    logger('debug', '[handleDoorAction] Walk succeeded, door was open.');
    return true;
  } catch (error) {
    logger(
      'debug',
      '[handleDoorAction] Walk failed, attempting to click door.',
    );
  }

  // Walk failed, so try clicking the door
  const initialPos = { ...workerState.playerMinimapPosition };
  const clickCoords = getAbsoluteClickCoordinatesForAction(
    globalState,
    targetWaypoint,
    initialPos,
    'center',
  );
  if (!clickCoords) {
    logger(
      'error',
      '[handleDoorAction] Could not calculate click coordinates.',
    );
    return false;
  }

  const posCounterBeforeMove = workerState.lastPlayerPosCounter;
  const pathCounterBeforeMove = workerState.lastPathDataCounter;

  logger('debug', '[handleDoorAction] Clicking on door.');
  leftClick(clickCoords.x, clickCoords.y);

  try {
    await awaitWalkConfirmation(
      workerState,
      config,
      posCounterBeforeMove,
      pathCounterBeforeMove,
      config.actionStateChangeTimeoutMs,
    );
    logger('debug', '[handleDoorAction] Move confirmed after clicking door.');
    return true;
  } catch (e) {
    logger('warn', '[handleDoorAction] Failed to confirm move after clicking.');
    return false;
  }
}

export async function handleScriptAction(workerState, config, targetWpt) {
  const { luaExecutor, logger } = workerState;
  const { waypointSections = {} } = workerState.globalState.cavebot;
  const allWaypoints = Object.values(waypointSections).flatMap(
    (section) => section.waypoints || [],
  );
  const waypointIndex = allWaypoints.findIndex((wpt) => wpt.id === targetWpt.id);
  logger(
    'debug',
    `[handleScriptAction] Executing for waypoint index ${waypointIndex + 1}.`,
  );

  if (!luaExecutor || !luaExecutor.isInitialized) {
    logger(
      'warn',
      '[handleScriptAction] Lua executor not ready, delaying...',
    );
    await delay(config.controlHandoverGraceMs);
    return;
  }

  if (workerState.scriptErrorWaypointId !== targetWpt.id) {
    workerState.scriptErrorWaypointId = targetWpt.id;
    workerState.scriptErrorCount = 0;
  }

  const result = await luaExecutor.executeScript(targetWpt.script);

  if (result.success) {
    logger(
      'debug',
      `[handleScriptAction] Script for waypoint index ${
        waypointIndex + 1
      } executed successfully.`,
    );
    workerState.scriptErrorCount = 0;
    if (!result.navigationOccurred) {
      logger(
        'debug',
        '[handleScriptAction] Script did not navigate, advancing waypoint manually.',
      );
      await advanceToNextWaypoint(workerState, config);
    }
  } else {
    workerState.scriptErrorCount++;
    logger(
      'warn',
      `[Cavebot] Script at waypoint index ${waypointIndex + 1} failed. Attempt ${
        workerState.scriptErrorCount
      }/${config.maxScriptRetries}.`,
    );

    if (workerState.scriptErrorCount >= config.maxScriptRetries) {
      const attemptText =
        config.maxScriptRetries === 1
          ? '1 time'
          : `${config.maxScriptRetries} times`;
      logger(
        'error',
        `[Cavebot] Script at waypoint index ${
          waypointIndex + 1
        } failed ${attemptText}. Skipping to next waypoint.`,
      );
      await advanceToNextWaypoint(workerState, config);
    } else {
      await delay(config.scriptErrorDelayMs);
    }
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/config.js
//start file
// /workers/cavebot/config.js

/**
 * Centralized configuration for the Cavebot Worker.
 * All time-based values are in milliseconds (Ms).
 */
export const config = {
  // --- Core Loop & Timing ---
  mainLoopIntervalMs: 25,
  stateChangePollIntervalMs: 5,
  mainLoopErrorDelayMs: 1000, // Delay after a critical error in the main loop

  // --- Action & Movement Timing ---
  animationArrivalTimeoutMs: 500, // Used for shovel/rope to let animation settle
  actionStateChangeTimeoutMs: 200,
  postDiagonalMoveDelayMs: 150,
  postTeleportGraceMs: 750,
  moveConfirmTimeoutMs: 400,
  moveConfirmTimeoutDiagonalMs: 650,
  defaultAwaitStateChangeTimeoutMs: 500,
  floorChangeGraceMs: 500,
  controlHandoverGraceMs: 100,

  // --- Retries & Delays ---
  maxScriptRetries: 1,
  maxMacheteRetries: 3, // Centralized from hardcoded value
  actionFailureRetryDelayMs: 500, // Renamed from macheteRetryDelay
  scriptErrorDelayMs: 250,

  // --- Gameplay Parameters ---
  teleportDistanceThreshold: 5,
  toolHotkeys: {
    rope: 'b',
    machete: 'n',
    shovel: 'v',
  },
  creatureMonitorSyncTimeoutMs: 1000, // Timeout for CreatureMonitor Z-level sync
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/fsm.js
//start file
// /workers/cavebot/fsm.js

import { postStoreUpdate } from './helpers/communication.js';
import { advanceToNextWaypoint } from './helpers/navigation.js';
import { delay } from './helpers/asyncUtils.js';
import { getDistance } from '../../utils/distance.js';
import {
  handleWalkAction,
  handleStandAction,
  handleLadderAction,
  handleRopeAction,
  handleShovelAction,
  handleMacheteAction,
  handleDoorAction,
  handleScriptAction,
} from './actionHandlers.js';
import {
  PATH_STATUS_PATH_FOUND,
  PATH_STATUS_WAYPOINT_REACHED,
  PATH_STATUS_NO_PATH_FOUND,
  PATH_STATUS_DIFFERENT_FLOOR,
  PATH_STATUS_ERROR,
  PATH_STATUS_NO_VALID_START_OR_END,
  PATH_STATUS_IDLE,
} from '../sharedConstants.js';

export function createFsm(workerState, config) {
  const logger = workerState.logger;
  return {
    IDLE: {
      enter: () => {
        logger('debug', '[FSM] Entering IDLE state.');
        postStoreUpdate('cavebot/setActionPaused', true);
      },
      execute: (context) => {
        if (context.targetWaypoint) {
          logger('debug', '[FSM] Target waypoint found, moving to EVALUATING_WAYPOINT.');
          return 'EVALUATING_WAYPOINT';
        }
        return 'IDLE';
      },
    },
    EVALUATING_WAYPOINT: {
      execute: async (context) => {
        const { playerPos, targetWaypoint, status, chebyshevDist } = context;
        const { unreachableWaypointIds = [], waypointSections = {} } =
          workerState.globalState.cavebot;
        const allWaypoints = Object.values(waypointSections).flatMap(
          (section) => section.waypoints || [],
        );
        const waypointIndex = allWaypoints.findIndex(
          (wpt) => wpt.id === targetWaypoint.id,
        );

        logger(
          'debug',
          `[FSM] Evaluating waypoint index ${waypointIndex + 1} (${
            targetWaypoint.type
          }) with path status: ${status}`,
        );

        // Immediately skip if this waypoint is known to be unreachable
        if (unreachableWaypointIds.includes(targetWaypoint.id)) {
          logger(
            'info',
            `[FSM] Skipping known unreachable waypoint index ${
              waypointIndex + 1
            }.`,
          );
          await advanceToNextWaypoint(workerState, config, {
            skipCurrent: false,
          }); // Already marked, just advance
          return 'IDLE';
        }

        // Handle Script waypoints first, as they ignore pathfinding and position.
        if (targetWaypoint.type === 'Script') {
          logger(
            'debug',
            `[FSM] Waypoint index ${
              waypointIndex + 1
            } is a script. Transitioning to EXECUTING_SCRIPT.`,
          );
          return 'EXECUTING_SCRIPT';
        }

        // Case 1: We are already on the target waypoint.
        const isOnWaypoint =
          playerPos.x === targetWaypoint.x &&
          playerPos.y === targetWaypoint.y &&
          playerPos.z === targetWaypoint.z;

        if (isOnWaypoint) {
          logger(
            'debug',
            `[FSM] Player is already on waypoint index ${waypointIndex + 1}.`,
          );
          switch (targetWaypoint.type) {
            case 'Stand':
            case 'Ladder':
            case 'Rope':
            case 'Shovel':
              logger(
                'debug',
                `[FSM] Waypoint is a '${targetWaypoint.type}' action. Transitioning to PERFORMING_ACTION.`,
              );
              return 'PERFORMING_ACTION';
            default: // For Node, etc., being on the tile means we're done.
              logger(
                'debug',
                '[FSM] Actionless waypoint reached. Advancing to next.',
              );
              await advanceToNextWaypoint(workerState, config);
              return 'IDLE';
          }
        }

        // Case 2: We are not on the waypoint, so we must evaluate the path.
        switch (status) {
          case PATH_STATUS_PATH_FOUND:
            logger('debug', '[FSM] Path found.');
            let isAdjacent =
              typeof chebyshevDist === 'number' && chebyshevDist <= 1;
            const isActionType = [
              'Ladder',
              'Rope',
              'Shovel',
              'Machete',
              'Door',
            ].includes(targetWaypoint.type);

            // Exclude South-East tile for Ladders
            if (targetWaypoint.type === 'Ladder' && isAdjacent) {
              if (
                playerPos.x === targetWaypoint.x + 1 &&
                playerPos.y === targetWaypoint.y + 1
              ) {
                logger(
                  'debug',
                  '[FSM] Player is on the south-east tile of a ladder. Ignoring adjacency.',
                );
                isAdjacent = false;
              }
            }

            if (isActionType && isAdjacent) {
              logger(
                'debug',
                `[FSM] Adjacent to action waypoint. Transitioning to PERFORMING_ACTION.`,
              );
              return 'PERFORMING_ACTION';
            }

            // Path is valid and we're not performing a special action, so walk.
            const wptIdHash = targetWaypoint.id
              ? targetWaypoint.id.split('').reduce((a, b) => {
                  a = (a << 5) - a + b.charCodeAt(0);
                  return a & a;
                }, 0)
              : 0;

            if (
              workerState.path &&
              workerState.path.length > 1 &&
              workerState.pathWptId === wptIdHash
            ) {
              logger(
                'debug',
                `[FSM] Path is valid (length: ${workerState.path.length}, wptId: ${workerState.pathWptId}). Transitioning to WALKING.`,
              );
              return 'WALKING';
            } else {
               logger(
                 'warn',
                 `[Cavebot FSM] Stale path detected. Expected WptIdHash: ${wptIdHash}, but path has ${workerState.pathWptId}. Path length: ${workerState.path?.length || 0}. Waiting for new path.`,
               );
            }
            // If path is stale or invalid, wait for a new one.
            workerState.shouldRequestNewPath = true;
            return 'EVALUATING_WAYPOINT';

          case PATH_STATUS_DIFFERENT_FLOOR:
            logger(
              'debug',
              '[FSM] Path status is DIFFERENT_FLOOR. Checking player Z-level.',
            );
            // If the pathfinder thinks we're on a different floor, but the core logic in index.js
            // confirms we are on the correct Z-level, it means the path is just stale.
            // We should wait for a new, correct path instead of skipping the waypoint.
            if (playerPos.z === targetWaypoint.z) {
              // DEADLOCK FIX: If we have a valid path despite the bad status, trust the path.
              // This handles cases where the pathfinder provides a correct path but an incorrect (stale) status.
              if (workerState.path && workerState.path.length > 1) {
                logger(
                  'warn',
                  '[FSM] Path status is DIFFERENT_FLOOR, but a valid path exists on the same Z-level. Overriding status and proceeding to WALK.',
                );
                return 'WALKING';
              }

              logger(
                'debug',
                '[FSM] Player Z matches waypoint Z. Path is stale. Requesting refresh.',
              );
              postStoreUpdate('cavebot/setForcePathRefresh', true);
              workerState.shouldRequestNewPath = true;
              return 'EVALUATING_WAYPOINT'; // Wait for a new path
            }
          // Fallthrough to default skip logic if Z-levels actually mismatch
          case PATH_STATUS_NO_PATH_FOUND:
          case PATH_STATUS_NO_VALID_START_OR_END:
          case PATH_STATUS_ERROR:
            logger(
              'warn',
              `[FSM] Unreachable waypoint index ${
                waypointIndex + 1
              } due to path status: ${status}. Skipping.`,
            );
            await advanceToNextWaypoint(workerState, config, {
              skipCurrent: true,
            });
            // DEADLOCK FIX: Immediately invalidate our knowledge of the current waypoint.
            // This forces the main loop to re-evaluate `findCurrentWaypoint` on the next tick
            // and prevents us from getting stuck processing the waypoint we just decided to skip.
            workerState.lastProcessedWptId = null;
            return 'IDLE';

          case PATH_STATUS_WAYPOINT_REACHED:
            logger(
              'debug',
              `[FSM] Path status is WAYPOINT_REACHED for index ${
                waypointIndex + 1
              }. Advancing.`,
            );
            // Pathfinder says we're there, but we're not exactly on the tile.
            // This is a success condition, so we advance.
            await advanceToNextWaypoint(workerState, config);
            return 'IDLE';

          case PATH_STATUS_IDLE:
          default:
            logger(
              'debug',
              `[FSM] Path status is ${status}. Waiting for pathfinder.`,
            );
            // Waiting for pathfinder.
            return 'EVALUATING_WAYPOINT';
        }
      },
    },
    WALKING: {
      enter: () => {
        logger('debug', '[FSM] Entering WALKING state.');
        postStoreUpdate('cavebot/setActionPaused', false);
      },
      execute: async () => {
        try {
          await handleWalkAction(workerState, config);
        } catch (error) {
          logger(
            'warn',
            `[FSM] Walk action failed: ${error.message}. Re-evaluating.`,
          );
        }
        return 'EVALUATING_WAYPOINT';
      },
    },
    PERFORMING_ACTION: {
      enter: () => {
        logger('debug', '[FSM] Entering PERFORMING_ACTION state.');
        postStoreUpdate('cavebot/setActionPaused', true);
      },
      execute: async (context) => {
        const { targetWaypoint } = context;
        const { waypointSections = {} } = workerState.globalState.cavebot;
        const allWaypoints = Object.values(waypointSections).flatMap(
          (section) => section.waypoints || [],
        );
        const waypointIndex = allWaypoints.findIndex(
          (wpt) => wpt.id === targetWaypoint.id,
        );
        logger(
          'debug',
          `[FSM] Performing action '${targetWaypoint.type}' for waypoint index ${
            waypointIndex + 1
          }.`,
        );
        let actionSucceeded = false;
        const targetCoords = {
          x: targetWaypoint.x,
          y: targetWaypoint.y,
          z: targetWaypoint.z,
        };
        switch (targetWaypoint.type) {
          case 'Stand':
            actionSucceeded = await handleStandAction(
              workerState,
              config,
              targetWaypoint,
            );
            break;
          case 'Ladder':
            actionSucceeded = await handleLadderAction(
              workerState,
              config,
              targetCoords,
            );
            break;
          case 'Rope':
            actionSucceeded = await handleRopeAction(
              workerState,
              config,
              targetCoords,
            );
            break;
          case 'Shovel':
            actionSucceeded = await handleShovelAction(
              workerState,
              config,
              targetCoords,
            );
            break;
          case 'Machete':
            actionSucceeded = await handleMacheteAction(
              workerState,
              config,
              targetWaypoint,
            );
            break;
          case 'Door':
            actionSucceeded = await handleDoorAction(
              workerState,
              config,
              targetWaypoint,
            );
            break;
        }

        if (actionSucceeded) {
          logger(
            'debug',
            `[FSM] Action '${targetWaypoint.type}' succeeded.`,
          );
          if (
            getDistance(workerState.playerMinimapPosition, targetWaypoint) >=
              config.teleportDistanceThreshold ||
            targetWaypoint.type === 'Ladder' || // Explicitly include Ladder type
            targetWaypoint.type === 'Rope' ||
            targetWaypoint.type === 'Shovel'
          ) {
            logger(
              'debug',
              '[FSM] Teleport-like action detected, transitioning to WAITING_FOR_CREATURE_MONITOR_SYNC.',
            );
            return 'WAITING_FOR_CREATURE_MONITOR_SYNC';
          } else {
            logger(
              'debug',
              '[FSM] Actionless waypoint reached. Advancing to next.',
            );
            await advanceToNextWaypoint(workerState, config);
            return 'IDLE';
          }
        } else {
          logger(
            'warn',
            `[FSM] Action '${
              targetWaypoint.type
            }' failed for waypoint index ${
              waypointIndex + 1
            }. Retrying after delay.`,
          );
          await delay(config.actionFailureRetryDelayMs);
          return 'EVALUATING_WAYPOINT';
        }
      },
    },
    WAITING_FOR_CREATURE_MONITOR_SYNC: {
      enter: () => {
        logger(
          'debug',
          '[FSM] Entering WAITING_FOR_CREATURE_MONITOR_SYNC state.',
        );
        postStoreUpdate('cavebot/setActionPaused', true); // Keep cavebot actions paused
        workerState.creatureMonitorSyncTimeout =
          Date.now() + config.creatureMonitorSyncTimeoutMs; // Set timeout
      },
      execute: async (context) => {
        const { playerPos } = context;
        const now = Date.now();

        // Check for timeout
        if (now >= workerState.creatureMonitorSyncTimeout) {
          logger(
            'warn',
            '[FSM] Timeout waiting for CreatureMonitor sync. Proceeding without explicit confirmation.',
          );
          await advanceToNextWaypoint(workerState, config); // Proceed anyway
          return 'IDLE';
        }

        // Read the last processed Z-level from CreatureMonitor via SAB
        const lastProcessedZ =
          workerState.sabStateManager.readCreatureMonitorLastProcessedZ();

        if (lastProcessedZ === playerPos.z) {
          logger(
            'info',
            '[FSM] CreatureMonitor sync confirmed for current Z-level. Advancing waypoint.',
          );
          await advanceToNextWaypoint(workerState, config);
          return 'IDLE';
        }

        logger(
          'debug',
          '[FSM] Waiting for CreatureMonitor to sync for current Z-level.',
        );
        await delay(config.stateChangePollIntervalMs); // Poll frequently
        return 'WAITING_FOR_CREATURE_MONITOR_SYNC'; // Stay in this state
      },
    },
    EXECUTING_SCRIPT: {
      enter: () => {
        logger('debug', '[FSM] Entering EXECUTING_SCRIPT state.');
        postStoreUpdate('cavebot/setActionPaused', true);
      },
      execute: async (context) => {
        await handleScriptAction(workerState, config, context.targetWaypoint);
        return 'EVALUATING_WAYPOINT';
      },
    },
  };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/actionUtils.js
//start file
// /workers/cavebot/helpers/actionUtils.js

// ====================== MODIFICATION START ======================
// Corrected path to go up three directories to the electron root
import { getAbsoluteGameWorldClickCoordinates } from '../../../utils/gameWorldClickTranslator.js';
// ======================= MODIFICATION END =======================

/**
 * A centralized helper to calculate absolute on-screen click coordinates for an action.
 * @param {object} globalState - The full global state object.
 * @param {object} targetCoords - The {x, y, z} of the target waypoint.
 * @param {object} playerPos - The player's current {x, y, z} position.
 * @param {string} clickOffset - The offset within the tile to click ('center', 'bottomRight', etc).
 * @returns {object|null} The {x, y} screen coordinates or null on failure.
 */
export function getAbsoluteClickCoordinatesForAction(
  globalState,
  targetCoords,
  playerPos,
  clickOffset,
) {
  const { gameWorld, tileSize } = globalState.regionCoordinates.regions;
  if (!gameWorld || !tileSize) {
    console.error(
      '[getAbsoluteClickCoordinatesForAction] Missing region coordinates for click.',
    );
    return null;
  }

  return getAbsoluteGameWorldClickCoordinates(
    targetCoords.x,
    targetCoords.y,
    playerPos,
    gameWorld,
    tileSize,
    clickOffset,
  );
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/asyncUtils.js
//start file
// /workers/cavebot/helpers/asyncUtils.js

import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
} from '../../sharedConstants.js';
// ====================== MODIFICATION START ======================
// Corrected path to go up three directories to the electron root
import { getDistance } from '../../../utils/distance.js';
// ======================= MODIFICATION END =======================

export const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

export const awaitStateChange = (
  getState,
  condition,
  timeoutMs,
  pollIntervalMs,
) => {
  return new Promise((resolve) => {
    let intervalId = null;
    const timeoutId = setTimeout(() => {
      if (intervalId) clearInterval(intervalId);
      resolve(false);
    }, timeoutMs);

    intervalId = setInterval(() => {
      const globalState = getState();
      if (globalState && condition(globalState)) {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        resolve(true);
      }
    }, pollIntervalMs);
  });
};

export const awaitWalkConfirmation = (
  workerState,
  config,
  posCounterBeforeMove,
  pathCounterBeforeMove,
  timeoutMs,
) => {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      clearInterval(intervalId);
      reject(new Error(`awaitWalkConfirmation timed out after ${timeoutMs}ms`));
    }, timeoutMs);

    const intervalId = setInterval(() => {
      const posChanged =
        workerState.playerPosArray &&
        Atomics.load(
          workerState.playerPosArray,
          PLAYER_POS_UPDATE_COUNTER_INDEX,
        ) > posCounterBeforeMove;

      const pathChanged =
        workerState.pathDataArray &&
        Atomics.load(workerState.pathDataArray, PATH_UPDATE_COUNTER_INDEX) >
          pathCounterBeforeMove;

      if (posChanged || pathChanged) {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        resolve(true);
      }
    }, config.stateChangePollIntervalMs);
  });
};

export const awaitZLevelChange = (workerState, config, initialZ, timeoutMs) => {
  return new Promise((resolve) => {
    const startTime = Date.now();
    const intervalId = setInterval(() => {
      const currentZ = Atomics.load(workerState.playerPosArray, PLAYER_Z_INDEX);
      if (currentZ !== initialZ) {
        clearInterval(intervalId);
        resolve(true);
      }
      if (Date.now() - startTime > timeoutMs) {
        clearInterval(intervalId);
        resolve(false);
      }
    }, config.stateChangePollIntervalMs);
  });
};

export const awaitStandConfirmation = (
  workerState,
  config,
  initialPos,
  timeoutMs,
) => {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    const intervalId = setInterval(() => {
      const finalPos = {
        x: Atomics.load(workerState.playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(workerState.playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(workerState.playerPosArray, PLAYER_Z_INDEX),
      };

      const zChanged = finalPos.z !== initialPos.z;
      const teleported =
        getDistance(initialPos, finalPos) >= config.teleportDistanceThreshold;

      if (zChanged || teleported) {
        clearInterval(intervalId);
        // A small delay to ensure state propagates
        setTimeout(() => resolve({ success: true, finalPos }), 10);
      }

      if (Date.now() - startTime > timeoutMs) {
        clearInterval(intervalId);
        reject(
          new Error(`awaitStandConfirmation timed out after ${timeoutMs}ms`),
        );
      }
    }, config.stateChangePollIntervalMs);
  });
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/communication.js
//start file
// /workers/cavebot/helpers/communication.js

import { parentPort } from 'worker_threads';
import { findCurrentWaypoint } from './navigation.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_WAYPOINTS_START_INDEX,
  PATH_WAYPOINT_SIZE,
  PATH_CHEBYSHEV_DISTANCE_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
  MAX_PATH_WAYPOINTS,
  PATH_START_X_INDEX,
  PATH_START_Y_INDEX,
  PATH_START_Z_INDEX,
  PATH_TARGET_X_INDEX,
  PATH_TARGET_Y_INDEX,
  PATH_TARGET_Z_INDEX,
  PATH_WPT_ID_INDEX,
  PATH_INSTANCE_ID_INDEX,
} from '../../sharedConstants.js';

export const postStoreUpdate = (type, payload) =>
  parentPort.postMessage({ storeUpdate: true, type, payload });

export const postGlobalVarUpdate = (key, value) => {
  parentPort.postMessage({
    type: 'lua_global_update',
    payload: { key, value },
  });
};

export const getFreshState = () =>
  new Promise((res) => {
    const onSnap = (msg) => {
      if (msg.type === 'state_snapshot') {
        parentPort.off('message', onSnap);
        res(msg.payload);
      }
    };
    parentPort.on('message', onSnap);
    parentPort.postMessage({ type: 'request_state_snapshot' });
  });

export const updateSABData = (workerState, config) => {
  // Restore original player position reading logic for state consistency
  if (workerState.playerPosArray) {
    const newPlayerPosCounter = Atomics.load(
      workerState.playerPosArray,
      PLAYER_POS_UPDATE_COUNTER_INDEX,
    );
    if (newPlayerPosCounter > workerState.lastPlayerPosCounter) {
      const lastPos = workerState.playerMinimapPosition;
      const newPos = {
        x: Atomics.load(workerState.playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(workerState.playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(workerState.playerPosArray, PLAYER_Z_INDEX),
      };

      // --- Teleport & Floor Change Detection ---
      if (lastPos) {
        const dist = Math.max(Math.abs(newPos.x - lastPos.x), Math.abs(newPos.y - lastPos.y));
        if (newPos.z !== lastPos.z) {
          workerState.logger('info', `[Cavebot] Floor change detected (${lastPos.z} -> ${newPos.z}). Applying grace period.`);
          workerState.floorChangeGraceUntil = Date.now() + config.postTeleportGraceMs;
        } else if (dist >= config.teleportDistanceThreshold) {
          workerState.logger('info', `[Cavebot] Teleport detected (distance: ${dist}). Applying grace period.`);
          workerState.floorChangeGraceUntil = Date.now() + config.postTeleportGraceMs;
        }
      }

      workerState.playerMinimapPosition = newPos;
      workerState.lastPlayerPosCounter = newPlayerPosCounter;
    }
  }

  if (workerState.pathDataArray) {
    if (workerState.shouldRequestNewPath) {
      workerState.path = [];
      workerState.pathfindingStatus = PATH_STATUS_IDLE;
      workerState.lastPathDataCounter = -1;
      workerState.shouldRequestNewPath = false;
      return;
    }

    const counterBeforeRead = Atomics.load(
      workerState.pathDataArray,
      PATH_UPDATE_COUNTER_INDEX,
    );
    // The stale path validation MUST run every tick, so we only check the counter
    // to see if we need to read the path array again. The validation against player
    // position happens below, regardless.
    if (counterBeforeRead !== workerState.lastPathDataCounter) {
      // Perform a direct, consistent read of all path data
      const pathStartX = Atomics.load(
        workerState.pathDataArray,
        PATH_START_X_INDEX,
      );
      const pathStartY = Atomics.load(
        workerState.pathDataArray,
        PATH_START_Y_INDEX,
      );
      const pathStartZ = Atomics.load(
        workerState.pathDataArray,
        PATH_START_Z_INDEX,
      );
      const tempPathfindingStatus = Atomics.load(
        workerState.pathDataArray,
        PATHFINDING_STATUS_INDEX,
      );
      const tempPathChebyshevDistance = Atomics.load(
        workerState.pathDataArray,
        PATH_CHEBYSHEV_DISTANCE_INDEX,
      );
      const pathLength = Atomics.load(
        workerState.pathDataArray,
        PATH_LENGTH_INDEX,
      );
      const tempPath = [];
      const safePathLength = Math.min(pathLength, MAX_PATH_WAYPOINTS);
      for (let i = 0; i < safePathLength; i++) {
        const offset = PATH_WAYPOINTS_START_INDEX + i * PATH_WAYPOINT_SIZE;
        tempPath.push({
          x: Atomics.load(workerState.pathDataArray, offset + 0),
          y: Atomics.load(workerState.pathDataArray, offset + 1),
          z: Atomics.load(workerState.pathDataArray, offset + 2),
        });
      }

      const counterAfterRead = Atomics.load(
        workerState.pathDataArray,
        PATH_UPDATE_COUNTER_INDEX,
      );

      if (counterBeforeRead === counterAfterRead) {
        // Cache the read values
        workerState.cachedPath = tempPath;
        workerState.cachedPathStart = {
          x: pathStartX,
          y: pathStartY,
          z: pathStartZ,
        };
        workerState.cachedPathTarget = {
          x: Atomics.load(workerState.pathDataArray, PATH_TARGET_X_INDEX),
          y: Atomics.load(workerState.pathDataArray, PATH_TARGET_Y_INDEX),
          z: Atomics.load(workerState.pathDataArray, PATH_TARGET_Z_INDEX),
        };
        workerState.cachedPathStatus = tempPathfindingStatus;
        workerState.cachedPathChebyshevDistance = tempPathChebyshevDistance;
        workerState.pathWptId = Atomics.load(
          workerState.pathDataArray,
          PATH_WPT_ID_INDEX,
        );
        workerState.pathInstanceId = Atomics.load(
          workerState.pathDataArray,
          PATH_INSTANCE_ID_INDEX,
        );
        workerState.lastPathDataCounter = counterAfterRead;
      }
    }

    // Always perform stale path validation against the latest cached path data
    if (workerState.cachedPathStart) {
      const currentWaypoint = workerState.globalState.cavebot
        ? findCurrentWaypoint(workerState.globalState)
        : null;

      const isPathStale =
        !workerState.playerMinimapPosition ||
        !currentWaypoint ||
        // Check 1: Path must start from our current position
        workerState.cachedPathStart.x !== workerState.playerMinimapPosition.x ||
        workerState.cachedPathStart.y !== workerState.playerMinimapPosition.y ||
        workerState.cachedPathStart.z !== workerState.playerMinimapPosition.z;

      // Invalidate the path only if it's stale AND we are outside the grace period.
      if (isPathStale && Date.now() > workerState.floorChangeGraceUntil) {
        workerState.path = []; // Invalidate path
        workerState.pathfindingStatus = PATH_STATUS_IDLE;
      } else {
        workerState.path = workerState.cachedPath;
        workerState.pathfindingStatus = workerState.cachedPathStatus;
        workerState.pathChebyshevDistance =
          workerState.cachedPathChebyshevDistance;
      }
    }
  }
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/navigation.js
//start file
// /workers/cavebot/helpers/navigation.js

import { postStoreUpdate } from './communication.js';
import { awaitStateChange } from './asyncUtils.js';
import { PATH_STATUS_IDLE } from '../../sharedConstants.js';

/**
 * Finds the current waypoint object from the global state.
 * This function is now a pure "getter" and does not modify state.
 * @param {object} globalState - The full global state object.
 * @returns {object|null} The current waypoint object or null if not found.
 */
export function findCurrentWaypoint(globalState) {
  if (!globalState?.cavebot) return null;
  const { waypointSections, currentSection, wptId } = globalState.cavebot;
  return waypointSections[currentSection]?.waypoints.find(
    (wp) => wp.id === wptId,
  );
}

/**
 * Finds the first valid waypoint in the script, used as a fallback.
 * @param {object} globalState - The full global state object.
 * @returns {object|null} The first valid waypoint or null.
 */
export function findFirstValidWaypoint(globalState) {
  if (!globalState?.cavebot) return null;
  const { waypointSections } = globalState.cavebot;
  const firstSectionWithWaypoints = Object.keys(waypointSections).find(
    (id) => waypointSections[id]?.waypoints?.length > 0,
  );
  if (firstSectionWithWaypoints) {
    const firstWaypoint =
      waypointSections[firstSectionWithWaypoints].waypoints[0];
    if (firstWaypoint) {
      return {
        waypoint: firstWaypoint,
        sectionId: firstSectionWithWaypoints,
      };
    }
  }
  return null;
}

export async function advanceToNextWaypoint(
  workerState,
  config,
  options = {},
) {
  const { skipCurrent = false } = options;
  workerState.scriptErrorWaypointId = null;
  workerState.scriptErrorCount = 0;

  const globalState = workerState.globalState;
  if (!globalState?.cavebot) return false;

  const {
    waypointSections,
    currentSection,
    wptId: oldWptId,
    unreachableWaypointIds = [],
  } = globalState.cavebot;
  const waypoints = waypointSections[currentSection]?.waypoints || [];
  if (waypoints.length === 0) return false;

  if (skipCurrent) {
    postStoreUpdate('cavebot/addUnreachableWaypointId', oldWptId);
  }

  const currentIndex = waypoints.findIndex((wp) => wp.id === oldWptId);
  if (currentIndex === -1) return false;

  // Find the next waypoint that is not marked as unreachable
  let nextWpt = null;
  let searchIndex = currentIndex;
  const updatedUnreachableIds = skipCurrent
    ? [...unreachableWaypointIds, oldWptId]
    : unreachableWaypointIds;

  for (let i = 1; i <= waypoints.length; i++) {
    const potentialIndex = (currentIndex + i) % waypoints.length;
    const candidateWpt = waypoints[potentialIndex];
    if (!updatedUnreachableIds.includes(candidateWpt.id)) {
      nextWpt = candidateWpt;
      break;
    }
  }

  if (nextWpt) {
    postStoreUpdate('cavebot/setwptId', nextWpt.id);
    const confirmed = await awaitStateChange(
      () => workerState.globalState,
      (state) => state?.cavebot?.wptId === nextWpt.id,
      config.defaultAwaitStateChangeTimeoutMs,
      config.stateChangePollIntervalMs,
    );
    if (confirmed) {
      workerState.lastProcessedWptId = nextWpt.id;
    }
    return confirmed;
  }
  return false;
}

export const goToLabel = async (label, globalState) => {
  const { waypointSections, currentSection } = globalState.cavebot;
  const targetWaypoint = waypointSections[currentSection].waypoints.find(
    (wpt) => wpt.label === label,
  );
  if (targetWaypoint) {
    postStoreUpdate('cavebot/setwptId', targetWaypoint.id);
  }
};

export const goToSection = async (sectionName, workerState, config) => {
  const { waypointSections } = workerState.globalState.cavebot;
  const foundEntry = Object.entries(waypointSections).find(
    ([, section]) => section.name === sectionName,
  );
  if (foundEntry) {
    const [targetSectionId, targetSection] = foundEntry;
    if (targetSection.waypoints?.length > 0) {
      const firstWpt = targetSection.waypoints[0];
      postStoreUpdate('cavebot/setCurrentWaypointSection', targetSectionId);
      postStoreUpdate('cavebot/setwptId', firstWpt.id);
    } else {
      await advanceToNextWaypoint(workerState, config);
    }
  } else {
    await advanceToNextWaypoint(workerState, config);
  }
};

export const goToWpt = async (index, globalState) => {
  const userIndex = parseInt(index, 10);
  if (isNaN(userIndex) || userIndex < 1) return;
  const arrayIndex = userIndex - 1;
  const { waypointSections, currentSection } = globalState.cavebot;
  const waypoints = waypointSections[currentSection]?.waypoints || [];
  if (arrayIndex < waypoints.length) {
    postStoreUpdate('cavebot/setwptId', waypoints[arrayIndex].id);
  }
};

export const resetInternalState = (workerState, fsm) => {
  if (workerState.fsmState !== 'IDLE') {
    workerState.fsmState = 'IDLE';
    fsm.IDLE.enter();
  }
  // Clear live path data
  workerState.path = [];
  workerState.pathfindingStatus = PATH_STATUS_IDLE;

  // Crucially, also clear cached path data to force a fresh read
  workerState.cachedPath = [];
  workerState.cachedPathStart = null;
  workerState.cachedPathStatus = PATH_STATUS_IDLE;

  // Request a new path from the pathfinder
  workerState.shouldRequestNewPath = true;
  workerState.lastPathDataCounter = -1;
  workerState.lastFsmState = null;
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/helpers/objectUtils.js
//start file
const isObject = (item) => {
  return item && typeof item === 'object' && !Array.isArray(item);
};

export const deepMerge = (target, ...sources) => {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} });
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }

  return deepMerge(target, ...sources);
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebot/index.js
//start file
// /workers/cavebot/index.js

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import { CavebotLuaExecutor } from '../cavebotLuaExecutor.js';
import { createLogger } from '../../utils/logger.js';
import { config } from './config.js'; // Still need config for other values
import { createFsm } from './fsm.js';
import { delay } from './helpers/asyncUtils.js';
import { SABStateManager } from '../sabStateManager.js';
import Pathfinder from 'pathfinder-native';
import {
  postStoreUpdate,
  postGlobalVarUpdate,
  getFreshState,
  updateSABData,
} from './helpers/communication.js';
import {
  findCurrentWaypoint,
  findFirstValidWaypoint,
  advanceToNextWaypoint,
  resetInternalState,
  goToLabel,
  goToSection,
  goToWpt,
} from './helpers/navigation.js';
import { deepMerge } from './helpers/objectUtils.js';

// --- Worker State Management ---
const workerState = {
  globalState: null,
  isShuttingDown: false,
  isInitialized: false,
  fsmState: 'IDLE',
  lastFsmState: null,
  lastControlState: 'CAVEBOT',
  lastPlayerPosCounter: -1,
  lastPathDataCounter: -1,
  playerMinimapPosition: null,
  path: [],
  pathChebyshevDistance: null,
  pathfindingStatus: 0,
  cachedPath: [],
  cachedPathStart: null,
  cachedPathTarget: null,
  cachedPathStatus: 0,
  cachedPathChebyshevDistance: null,
  playerPosArray: null,
  pathDataArray: null,
  luaExecutor: null,
  floorChangeGraceUntil: 0,
  lastProcessedWptId: null,
  shouldRequestNewPath: false,
  scriptErrorWaypointId: null,
  scriptErrorCount: 0,
  pathfinderInstance: null,
  creatureMonitorSyncTimeout: 0,
  logger: createLogger({ info: true, error: true, debug: true }),
  parentPort: parentPort,
};

// --- Initialization ---
const fsm = createFsm(workerState, config);
if (workerData.playerPosSAB) {
  workerState.playerPosArray = new Int32Array(workerData.playerPosSAB);
}
if (workerData.pathDataSAB) {
  workerState.pathDataArray = new Int32Array(workerData.pathDataSAB);
}

// Initialize SAB state manager
workerState.sabStateManager = new SABStateManager({
  playerPosSAB: workerData.playerPosSAB,
  battleListSAB: workerData.battleListSAB,
  creaturesSAB: workerData.creaturesSAB,
  lootingSAB: workerData.lootingSAB,
  targetingListSAB: workerData.targetingListSAB,
  targetSAB: workerData.targetSAB,
  pathDataSAB: workerData.pathDataSAB,
});

// --- Main Loop & Orchestration ---

function handleControlHandover() {
  const { waypointIdAtTargetingStart, visitedTiles } =
    workerState.globalState.cavebot;
  let skippedWaypoint = false;

  // Always clear path when gaining control
  workerState.path = [];
  workerState.pathfindingStatus = 0;
  workerState.lastPathDataCounter = -1;
  workerState.shouldRequestNewPath = true;

  workerState.logger(
    'info',
    '[Cavebot] Gained control, cleared path and requesting new pathfinding',
  );

  const currentWaypoint = findCurrentWaypoint(workerState.globalState);
  const allWaypoints = Object.values(
    workerState.globalState.cavebot.waypointSections || {},
  ).flatMap((section) => section.waypoints || []);
  const waypointIndex = allWaypoints.findIndex(
    (wpt) => wpt.id === currentWaypoint?.id,
  );
  workerState.logger(
    'debug',
    `[Cavebot] Control handover at waypoint index: ${
      waypointIndex > -1 ? waypointIndex + 1 : 'N/A'
    }`,
  );

  if (waypointIdAtTargetingStart && visitedTiles && visitedTiles.length > 0) {
    const currentWaypoint = findCurrentWaypoint(workerState.globalState);
    if (
      currentWaypoint &&
      currentWaypoint.id === waypointIdAtTargetingStart &&
      currentWaypoint.type === 'Node'
    ) {
      // Get nodeRange from Redux store
      const radius = workerState.globalState.cavebot.nodeRange;
      const wasVisited = visitedTiles.some(
        (tile) =>
          tile.z === currentWaypoint.z &&
          Math.max(
            Math.abs(tile.x - currentWaypoint.x),
            Math.abs(tile.y - currentWaypoint.y),
          ) <= radius,
      );

      if (wasVisited) {
        workerState.logger(
          'info',
          `[Cavebot] Node waypoint ${currentWaypoint.id} was visited during targeting. Skipping.`,
        );
        advanceToNextWaypoint(workerState, config);
        skippedWaypoint = true;
      }
    }
  }

  postStoreUpdate('cavebot/clearVisitedTiles');
}

async function performOperation() {
  const { globalState, isInitialized } = workerState;
  if (!globalState || !isInitialized || !globalState.global?.windowId) {
    return;
  }

  if (!globalState.cavebot) {
    workerState.logger(
      'debug',
      '[Cavebot] cavebot state not present, skipping tick.',
    );
    return;
  }
  // workerState.logger('debug', '[Cavebot] --- Tick ---');

  if (!globalState.regionCoordinates?.regions?.onlineMarker) {
    if (
      workerState.fsmState === 'SCRIPT' &&
      workerState.luaExecutor.isExecuting()
    ) {
      const scriptContent = workerState.luaExecutor.getCurrentScriptContent();
      if (scriptContent && !scriptContent.includes('login(')) {
        workerState.logger(
          'warn',
          '[Cavebot] Player is offline. Terminating non-login script.',
        );
        workerState.luaExecutor.forceStop();
        resetInternalState(workerState, fsm);
      }
    } else if (workerState.fsmState !== 'IDLE') {
      workerState.logger(
        'info',
        '[Cavebot] Player is offline. Resetting cavebot state.',
      );
      resetInternalState(workerState, fsm);
    }
    return;
  }

  if (
    !globalState.regionCoordinates ||
    !globalState.regionCoordinates.regions.gameWorld
  ) {
    workerState.logger(
      'debug',
      '[Cavebot] Game world not visible, skipping tick.',
    );
    if (
      workerState.fsmState === 'SCRIPT' &&
      workerState.luaExecutor.isExecuting()
    ) {
      const scriptContent = workerState.luaExecutor.getCurrentScriptContent();
      if (scriptContent && !scriptContent.includes('login(')) {
        workerState.logger(
          'warn',
          '[Cavebot] Game world not visible. Terminating non-login script.',
        );
        workerState.luaExecutor.forceStop();
        resetInternalState(workerState, fsm);
      }
    }
    return;
  }

  const {
    enabled: cavebotIsEnabled,
    controlState,
    isPausedByScript,
    waypointSections = {},
  } = globalState.cavebot;
  const waypoints = Object.values(waypointSections).flatMap(
    (section) => section.waypoints || [],
  );

  if (isPausedByScript) {
    workerState.logger('debug', '[Cavebot] Paused by script, skipping tick.');
    if (workerState.fsmState !== 'IDLE') resetInternalState(workerState, fsm);
    return;
  }

  if (workerState.sabStateManager.isLootingRequired()) {
    workerState.logger('debug', '[Cavebot] Looting required, skipping tick.');
    if (workerState.fsmState !== 'IDLE') resetInternalState(workerState, fsm);
    return; // Do not perform any cavebot operations if looting is required
  }

  if (!cavebotIsEnabled) {
    // workerState.logger('debug', '[Cavebot] Disabled, skipping tick.');
    if (workerState.fsmState !== 'IDLE') resetInternalState(workerState, fsm);
    return;
  }

  if (workerState.fsmState === 'WAITING_FOR_CREATURE_MONITOR_SYNC') {
    if (controlState !== 'CAVEBOT' && workerState.lastControlState === 'CAVEBOT') {
      workerState.logger(
        'info',
        `[Cavebot] Control lost during CreatureMonitor sync. Current state: ${controlState}. Will not reset FSM.`,
      );
    }
    workerState.lastControlState = controlState;
  } else if (controlState !== 'CAVEBOT') {
    if (workerState.lastControlState === 'CAVEBOT') {
      workerState.logger(
        'info',
        `[Cavebot] Control lost. Current state: ${controlState}. Resetting FSM.`,
      );
      resetInternalState(workerState, fsm); // Reset state when losing control
    }
    workerState.lastControlState = controlState;
    return;
  }

  if (workerState.lastControlState !== 'CAVEBOT') {
    workerState.logger(
      'info',
      '[Cavebot] Control gained. Handling handover.',
    );
    handleControlHandover();
    await delay(config.controlHandoverGraceMs);
  }

  updateSABData(workerState, config);


  if (!workerState.playerMinimapPosition) {
    workerState.logger(
      'debug',
      '[Cavebot] No player position yet, skipping tick.',
    );
    return;
  }

  let targetWaypoint = findCurrentWaypoint(globalState);
  if (!targetWaypoint) {
    const fallback = findFirstValidWaypoint(globalState);
    if (fallback) {
      const waypointIndex = waypoints.findIndex(
        (wpt) => wpt.id === fallback.waypoint.id,
      );
      workerState.logger(
        'warn',
        `Current waypoint not found, resetting to first valid waypoint at index ${
          waypointIndex + 1
        }.`,
      );
      postStoreUpdate('cavebot/setCurrentWaypointSection', fallback.sectionId);
      postStoreUpdate('cavebot/setwptId', fallback.waypoint.id);
    }
    if (workerState.fsmState !== 'IDLE') resetInternalState(workerState, fsm);
    return;
  }

  if (
    workerState.lastProcessedWptId &&
    targetWaypoint.id !== workerState.lastProcessedWptId
  ) {
    const fromIndex = waypoints.findIndex(
      (wpt) => wpt.id === workerState.lastProcessedWptId,
    );
    const toIndex = waypoints.findIndex((wpt) => wpt.id === targetWaypoint.id);
    workerState.logger(
      'info',
      `[Cavebot] Waypoint changed from index ${fromIndex + 1} to ${
        toIndex + 1
      }. Resetting FSM. PlayerPos: ${JSON.stringify(workerState.playerMinimapPosition)}. TargetWptId: ${targetWaypoint.id}. PathWptId: ${workerState.pathWptId}.`,
    );
    resetInternalState(workerState, fsm);
    // Manually reset pathfinding state on any waypoint change to prevent using stale data.
    // This is critical when a waypoint is skipped, as the pathfinder might still be processing
    // the old, now-irrelevant waypoint.
    workerState.path = [];
    workerState.pathfindingStatus = 0; // Assumes 0 is a neutral/idle state
    workerState.lastPathDataCounter = -1; // Force waiting for a new path
    workerState.shouldRequestNewPath = true; // Ensure we actively wait for a new path
  }
  workerState.lastProcessedWptId = targetWaypoint.id;

  // --- Z-level Mismatch Logic Change ---
  if (
    targetWaypoint.z !== workerState.playerMinimapPosition.z &&
    targetWaypoint.type !== 'Script' // Scripts are now exempt from this check
  ) {
    const waypointIndex = waypoints.findIndex(
      (wpt) => wpt.id === targetWaypoint.id,
    );
    workerState.logger(
      'debug',
      `Skipping waypoint index ${
        waypointIndex + 1
      } due to Z-level mismatch. Player Z: ${
        workerState.playerMinimapPosition.z
      }, Waypoint Z: ${targetWaypoint.z}, Status: ${
        workerState.pathfindingStatus
      }. PlayerPos: ${JSON.stringify(workerState.playerMinimapPosition)}. TargetWptId: ${targetWaypoint.id}. PathWptId: ${workerState.pathWptId}.`,
    );
    await advanceToNextWaypoint(workerState, config);
    return;
  }

  const context = {
    playerPos: workerState.playerMinimapPosition,
    targetWaypoint: targetWaypoint,
    status: workerState.pathfindingStatus,
    chebyshevDist: workerState.pathChebyshevDistance,
  };

  const stateLogic = fsm[workerState.fsmState];
  if (stateLogic) {
    const nextState = await stateLogic.execute(context);
    if (nextState && nextState !== workerState.fsmState) {
      const waypointIndex = waypoints.findIndex(
        (wpt) => wpt.id === targetWaypoint.id,
      );
      workerState.logger(
        'debug',
        `[FSM] State transition: ${workerState.fsmState} -> ${nextState} for waypoint index ${waypointIndex + 1}`,
      );
      workerState.lastFsmState = workerState.fsmState;
      workerState.fsmState = nextState;
      const newStateLogic = fsm[workerState.fsmState];
      if (newStateLogic && newStateLogic.enter) {
        newStateLogic.enter(context);
      }
    }
  } else {
    workerState.logger(
      'error',
      `Invalid FSM state: ${workerState.fsmState}. Resetting to IDLE.`,
    );
    workerState.fsmState = 'IDLE';
  }

  workerState.lastControlState = globalState.cavebot.controlState;
}

async function mainLoop() {
  workerState.logger('info', '[CavebotWorker] Starting main loop...');
  while (!workerState.isShuttingDown) {
    const loopStart = performance.now();

    try {
      await performOperation();
    } catch (error) {
      workerState.logger(
        'error',
        '[CavebotWorker] Unhandled error in main loop:',
        error,
      );
      workerState.fsmState = 'IDLE';
      // --- Error Resilience Change ---
      await delay(config.mainLoopErrorDelayMs);
    }
    const loopEnd = performance.now();
    const elapsedTime = loopEnd - loopStart;
    const delayTime = Math.max(0, config.mainLoopIntervalMs - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  workerState.logger('info', '[CavebotWorker] Main loop stopped.');
}

// --- Worker Lifecycle ---

async function initializePathfinder() {
  workerState.logger('info', 'Initializing Pathfinder instance...');
  try {
    workerState.pathfinderInstance = new Pathfinder.Pathfinder();
    const fs = await import('fs/promises');
    const path = await import('path');
    const mapDataForAddon = {};
    const baseDir = workerData.paths.minimapResources;

    if (!baseDir) {
      throw new Error('minimapResources path not provided');
    }

    const zLevelDirs = (await fs.readdir(baseDir, { withFileTypes: true }))
      .filter((d) => d.isDirectory() && d.name.startsWith('z'))
      .map((d) => d.name);

    for (const zDir of zLevelDirs) {
      const zLevel = parseInt(zDir.substring(1), 10);
      const zLevelPath = path.join(baseDir, zDir);
      try {
        const metadata = JSON.parse(
          await fs.readFile(path.join(zLevelPath, 'walkable.json'), 'utf8'),
        );
        const grid = await fs.readFile(path.join(zLevelPath, 'walkable.bin'));
        mapDataForAddon[zLevel] = { ...metadata, grid };
      } catch (e) {
        if (e.code !== 'ENOENT')
          workerState.logger(
            'error',
            `Could not load path data for Z=${zLevel}: ${e.message}`,
          );
      }
    }

    workerState.pathfinderInstance.loadMapData(mapDataForAddon);
    if (workerState.pathfinderInstance.isLoaded) {
      workerState.logger(
        'info',
        'Pathfinder instance loaded map data successfully.',
      );
    } else {
      throw new Error('Pathfinder failed to load map data.');
    }
  } catch (err) {
    workerState.logger(
      'error',
      'Could not initialize Pathfinder instance:',
      err,
    );
    workerState.pathfinderInstance = null;
  }
}

async function initializeWorker() {
  workerState.logger('info', 'Cavebot worker starting up...');

  // Initialize pathfinder first
  await initializePathfinder();

  try {
    workerState.luaExecutor = new CavebotLuaExecutor({
      logger: workerState.logger,
      postStoreUpdate,
      getState: () => workerState.globalState,
      getFreshState,
      advanceToNextWaypoint: () => advanceToNextWaypoint(workerState, config),
      goToLabel: (label) => goToLabel(label, workerState.globalState),
      goToSection: (sectionName) =>
        goToSection(sectionName, workerState, config),
      goToWpt: (index) => goToWpt(index, workerState.globalState),
      sharedLuaGlobals: workerData.sharedLuaGlobals,
      postGlobalVarUpdate,
      pathfinderInstance: workerState.pathfinderInstance,
    });
    if (!(await workerState.luaExecutor.initialize()))
      throw new Error('LuaExecutor failed to initialize.');
    workerState.logger(
      'info',
      'Cavebot Lua Executor initialized successfully.',
    );
  } catch (e) {
    workerState.logger(
      'error',
      `Could not initialize Cavebot Lua Executor: ${e.message}`,
    );
    workerState.luaExecutor = null;
  }
  workerState.isInitialized = true;
  workerState.logger('info', 'Cavebot worker initialization complete.');
}

parentPort.on('message', (message) => {
  try {
    if (message.type === 'state_full_sync') {
      workerState.globalState = message.payload;
    } else if (message.type === 'state_diff') {
      if (workerState.globalState && message.payload) {
        deepMerge(workerState.globalState, message.payload);
      }
    } else if (message.type === 'shutdown') {
      workerState.isShuttingDown = true;
      if (workerState.luaExecutor) workerState.luaExecutor.destroy();
      // NOTE: The pathfinder native instance does not have a destroy method.
      // It will be garbage collected automatically when the worker terminates.
    } else if (message.type === 'lua_global_broadcast') {
      const { key, value } = message.payload;
      if (workerData.sharedLuaGlobals) {
        workerData.sharedLuaGlobals[key] = value;
      }
    } else if (typeof message === 'object' && !message.type) {
      workerState.globalState = message;
      if (!workerState.isInitialized) {
        initializeWorker().catch((error) => {
          workerState.logger(
            'error',
            '[CavebotWorker] Failed to initialize worker:',
            error,
          );
          process.exit(1);
        });
      }
    }
  } catch (error) {
    workerState.logger(
      'error',
      '[CavebotWorker] Error handling message:',
      error,
    );
  }
});

function startWorker() {
  if (!workerData) throw new Error('[CavebotWorker] Worker data not provided');
  mainLoop().catch((error) => {
    workerState.logger(
      'error',
      '[CavebotWorker] Fatal error in main loop:',
      error,
    );
    process.exit(1);
  });
}

startWorker();

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/cavebotLuaExecutor.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/cavebotLuaExecutor.js

import { LuaFactory } from 'wasmoon';
import { parentPort } from 'worker_threads';
import { performance } from 'perf_hooks';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createLuaApi, createStateShortcutObject } from './luaApi.js';
import { preprocessLuaScript } from './luaScriptProcessor.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class CavebotLuaExecutor {
  constructor(context) {
    this.lua = null;
    this.logger = context.logger;
    this.context = context;
    this.isInitialized = false;
    this.isShuttingDown = false;
    this.executionCount = 0;
    this.totalExecutionTime = 0;
    this.lastPerfReport = Date.now();
    this.asyncFunctionNames = [];
    this.navigationOccurred = false;
    this.consecutiveErrors = 0;
    this.maxConsecutiveErrors = 5000000;
    this.reusableResult = {
      success: false,
      error: null,
      navigationOccurred: false,
    };
    this.logger(
      'info',
      '[CavebotLuaExecutor] Instance created with performance monitoring.',
    );
  }

  // ======================= FIX START: COMPLETE REFACTOR OF INITIALIZATION AND SYNC =======================

  async _loadLuaLibraries() {
    if (!this.lua) return;
    const libPath = path.join(__dirname, 'lua', 'lib');
    try {
      const files = await fs.readdir(libPath);
      for (const file of files) {
        if (path.extname(file) === '.lua') {
          const filePath = path.join(libPath, file);
          const content = await fs.readFile(filePath, 'utf8');
          await this.lua.doString(content);
          this.logger('info', `[CavebotLuaExecutor] Loaded Lua library: ${file}`);
        }
      }
    } catch (error) {
      if (error.code !== 'ENOENT') {
        this.logger('error', `[CavebotLuaExecutor] Error loading Lua libraries:`, error);
      } else {
        this.logger('info', `[CavebotLuaExecutor] No Lua libraries found to load.`);
      }
    }
  }

  async initialize() {
    if (this.isShuttingDown) return false;
    this.logger(
      'info',
      '[CavebotLuaExecutor] Initializing Lua VM and full API...',
    );

    try {
      const initStart = performance.now();
      const factory = new LuaFactory();
      this.lua = await factory.createEngine();
      await this._loadLuaLibraries();

      // Create the full API, including the SharedGlobals proxy, ONCE.
      const { api, asyncFunctionNames: newNames } = await createLuaApi({
        type: 'cavebot',
        ...this.context,
        postSystemMessage: (message) => {
          if (!this.isShuttingDown) parentPort.postMessage(message);
        },
        refreshLuaGlobalState: () => this._syncDynamicStateToLua(), // This now calls the lightweight sync
        sharedLuaGlobals: this.context.sharedLuaGlobals,
        lua: this.lua,
        postInputAction: (action) => parentPort.postMessage({ type: 'inputAction', payload: action }),
      });

      this.asyncFunctionNames = newNames;

      // Wrap navigation functions to track events
      const wrappedApi = { ...api };
      const navFuncs = ['skipWaypoint', 'goToLabel', 'goToSection', 'goToWpt'];
      navFuncs.forEach((funcName) => {
        if (api[funcName]) {
          wrappedApi[funcName] = (...args) => {
            this.navigationOccurred = true;
            return api[funcName](...args);
          };
        }
      });

      // Set all functions and the SharedGlobals proxy in the Lua environment
      const globals = this.lua.global;
      for (const funcName in wrappedApi) {
        globals.set(funcName, wrappedApi[funcName]);
      }

      // Perform the first sync of dynamic state (__BOT_STATE__)
      await this._syncDynamicStateToLua();

      const initTime = performance.now() - initStart;
      this.logger(
        'info',
        `[CavebotLuaExecutor] Lua VM and API initialized successfully in ${initTime.toFixed(2)}ms.`,
      );

      this.isInitialized = true;
      this.consecutiveErrors = 0;
      return true;
    } catch (error) {
      this.logger(
        'error',
        '[CavebotLuaExecutor] Failed to initialize Lua VM:',
        error,
      );
      this.isInitialized = false;
      return false;
    }
  }

  // This is the new lightweight function that runs before each script execution.
  // It ONLY updates the __BOT_STATE__ object with fresh, per-tick data.
  async _syncDynamicStateToLua() {
    if (!this.lua || this.isShuttingDown) return;

    // Get fresh state from the main thread
    await this.context.getFreshState();

    // Create and set only the dynamic state object
    const stateObject = createStateShortcutObject(
      () => this.context.getState(),
      'cavebot',
    );
    this.lua.global.set('__BOT_STATE__', stateObject);
  }

  // The old _syncApiToLua function is no longer needed and has been replaced by the logic above.

  // ======================= FIX END =======================

  _logPerformanceStats() {
    const now = Date.now();
    const timeSinceLastReport = now - this.lastPerfReport;

    if (timeSinceLastReport >= 30000) {
      const avgExecTime =
        this.executionCount > 0
          ? (this.totalExecutionTime / this.executionCount).toFixed(2)
          : 0;
      const execPerMinute = (
        (this.executionCount / timeSinceLastReport) *
        60000
      ).toFixed(1);

      this.logger(
        'info',
        `[CavebotLuaExecutor] Performance: ${execPerMinute} executions/min, avg: ${avgExecTime}ms, errors: ${this.consecutiveErrors}`,
      );

      this.executionCount = 0;
      this.totalExecutionTime = 0;
      this.lastPerfReport = now;
    }
  }

  _resetResult() {
    this.reusableResult.success = false;
    this.reusableResult.error = null;
    this.reusableResult.navigationOccurred = false;
    return this.reusableResult;
  }

  async executeScript(scriptCode) {
    if (this.isShuttingDown) {
      const result = this._resetResult();
      result.error = 'Executor is shutting down';
      return result;
    }

    if (!this.isInitialized) {
      const result = this._resetResult();
      result.error = 'Lua VM is not initialized';
      return result;
    }

    if (this.consecutiveErrors >= this.maxConsecutiveErrors) {
      this.logger(
        'error',
        `[CavebotLuaExecutor] Circuit breaker triggered: ${this.consecutiveErrors} consecutive errors. Refusing execution.`,
      );
      const result = this._resetResult();
      result.error = 'Too many consecutive errors, execution disabled';
      return result;
    }

    if (!scriptCode?.trim()) {
      const result = this._resetResult();
      result.success = true;
      return result;
    }

    const execStart = performance.now();
    this.logger('debug', '[CavebotLuaExecutor] Executing script...');
    this.navigationOccurred = false;

    try {
      // Now only syncs the dynamic state, not the whole API
      await this._syncDynamicStateToLua();

      let processedCode;
      try {
        processedCode = preprocessLuaScript(
          scriptCode,
          this.asyncFunctionNames,
        );
      } catch (preprocessError) {
        throw new Error(
          `Script preprocessing failed: ${preprocessError.message}`,
        );
      }

      await this.lua.doString(processedCode);

      // NEW: Wait for any pending async operations triggered by the script to complete
      const asyncWaitStart = performance.now();
      while (this.context.activeAsyncOperations > 0) {
        if (performance.now() - asyncWaitStart > 60000) { // 60-second timeout
          this.logger('error', `[CavebotLuaExecutor] Timeout waiting for ${this.context.activeAsyncOperations} async operations to complete.`);
          this.context.activeAsyncOperations = 0; // Reset to prevent infinite loop
          break;
        }
        await new Promise(resolve => setTimeout(resolve, 10)); // Poll every 10ms
      }

      const execTime = performance.now() - execStart;
      this.executionCount++;
      this.totalExecutionTime += execTime;

      if (execTime > 100) {
        this.logger(
          'warn',
          `[CavebotLuaExecutor] Slow script execution: ${execTime.toFixed(2)}ms`,
        );
      }

      this.consecutiveErrors = 0;
      const result = this._resetResult();
      result.success = true;
      result.navigationOccurred = this.navigationOccurred;
      this._logPerformanceStats();
      return result;
    } catch (error) {
      const execTime = performance.now() - execStart;
      this.executionCount++;
      this.totalExecutionTime += execTime;
      this.consecutiveErrors++;

      const errorMessage = error.message || String(error);
      this.logger(
        'error',
        `[CavebotLuaExecutor] Script execution failed (attempt ${this.consecutiveErrors}): ${errorMessage}`,
      );

      try {
        const currentState = this.context.getState();
        const scriptId = currentState?.cavebot?.wptId;

        if (scriptId) {
          this.context.postStoreUpdate('cavebot/addWaypointLogEntry', {
            id: scriptId,
            message: `[ERROR] ${errorMessage}`,
          });
        }
      } catch (storeError) {
        this.logger(
          'error',
          '[CavebotLuaExecutor] Failed to log error to store:',
          storeError,
        );
      }

      const result = this._resetResult();
      result.error = errorMessage;
      result.navigationOccurred = this.navigationOccurred;
      this._logPerformanceStats();
      return result;
    }
  }

  reset() {
    this.consecutiveErrors = 0;
    this.logger('info', '[CavebotLuaExecutor] Error state reset.');
  }

  getMetrics() {
    return {
      isInitialized: this.isInitialized,
      isShuttingDown: this.isShuttingDown,
      executionCount: this.executionCount,
      avgExecutionTime:
        this.executionCount > 0
          ? this.totalExecutionTime / this.executionCount
          : 0,
      consecutiveErrors: this.consecutiveErrors,
      circuitBreakerTripped:
        this.consecutiveErrors >= this.maxConsecutiveErrors,
    };
  }

  destroy() {
    this.logger('info', '[CavebotLuaExecutor] Starting graceful shutdown...');
    this.isShuttingDown = true;

    if (this.lua) {
      try {
        if (this.executionCount > 0) {
          const avgTime = (
            this.totalExecutionTime / this.executionCount
          ).toFixed(2);
          this.logger(
            'info',
            `[CavebotLuaExecutor] Final stats - Executions: ${this.executionCount}, Avg time: ${avgTime}ms`,
          );
        }

        this.lua.global.close();
        this.lua = null;
        this.isInitialized = false;

        this.logger(
          'info',
          '[CavebotLuaExecutor] Lua VM destroyed successfully.',
        );
      } catch (error) {
        this.logger(
          'error',
          '[CavebotLuaExecutor] Error during cleanup:',
          error,
        );
      }
    }

    this.context = null;
    this.asyncFunctionNames = [];
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/creatureMonitor/ocr.js
//start file
import pkg from 'font-ocr';
import regionDefinitions from '../../constants/regionDefinitions.js';

const { recognizeText } = pkg;

export const CHAR_PRESETS = {
  ALPHANUMERIC_SPACE:
    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ',
};

/**
 * Processes the player list region to extract player names.
 * @param {Buffer} buffer - The screen capture buffer.
 * @param {object} regions - The object containing all region definitions.
 * @returns {Promise<string[]>} A promise that resolves to an array of player names.
 */
export async function processPlayerList(buffer, regions) {
  const playerListRegion = regions.playerList;
  if (
    !playerListRegion ||
    !playerListRegion.x ||
    !playerListRegion.y ||
    playerListRegion.width <= 0 ||
    playerListRegion.height <= 0
  ) {
    return [];
  }

  try {
    const playerOcrColors = regionDefinitions.playerList?.ocrColors || [];
    const ocrResults =
      recognizeText(
        buffer,
        playerListRegion,
        playerOcrColors,
        CHAR_PRESETS.ALPHANUMERIC_SPACE,
      ) || [];

    return ocrResults
      .map((result) => result.text.trim())
      .filter((name) => name.length > 0);
  } catch (ocrError) {
    console.error(
      '[CreatureMonitorOCR] OCR failed for playerList entries:',
      ocrError,
    );
    return [];
  }
}

/**
 * Processes the NPC list region to extract NPC names.
 * @param {Buffer} buffer - The screen capture buffer.
 * @param {object} regions - The object containing all region definitions.
 * @returns {Promise<string[]>} A promise that resolves to an array of NPC names.
 */
export async function processNpcList(buffer, regions) {
  const npcListRegion = regions.npcList;
  if (
    !npcListRegion ||
    !npcListRegion.x ||
    !npcListRegion.y ||
    npcListRegion.width <= 0 ||
    npcListRegion.height <= 0
  ) {
    return [];
  }

  try {
    const npcOcrColors = regionDefinitions.npcList?.ocrColors || [];
    const ocrResults =
      recognizeText(
        buffer,
        npcListRegion,
        npcOcrColors,
        CHAR_PRESETS.ALPHANUMERIC_SPACE,
      ) || [];

    return ocrResults
      .map((result) => result.text.trim())
      .filter((name) => name.length > 0);
  } catch (ocrError) {
    console.error(
      '[CreatureMonitorOCR] OCR failed for npcList entries:',
      ocrError,
    );
    return [];
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/creatureMonitor.js
//start file
import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import { createLogger } from '../utils/logger.js';
import findTarget from 'find-target-native';
import findHealthBars from 'find-healthbars-native';
import findSequences from 'find-sequences-native';
import Pathfinder from 'pathfinder-native';
import pkg from 'font-ocr';
import regionDefinitions from '../constants/regionDefinitions.js';
import { calculateDistance, chebyshevDistance } from '../utils/distance.js';
import {
  getGameCoordinatesFromScreen,
  getAbsoluteGameWorldClickCoordinates,
} from '../utils/gameWorldClickTranslator.js';
import { FrameUpdateManager } from '../utils/frameUpdateManager.js';
import { SABStateManager } from './sabStateManager.js';
import { findBestNameMatch } from '../utils/nameMatcher.js';
import { processPlayerList, processNpcList } from './creatureMonitor/ocr.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_BLOCKED_BY_CREATURE,
  PATH_BLOCKING_CREATURE_X_INDEX,
  PATH_BLOCKING_CREATURE_Y_INDEX,
  PATH_BLOCKING_CREATURE_Z_INDEX,
} from './sharedConstants.js';

const logger = createLogger({ info: false, error: true, debug: false });
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const { recognizeText } = pkg;
const BATTLELIST_ALLOWED_CHARS =
  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

const frameUpdateManager = new FrameUpdateManager();
let pathfinderInstance = null;
const { sharedData, paths } = workerData;
if (!sharedData) throw new Error('[CreatureMonitor] Shared data not provided.');

const {
  imageSAB,
  playerPosSAB,
  pathDataSAB,
  battleListSAB,
  creaturesSAB,
  lootingSAB,
  targetingListSAB,
  targetSAB,
} = sharedData;

const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const pathDataArray = pathDataSAB ? new Int32Array(pathDataSAB) : null;
const sharedBufferView = Buffer.from(imageSAB);

const sabStateManager = new SABStateManager({
  playerPosSAB,
  battleListSAB,
  creaturesSAB,
  lootingSAB,
  targetingListSAB,
  targetSAB,
});

const PLAYER_ANIMATION_FREEZE_MS = 25;
const STICKY_SNAP_THRESHOLD_TILES = 0.5;
const JITTER_CONFIRMATION_TIME_MS = 75;
const CORRELATION_DISTANCE_THRESHOLD_PIXELS = 200;
const TARGET_LOSS_GRACE_PERIOD_MS = 125;
const CREATURE_FLICKER_GRACE_PERIOD_MS = 125;
const ADJACENT_DISTANCE_THRESHOLD_DIAGONAL = 1.45;
const ADJACENT_DISTANCE_THRESHOLD_STRAIGHT = 1.0;
const ADJACENT_TIME_THRESHOLD_MS = 0;

let currentState = null;
let isInitialized = false;
let isShuttingDown = false;
let lastSentCreatures = [];
let lastSentTarget = null;
let lastBattleListEntries = [];
let lastPlayerNames = [];
let lastNpcNames = [];
let nextInstanceId = 1;
let activeCreatures = new Map();
const lastPostedResults = new Map();
let previousTargetedCreatureCounts = new Map();
let previousTargetName = null;
let isLootingInProgress = false;
let previousPlayerMinimapPosition = { x: 0, y: 0, z: 0 };
let playerAnimationFreezeEndTime = 0;
let lastStablePlayerMinimapPosition = { x: 0, y: 0, z: 0 };
let targetLossGracePeriodEndTime = 0;
let lastBattleListOcrTime = 0;

function arePositionsEqual(pos1, pos2) {
  if (!pos1 || !pos2) return pos1 === pos2;
  return pos1.x === pos2.x && pos1.y === pos2.y && pos1.z === pos2.z;
}

function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

function postUpdateOnce(type, payload) {
  const key = type;
  const prevPayloadString = lastPostedResults.get(key);
  const payloadString = JSON.stringify(payload);
  if (prevPayloadString === payloadString) return;
  lastPostedResults.set(key, payloadString);
  parentPort.postMessage({ storeUpdate: true, type, payload });
}

async function processBattleListOcr(buffer, regions) {
  const entriesRegion = regions.battleList?.children?.entries;
  if (!entriesRegion) {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'battleList/setBattleListEntries',
      payload: [],
    });
    return [];
  }
  try {
    const ocrResults =
      recognizeText(
        buffer,
        entriesRegion,
        regionDefinitions.battleList?.ocrColors || [],
        BATTLELIST_ALLOWED_CHARS,
      ) || [];
    return ocrResults
      .map((result) => {
        const trimmedName = result.text.trim();
        const fixedName = trimmedName.replace(/([a-z])([A-Z])/g, '$1 $2');
        return {
          name: fixedName,
          x: result.click.x,
          y: result.click.y,
        };
      })
      .filter((creature) => creature.name.length > 0);
  } catch (ocrError) {
    logger(
      'error',
      '[CreatureMonitor] OCR failed for battleList region:',
      ocrError,
    );
    parentPort.postMessage({
      storeUpdate: true,
      type: 'battleList/setBattleListEntries',
      payload: [],
    });
    return [];
  }
}

function getCoordsKey(coords) {
  if (!coords) return '';
  return `${coords.x},${coords.y},${coords.z}`;
}

function deepCompareEntities(a, b) {
  if (a === b) return true;
  if (!a || !b) return false;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (
        a[i].instanceId !== b[i].instanceId ||
        a[i].isReachable !== b[i].isReachable ||
        a[i].isAdjacent !== b[i].isAdjacent ||
        a[i].hp !== b[i].hp ||
        a[i].distance !== b[i].distance ||
        !arePositionsEqual(a[i].gameCoords, b[i].gameCoords)
      )
        return false;
    }
    return true;
  }
  if (typeof a === 'object' && typeof b === 'object') {
    return (
      a.instanceId === b.instanceId &&
      a.name === b.name &&
      a.hp === b.hp &&
      arePositionsEqual(a.gameCoordinates, b.gameCoordinates)
    );
  }
  return false;
}

function screenDist(p1, p2) {
  if (!p1 || !p2) return Infinity;
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function updateCreatureState(
  creature,
  detection,
  currentPlayerMinimapPosition,
  regions,
  tileSize,
  now,
  isPlayerInAnimationFreeze,
) {
  const { gameWorld } = regions;
  const creatureScreenX = detection.absoluteCoords.x;
  const creatureScreenY = detection.healthBarY + 14 + tileSize.height / 2;
  const playerPosForCreatureCalc = isPlayerInAnimationFreeze
    ? lastStablePlayerMinimapPosition
    : currentPlayerMinimapPosition;
  const rawGameCoordsFloat = getGameCoordinatesFromScreen(
    creatureScreenX,
    creatureScreenY,
    playerPosForCreatureCalc,
    gameWorld,
    tileSize,
  );
  if (!rawGameCoordsFloat) return null;

  creature.rawDistance = calculateDistance(
    currentPlayerMinimapPosition,
    rawGameCoordsFloat,
  );

  let finalGameCoords;
  if (isPlayerInAnimationFreeze && creature.gameCoords) {
    finalGameCoords = creature.gameCoords;
  } else {
    let intermediateX = Math.floor(rawGameCoordsFloat.x);
    let intermediateY = Math.floor(rawGameCoordsFloat.y);
    if (creature.gameCoords) {
      const distX = Math.abs(rawGameCoordsFloat.x - creature.gameCoords.x);
      const distY = Math.abs(rawGameCoordsFloat.y - creature.gameCoords.y);
      if (
        distX < STICKY_SNAP_THRESHOLD_TILES &&
        distY < STICKY_SNAP_THRESHOLD_TILES
      ) {
        intermediateX = creature.gameCoords.x;
        intermediateY = creature.gameCoords.y;
      }
    }
    const newCoords = {
      x: intermediateX,
      y: intermediateY,
      z: currentPlayerMinimapPosition.z,
    };
    if (!creature.stableCoords) creature.stableCoords = newCoords;
    const hasChanged = !arePositionsEqual(newCoords, creature.stableCoords);
    if (creature.unconfirmedChange) {
      if (arePositionsEqual(newCoords, creature.unconfirmedChange.newCoords)) {
        if (
          now - creature.unconfirmedChange.timestamp >
          JITTER_CONFIRMATION_TIME_MS
        ) {
          creature.stableCoords = creature.unconfirmedChange.newCoords;
          creature.unconfirmedChange = null;
        }
      } else {
        creature.unconfirmedChange = { newCoords: newCoords, timestamp: now };
      }
    } else if (hasChanged) {
      creature.unconfirmedChange = { newCoords: newCoords, timestamp: now };
    }
    finalGameCoords = creature.stableCoords;
  }

  creature.absoluteCoords = {
    x: Math.round(creatureScreenX),
    y: Math.round(creatureScreenY),
    lastUpdate: now,
  };
  creature.gameCoords = {
    x: finalGameCoords.x,
    y: finalGameCoords.y,
    z: finalGameCoords.z,
  };
  creature.distance = chebyshevDistance(
    currentPlayerMinimapPosition,
    creature.gameCoords,
  );
  creature.lastSeen = now;
  if (detection.name) creature.name = detection.name;
  if (detection.hp) creature.hp = detection.hp;

  return creature;
}

async function performOperation() {
  try {
    const startTime = performance.now();

    if (
      !isInitialized ||
      !currentState?.regionCoordinates?.regions ||
      !pathfinderInstance?.isLoaded
    )
      return;
    const { regions } = currentState.regionCoordinates;
    const { gameWorld, tileSize } = regions;
    if (!gameWorld || !tileSize) return;

    const now = Date.now();
    const zLevelAtScanStart = Atomics.load(playerPosArray, PLAYER_Z_INDEX);

    let battleListEntries = lastBattleListEntries;
    let playerNames = lastPlayerNames;
    let npcNames = lastNpcNames;

    const dirtyRects = [...frameUpdateManager.accumulatedDirtyRects];
    frameUpdateManager.accumulatedDirtyRects.length = 0;

    let forceBattleListOcr = false;
    if (now - lastBattleListOcrTime > 500) {
      forceBattleListOcr = true;
    }

    if (dirtyRects.length > 0 || forceBattleListOcr) {
      if (
        regions.battleList &&
        (dirtyRects.some((r) => rectsIntersect(r, regions.battleList)) ||
          forceBattleListOcr)
      ) {
        battleListEntries = await processBattleListOcr(
          sharedBufferView,
          regions,
        );
        lastBattleListOcrTime = now;
      }
      if (
        regions.playerList &&
        dirtyRects.some((r) => rectsIntersect(r, regions.playerList))
      ) {
        playerNames = await processPlayerList(sharedBufferView, regions);
      }
      if (
        regions.npcList &&
        dirtyRects.some((r) => rectsIntersect(r, regions.npcList))
      ) {
        npcNames = await processNpcList(sharedBufferView, regions);
      }
    }

    lastBattleListEntries = battleListEntries;
    lastPlayerNames = playerNames;
    lastNpcNames = npcNames;

    const targetingList = sabStateManager.getTargetingList();
    let lootReason = '';
    const currentTargetedCreatureCounts = new Map();
    for (const targetingCreature of targetingList) {
      const count = battleListEntries.filter((entry) => {
        if (targetingCreature.name === entry.name) return true;
        if (entry.name.endsWith('...')) {
          const truncatedPart = entry.name.slice(0, -3);
          return targetingCreature.name.startsWith(truncatedPart);
        }
        return false;
      }).length;
      if (count > 0)
        currentTargetedCreatureCounts.set(targetingCreature.name, count);
    }

    const disappearedCreatures = new Set();
    for (const [
      creatureName,
      previousCount,
    ] of previousTargetedCreatureCounts) {
      const currentCount = currentTargetedCreatureCounts.get(creatureName) || 0;
      if (currentCount < previousCount) disappearedCreatures.add(creatureName);
    }
    if (disappearedCreatures.size > 0)
      lootReason = `Count decreased for: ${[...disappearedCreatures].join(', ')}`;

    if (previousTargetName) {
      const targetStillPresent = battleListEntries.some((entry) => {
        if (previousTargetName === entry.name) return true;
        if (entry.name.endsWith('...')) {
          const truncatedPart = entry.name.slice(0, -3);
          return previousTargetName.startsWith(truncatedPart);
        }
        return false;
      });
      if (!targetStillPresent && !lootReason)
        lootReason = `Target '${previousTargetName}' disappeared from battle list`;
    }

    if (lootReason && !isLootingInProgress) {
      logger('info', `[CreatureMonitor] ${lootReason} - triggering looting.`);
      await performImmediateLooting();
    }

    if (sabStateManager.isLootingRequired()) return;

    if (
      battleListEntries.length === 0 &&
      playerNames.length === 0 &&
      npcNames.length === 0
    ) {
      if (lastSentCreatures.length > 0 || lastSentTarget !== null) {
        activeCreatures.clear();
        lastSentCreatures = [];
        lastSentTarget = null;
        sabStateManager.writeWorldState({
          creatures: [],
          target: null,
          battleList: [],
        });
        postUpdateOnce('targeting/setEntities', { creatures: [], duration: 0 });
        postUpdateOnce('targeting/setTarget', null);
      }
      postUpdateOnce('battleList/setBattleListEntries', battleListEntries);
      postUpdateOnce('uiValues/setPlayers', playerNames);
      postUpdateOnce('uiValues/setNpcs', npcNames);
      previousTargetName = null;
      previousTargetedCreatureCounts = new Map();
      return;
    }

    const currentPlayerMinimapPosition = {
      x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
      y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
      z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
    };

    const playerDelta = {
      x: currentPlayerMinimapPosition.x - previousPlayerMinimapPosition.x,
      y: currentPlayerMinimapPosition.y - previousPlayerMinimapPosition.y,
    };
    const scrollDeltaPixels = {
      x: -playerDelta.x * tileSize.width,
      y: -playerDelta.y * tileSize.height,
    };

    const playerPositionChanged = !arePositionsEqual(
      currentPlayerMinimapPosition,
      previousPlayerMinimapPosition,
    );
    if (playerPositionChanged) {
      playerAnimationFreezeEndTime = now + PLAYER_ANIMATION_FREEZE_MS;
      lastStablePlayerMinimapPosition = { ...currentPlayerMinimapPosition };
    }
    previousPlayerMinimapPosition = { ...currentPlayerMinimapPosition };
    const isPlayerInAnimationFreeze = now < playerAnimationFreezeEndTime;

    const constrainedGameWorld = {
      ...gameWorld,
      y: gameWorld.y + 14,
      height: Math.max(0, gameWorld.height - 28),
    };
    const healthBars = await findHealthBars.findHealthBars(
      sharedBufferView,
      constrainedGameWorld,
    );
    const newActiveCreatures = new Map();
    const matchedHealthBars = new Set();

    const canonicalNames = [...new Set(targetingList.map((rule) => rule.name))];
    const performOcrForHealthBar = async (hb) => {
      const idealOcrX = hb.x - tileSize.width / 2;
      const idealOcrY = hb.y - 16;
      const ocrWidth = tileSize.width;
      const ocrHeight = 14;
      const clampedX = Math.max(gameWorld.x, idealOcrX);
      const clampedY = Math.max(gameWorld.y, idealOcrY);
      const clampedWidth = Math.min(
        ocrWidth,
        gameWorld.x + gameWorld.width - clampedX,
      );
      const clampedHeight = Math.min(
        ocrHeight,
        gameWorld.y + gameWorld.height - clampedY,
      );
      if (clampedWidth <= 0 || clampedHeight <= 0) return null;
      const ocrRegion = {
        x: clampedX,
        y: clampedY,
        width: clampedWidth,
        height: clampedHeight,
      };
      const nameplateOcrResults =
        recognizeText(
          sharedBufferView,
          ocrRegion,
          regionDefinitions.gameWorld?.ocrColors || [],
          BATTLELIST_ALLOWED_CHARS,
        ) || [];
      const rawOcrName =
        nameplateOcrResults.length > 0
          ? nameplateOcrResults[0].text
              .trim()
              .replace(/([a-z])([A-Z])/g, '$1 $2')
          : null;
      return findBestNameMatch(rawOcrName, canonicalNames, logger);
    };

    for (const [id, oldCreature] of activeCreatures.entries()) {
      let bestMatch = null;
      let minDistance = CORRELATION_DISTANCE_THRESHOLD_PIXELS;

      for (const hb of healthBars) {
        if (matchedHealthBars.has(hb)) continue;
        const distance = screenDist(
          { x: hb.x, y: hb.y },
          oldCreature.absoluteCoords,
        );
        if (distance < minDistance) {
          minDistance = distance;
          bestMatch = hb;
        }
      }

      if (bestMatch) {
        let creatureName = await performOcrForHealthBar(bestMatch);
        if (!creatureName) {
          creatureName = oldCreature.name;
        }
        const detection = {
          absoluteCoords: { x: bestMatch.x, y: bestMatch.y },
          healthBarY: bestMatch.y,
          name: creatureName,
          hp: bestMatch.healthTag,
        };
        const updated = updateCreatureState(
          oldCreature,
          detection,
          currentPlayerMinimapPosition,
          regions,
          tileSize,
          now,
          isPlayerInAnimationFreeze,
        );
        if (updated) {
          if (updated.flickerGracePeriodEndTime)
            delete updated.flickerGracePeriodEndTime;
          newActiveCreatures.set(id, updated);
        }
        matchedHealthBars.add(bestMatch);
      } else {
        if (!oldCreature.flickerGracePeriodEndTime) {
          oldCreature.flickerGracePeriodEndTime =
            now + CREATURE_FLICKER_GRACE_PERIOD_MS;
        }
        if (now < oldCreature.flickerGracePeriodEndTime) {
          if (playerPositionChanged && oldCreature.gameCoords) {
            const expectedScreenPos = getAbsoluteGameWorldClickCoordinates(
              oldCreature.gameCoords.x,
              oldCreature.gameCoords.y,
              currentPlayerMinimapPosition,
              regions.gameWorld,
              regions.tileSize
            );
            if (expectedScreenPos) {
              oldCreature.absoluteCoords = {
                x: expectedScreenPos.x,
                y: expectedScreenPos.y,
                lastUpdate: now,
              };
            }
          }
          newActiveCreatures.set(id, oldCreature);
        }
      }
    }

    if (healthBars.length > matchedHealthBars.size) {
      for (const hb of healthBars) {
        if (!matchedHealthBars.has(hb)) {
          const creatureName = await performOcrForHealthBar(hb);
          const detection = {
            absoluteCoords: { x: hb.x, y: hb.y },
            healthBarY: hb.y,
            name: creatureName,
            hp: hb.healthTag,
          };
          const newId = nextInstanceId++;
          let newCreature = { instanceId: newId };
          newCreature = updateCreatureState(
            newCreature,
            detection,
            currentPlayerMinimapPosition,
            regions,
            tileSize,
            now,
            isPlayerInAnimationFreeze,
          );
          if (newCreature) {
            newActiveCreatures.set(newId, newCreature);
          }
        }
      }
    }

    activeCreatures = newActiveCreatures;

    let detectedEntities = Array.from(activeCreatures.values());
    const blockingCreatures = new Set();

    
    const cavebotTargetWpt = sabStateManager.getCavebotTargetWaypoint();
    if (cavebotTargetWpt) {
      const blockingCavebotCreature = pathfinderInstance.getBlockingCreature(
        currentPlayerMinimapPosition,
        cavebotTargetWpt,
        detectedEntities.map((c) => c.gameCoords),
      );
      if (blockingCavebotCreature) {
        const blocker = detectedEntities.find(
          (c) =>
            c.gameCoords.x === blockingCavebotCreature.x &&
            c.gameCoords.y === blockingCavebotCreature.y &&
            c.gameCoords.z === blockingCavebotCreature.z,
        );
        if (blocker) {
          blockingCreatures.add(blocker.instanceId);
        }
      }
    }

    
    const primaryTargets = detectedEntities.filter((entity) => {
      const rule = targetingList.find((r) => r.name === entity.name);
      return rule && !rule.onlyIfTrapped && entity.isReachable;
    });

    for (const primaryTarget of primaryTargets) {
      const blockingTargetCreature = pathfinderInstance.getBlockingCreature(
        currentPlayerMinimapPosition,
        primaryTarget.gameCoords,
        detectedEntities.map((c) => c.gameCoords),
      );
      if (blockingTargetCreature) {
        const blocker = detectedEntities.find(
          (c) =>
            c.gameCoords.x === blockingTargetCreature.x &&
            c.gameCoords.y === blockingTargetCreature.y &&
            c.gameCoords.z === blockingTargetCreature.z,
        );
        if (blocker) {
          blockingCreatures.add(blocker.instanceId);
        }
      }
    }

    if (detectedEntities.length > 0) {
      const allCreaturePositions = detectedEntities.map((c) => c.gameCoords);
      const screenBounds = {
        minX: currentPlayerMinimapPosition.x - 7,
        maxX: currentPlayerMinimapPosition.x + 7,
        minY: currentPlayerMinimapPosition.y - 5,
        maxY: currentPlayerMinimapPosition.y + 5,
      };
      const reachableTiles = pathfinderInstance.getReachableTiles(
        currentPlayerMinimapPosition,
        allCreaturePositions,
        screenBounds,
      );
      detectedEntities = detectedEntities.map((entity) => {
        const coordsKey = getCoordsKey(entity.gameCoords);
        const isReachable = typeof reachableTiles[coordsKey] !== 'undefined';
        let isAdjacent = false;
        if (entity.gameCoords) {
          const deltaX = Math.abs(
            currentPlayerMinimapPosition.x - entity.gameCoords.x,
          );
          const deltaY = Math.abs(
            currentPlayerMinimapPosition.y - entity.gameCoords.y,
          );
          if ((deltaX === 1 && deltaY <= 1) || (deltaY === 1 && deltaX <= 1)) {
            isAdjacent = true;
          }
        }
        const isBlockingPath = blockingCreatures.has(entity.instanceId);
        return { ...entity, isReachable, isAdjacent, isBlockingPath };
      });
    }

    const creaturesChanged = !deepCompareEntities(
      detectedEntities,
      lastSentCreatures,
    );
    if (creaturesChanged) {
      const duration = (performance.now() - startTime).toFixed(2);
      postUpdateOnce('targeting/setEntities', {
        creatures: detectedEntities,
        duration,
      });
      lastSentCreatures = detectedEntities;
    }

    let gameWorldTarget = null;
    const allObstructed =
      detectedEntities.length > 0 &&
      detectedEntities.every((e) => e.hp === 'Obstructed');

    if (!allObstructed) {
      const targetRect = await findTarget.findTarget(
        sharedBufferView,
        gameWorld,
      );
      if (targetRect) {
        targetLossGracePeriodEndTime = 0;
        const playerPosForTargetCalc = isPlayerInAnimationFreeze
          ? lastStablePlayerMinimapPosition
          : currentPlayerMinimapPosition;
        const screenX = targetRect.x + targetRect.width / 2;
        const screenY = targetRect.y + targetRect.height / 2;
        const targetGameCoordsRaw = getGameCoordinatesFromScreen(
          screenX,
          screenY,
          playerPosForTargetCalc,
          gameWorld,
          tileSize,
        );
        if (targetGameCoordsRaw) {
          let closestCreature = null;
          let minDistance = Infinity;
          for (const entity of detectedEntities) {
            if (entity.gameCoords) {
              const distance = calculateDistance(
                targetGameCoordsRaw,
                entity.gameCoords,
              );
              if (distance < minDistance) {
                minDistance = distance;
                closestCreature = entity;
              }
            }
          }
          if (closestCreature) {
            gameWorldTarget = {
              instanceId: closestCreature.instanceId,
              name: closestCreature.name || null,
              hp: closestCreature.hp || null,
              distance: parseFloat(closestCreature.distance.toFixed(1)),
              gameCoordinates: closestCreature.gameCoords,
              isReachable: closestCreature.isReachable,
            };
          }
        }
      } else if (lastSentTarget) {
        if (targetLossGracePeriodEndTime === 0)
          targetLossGracePeriodEndTime = now + TARGET_LOSS_GRACE_PERIOD_MS;
        if (now < targetLossGracePeriodEndTime)
          gameWorldTarget = lastSentTarget;
      }
    }

    let unifiedTarget = null;
    const battleListRegion = currentState.regionCoordinates.regions.battleList;

    
    
    let battleListTargetName = null;
    if (battleListRegion) {
      const redColor = [255, 0, 0];
      const redBarSequence = new Array(5).fill(redColor);
      const result = await findSequences.findSequencesNative(
        sharedBufferView,
        {
          red_vertical_bar: { sequence: redBarSequence, direction: 'vertical' },
        },
        battleListRegion,
      );
      if (result && result.red_vertical_bar) {
        const markerY = result.red_vertical_bar.y;
        let closestEntry = null;
        let minDistance = Infinity;
        for (const entry of battleListEntries) {
          const distance = Math.abs(entry.y - markerY);
          if (distance < minDistance) {
            minDistance = distance;
            closestEntry = entry;
          }
        }
        if (closestEntry) {
          battleListTargetName = closestEntry.name;
        }
      }
    }

    
    if (gameWorldTarget && battleListTargetName) {
      
      unifiedTarget = { ...gameWorldTarget, name: battleListTargetName };
    } else if (gameWorldTarget && !battleListTargetName) {
      
      
      
      unifiedTarget = gameWorldTarget;
    } else if (!gameWorldTarget && battleListTargetName) {
      
      
      const matchingCreature = detectedEntities.find(
        (c) => c.name === battleListTargetName,
      );
      if (matchingCreature) {
        unifiedTarget = {
          instanceId: matchingCreature.instanceId,
          name: matchingCreature.name || null,
          hp: matchingCreature.hp || null,
          distance: parseFloat(matchingCreature.distance.toFixed(1)),
          gameCoordinates: matchingCreature.gameCoords,
          isReachable: matchingCreature.isReachable,
        };
      }
    }

    if (detectedEntities.length === 0 && unifiedTarget !== null) {
      unifiedTarget = null;
    }

    const targetChanged = !deepCompareEntities(unifiedTarget, lastSentTarget);
    if (targetChanged) {
      const newTargetName = unifiedTarget?.name || null;
      const oldTargetName = lastSentTarget?.name || null;
      if (newTargetName !== oldTargetName)
        logger(
          'debug',
          `[CreatureMonitor] Target switched: ${oldTargetName || 'none'} → ${newTargetName || 'none'}`,
        );
      lastSentTarget = unifiedTarget;
    }

    
    
    const detectedCreatureNames = new Set(detectedEntities.map(c => c.name));
    const sanitizedBattleList = battleListEntries.filter(entry => detectedCreatureNames.has(entry.name));

    if (sanitizedBattleList.length < battleListEntries.length) {
        logger('debug', `[CreatureMonitor] Sanitized battle list. Removed ${battleListEntries.length - sanitizedBattleList.length} ghost entries.`);
    }

    sabStateManager.writeWorldState({
      creatures: detectedEntities,
      target: unifiedTarget,
      battleList: sanitizedBattleList,
    });

    sabStateManager.writeCreatureMonitorLastProcessedZ(zLevelAtScanStart);

    postUpdateOnce('targeting/setTarget', unifiedTarget);
    postUpdateOnce('battleList/setBattleListEntries', battleListEntries);
    if (battleListEntries.length > 0)
      parentPort.postMessage({
        storeUpdate: true,
        type: 'battleList/updateLastSeenMs',
      });

    postUpdateOnce('uiValues/setPlayers', playerNames);
    if (playerNames.length > 0)
      parentPort.postMessage({
        storeUpdate: true,
        type: 'uiValues/updateLastSeenPlayerMs',
      });

    postUpdateOnce('uiValues/setNpcs', npcNames);
    if (npcNames.length > 0)
      parentPort.postMessage({
        storeUpdate: true,
        type: 'uiValues/updateLastSeenNpcMs',
      });

    const currentTarget = sabStateManager.getCurrentTarget();
    previousTargetName = currentTarget?.name || null;
    previousTargetedCreatureCounts = new Map(currentTargetedCreatureCounts);
  } catch (error) {
    logger('error', '[CreatureMonitor] Error in operation:', error);
  }
}

async function performImmediateLooting() {
  if (isLootingInProgress) {
    logger('debug', '[CreatureMonitor] Looting already in progress, skipping');
    return;
  }
  try {
    isLootingInProgress = true;
    logger('info', '[CreatureMonitor] Starting immediate looting action');
    sabStateManager.setLootingRequired(true);
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/setLootingRequired',
      payload: true,
    });
    parentPort.postMessage({
      type: 'inputAction',
      payload: {
        type: 'looting',
        action: { module: 'keypress', method: 'sendKey', args: ['f8'] },
      },
    });
    await delay(50);
    sabStateManager.setLootingRequired(false);
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/setLootingRequired',
      payload: false,
    });
    logger('info', '[CreatureMonitor] Immediate looting action completed');
  } catch (error) {
    logger('error', '[CreatureMonitor] Error during immediate looting:', error);
    sabStateManager.setLootingRequired(false);
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/setLootingRequired',
      payload: false,
    });
  } finally {
    isLootingInProgress = false;
  }
}

async function initialize() {
  logger('info', '[CreatureMonitor] Initializing Pathfinder instance...');
  try {
    pathfinderInstance = new Pathfinder.Pathfinder();
    const fs = await import('fs/promises');
    const path = await import('path');
    const mapDataForAddon = {};
    const baseDir = paths.minimapResources;
    const zLevelDirs = (await fs.readdir(baseDir, { withFileTypes: true }))
      .filter((d) => d.isDirectory() && d.name.startsWith('z'))
      .map((d) => d.name);
    for (const zDir of zLevelDirs) {
      const zLevel = parseInt(zDir.substring(1), 10);
      const zLevelPath = path.join(baseDir, zDir);
      try {
        const metadata = JSON.parse(
          await fs.readFile(path.join(zLevelPath, 'walkable.json'), 'utf8'),
        );
        const grid = await fs.readFile(path.join(zLevelPath, 'walkable.bin'));
        mapDataForAddon[zLevel] = { ...metadata, grid };
      } catch (e) {
        if (e.code !== 'ENOENT')
          logger(
            'error',
            `[CreatureMonitor] Could not load path data for Z=${zLevel}: ${e.message}`,
          );
      }
    }
    pathfinderInstance.loadMapData(mapDataForAddon);
    if (pathfinderInstance.isLoaded)
      logger(
        'info',
        '[CreatureMonitor] Pathfinder instance loaded map data successfully.',
      );
    else throw new Error('Pathfinder failed to load map data.');
  } catch (err) {
    logger(
      'error',
      '[CreatureMonitor] FATAL: Could not initialize Pathfinder instance:',
      err,
    );
    pathfinderInstance = null;
  }
}

parentPort.on('message', async (message) => {
  if (isShuttingDown) return;
  try {
    if (message.type === 'frame-update') {
      frameUpdateManager.addDirtyRects(message.payload.dirtyRects);
    }
    if (message.type === 'shutdown') {
      isShuttingDown = true;
      if (pathfinderInstance) pathfinderInstance.destroy();
      return;
    } else if (message.type === 'sab_sync_targeting_list') {
      sabStateManager.writeTargetingList(message.payload);
      return;
    } else if (message.type === 'manual_loot_trigger') {
      logger('info', '[CreatureMonitor] Manual looting trigger received');
      await performImmediateLooting();
      return;
    } else if (message.type === 'state_full_sync') {
      currentState = message.payload;
    } else if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      Object.assign(currentState, message.payload);
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
    }
    if (currentState && !isInitialized) {
      isInitialized = true;
      initialize()
        .then(() => {
          if (currentState.gameState?.playerMinimapPosition) {
            previousPlayerMinimapPosition = {
              ...currentState.gameState.playerMinimapPosition,
            };
            lastStablePlayerMinimapPosition = {
              ...currentState.gameState.playerMinimapPosition,
            };
          }
        })
        .catch((err) =>
          logger('error', '[CreatureMonitor] Initialization failed:', err),
        );
    }
    performOperation();
  } catch (e) {
    logger('error', '[CreatureMonitor] Error handling message:', e);
  }
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/exposedLuaFunctions.js
//start file
import { getRandomNumber } from '../utils/getRandomNumber.js';

export const wait = async (min_ms, max_ms, refreshCallback = null) => {
  const delay = max_ms === undefined ? min_ms : getRandomNumber(min_ms, max_ms);
  return new Promise((resolve) =>
    setTimeout(() => {
      if (refreshCallback) {
        refreshCallback(); // Call the refresh callback after the delay
      }
      resolve();
    }, delay),
  );
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/inputOrchestrator.js
//start file
import { parentPort } from 'worker_threads';
import keypress from 'keypress-native';
import mouseController from 'mouse-controller';
import { createLogger } from '../utils/logger.js';

const log = createLogger({
  info: false,
  error: true,
  debug: false,
});

const PRIORITY_MAP = {
  userRule: 0,
  looting: 1,
  script: 2,
  targeting: 3,
  movement: 4,
  hotkey: 5,
  default: 10,
};

const DELAY_MAP = {
  userRule: { min: 50, max: 75 },
  looting: { min: 50, max: 150 },
  script: { min: 50, max: 100 },
  targeting: { min: 50, max: 200 },
  movement: { min: 50, max: 100 },
  hotkey: { min: 50, max: 200 },
  default: { min: 50, max: 100 },
};

const getRandomDelay = (type) => {
  const config = DELAY_MAP[type] || DELAY_MAP.default;
  return Math.floor(Math.random() * (config.max - config.min + 1)) + config.min;
};

const MAX_DEFERRALS = 4;

let globalState = null;
const eventQueue = [];
let isProcessing = false;

function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function processQueue() {
  if (isProcessing || eventQueue.length === 0) {
    isProcessing = false;
    return;
  }

  // NEW: Defer processing if globalState is not yet available
  if (
    !globalState ||
    !globalState.global?.windowId ||
    !globalState.global?.display
  ) {
    log(
      'warn',
      '[InputOrchestrator] Deferring action processing: Missing windowId or display from globalState.',
    );
    isProcessing = false; // Allow other messages to be processed
    return; // Exit and wait for state update
  }

  isProcessing = true;

  // --- Starvation Prevention Logic ---
  // First, identify the highest priority currently in the queue
  let highestPriorityInQueue = Infinity;
  if (eventQueue.length > 0) {
    highestPriorityInQueue = eventQueue.reduce(
      (min, item) => Math.min(min, item.priority),
      Infinity,
    );
  }

  // Iterate through the queue to update deferral counts and elevate priority if needed
  eventQueue.forEach((item) => {
    // Only increment deferral count if there's a higher priority item currently in the queue
    // and this item is not already at the highest possible priority (-1)
    if (item.priority > highestPriorityInQueue && item.priority !== -1) {
      item.deferralCount++;
      if (item.deferralCount >= MAX_DEFERRALS) {
        // Elevate priority to be higher than any existing priority, but lower than userRule (0)
        // Let's use -1 for anti-starvation priority.
        item.priority = -1;
        log(
          'warn',
          `[InputOrchestrator] Elevated priority for ${item.type} due to starvation (${item.deferralCount} deferrals).`,
        );
      }
    }
  });
  // --- End Starvation Prevention Logic ---

  eventQueue.sort((a, b) => a.priority - b.priority);
  const {
    action,
    priority,
    type,
    originalPriority,
    deferralCount,
    insertionTime,
  } = eventQueue.shift();

  try {
    if (
      !globalState ||
      !globalState.global?.windowId ||
      !globalState.global?.display
    ) {
      throw new Error('Missing windowId or display from globalState');
    }

    const windowId = parseInt(globalState.global.windowId, 10);
    const display = globalState.global.display;

    log(
      'info',
      `[InputOrchestrator] Executing action of type: ${type} (Original Prio: ${originalPriority}, Current Prio: ${priority}, Deferrals: ${deferralCount})`,
    );

    switch (action.module) {
      case 'keypress':
        switch (action.method) {
          case 'sendKey':
          case 'keyDown':
          case 'keyUp':
            await keypress[action.method](
              action.args[0],
              display,
              action.args[1],
            );
            break;
          case 'typeArray':
            await keypress.typeArray(action.args[0], display, action.args[1]);
            break;
          case 'rotate':
            await keypress.rotate(display, action.args[0]);
            break;
          default:
            await keypress[action.method](...action.args, display);
            break;
        }
        break;
      case 'mouseController':
        await mouseController[action.method](windowId, ...action.args, display);
        break;
      default:
        log('warn', `[InputOrchestrator] Unknown module: ${action.module}`);
    }
  } catch (error) {
    log('error', '[InputOrchestrator] Error executing action:', error);
  } finally {
    const delayMs = getRandomDelay(type);
    await delay(delayMs);
    isProcessing = false;
    processQueue();
  }
}

parentPort.on('message', (message) => {
  if (message.type === 'state_full_sync' || message.type === 'state_diff') {
    globalState = message.payload;
    // NEW: If state is updated, try processing the queue again
    if (!isProcessing && eventQueue.length > 0) {
      processQueue();
    }
    return;
  }

  if (message.type === 'inputAction') {
    const { payload } = message;
    const priority = PRIORITY_MAP[payload.type] || PRIORITY_MAP.default;
    eventQueue.push({
      action: payload.action,
      priority: priority,
      originalPriority: priority, // Store original priority
      type: payload.type,
      deferralCount: 0, // Initialize deferral count
      insertionTime: Date.now(), // Timestamp for tie-breaking if needed
    });

    if (!isProcessing) {
      processQueue();
    }
  }
});

log('info', '[InputOrchestrator] Worker started and listening for messages.');

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaApi.js
//start file
import { getAbsoluteGameWorldClickCoordinates } from '../utils/gameWorldClickTranslator.js';
import { getAbsoluteClickCoordinates } from '../utils/minimapClickTranslator.js';
import { wait } from './exposedLuaFunctions.js';

const getNested = (obj, path) => {
  if (path === null || path === undefined) return obj;
  return path.split('.').reduce((acc, part) => acc && acc[part], obj);
};

/**
 * Creates an object with getters for convenient, direct access to state in Lua.
 * This object will be exposed globally in Lua as `__BOT_STATE__`.
 * @param {function} getState - A function that returns the latest full Redux state.
 * @param {'script'|'cavebot'} type - The type of worker, to determine which variables to expose.
 * @returns {object} The state shortcut object.
 */
export const createStateShortcutObject = (getState, type) => {
  const shortcuts = {};

  Object.defineProperty(shortcuts, 'hppc', {
    get: () => getState().gameState?.hppc,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'mppc', {
    get: () => getState().gameState?.mppc,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'characterName', {
    get: () => getState().gameState?.characterName,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'lastCharacterName', {
    get: () => getState().gameState?.lastCharacterName,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'lastLabel', {
    get: () => getState().cavebot?.lastLabel,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'cap', {
    get: () => getState().uiValues?.skillsWidget?.capacity || 0,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'stamina', {
    get: () => getState().uiValues?.skillsWidget?.stamina || 0,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'level', {
    get: () => getState().uiValues?.skillsWidget?.level,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'exp', {
    get: () => getState().uiValues?.skillsWidget?.experience,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'soul', {
    get: () => getState().uiValues?.skillsWidget?.soulPoints,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'speed', {
    get: () => getState().uiValues?.skillsWidget?.speed,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'xpRate', {
    get: () => getState().uiValues?.skillsWidget?.xpGainRate,
    enumerable: true,
  });

  Object.defineProperty(shortcuts, 'lastSeenBattleListMs', {
    get: () => getState().battleList?.lastSeenMs,
    enumerable: true,
  });

  Object.defineProperty(shortcuts, 'lastSeenPlayerMs', {
    get: () => getState().uiValues?.lastSeenPlayerMs,
    enumerable: true,
  });

  Object.defineProperty(shortcuts, 'lastSeenNpcMs', {
    get: () => getState().uiValues?.lastSeenNpcMs,
    enumerable: true,
  });

  Object.defineProperty(shortcuts, 'food', {
    get: () => getState().uiValues?.skillsWidget?.food,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isChatOff', {
    get: () => getState().gameState?.isChatOff,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'monsterNum', {
    get: () => getState().battleList.entries.length,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'playerNum', {
    get: () => getState().uiValues.players.length,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'npcNum', {
    get: () => getState().uiValues.npcs.length,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'battleList', {
    get: () => ({
      entries:
        getState().regionCoordinates.regions.battleList?.children?.entries
          ?.list || [],
    }),
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'partyNum', {
    get: () => getState().gameState?.partyNum,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isTyping', {
    get: () => getState().gameState?.isTyping,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'isOnline', {
    get: () => !!getState().regionCoordinates?.regions?.onlineMarker,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'stowText', {
    get: () => getState().regionCoordinates?.regions?.stowText,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'stashIcon', {
    get: () => getState().regionCoordinates?.regions?.stashIcon,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'pk', {
    get: () =>
      getState().regionCoordinates?.regions?.playerList?.children?.whiteSkull,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'activeTab', {
    get: () => getState().uiValues?.chatboxTabs?.activeTab || 'unknown',
    enumerable: true,
  });

  Object.defineProperty(shortcuts, 'actionItems', {
    get: () => {
      const hotkeyBarChildren =
        getState().regionCoordinates?.regions?.hotkeyBar?.children || {};
      return new Proxy(
        {},
        {
          get(target, prop) {
            const child = hotkeyBarChildren[prop];
            return !!(child && child.x !== undefined && child.y !== undefined);
          },
          has(target, prop) {
            return true;
          },
          ownKeys() {
            return Object.keys(hotkeyBarChildren);
          },
        },
      );
    },
    enumerable: true,
  });

  const charStatus = getState().gameState?.characterStatus;
  if (charStatus) {
    for (const status in charStatus) {
      Object.defineProperty(shortcuts, status, {
        get: () => getState().gameState.characterStatus[status],
        enumerable: true,
      });
    }
  }

  Object.defineProperty(shortcuts, 'pos', {
    get: () => {
      const pos = getState().gameState?.playerMinimapPosition || {};
      return { x: pos.x, y: pos.y, z: pos.z };
    },
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'wpt', {
    get: () => {
      const cavebotState = getState().cavebot;
      const currentWaypoints =
        cavebotState?.waypointSections[cavebotState?.currentSection]
          ?.waypoints || [];
      const currentWptIndex = currentWaypoints.findIndex(
        (wp) => wp.id === cavebotState?.wptId,
      );
      const currentWpt =
        currentWptIndex !== -1 ? currentWaypoints[currentWptIndex] : null;
      if (currentWpt) {
        return {
          id: currentWptIndex + 1,
          x: currentWpt.x,
          y: currentWpt.y,
          z: currentWpt.z,
          type: currentWpt.type,
          label: currentWpt.label,
          distance: cavebotState.wptDistance,
        };
      }
      return null;
    },
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'cavebot', {
    get: () => getState().cavebot?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'section', {
    get: () =>
      getState().cavebot?.waypointSections[getState().cavebot?.currentSection]
        ?.name,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'healing', {
    get: () => getState().rules?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'targeting', {
    get: () => getState().targeting?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'scripts', {
    get: () => getState().lua?.enabled,
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'players', {
    get: () => getState().uiValues?.players || [],
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'npcs', {
    get: () => getState().uiValues?.npcs || [],
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'standTime', {
    get: () => {
      const lastMoveTime = getState().gameState?.lastMoveTime;
      if (lastMoveTime) {
        return Date.now() - lastMoveTime;
      }
      return 0;
    },
    enumerable: true,
  });
  Object.defineProperty(shortcuts, 'target', {
    get: () => {
      const state = getState();
      const target = state.targeting?.target;
      const playerPos = state.gameState?.playerMinimapPosition;

      if (!target) {
        return null;
      }

      // Get coordinates from gameCoords if available, otherwise fallback to x,y,z
      const targetX = target.gameCoordinatess?.x;
      const targetY = target.gameCoordinates?.y;
      const targetZ = target.gameCoordinatess?.z;

      const distance = target.gameCoordinatess?.distance;

      return {
        x: targetX,
        y: targetY,
        z: targetZ,
        distance: distance,
      };
    },
    enumerable: true,
  });
  return shortcuts;
};

/**
 * Creates a consolidated API (functions and state object) to be exposed to a Lua environment.
 * @param {object} context - The context object from the calling worker.
 * @returns {{api: object, asyncFunctionNames: string[], stateObject: object, sharedGlobalsProxy: object}}
 */
export const createLuaApi = async (context) => {
  const { onAsyncStart, onAsyncEnd, sharedLuaGlobals, lua, postInputAction } =
    context; // Added postInputAction
  const { type, getState, postSystemMessage, logger, id } = context;
  const scriptName = type === 'script' ? `Script ${id}` : 'Cavebot';
  const asyncFunctionNames = [
    'wait',
    'keyPress',
    'keyPressMultiple',
    'typeText',
    'typeSequence',
    'rotate',
    'clickTile',
    'clickAbsolute',
    'mapClick',
    'drag',
    'dragAbsolute',
    'focusTab',
    'login',
    'waitFor',
    'isTileReachable',
  ];
  const getWindowId = () => getState()?.global?.windowId;
  const getDisplay = () => getState()?.global?.display || ':0';

  const waitFor = async (
    path,
    comparison = 'exists',
    value = null,
    timeout = 5000,
    interval = 200,
  ) => {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      await context.refreshLuaGlobalState();
      const state = getState();
      const actualValue = getNested(state, path);

      let conditionMet = false;
      switch (comparison) {
        case 'equals':
          conditionMet = actualValue === value;
          break;
        case 'notEquals':
          conditionMet = actualValue !== value;
          break;
        case 'greaterThan':
          conditionMet = actualValue > value;
          break;
        case 'lessThan':
          conditionMet = actualValue < value;
          break;
        case 'exists':
          conditionMet = actualValue !== undefined && actualValue !== null;
          break;
        case 'notExists':
          conditionMet = actualValue === undefined || actualValue === null;
          break;
        default:
          logger(
            'warn',
            `[Lua/${scriptName}] waitFor: unknown comparison '${comparison}'`,
          );
          return false;
      }

      if (conditionMet) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
    logger('info', `[Lua/${scriptName}] waitFor timed out for path: '${path}'`);
    return false;
  };

  const closeAllModals = async (timeout = 10000) => {
    const modalsToClose = [
      { name: 'pleaseWaitModal' },
      { name: 'ipChangedModal' },
      { name: 'wrongPasswordModal' },
      { name: 'connectionLostModal' },
      { name: 'connectionFailedModal' },
      { name: 'warningModal' },
      { name: 'notLoggedInAnymoreModal' },
    ];
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      await context.refreshLuaGlobalState();
      const state = getState();
      const regions = state.regionCoordinates?.regions;
      if (!regions) {
        await new Promise((r) => setTimeout(r, 200));
        continue;
      }

      let foundModal = false;
      for (const modalInfo of modalsToClose) {
        const modal = regions[modalInfo.name];
        const button =
          modal?.children?.abort ||
          modal?.children?.close ||
          modal?.children?.ok;

        if (button?.x && button?.y) {
          logger('info', `[Lua/${scriptName}] Closing '${modalInfo.name}'`);
          if (
            modalInfo.name === 'ipChangedModal' ||
            modalInfo.name === 'notLoggedInAnymoreModal'
          ) {
            postInputAction({
              type: 'luaScript',
              action: {
                module: 'keypress',
                method: 'sendKey',
                args: ['Escape'],
              },
            });
            await wait(500);
            postInputAction({
              type: 'luaScript',
              action: {
                module: 'keypress',
                method: 'sendKey',
                args: ['Escape'],
              },
            });
            await wait(500);
          } else {
            postInputAction({
              type: 'luaScript',
              action: {
                module: 'mouseController',
                method: 'leftClick',
                args: [button.x, button.y],
              },
            });
            await wait(500);
          }
          foundModal = true;
          break; // Restart the scan for modals
        }
      }

      if (!foundModal) {
        return true; // No modals found, we are done.
      }
    }
    logger('warn', `[Lua/${scriptName}] closeAllModals timed out.`);
    return false; // Timed out
  };

  const baseApi = {
    getDistanceTo: (x, y, z) => {
      const state = getState();
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!playerPos) return 9999;
      if (z !== undefined && playerPos.z !== z) return 9999;
      return Math.max(Math.abs(playerPos.x - x), Math.abs(playerPos.y - y));
    },
    canUse: (itemName) => {
      const state = getState();
      const activeActionItems = state.gameState?.activeActionItems || {};
      return !!activeActionItems[itemName];
    },
    isLocation: (range = 0) => {
      const state = getState();
      const playerPos = state.gameState?.playerMinimapPosition;
      const { waypointSections, currentSection, wptId } = state.cavebot || {};

      if (
        !playerPos ||
        wptId == null ||
        !waypointSections ||
        !waypointSections[currentSection]
      ) {
        console.log('isLocation failed, missing data.', {
          playerPos,
          wptId,
          currentSection,
        });
        return false;
      }

      const targetWpt = waypointSections[currentSection].waypoints.find(
        (wp) => wp.id === wptId,
      );
      if (!targetWpt) {
        console.log('isLocation: target waypoint not found for wptId', wptId);
        return false;
      }
      if (playerPos.z !== targetWpt.z) {
        console.log('isLocation: z mismatch', playerPos.z, targetWpt.z);
        return false;
      }

      const px = Number(playerPos.x);
      const py = Number(playerPos.y);
      const tx = Number(targetWpt.x);
      const ty = Number(targetWpt.y);

      if ([px, py, tx, ty].some(Number.isNaN)) {
        console.log('isLocation: numeric conversion failed', {
          px,
          py,
          tx,
          ty,
        });
        return false;
      }

      if (px === tx && py === ty) {
        return true; // exact match fast-path
      }

      const dist = Math.max(Math.abs(px - tx), Math.abs(py - ty));
      return dist <= range;
    },
    caround: (distance) => {
      const state = getState();
      const creatures = state.targeting?.creatures || [];

      // If no distance parameter provided, return all detected creatures
      if (distance === undefined || distance === null) {
        return creatures.length;
      }

      const playerPos = state.gameState?.playerMinimapPosition;

      if (!playerPos || !Number.isInteger(distance) || distance < 0) {
        return 0;
      }

      let count = 0;
      for (const creature of creatures) {
        if (creature.gameCoords && creature.gameCoords.z === playerPos.z) {
          const dist = Math.max(
            Math.abs(playerPos.x - creature.gameCoords.x),
            Math.abs(playerPos.y - creature.gameCoords.y),
          );
          if (dist <= distance) {
            count++;
          }
        }
      }
      return count;
    },
    paround: () => {
      const state = getState();
      const players = state.uiValues?.players || [];
      return players.length;
    },
    npcaround: () => {
      const state = getState();
      const npcs = state.uiValues?.npcs || [];
      return npcs.length;
    },
    maround: () => {
      const state = getState();
      const battleListEntries = state.battleList?.entries || [];
      return battleListEntries.length;
    },
    wptDistance: () => {
      const state = getState();
      // First try to get the distance from pathfinder state
      const pathfinderDistance = state.pathfinder?.wptDistance;
      if (typeof pathfinderDistance === 'number') {
        return pathfinderDistance;
      }

      // Fallback to manual calculation
      const playerPos = state.gameState?.playerMinimapPosition;
      const { waypointSections, currentSection, wptId } = state.cavebot || {};

      if (
        !playerPos ||
        wptId == null ||
        !waypointSections ||
        !waypointSections[currentSection]
      ) {
        return 0;
      }

      const targetWpt = waypointSections[currentSection].waypoints.find(
        (wp) => wp.id === wptId,
      );
      if (!targetWpt || playerPos.z !== targetWpt.z) {
        return 0;
      }

      return Math.max(
        Math.abs(playerPos.x - targetWpt.x),
        Math.abs(playerPos.y - targetWpt.y),
      );
    },
    isTileReachable: async (x, y, z) => {
      const state = getState();
      const playerPos = state.gameState?.playerMinimapPosition;

      if (
        !playerPos ||
        !Number.isInteger(x) ||
        !Number.isInteger(y) ||
        !Number.isInteger(z)
      ) {
        return false;
      }

      // If the distance is greater than 50, always return false
      const distance = Math.max(
        Math.abs(playerPos.x - x),
        Math.abs(playerPos.y - y),
      );
      if (distance > 50) {
        return false;
      }

      // If on different floors, not reachable
      if (playerPos.z !== z) {
        return false;
      }

      // Try to use pathfinder instance if available (like creatureMonitor does)
      if (context && context.pathfinderInstance) {
        try {
          const targetNode = { x, y, z };
          const isReachable = context.pathfinderInstance.isReachable(
            playerPos,
            targetNode,
            [],
          );
          return isReachable;
        } catch (error) {
          logger(
            'warn',
            `[Lua/${scriptName}] pathfinder check failed: ${error.message}`,
          );
        }
      }

      // Fallback to distance-based reachability check
      // Adjacent tiles (distance 1) are always reachable
      if (distance <= 1) {
        return true;
      }

      // For farther distances, use a conservative estimate
      return distance <= 20;
    },
    log: (level, ...messages) =>
      logger(
        String(level).toLowerCase(),
        `[Lua/${scriptName}] ${messages.map(String).join(' ')}`,
      ),
    print: (...messages) => {
      const message = messages.map(String).join(' ');
      logger('info', `[Lua/${scriptName}] print: ${message}`);
      if (type === 'cavebot') {
        const state = getState();
        const scriptId = state.cavebot.wptId;
        context.postStoreUpdate('cavebot/addWaypointLogEntry', {
          id: scriptId,
          message: message,
        });
      } else {
        context.postStoreUpdate('lua/addLogEntry', {
          id: id,
          message: message,
        });
      }
    },
    alert: (soundFile = 'alert.wav') =>
      postSystemMessage({ type: 'play_alert', payload: { soundFile } }),
    wait: (min_ms, max_ms) =>
      wait(min_ms, max_ms, context.refreshLuaGlobalState),
    keyPress: (key, modifier = null) =>
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'keypress',
          method: 'sendKey',
          args: [key, modifier],
        },
      }),
    keyPressMultiple: (key, count = 1, modifier = null, delayMs = 50) => {
      for (let i = 0; i < count; i++) {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'keypress',
            method: 'sendKey',
            args: [key, modifier],
          },
        });
        if (i < count - 1) {
          wait(delayMs);
        }
      }
    },
    typeText: async (...args) => {
      if (args.length === 0) {
        logger(
          'warn',
          `[Lua/${scriptName}] 'type' function called with no arguments.`,
        );
        return false;
      }

      let texts = [];
      let startAndEndWithEnter = true;

      const lastArg = args[args.length - 1];
      if (typeof lastArg === 'boolean') {
        startAndEndWithEnter = lastArg;
        texts = args.slice(0, -1);
      } else {
        texts = args;
      }

      const stringArgs = texts.map(String);

      if (stringArgs.length === 0) {
        logger(
          'warn',
          `[Lua/${scriptName}] 'type' function called without any text to type.`,
        );
        return false;
      }

      try {
        // typeArray is a native function, so we need to send it as a single action
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'keypress',
            method: 'typeArray',
            args: [stringArgs, startAndEndWithEnter],
          },
        });
        return true;
      } catch (error) {
        logger(
          'error',
          `[Lua/${scriptName}] Error in 'type' function: ${error.message}`,
        );
        throw error;
      }
    },
    typeSequence: async (texts, delayBetween = 100) => {
      for (const text of texts) {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'keypress',
            method: 'typeArray',
            args: [[text], true], // typeArray expects an array of strings
          },
        });
        if (delayBetween > 0) {
          await wait(delayBetween);
        }
      }
    },
    rotate: (direction) =>
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'keypress',
          method: 'rotate',
          args: [direction],
        },
      }),
    isTyping: () => getState().gameState?.isTyping, // This state is read from Redux, not directly from input
    clickTile: async (button, x, y, position = 'center') => {
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform game click: missing region data or player position`,
        );
        return false;
      }
      const clickCoords = getAbsoluteGameWorldClickCoordinates(
        x,
        y,
        playerPos,
        gameWorld,
        tileSize,
        position,
      );
      if (!clickCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform game click: invalid coordinates`,
        );
        return false;
      }

      if (button === 'right') {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'rightClick',
            args: [clickCoords.x, clickCoords.y],
          },
        });
      } else {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'leftClick',
            args: [clickCoords.x, clickCoords.y],
          },
        });
      }
      await wait(100);
      return true;
    },
    clickAbsolute: async (button, x, y) => {
      if (button === 'right') {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'rightClick',
            args: [x, y],
          },
        });
      } else {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'leftClick',
            args: [x, y],
          },
        });
      }
      await wait(100);
      return true;
    },
    mapClick: async (x, y, position = 'center') => {
      const state = getState();
      const minimapRegionDef = state.regionCoordinates?.regions?.minimapFull;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!minimapRegionDef || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform minimap click: missing region data or player position`,
        );
        return false;
      }
      const clickCoords = getAbsoluteClickCoordinates(
        x,
        y,
        playerPos,
        minimapRegionDef,
      );
      if (!clickCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform minimap click: invalid coordinates`,
        );
        return false;
      }
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'mouseController',
          method: 'leftClick',
          args: [clickCoords.x, clickCoords.y],
        },
      });
      await wait(100);
      return true;
    },
    drag: async (startX, startY, endX, endY, button = 'left') => {
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform drag: missing region data or player position`,
        );
        return false;
      }
      const startCoords = getAbsoluteGameWorldClickCoordinates(
        startX,
        startY,
        playerPos,
        gameWorld,
        tileSize,
        'bottomRight',
      );
      const endCoords = getAbsoluteGameWorldClickCoordinates(
        endX,
        endY,
        playerPos,
        gameWorld,
        tileSize,
        'bottomRight',
      );
      if (!startCoords || !endCoords) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot perform drag: invalid coordinates`,
        );
        return false;
      }
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'mouseController',
          method: 'mouseMove',
          args: [startCoords.x, startCoords.y],
        },
      });
      await wait(50);
      if (button === 'right') {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'rightMouseDown',
            args: [startCoords.x, startCoords.y],
          },
        });
      } else {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'mouseDown',
            args: [startCoords.x, startCoords.y],
          },
        });
      }
      await wait(100);
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'mouseController',
          method: 'mouseMove',
          args: [endCoords.x, endCoords.y],
        },
      });
      await wait(100);
      if (button === 'right') {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'rightMouseUp',
            args: [endCoords.x, endCoords.y],
          },
        });
      } else {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'mouseUp',
            args: [endCoords.x, endCoords.y],
          },
        });
      }
      await wait(100);
      return true;
    },
    dragAbsolute: async (startX, startY, endX, endY, button = 'left') => {
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'mouseController',
          method: 'mouseMove',
          args: [startX, startY],
        },
      });
      await wait(50);
      if (button === 'right') {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'rightMouseDown',
            args: [startX, startY],
          },
        });
      } else {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'mouseDown',
            args: [startX, startY],
          },
        });
      }
      await wait(100);
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'mouseController',
          method: 'mouseMove',
          args: [endX, endY],
        },
      });
      await wait(100);
      if (button === 'right') {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'rightMouseUp',
            args: [endX, endY],
          },
        });
      } else {
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'mouseUp',
            args: [endX, endY],
          },
        });
      }
      await wait(100);
      return true;
    },
    tileToCoordinate: (tileX, tileY, position = 'bottomRight') => {
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot convert tile to coordinate: missing region data`,
        );
        return null;
      }
      const coords = getAbsoluteGameWorldClickCoordinates(
        tileX,
        tileY,
        playerPos,
        gameWorld,
        tileSize,
        position,
      );
      return coords ? { x: coords.x, y: coords.y } : null;
    },
    coordinateToTile: (screenX, screenY) => {
      const state = getState();
      const gameWorld = state.regionCoordinates?.regions?.gameWorld;
      const tileSize = state.regionCoordinates?.regions?.tileSize;
      const playerPos = state.gameState?.playerMinimapPosition;
      if (!gameWorld || !tileSize || !playerPos) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot convert coordinate to tile: missing region data`,
        );
        return null;
      }
      const relX = screenX - gameWorld.x;
      const relY = screenY - gameWorld.y;
      const tileX =
        Math.floor(relX / tileSize.width) +
        playerPos.x -
        Math.floor(gameWorld.width / tileSize.width / 2);
      const tileY =
        Math.floor(relY / tileSize.height) +
        playerPos.y -
        Math.floor(gameWorld.height / tileSize.height / 2);
      return { x: tileX, y: tileY };
    },
    focusTab: async (tabName) => {
      const state = getState();
      const tabs = state.uiValues?.chatboxTabs?.tabs;
      if (!tabs || !tabName) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot focus tab: missing tab data or tab name`,
        );
        return false;
      }
      const tab = tabs[tabName];
      if (!tab || !tab.tabPosition) {
        logger(
          'warn',
          `[Lua/${scriptName}] Cannot focus tab: tab "${tabName}" not found or missing position`,
        );
        return false;
      }
      const { x, y } = tab.tabPosition;
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'mouseController',
          method: 'leftClick',
          args: [x, y],
        },
      });
      await wait(100);
      return true;
    },
    setTargeting: (enabled) => {
      context.postStoreUpdate('targeting/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Targeting ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    setHealing: (enabled) => {
      context.postStoreUpdate('rules/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Healing (rules) ${
          enabled ? 'enabled' : 'disabled'
        }`,
      );
    },
    setCavebot: (enabled) => {
      context.postStoreUpdate('cavebot/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Cavebot ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    isCreatureOnTile: (x, y, z) => {
      const state = getState();
      const creatures = state.targeting?.creatures || [];
      return creatures.some(
        (creature) =>
          creature.gameCoords.x === x &&
          creature.gameCoords.y === y &&
          creature.gameCoords.z === z,
      );
    },
    setScripts: (enabled) => {
      context.postStoreUpdate('lua/setenabled', !!enabled);
      logger(
        'info',
        `[Lua/${scriptName}] Scripts ${enabled ? 'enabled' : 'disabled'}`,
      );
    },
    setScript: (name, status) => {
      const enabled = status === 'enabled';
      postSystemMessage({
        type: 'lua_set_script_enabled',
        payload: { name, enabled },
      });
      logger(
        'info',
        `[Lua/${scriptName}] Setting script "${name}" to ${status}`,
      );
    },
    pauseWalking: (ms) => {
      const duration = parseInt(ms, 10);
      if (!isNaN(duration)) {
        postSystemMessage({ type: 'lua-pause-walking', payload: duration });
        logger('info', `[Lua/${scriptName}] Pausing walking for ${duration}ms`);
      }
    },
    pauseTargeting: (ms) => {
      const duration = parseInt(ms, 10);
      if (!isNaN(duration)) {
        postSystemMessage({ type: 'lua-pause-targeting', payload: duration });
        logger(
          'info',
          `[Lua/${scriptName}] Pausing targeting for ${duration}ms`,
        );
      }
    },
    waitFor,
    login: async (email, password, character) => {
      if (
        await waitFor(
          'regionCoordinates.regions.onlineMarker',
          'exists',
          null,
          100,
        )
      ) {
        logger(
          'info',
          `[Lua/${scriptName}] Player is already online, skipping login.`,
        );
        return false;
      }

      await closeAllModals(15000);

      const isAtCharSelect = await waitFor(
        'regionCoordinates.regions.selectCharacterModal',
        'exists',
        null,
        100,
      );

      if (isAtCharSelect) {
        logger(
          'info',
          `[Lua/${scriptName}] Already at character selection, skipping login form.`,
        );
      } else {
        logger(
          'info',
          `[Lua/${scriptName}] Starting login process for character: ${character}`,
        );

        const loginModalExists = await waitFor(
          'regionCoordinates.regions.loginModal',
          'exists',
          null,
          1000,
        );
        if (!loginModalExists) {
          logger('warn', `[Lua/${scriptName}] loginModal not found`);
          return false;
        }

        const state = getState(); // We know it exists now.
        const loginModal = state.regionCoordinates.regions.loginModal;

        postInputAction({
          type: 'luaScript',
          action: {
            module: 'keypress',
            method: 'sendKey',
            args: ['Escape'],
          },
        });
        await wait(100);
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'keypress',
            method: 'sendKey',
            args: ['Escape'],
          },
        });
        await wait(100);

        const emailInput = loginModal.children?.emailInput;
        if (!emailInput) {
          logger('warn', `[Lua/${scriptName}] emailInput not found`);
          return false;
        }
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'leftClick',
            args: [emailInput.x, emailInput.y],
          },
        });
        await wait(50);
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'keypress',
            method: 'typeArray',
            args: [[email], false],
          },
        });
        await wait(100);

        const passwordInput = loginModal.children?.passwordInput;
        if (!passwordInput) {
          logger('warn', `[Lua/${scriptName}] passwordInput not found`);
          return false;
        }
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'mouseController',
            method: 'leftClick',
            args: [passwordInput.x, passwordInput.y],
          },
        });
        await wait(50);
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'keypress',
            method: 'typeArray',
            args: [[password], false],
          },
        });
        await wait(100);
        postInputAction({
          type: 'luaScript',
          action: {
            module: 'keypress',
            method: 'sendKey',
            args: ['Enter'],
          },
        });
      }

      const charSelectAppeared = await waitFor(
        'regionCoordinates.regions.selectCharacterModal',
        'exists',
        null,
        10000,
      );

      if (!charSelectAppeared) {
        logger(
          'warn',
          `[Lua/${scriptName}] selectCharacterModal not found after login attempt.`,
        );
        // Try to recover by closing any new modals
        await closeAllModals(5000);
        return false;
      }

      // Wait for character data to be parsed by OCR
      const charDataExists = await waitFor(
        'uiValues.selectCharacterModal.characters',
        'exists',
        null,
        5000,
      );
      if (!charDataExists) {
        logger(
          'warn',
          `[Lua/${scriptName}] No character data available for selection after 5s.`,
        );
        return false;
      }

      const characters = getState().uiValues.selectCharacterModal.characters;
      const characterNames = Object.keys(characters);
      const targetCharacterLower = character.toLowerCase();
      const targetCharacterFound = characterNames.find((name) =>
        name.toLowerCase().includes(targetCharacterLower),
      );

      if (!targetCharacterFound) {
        logger(
          'warn',
          `[Lua/${scriptName}] Target character '${character}' not found in list: [${characterNames.join(
            ', ',
          )}]`,
        );
        return false;
      }

      const characterItem = characters[targetCharacterFound];
      if (!characterItem || !characterItem.position) {
        logger(
          'warn',
          `[Lua/${scriptName}] Could not find coordinates for character '${targetCharacterFound}'`,
        );
        return false;
      }

      postInputAction({
        type: 'luaScript',
        action: {
          module: 'mouseController',
          method: 'leftClick',
          args: [characterItem.position.x, characterItem.position.y],
        },
      });
      await wait(100);
      postInputAction({
        type: 'luaScript',
        action: {
          module: 'keypress',
          method: 'sendKey',
          args: ['Enter'],
        },
      });

      const isOnline = await waitFor(
        'regionCoordinates.regions.onlineMarker',
        'exists',
        null,
        10000,
      );

      if (isOnline) {
        logger(
          'info',
          `[Lua/${scriptName}] Login successful, player is online.`,
        );
        return true;
      } else {
        logger(
          'warn',
          `[Lua/${scriptName}] Login timeout, player did not come online.`,
        );
        return false;
      }
    },
  };
  let navigationApi = {};

  const goBackWaypoints = (numBack) => {
    const state = getState();
    const { waypointSections, currentSection, wptId } = state.cavebot;
    const waypoints = waypointSections[currentSection]?.waypoints || [];
    if (waypoints.length === 0) {
      logger(
        'warn',
        `[Lua/${scriptName}] back function failed: no waypoints in current section.`,
      );
      return;
    }

    const currentIndex = waypoints.findIndex((wp) => wp.id === wptId);
    if (currentIndex === -1) {
      logger(
        'warn',
        `[Lua/${scriptName}] back function failed: current waypoint not found.`,
      );
      return;
    }

    const newIndex = Math.max(0, currentIndex - numBack);
    if (currentIndex === newIndex) {
      logger(
        'info',
        `[Lua/${scriptName}] back function: already at or before target waypoint index.`,
      );
      return;
    }

    if (waypoints[newIndex]) {
      context.postStoreUpdate('cavebot/setwptId', waypoints[newIndex].id);
    }
  };

  const goToSection = (sectionName, label) => {
    const state = getState();
    const { waypointSections } = state.cavebot;
    const foundEntry = Object.entries(waypointSections).find(
      ([, s]) => s.name === sectionName,
    );

    if (foundEntry) {
      const [targetSectionId, targetSection] = foundEntry;
      if (targetSection.waypoints?.length > 0) {
        let targetWpt = targetSection.waypoints[0]; // Default to first
        if (label) {
          const foundWpt = targetSection.waypoints.find(
            (wp) => wp.label === label,
          );
          if (foundWpt) {
            targetWpt = foundWpt;
          } else {
            logger(
              'warn',
              `[Lua/${scriptName}] goToSection: Label '${label}' not found in section '${sectionName}'. Failing gracefully.`,
            );
            return;
          }
        }
        context.postStoreUpdate(
          'cavebot/setCurrentWaypointSection',
          targetSectionId,
        );
        context.postStoreUpdate('cavebot/setwptId', targetWpt.id);
      } else {
        logger(
          'warn',
          `[Lua/${scriptName}] goToSection: Section '${sectionName}' has no waypoints.`,
        );
      }
    } else {
      logger(
        'warn',
        `[Lua/${scriptName}] goToSection: Section '${sectionName}' not found.`,
      );
    }
  };

  if (type === 'cavebot') {
    navigationApi = {
      skipWaypoint: context.advanceToNextWaypoint,
      goToLabel: context.goToLabel,
      goToSection,
      goToWpt: context.goToWpt,
      back: (x) => goBackWaypoints(x),
      backLoc: (x, y) => {
        if (!baseApi.isLocation(x)) {
          goBackWaypoints(y);
        }
      },
      backz: (y) => {
        const state = getState();
        const playerPos = state.gameState?.playerMinimapPosition;
        const { waypointSections, currentSection, wptId } = state.cavebot;
        const waypoints = waypointSections[currentSection]?.waypoints || [];
        const currentWpt = waypoints.find((wp) => wp.id === wptId);
        if (playerPos && currentWpt && playerPos.z !== currentWpt.z) {
          goBackWaypoints(y);
        }
      },
      pauseActions: (paused) =>
        context.postStoreUpdate('cavebot/setActionPaused', !!paused),
      setCavebotEnabled: (enabled) =>
        context.postStoreUpdate('cavebot/setenabled', !!enabled),
    };
  } else {
    navigationApi = {
      skipWaypoint: () => {
        const state = getState();
        const { waypointSections, currentSection, wptId } = state.cavebot;
        const waypoints = waypointSections[currentSection]?.waypoints || [];
        const currentIndex = waypoints.findIndex((wp) => wp.id === wptId);
        if (currentIndex === -1) return;
        const nextIndex = (currentIndex + 1) % waypoints.length;
        if (waypoints[nextIndex])
          context.postStoreUpdate('cavebot/setwptId', waypoints[nextIndex].id);
      },
      goToLabel: (label) => {
        const state = getState();
        const { waypointSections, currentSection } = state.cavebot;
        const targetWpt = waypointSections[currentSection]?.waypoints.find(
          (wp) => wp.label === label,
        );
        if (targetWpt)
          context.postStoreUpdate('cavebot/setwptId', targetWpt.id);
      },
      goToSection,
      goToWpt: (index) => {
        const arrayIndex = parseInt(index, 10) - 1;
        if (isNaN(arrayIndex) || arrayIndex < 0) return;
        const state = getState();
        const { waypointSections, currentSection } = state.cavebot;
        const waypoints = waypointSections[currentSection]?.waypoints || [];
        if (arrayIndex < waypoints.length)
          context.postStoreUpdate('cavebot/setwptId', waypoints[arrayIndex].id);
      },
      back: (x) => goBackWaypoints(x),
      backLoc: (x, y) => {
        if (!baseApi.isLocation(x)) {
          goBackWaypoints(y);
        }
      },
      backz: (y) => {
        const state = getState();
        const playerPos = state.gameState?.playerMinimapPosition;
        const { waypointSections, currentSection, wptId } = state.cavebot;
        const waypoints = waypointSections[currentSection]?.waypoints || [];
        const currentWpt = waypoints.find((wp) => wp.id === wptId);
        if (playerPos && currentWpt && playerPos.z !== currentWpt.z) {
          goBackWaypoints(y);
        }
      },
      pauseActions: (paused) =>
        context.postStoreUpdate('cavebot/setActionPaused', !!paused),
    };
  }
  const api = { ...baseApi, ...navigationApi };
  const stateObject = createStateShortcutObject(getState, type);
  const asyncApiFunctionSet = new Set(asyncFunctionNames);
  const apiProxy = new Proxy(api, {
    get(target, prop, receiver) {
      const originalMember = target[prop];
      if (
        typeof originalMember === 'function' &&
        asyncApiFunctionSet.has(prop)
      ) {
        return async (...args) => {
          if (onAsyncStart) {
            onAsyncStart();
          }
          try {
            // NEW: Auto-refresh state before executing async function
            if (typeof context.refreshLuaGlobalState === 'function') {
              await context.refreshLuaGlobalState(true);
            }
            return await originalMember.apply(target, args);
          } finally {
            if (onAsyncEnd) {
              onAsyncEnd();
            }
          }
        };
      }
      return Reflect.get(target, prop, receiver);
    },
  });

  // NEW: Create a Lua table that proxies access to the sharedLuaGlobals JS object
  lua.global.set('__automaton_index_handler', (table, key) => {
    return sharedLuaGlobals[key];
  });
  lua.global.set('__automaton_newindex_handler', (table, key, value) => {
    sharedLuaGlobals[key] = value;
    if (context.postGlobalVarUpdate) {
      context.postGlobalVarUpdate(key, value);
    }
  });
  await lua.doString(`
    local metatable = {
      __index = __automaton_index_handler,
      __newindex = __automaton_newindex_handler
    }
    SharedGlobals = {}
    setmetatable(SharedGlobals, metatable)
  `);
  const sharedGlobalsProxy = lua.global.get('SharedGlobals');
  lua.global.set('__automaton_index_handler', undefined);
  lua.global.set('__automaton_newindex_handler', undefined);

  return { api: apiProxy, asyncFunctionNames, stateObject, sharedGlobalsProxy }; // NEW: Return sharedGlobalsProxy
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaScriptProcessor.js
//start file
/**
 * @fileoverview Centralized processor for preparing Lua scripts for execution.
 * This module contains utility functions for manipulating Lua script code before
 * it is run by the wasmoon engine.
 */

/**
 * Replaces convenient '$' prefixed variables with their valid, secret internal counterparts.
 * This uses a regular expression to safely replace `$var` with `__BOT_STATE__.var`
 * to avoid conflicts with user-defined variables.
 *
 * @param {string} code - The raw Lua code from the user.
 * @returns {string} The processed code with valid Lua syntax.
 */
const replaceShortcutVariables = (code) => {
  // This regex finds a literal '$' followed by a valid Lua identifier
  // (starts with a letter or underscore, followed by letters, numbers, or underscores).
  const regex = /\$([a-zA-Z_][a-zA-Z0-9_]*)/g;
  // The replacement string '__BOT_STATE__.$1' uses the captured group ($1)
  // to construct the valid Lua code, e.g., '$hp' becomes '__BOT_STATE__.hp'.
  return code.replace(regex, '__BOT_STATE__.$1');
};

/**
 * Preprocesses a raw Lua script string to handle custom syntax.
 * This now runs as a two-step process:
 * 1. Replaces '$' shortcut variables (e.g., `$hp`) with their valid form (`__BOT_STATE__.hp`).
 * 2. Appends `:await()` to specified async function calls for wasmoon compatibility.
 *
 * @param {string} scriptCode - The raw Lua script to preprocess.
 * @param {string[]} asyncFunctionNames - A list of function names that are asynchronous and return Promises.
 * @returns {string} The fully processed script with valid syntax, ready for execution.
 */
export function preprocessLuaScript(scriptCode, asyncFunctionNames) {
  // Step 1: Replace $ variables
  let processedCode = replaceShortcutVariables(scriptCode);

  if (!asyncFunctionNames || asyncFunctionNames.length === 0) {
    return processedCode;
  }

  // Build regex for async functions
  const funcNamePattern = asyncFunctionNames.join('|');

  // This regex matches function calls that don't already have :await()
  const regex = new RegExp(
    `\\b(${funcNamePattern})\\s*\\((?:[^()]*|\\([^)]*\\))*\\)(?!:await\\(\\))`,
    'g',
  );

  processedCode = processedCode.replace(regex, (match) => {
    return `${match}:await()`;
  });

  return processedCode;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/luaScriptWorker.js
//start file
// luaScriptWorker.js

import { parentPort, workerData, threadId } from 'worker_threads';
import { LuaFactory } from 'wasmoon';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createLogger } from '../utils/logger.js';
import { createLuaApi } from './luaApi.js';
import { createStateShortcutObject } from './luaApi.js';
import { preprocessLuaScript } from './luaScriptProcessor.js';
import Pathfinder from 'pathfinder-native';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const log = createLogger({ info: false, error: true, debug: false });
let lua;
let currentState = {};
let scriptConfig = {};
let loopInterval = null;
let asyncFunctionNames = [];
let keepAliveInterval = null;
let apiInitialized = false;
let pathfinderInstance = null;

// --- State machine to prevent shutdown during init ---
let workerState = 'pending'; // 'pending' | 'initializing' | 'running'
let shutdownRequested = false;

// --- Active async operation counter ---
let activeAsyncOperations = 0;
const onAsyncStart = () => activeAsyncOperations++;
const onAsyncEnd = () => activeAsyncOperations--;

const getFreshState = () =>
  new Promise((res, rej) => {
    const timeout = setTimeout(() => {
      parentPort.off('message', onSnap);
      rej(new Error('Timeout waiting for state snapshot from main thread.'));
    }, 5000); // 5 second timeout

    const onSnap = (msg) => {
      if (msg.type === 'state_snapshot') {
        clearTimeout(timeout);
        parentPort.off('message', onSnap);
        res(msg.payload);
      }
    };
    parentPort.on('message', onSnap);
    parentPort.postMessage({ type: 'request_state_snapshot' });
  });

const postStoreUpdate = (type, payload) => {
  parentPort.postMessage({ storeUpdate: true, type, payload });
};

const postGlobalVarUpdate = (key, value) => {
  parentPort.postMessage({
    type: 'lua_global_update',
    payload: { key, value },
  });
};

const keepAlive = () => {
  if (keepAliveInterval) return;
  keepAliveInterval = setInterval(() => {}, 60 * 60 * 1000);
};

const cleanupAndExit = async () => {
  log(
    'info',
    `[Lua Script Worker ${scriptConfig.id}] Cleaning up and exiting.`,
  );
  stopScriptLoop();
  if (keepAliveInterval) clearInterval(keepAliveInterval);

  const maxWait = 5000;
  const start = Date.now();
  while (activeAsyncOperations > 0 && Date.now() - start < maxWait) {
    // Silently wait for operations to finish, checking less frequently to throttle.
    await new Promise((r) => setTimeout(r, 250));
  }

  if (activeAsyncOperations > 0) {
    log(
      'warn',
      `[Lua Script Worker ${scriptConfig.id}] Exiting with ${activeAsyncOperations} async operations still pending after timeout.`,
    );
  }

  if (pathfinderInstance) {
    try {
      pathfinderInstance.destroy();
    } catch (e) {
      log(
        'error',
        `[Lua Script Worker ${scriptConfig.id}] pathfinder cleanup error: ${e.message}`,
      );
    }
  }

  if (lua) {
    try {
      lua.global.close();
    } catch (e) {
      log(
        'error',
        `[Lua Script Worker ${scriptConfig.id}] close error: ${e.message}`,
      );
    }
  }
  process.exit(0);
};

const loadLuaLibraries = async () => {
  if (!lua) return;
  const libPath = path.join(__dirname, 'lua', 'lib');
  try {
    const files = await fs.readdir(libPath);
    for (const file of files) {
      if (path.extname(file) === '.lua') {
        const filePath = path.join(libPath, file);
        const content = await fs.readFile(filePath, 'utf8');
        await lua.doString(content);
        log(
          'info',
          `[Lua Script Worker ${scriptConfig.id}] Loaded Lua library: ${file}`,
        );
      }
    }
  } catch (error) {
    if (error.code !== 'ENOENT') {
      log(
        'error',
        `[Lua Script Worker ${scriptConfig.id}] Error loading Lua libraries:`,
        error,
      );
    } else {
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] No Lua libraries found to load.`,
      );
    }
  }
};

const initializeLuaVM = async () => {
  log('info', `[Lua Script Worker ${scriptConfig.id}] Initializing Lua VM…`);
  try {
    const factory = new LuaFactory();
    lua = await factory.createEngine();
    await loadLuaLibraries();
    log('info', `[Lua Script Worker ${scriptConfig.id}] Lua VM ready.`);
  } catch (error) {
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] VM init failed:`,
      error,
    );
    throw error;
  }
};

const initializeLuaApi = async () => {
  if (!lua) {
    log(
      'warn',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: Lua VM not available.`,
    );
    return;
  }
  if (apiInitialized) {
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: API already initialized.`,
    );
    return;
  }

  try {
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: Requesting fresh state.`,
    );
    currentState = await getFreshState();
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: Fresh state received.`,
    );

    const { api, asyncFunctionNames: newNames } = await createLuaApi({
      type: 'script',
      getState: () => currentState,
      postSystemMessage: (m) => parentPort.postMessage(m),
      logger: log,
      id: scriptConfig.id,
      postStoreUpdate,
      postGlobalVarUpdate,
      refreshLuaGlobalState: syncDynamicStateToLua, // Pass the sync function
      onAsyncStart,
      onAsyncEnd,
      sharedLuaGlobals: workerData.sharedLuaGlobals,
      lua: lua,
      postInputAction: (action) =>
        parentPort.postMessage({ type: 'inputAction', payload: action }),
      pathfinderInstance: pathfinderInstance,
    });

    asyncFunctionNames = newNames;
    for (const fn in api) {
      lua.global.set(fn, api[fn]);
    }

    apiInitialized = true;
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: API setup complete.`,
    );
  } catch (error) {
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] initializeLuaApi: Error during API initialization: ${error.message}`,
      error,
    );
    throw error; // Re-throw to be caught by the init handler's try/catch
  }
};

const initializePathfinder = async () => {
  log(
    'info',
    `[Lua Script Worker ${scriptConfig.id}] Initializing Pathfinder instance...`,
  );
  try {
    pathfinderInstance = new Pathfinder.Pathfinder();
    const fs = await import('fs/promises');
    const path = await import('path');
    const mapDataForAddon = {};
    const baseDir = workerData.paths?.minimapResources;

    if (!baseDir) {
      throw new Error('minimapResources path not provided');
    }

    const zLevelDirs = (await fs.readdir(baseDir, { withFileTypes: true }))
      .filter((d) => d.isDirectory() && d.name.startsWith('z'))
      .map((d) => d.name);

    for (const zDir of zLevelDirs) {
      const zLevel = parseInt(zDir.substring(1), 10);
      const zLevelPath = path.join(baseDir, zDir);
      try {
        const metadata = JSON.parse(
          await fs.readFile(path.join(zLevelPath, 'walkable.json'), 'utf8'),
        );
        const grid = await fs.readFile(path.join(zLevelPath, 'walkable.bin'));
        mapDataForAddon[zLevel] = { ...metadata, grid };
      } catch (e) {
        if (e.code !== 'ENOENT')
          log(
            'error',
            `[Lua Script Worker ${scriptConfig.id}] Could not load path data for Z=${zLevel}: ${e.message}`,
          );
      }
    }

    pathfinderInstance.loadMapData(mapDataForAddon);
    if (pathfinderInstance.isLoaded) {
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] Pathfinder instance loaded map data successfully.`,
      );
    } else {
      throw new Error('Pathfinder failed to load map data.');
    }
  } catch (err) {
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] Could not initialize Pathfinder instance:`,
      err,
    );
    pathfinderInstance = null;
  }
};

const syncDynamicStateToLua = async () => {
  if (!lua || !apiInitialized) return;

  try {
    const freshState = await getFreshState();
    if (freshState) {
      currentState = freshState;
      const stateObject = createStateShortcutObject(
        () => currentState,
        'script',
      );
      lua.global.set('__BOT_STATE__', stateObject);
    }
  } catch (e) {
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] Failed to get fresh state: ${e.message}`,
    );
  }
};

const executeOneShot = async () => {
  log(
    'info',
    `[Lua Script Worker ${scriptConfig.id}] Executing one-shot script.`,
  );

  if (!lua) {
    const errorMsg = 'Lua VM not ready.';
    log(
      'error',
      `[Lua Script Worker ${scriptConfig.id}] one-shot error: ${errorMsg}`,
    );
    parentPort.postMessage({
      type: 'scriptExecutionResult',
      payload: {
        id: scriptConfig.id,
        success: false,
        error: errorMsg,
        isCavebotScript: workerData.isCavebotScript,
      },
    });
    return; // Still return if Lua VM is not ready, as API init will fail
  }

  // Initialize API even for empty scripts to ensure SharedGlobals are set up
  await initializeLuaApi();
  log(
    'debug',
    `[Lua Script Worker ${scriptConfig.id}] Lua API initialized for one-shot script.`,
  );

  if (!scriptConfig.code?.trim()) {
    const infoMsg = 'No script code provided. Script will do nothing.';
    log('info', `[Lua Script Worker ${scriptConfig.id}] one-shot: ${infoMsg}`);
    parentPort.postMessage({
      type: 'scriptExecutionResult',
      payload: {
        id: scriptConfig.id,
        success: true, // An empty script is not an error, it just does nothing.
        error: null,
        isCavebotScript: workerData.isCavebotScript,
      },
    });
    return; // Return after sending result for empty script
  }

  try {
    await syncDynamicStateToLua();
    // Log SharedGlobals.asd before execution
    const sharedAsdValue = workerData.sharedLuaGlobals.asd;
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] Lua script sees SharedGlobals.asd as: ${sharedAsdValue}`,
    );

    const processedCode = preprocessLuaScript(
      scriptConfig.code,
      asyncFunctionNames,
    );
    await lua.doString(processedCode);

    // NEW: Wait for any pending async operations triggered by the script to complete
    const asyncWaitStart = Date.now();
    while (activeAsyncOperations > 0) {
      if (Date.now() - asyncWaitStart > 60000) { // 60-second timeout
        log('error', `[Lua Script Worker ${scriptConfig.id}] Timeout waiting for ${activeAsyncOperations} async operations to complete.`);
        activeAsyncOperations = 0; // Reset to prevent infinite loop
        break;
      }
      await new Promise(resolve => setTimeout(resolve, 10)); // Poll every 10ms
    }

    parentPort.postMessage({
      type: 'scriptExecutionResult',
      payload: {
        id: scriptConfig.id,
        success: true,
        isCavebotScript: workerData.isCavebotScript,
      },
    });
  } catch (error) {
    const msg = error.message || String(error);
    log('error', `[Lua Script Worker ${scriptConfig.id}] one-shot error:`, msg);
    postStoreUpdate('lua/addLogEntry', {
      id: scriptConfig.id,
      message: `[ERROR] ${msg}`,
    });
    parentPort.postMessage({
      type: 'scriptExecutionResult',
      payload: {
        id: scriptConfig.id,
        success: false,
        error: msg,
        isCavebotScript: workerData.isCavebotScript,
      },
    });
  }
};

const executeScriptLoop = async () => {
  if (!lua) return stopScriptLoop();
  if (!scriptConfig.code?.trim()) {
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] Script empty; skipping.`,
    );
  } else {
    try {
      await syncDynamicStateToLua();
      // Log SharedGlobals.asd before execution
      const sharedAsdValue = workerData.sharedLuaGlobals.asd;
      log(
        'debug',
        `[Lua Script Worker ${scriptConfig.id}] Lua script sees SharedGlobals.asd as: ${sharedAsdValue}`,
      );

      await lua.doString(
        preprocessLuaScript(scriptConfig.code, asyncFunctionNames),
      );

      // NEW: Wait for any pending async operations triggered by the script to complete
      const asyncWaitStart = Date.now();
      while (activeAsyncOperations > 0) {
        if (Date.now() - asyncWaitStart > 60000) { // 60-second timeout
          log('error', `[Lua Script Worker ${scriptConfig.id}] Timeout waiting for ${activeAsyncOperations} async operations to complete.`);
          activeAsyncOperations = 0; // Reset to prevent infinite loop
          break;
        }
        await new Promise(resolve => setTimeout(resolve, 10)); // Poll every 10ms
      }
    } catch (error) {
      const msg = error.message || String(error);
      log('error', `[Lua Script Worker ${scriptConfig.id}] loop error:`, msg);
      postStoreUpdate('lua/addLogEntry', {
        id: scriptConfig.id,
        message: `[ERROR] ${msg}`,
      });
    }
  }
  const min = scriptConfig.loopMin || 100;
  const max = scriptConfig.loopMax || 200;
  const delay = Math.floor(Math.random() * (max - min + 1)) + min;
  loopInterval = setTimeout(executeScriptLoop, delay);
};

const startScriptLoop = () => {
  if (loopInterval) clearTimeout(loopInterval);
  log('info', `[Lua Script Worker ${scriptConfig.id}] Starting script loop.`);
  executeScriptLoop();
};

const stopScriptLoop = () => {
  if (loopInterval) {
    log('info', `[Lua Script Worker ${scriptConfig.id}] Stopping script loop.`);
    clearTimeout(loopInterval);
    loopInterval = null;
  }
};

/* ------------ message router ------------ */
parentPort.on('message', async (message) => {
  if (message.type === 'shutdown') {
    shutdownRequested = true;
    if (workerState === 'running') await cleanupAndExit();
    return;
  }

  if (message.type === 'lua_global_broadcast') {
    const { key, value } = message.payload;
    log(
      'debug',
      `[Lua Script Worker ${scriptConfig.id}] Received lua_global_broadcast: key=${key}, value=${value}`,
    );
    if (workerData.sharedLuaGlobals) {
      workerData.sharedLuaGlobals[key] = value;
      log(
        'debug',
        `[Lua Script Worker ${scriptConfig.id}] workerData.sharedLuaGlobals.${key} updated to: ${workerData.sharedLuaGlobals[key]}`,
      );
    }
    return;
  }

  if (message.type === 'init') {
    workerState = 'initializing';
    scriptConfig = message.script;
    log(
      'info',
      `[Lua Script Worker ${scriptConfig.id}] Init received. Script config:`,
      scriptConfig,
    );

    await initializeLuaVM();
    if (shutdownRequested) {
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] Shutdown requested during initialization. Exiting.`,
      );
      await cleanupAndExit();
      return;
    }

    await initializePathfinder();
    await initializeLuaApi();
    log('info', `[Lua Script Worker ${scriptConfig.id}] Lua API initialized.`);

    workerState = 'running';
    log(
      'info',
      `[Lua Script Worker ${scriptConfig.id}] Worker state set to running.`,
    );

    if (scriptConfig.type === 'oneshot') {
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] Executing one-shot script.`,
      );
      await executeOneShot();
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] One-shot script execution finished.`,
      );
      // For one-shot scripts, we should exit after execution
      await cleanupAndExit();
    } else {
      log(
        'info',
        `[Lua Script Worker ${scriptConfig.id}] Starting script loop.`,
      );
      startScriptLoop();
      keepAlive();
    }
    return;
  }

  if (message.type === 'update') {
    scriptConfig = message.script;
    return;
  }

  if (message.type === 'state_snapshot') {
    currentState = message.payload;
  } else if (message.type === 'state_diff') {
    // Apply partial state updates
    if (!currentState) currentState = {};
    Object.assign(currentState, message.payload);
  }
});

parentPort.on('close', async () => {
  log('info', `[Lua Script Worker ${scriptConfig.id}] Parent port closed.`);
  await cleanupAndExit();
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/config.js
//start file
import { PALETTE_DATA } from '../../constants/palette.js';

// --- Worker Timing ---

// --- Performance Logging ---
export const PERFORMANCE_LOGGING_ENABLED = false; // Set to false to disable logging
export const PERFORMANCE_LOG_INTERVAL_MS = 10000; // Log stats every 10 seconds

// --- SharedArrayBuffer (SAB) Indices ---
export const FRAME_COUNTER_INDEX = 0;
// ... (rest of the file is unchanged)
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

// --- Image Buffer Constants ---
export const HEADER_SIZE = 8;
export const BYTES_PER_PIXEL = 4;

// --- Minimap Specifics ---
export const MINIMAP_WIDTH = 106;
export const MINIMAP_HEIGHT = 109;
export const LANDMARK_SIZE = 3;
/**
 * A pre-computed map for fast lookups of a color's 8-bit palette index.
 * Key: An integer representing an RGB color (e.g., (r << 16) | (g << 8) | b).
 * Value: The 8-bit index from the palette.
 */
export const colorToIndexMap = new Map();
PALETTE_DATA.forEach((color, index) => {
  const intKey = (color.r << 16) | (color.g << 8) | color.b;
  colorToIndexMap.set(intKey, index);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/core.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/core.js
import { parentPort, workerData } from 'worker_threads';
import {
  MinimapMatcher,
  setMinimapResourcesPath,
} from '../../utils/minimapMatcher.js';
import * as config from './config.js';
import { extractBGRA } from './helpers.js';
import { processMinimapData } from './processing.js';
import { LANDMARK_SIZE } from './config.js';

let currentState = null;
let isShuttingDown = false;
let isInitialized = false;
let minimapMatcher = null;
let isProcessing = false;
let needsReProcessing = false;
let dirtyRectsQueue = [];
let lastProcessedTime = Date.now();

const { imageSAB, syncSAB } = workerData.sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

async function initialize() {
  console.log('[MinimapCore] Initializing...');
  setMinimapResourcesPath(workerData.paths.minimapResources);

  const LANDMARK_PATTERN_BYTES = Math.ceil((LANDMARK_SIZE * LANDMARK_SIZE) / 2);

  minimapMatcher = new MinimapMatcher({
    LANDMARK_SIZE: LANDMARK_SIZE,
    LANDMARK_PATTERN_BYTES: LANDMARK_PATTERN_BYTES,
  });
  await minimapMatcher.loadMapData();
  isInitialized = true;
  console.log('[MinimapCore] Initialized successfully.');
}

async function performOperation(dirtyRects) {
  if (!isInitialized || !currentState?.regionCoordinates?.regions) {
    return;
  }

  const { minimapFull, minimapFloorIndicatorColumn } =
    currentState.regionCoordinates.regions;
  const screenWidth = Atomics.load(syncArray, config.WIDTH_INDEX);
  if (!minimapFull || !minimapFloorIndicatorColumn || screenWidth <= 0) return;

  const minimapData = extractBGRA(sharedBufferView, screenWidth, minimapFull);
  const floorIndicatorData = extractBGRA(
    sharedBufferView,
    screenWidth,
    minimapFloorIndicatorColumn,
  );

  if (minimapData && floorIndicatorData) {
    await processMinimapData(
      minimapData,
      floorIndicatorData,
      minimapMatcher,
      workerData,
    );
    lastProcessedTime = Date.now();
  }
}

async function processFrames(force = false) {
  if (isProcessing) {
    needsReProcessing = true;
    return;
  }

  if (dirtyRectsQueue.length === 0 && !force) {
    return;
  }

  isProcessing = true;

  try {
    if (dirtyRectsQueue.length > 0) {
      while (dirtyRectsQueue.length > 0) {
        const currentDirtyRects = dirtyRectsQueue.shift();
        await performOperation(currentDirtyRects);
      }
    } else if (force) {
      await performOperation(null);
    }
  } catch (error) {
    console.error('[MinimapCore] Error during frame processing:', error);
  } finally {
    isProcessing = false;
    if (needsReProcessing) {
      needsReProcessing = false;
      setTimeout(processFrames, 0);
    }
  }
}

function handleMessage(message) {
  if (message.type === 'frame-update') {
    if (message.payload.dirtyRects && message.payload.dirtyRects.length > 0) {
      dirtyRectsQueue.push(message.payload.dirtyRects);
    }
    processFrames();
    return;
  }

  if (message.type === 'shutdown') {
    console.log('[MinimapCore] Received shutdown command.');
    isShuttingDown = true;
  } else if (message.type === 'state_diff') {
    if (!currentState) currentState = {};
    Object.assign(currentState, message.payload);
  } else if (typeof message === 'object' && !message.type) {
    currentState = message;
    if (!isInitialized) {
      initialize().catch((err) => {
        console.error('[MinimapCore] Initialization failed:', err);
        process.exit(1);
      });
    }
  }
}

export function start() {
  console.log('[MinimapCore] Worker starting up.');
  parentPort.on('message', handleMessage);

  setInterval(() => {
    if (isShuttingDown) {
      return;
    }
    if (Date.now() - lastProcessedTime > 1000) {
      processFrames(true);
    }
  }, 200);
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/helpers.js
//start file
import { HEADER_SIZE, BYTES_PER_PIXEL } from './config.js';

/**
 * Checks if two rectangle objects intersect.
 * @returns {boolean} True if the rectangles overlap.
 */
export function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

/**
 * Extracts a rectangular region of raw BGRA pixel data from a larger buffer.
 * @param {Buffer} sourceBuffer - The full screen capture buffer.
 * @param {number} sourceWidth - The width of the full screen capture.
 * @param {object} rect - The {x, y, width, height} of the region to extract.
 * @returns {Buffer|null} A new Buffer containing the extracted region, or null on error.
 */
export function extractBGRA(sourceBuffer, sourceWidth, rect) {
  if (!rect || rect.width <= 0 || rect.height <= 0) {
    return null;
  }

  const targetSize = rect.width * rect.height * BYTES_PER_PIXEL;
  const targetBuffer = Buffer.alloc(targetSize);

  for (let y = 0; y < rect.height; y++) {
    const sourceY = rect.y + y;
    const sourceRowStart =
      HEADER_SIZE + (sourceY * sourceWidth + rect.x) * BYTES_PER_PIXEL;
    const targetRowStart = y * rect.width * BYTES_PER_PIXEL;

    if (
      sourceRowStart < 0 ||
      sourceRowStart + rect.width * BYTES_PER_PIXEL > sourceBuffer.length
    ) {
      console.error('[MinimapHelpers] Buffer copy out of bounds.');
      return null;
    }

    sourceBuffer.copy(
      targetBuffer,
      targetRowStart,
      sourceRowStart,
      sourceRowStart + rect.width * BYTES_PER_PIXEL,
    );
  }

  return targetBuffer;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  /**
   * Resets all statistics to their initial state.
   */
  reset() {
    this.times = [];
    this.minTime = Infinity;
    this.maxTime = 0;
    this.totalTime = 0;
  }

  /**
   * Adds a new duration measurement to the tracker.
   * @param {number} duration - The time in milliseconds for an operation.
   */
  addMeasurement(duration) {
    this.times.push(duration);
    this.totalTime += duration;
    if (duration < this.minTime) this.minTime = duration;
    if (duration > this.maxTime) this.maxTime = duration;
  }

  /**
   * Calculates the median from the collected times.
   * @returns {number} The median value.
   */
  _calculateMedian() {
    const sorted = [...this.times].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    }
    return sorted[mid];
  }

  /**
   * Generates a formatted string of the current performance statistics.
   * @returns {string|null} A report string or null if no data is available.
   */
  getReport() {
    const iterations = this.times.length;
    if (iterations === 0) {
      return '[MinimapPerformance] No successful operations in the last period.';
    }

    const avg = this.totalTime / iterations;
    const median = this._calculateMedian();

    const report = [
      '[MinimapPerformance] Stats:',
      `${iterations} iterations |`,
      `Avg: ${avg.toFixed(2)}ms |`,
      `Median: ${median.toFixed(2)}ms |`,
      `Min: ${this.minTime.toFixed(2)}ms |`,
      `Max: ${this.maxTime.toFixed(2)}ms`,
    ].join(' ');

    return report;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimap/processing.js
//start file
// minimap/processing.js (Updated)

import { parentPort } from 'worker_threads';
import { performance } from 'perf_hooks';
import findSequences from 'find-sequences-native';
import { floorLevelIndicators } from '../../constants/index.js';
import {
  MINIMAP_WIDTH,
  MINIMAP_HEIGHT,
  HEADER_SIZE,
  colorToIndexMap,
} from './config.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
} from '../sharedConstants.js';

let lastWrittenPosition = null;

// Pre-allocate the buffer for minimap processing to avoid re-allocation on every frame.
const minimapIndexData = new Uint8Array(MINIMAP_WIDTH * MINIMAP_HEIGHT);

/**
 * Analyzes minimap and floor indicator data to determine player position.
 * @returns {Promise<number|null>} The processing duration in ms if successful, otherwise null.
 */
export async function processMinimapData(
  minimapBuffer,
  floorIndicatorBuffer,
  minimapMatcher,
  workerData,
) {
  const startTime = performance.now();
  const { playerPosSAB } = workerData;
  const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;

  try {
    const floorIndicatorSearchBuffer = Buffer.alloc(
      HEADER_SIZE + floorIndicatorBuffer.length,
    );
    floorIndicatorSearchBuffer.writeUInt32LE(2, 0);
    floorIndicatorSearchBuffer.writeUInt32LE(63, 4);
    floorIndicatorBuffer.copy(floorIndicatorSearchBuffer, HEADER_SIZE);

    const searchResults = await findSequences.findSequencesNativeBatch(
      floorIndicatorSearchBuffer,
      {
        floor: {
          sequences: floorLevelIndicators,
          searchArea: { x: 0, y: 0, width: 2, height: 63 },
          occurrence: 'first',
        },
      },
    );

    const foundFloor = searchResults.floor || {};
    const floorKey = Object.keys(foundFloor).reduce(
      (lowest, key) =>
        foundFloor[key] !== null && foundFloor[key].y < lowest.y
          ? { key, y: foundFloor[key].y }
          : lowest,
      { key: null, y: Infinity },
    ).key;
    const detectedZ = floorKey !== null ? parseInt(floorKey, 10) : null;

    if (detectedZ === null) return null;

    for (let i = 0; i < minimapIndexData.length; i++) {
      const p = i * 4;
      // BGRA to RGB integer key
      const key =
        (minimapBuffer[p + 2] << 16) |
        (minimapBuffer[p + 1] << 8) |
        minimapBuffer[p];
      minimapIndexData[i] = colorToIndexMap.get(key) ?? 0;
    }

    const result = await minimapMatcher.findPosition(
      minimapIndexData,
      MINIMAP_WIDTH,
      MINIMAP_HEIGHT,
      detectedZ,
    );

    if (result?.position) {
      const newPos = {
        ...result.position,
        positionSearchMs: result.performance?.totalTimeMs?.toFixed(2) || 0,
      };

      if (
        !lastWrittenPosition ||
        newPos.x !== lastWrittenPosition.x ||
        newPos.y !== lastWrittenPosition.y ||
        newPos.z !== lastWrittenPosition.z
      ) {
        // --- FIX START: Directly update Redux from minimapMonitor ---
        // Post a message to the main thread to update the global Redux store.
        parentPort.postMessage({
          type: 'batch-update',
          payload: [
            {
              type: 'gameState/setPlayerMinimapPosition',
              payload: newPos,
            },
            {
              type: 'gameState/setLastMoveTime',
              payload: Date.now(),
            },
          ],
        });
        // --- FIX END ---

        // Update SharedArrayBuffer for other workers (like targetMonitor) to consume.
        if (playerPosArray) {
          Atomics.store(playerPosArray, PLAYER_X_INDEX, newPos.x);
          Atomics.store(playerPosArray, PLAYER_Y_INDEX, newPos.y);
          Atomics.store(playerPosArray, PLAYER_Z_INDEX, newPos.z);
          Atomics.add(playerPosArray, PLAYER_POS_UPDATE_COUNTER_INDEX, 1);
          Atomics.notify(playerPosArray, PLAYER_POS_UPDATE_COUNTER_INDEX);
        }

        lastWrittenPosition = newPos;
      }

      return performance.now() - startTime;
    }
  } catch (err) {
    console.error(`[MinimapProcessing] Error: ${err.message}`);
  }

  return null;
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/minimapMonitor.js
//start file
/**
 * @file minimap-monitor.js
 * @summary A dedicated worker for analyzing minimap data to determine player position.
 * @description This file is the entry point for the minimap worker. It delegates
 * all logic to the modules in the /minimap sub-directory.
 */

import { start } from './minimap/core.js';

try {
  start();
} catch (error) {
  console.error('[MinimapMonitor] Failed to start worker core:', error);
  process.exit(1);
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/config.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/config.js
// --- MODIFIED ---

import { regionParsers } from './parsers.js';
import regionDefinitions from '../../constants/regionDefinitions.js';

export const MAIN_LOOP_INTERVAL = 5;

export const FRAME_COUNTER_INDEX = 0;
export const WIDTH_INDEX = 1;
export const HEIGHT_INDEX = 2;
export const IS_RUNNING_INDEX = 3;
export const DIRTY_REGION_COUNT_INDEX = 5;
export const DIRTY_REGIONS_START_INDEX = 6;

export const CHAR_PRESETS = {
  LOWERCASE: 'abcdefghijklmnopqrstuvwxyz',
  UPPERCASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  NUMERIC: '0123456789',
  SPECIAL: `~!@#$%^&*()_+{}|":?><-=[];'./ `,
};
CHAR_PRESETS.ALL =
  CHAR_PRESETS.LOWERCASE +
  CHAR_PRESETS.NUMERIC +
  CHAR_PRESETS.SPECIAL +
  CHAR_PRESETS.UPPERCASE;
CHAR_PRESETS.ALPHA = CHAR_PRESETS.LOWERCASE + CHAR_PRESETS.UPPERCASE;
CHAR_PRESETS.ALPHANUMERIC = CHAR_PRESETS.ALPHA + CHAR_PRESETS.NUMERIC;

export const OCR_REGION_CONFIGS = {
  skillsWidget: {
    colors: regionDefinitions.skillsWidget?.ocrColors,
    parser: regionParsers.skillsWidget,
    storeAction: 'uiValues/setSkillsWidget',
    allowedChars: CHAR_PRESETS.ALPHANUMERIC + ' .:,',
    throttleMs: 250, // NEW
  },
  chatBoxTabRow: {
    colors: regionDefinitions.chatBoxTabRow?.ocrColors,
    parser: regionParsers.chatBoxTabRow,
    storeAction: 'uiValues/setChatTabs',
    allowedChars: CHAR_PRESETS.ALPHA + ' ',
    throttleMs: 500, // NEW
  },
  selectCharacterModal: {
    colors: regionDefinitions.selectCharacterModal?.ocrColors,
    parser: regionParsers.selectCharacterModal,
    storeAction: 'uiValues/setSelectCharacterModal',
    allowedChars: CHAR_PRESETS.ALPHA + ' ',
    throttleMs: 100, // NEW
  },
  vipWidget: {
    colors: regionDefinitions.vipWidget?.ocrColors,
    parser: regionParsers.vipWidget,
    storeAction: 'uiValues/setVipWidget',
    allowedChars: CHAR_PRESETS.ALPHA + ' ',
    throttleMs: 2000, // NEW
  },
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/core.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/core.js
// --- REFACTORED ---

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import * as config from './config.js';
import { rectsIntersect, processOcrRegions } from './processing.js';

// --- Worker Configuration & Setup ---
const { sharedData } = workerData;
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

// --- State ---
let currentState = null;
let isShuttingDown = false;
let isInitialized = false;
let lastProcessedFrameCounter = -1;
let lastBattleListProcessTime = 0;
let lastRegionHash = null;
let oneTimeInitializedRegions = new Set();
const pendingThrottledRegions = new Map();

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function hashRegionCoordinates(regionCoordinates) {
  if (!regionCoordinates || typeof regionCoordinates !== 'object') {
    return JSON.stringify(regionCoordinates);
  }
  const replacer = (key, value) =>
    value instanceof Object && !(value instanceof Array)
      ? Object.keys(value)
          .sort()
          .reduce((sorted, key) => {
            sorted[key] = value[key];
            return sorted;
          }, {})
      : value;
  return JSON.stringify(regionCoordinates, replacer);
}

async function processPendingRegions() {
  if (pendingThrottledRegions.size === 0) return;
  const now = Date.now();
  const regionsToProcessNow = new Set();
  for (const [regionKey, startTime] of pendingThrottledRegions.entries()) {
    const regionConfig = config.OCR_REGION_CONFIGS[regionKey];
    if (now - startTime >= (regionConfig.throttle || 0)) {
      regionsToProcessNow.add(regionKey);
    }
  }
  if (regionsToProcessNow.size > 0) {
    await processOcrRegions(
      sharedBufferView,
      currentState.regionCoordinates.regions,
      regionsToProcessNow,
    );
    for (const regionKey of regionsToProcessNow) {
      pendingThrottledRegions.delete(regionKey);
    }
  }
}

async function performOperation() {
  try {
    if (!isInitialized || !currentState || !currentState.regionCoordinates)
      return;

    const newFrameCounter = Atomics.load(syncArray, config.FRAME_COUNTER_INDEX);
    if (
      newFrameCounter <= lastProcessedFrameCounter ||
      Atomics.load(syncArray, config.IS_RUNNING_INDEX) !== 1
    ) {
      return;
    }

    const width = Atomics.load(syncArray, config.WIDTH_INDEX);
    const height = Atomics.load(syncArray, config.HEIGHT_INDEX);
    const { regions } = currentState.regionCoordinates;
    if (Object.keys(regions).length === 0 || width <= 0 || height <= 0) return;

    lastProcessedFrameCounter = newFrameCounter;

    const dirtyRegionCount = Atomics.load(
      syncArray,
      config.DIRTY_REGION_COUNT_INDEX,
    );
    const dirtyRects = [];
    for (let i = 0; i < dirtyRegionCount; i++) {
      const offset = config.DIRTY_REGIONS_START_INDEX + i * 4;
      dirtyRects.push({
        x: Atomics.load(syncArray, offset + 0),
        y: Atomics.load(syncArray, offset + 1),
        width: Atomics.load(syncArray, offset + 2),
        height: Atomics.load(syncArray, offset + 3),
      });
    }

    const processingTasks = [];
    const immediateGenericRegions = new Set();

    // --- MODIFIED LOGIC ---

    // 2. Handle all other generic OCR regions.
    for (const regionKey in config.OCR_REGION_CONFIGS) {
      if (regionKey === 'gameWorld') continue;
      const region = regions[regionKey];
      if (!region) continue;

      const isDirty = dirtyRects.some((dirtyRect) =>
        rectsIntersect(region, dirtyRect),
      );
      const needsOneTimeInit = !oneTimeInitializedRegions.has(regionKey);

      if (isDirty || needsOneTimeInit) {
        const regionConfig = config.OCR_REGION_CONFIGS[regionKey];
        if (regionConfig.throttle && !needsOneTimeInit) {
          if (!pendingThrottledRegions.has(regionKey)) {
            pendingThrottledRegions.set(regionKey, Date.now());
          }
        } else {
          immediateGenericRegions.add(regionKey);
          if (needsOneTimeInit) {
            oneTimeInitializedRegions.add(regionKey);
          }
        }
      }
    }

    if (immediateGenericRegions.size > 0) {
      processingTasks.push(
        processOcrRegions(sharedBufferView, regions, immediateGenericRegions),
      );
    }
    // --- END MODIFICATION ---

    if (processingTasks.length > 0) {
      await Promise.all(processingTasks);
    }
  } catch (error) {
    console.error('[OcrCore] Error in operation:', error);
  }
}

async function mainLoop() {
  console.log('[OcrCore] Starting main loop...');
  while (!isShuttingDown) {
    const loopStart = performance.now();
    if (isInitialized) {
      await performOperation();
      await processPendingRegions();
    }
    const elapsedTime = performance.now() - loopStart;
    const delayTime = Math.max(0, config.MAIN_LOOP_INTERVAL - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  console.log('[OcrCore] Main loop stopped.');
}

function handleMessage(message) {
  try {
    if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      const payload = message.payload;
      if (payload.regionCoordinates) {
        const newHash = hashRegionCoordinates(payload.regionCoordinates);
        if (newHash !== lastRegionHash) {
          lastRegionHash = newHash;
          oneTimeInitializedRegions.clear();
        }
      }
      Object.assign(currentState, payload);
    } else if (message.type === 'shutdown') {
      isShuttingDown = true;
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
      lastRegionHash = hashRegionCoordinates(message.regionCoordinates || {});
      oneTimeInitializedRegions.clear();
      if (!isInitialized) {
        isInitialized = true;
        console.log('[OcrCore] Initial state received. Worker is now active.');
      }
    }
  } catch (error) {
    console.error('[OcrCore] Error handling message:', error);
  }
}

export async function start() {
  console.log('[OcrCore] Worker starting up...');
  if (!workerData?.sharedData) {
    throw new Error('[OcrCore] Shared data not provided');
  }
  parentPort.on('message', handleMessage);
  mainLoop().catch((error) => {
    console.error('[OcrCore] Fatal error in main loop:', error);
    process.exit(1);
  });
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/parsers.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/parsers.js
// --- MODIFIED ---

/**
 * @file parsers.js
 * @summary The single source of truth for parsing all OCR data.
 * @description This module contains powerful parsers that transform raw OCR text
 * into the final, structured objects ready for the Redux state.
 */

function timeStringToMinutes(timeStr) {
  if (typeof timeStr !== 'string') {
    return null;
  }
  const normalizedTime = timeStr.replace('.', ':');
  const parts = normalizedTime.split(':');
  if (parts.length !== 2) return null;
  const hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);
  if (isNaN(hours) || isNaN(minutes)) return null;
  return hours * 60 + minutes;
}

function parseSkillsWidget(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0) return null;
  const result = {};
  const skills = {};
  const combat = {};
  const validData = ocrData.filter(
    (item) =>
      item.text &&
      item.text.trim() &&
      !item.text.match(/^[-\s]*$/) &&
      item.text !== 'alue',
  );
  const rows = new Map();
  validData.forEach((item) => {
    let rowKey = Array.from(rows.keys()).find(
      (key) => Math.abs(item.y - key) <= 5,
    );
    if (rowKey === undefined) rowKey = item.y;
    if (!rows.has(rowKey)) rows.set(rowKey, []);
    rows.get(rowKey).push(item);
  });
  Array.from(rows.values()).forEach((row) => {
    row.sort((a, b) => a.x - b.x);
    for (let i = 0; i < row.length - 1; i++) {
      const label = row[i].text.trim().toLowerCase();
      const value = row[i + 1]?.text?.trim();
      if (!value) continue;
      switch (label) {
        case 'level':
          result.level = parseInt(value) || null;
          break;
        case 'experience':
          result.experience = parseInt(value.replace(/,/g, '')) || null;
          break;
        case 'xp gain rate':
          result.xpGainRate = parseFloat(value.replace('%', '')) || null;
          break;
        case 'hit points':
          result.hitPoints = parseInt(value) || null;
          break;
        case 'mana':
          result.mana = parseInt(value) || null;
          break;
        case 'soul points':
          result.soulPoints = parseInt(value) || null;
          break;
        case 'capacity':
          result.capacity = parseInt(value.replace(/,/g, '')) || null;
          break;
        case 'speed':
          result.speed = parseInt(value) || null;
          break;
        case 'food':
          result.food = timeStringToMinutes(value);
          break;
        case 'stamina':
          result.stamina = timeStringToMinutes(value);
          break;
        case 'offline training':
          result.offlineTraining = value;
          break;
        case 'magic':
          skills.magic = parseInt(value) || null;
          break;
        case 'fist':
          skills.fist = parseInt(value) || null;
          break;
        case 'club':
          skills.club = parseInt(value) || null;
          break;
        case 'sword':
          skills.sword = parseInt(value) || null;
          break;
        case 'axe':
          skills.axe = parseInt(value) || null;
          break;
        case 'distance':
          skills.distance = parseInt(value) || null;
          break;
        case 'shielding':
          skills.shielding = parseInt(value) || null;
          break;
        case 'fishing':
          skills.fishing = parseInt(value) || null;
          break;
        case 'damage/healing':
          combat.damageHealing = parseInt(value) || null;
          break;
        case 'attack':
          if (value.endsWith('V'))
            combat.attack = parseInt(value.replace('V', '')) || null;
          break;
        case 'defence':
          if (value.endsWith('V'))
            combat.defence = parseInt(value.replace('V', '')) || null;
          break;
        case 'armor':
          if (value.endsWith('V'))
            combat.armor = parseInt(value.replace('V', '')) || null;
          break;
        case 'mantra':
          if (value.endsWith('V'))
            combat.mantra = parseInt(value.replace('V', '')) || null;
          break;
        case 'mitigation':
          if (value.includes('%'))
            combat.mitigation = parseFloat(value.replace(/[+%]/g, '')) || null;
          break;
      }
    }
  });
  return { ...result, skills, combat };
}

function parseChatData(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0) return [];
  return ocrData.filter((item) => item && typeof item === 'object');
}

function parseChatBoxTabRow(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { activeTab: null, tabs: {} };
  const tabs = {};
  let activeTab = null;
  ocrData.forEach((item) => {
    const tabName = item.text.trim();
    if (!tabName) return;
    tabs[tabName] = {
      tabName,
      tabPosition: { x: item.click.x, y: item.click.y },
      originalPosition: { x: item.x, y: item.y },
    };
    if (
      item.color &&
      item.color.r === 223 &&
      item.color.g === 223 &&
      item.color.b === 223
    ) {
      activeTab = tabName;
    }
  });
  return { activeTab, tabs };
}

function parseSelectCharacterModal(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { selectedCharacter: null, characters: {}, accountStatus: null };
  const characters = {};
  let selectedCharacter = null;
  let accountStatus = null;
  ocrData.forEach((item) => {
    const text = item.text.trim();
    if (!text) return;
    if (text.includes('Account Status:')) {
      const nextItem = ocrData.find(
        (next) => next.y > item.y && Math.abs(next.x - item.x) < 50,
      );
      if (nextItem) accountStatus = nextItem.text.trim();
      return;
    }
    if (text === 'Free Account' || text === 'Premium Account') {
      if (!accountStatus) accountStatus = text;
      return;
    }
    const characterName = text.replace(/(?!^)(?<!\s)([A-Z])/g, ' $1');
    characters[characterName] = {
      name: characterName,
      position: { x: item.click.x, y: item.click.y },
      originalPosition: { x: item.x, y: item.y },
      color: item.color,
    };
    if (
      item.color &&
      item.color.r === 244 &&
      item.color.g === 244 &&
      item.color.b === 244
    ) {
      selectedCharacter = characterName;
    }
  });
  return { selectedCharacter, characters, accountStatus };
}

function parseVipWidget(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0)
    return { online: [], offline: [] };
  const online = [];
  const offline = [];
  ocrData.forEach((item) => {
    if (!item?.text) return;
    const isOnline =
      item.color &&
      item.color.r === 96 &&
      item.color.g === 248 &&
      item.color.b === 96;
    if (isOnline) online.push(item.text);
    else offline.push(item.text);
  });
  online.sort((a, b) => a.localeCompare(b));
  offline.sort((a, b) => a.localeCompare(b));
  return { online, offline };
}

function parseGameWorldOcr(ocrData) {
  if (!Array.isArray(ocrData) || ocrData.length === 0) return [];
  return ocrData.filter((item) => {
    if (
      !item ||
      typeof item !== 'object' ||
      !item.text ||
      typeof item.text !== 'string'
    ) {
      return false;
    }
    const text = item.text.trim();
    // Exclude entries that start with lowercase letters
    if (
      text.length > 0 &&
      text[0] === text[0].toLowerCase() &&
      text[0].match(/[a-z]/i)
    ) {
      return false;
    }
    // Exclude entries that length is shorter than 3 letters
    if (text.length < 3) {
      return false;
    }
    return true;
  });
}

export const regionParsers = {
  skillsWidget: parseSkillsWidget,
  chatboxMain: parseChatData,
  chatboxSecondary: parseChatData,
  chatBoxTabRow: parseChatBoxTabRow,
  selectCharacterModal: parseSelectCharacterModal,
  vipWidget: parseVipWidget,
  gameWorld: parseGameWorldOcr,
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/performanceTracker.js
//start file
/**
 * A class to track, calculate, and report OCR performance statistics.
 */
export class PerformanceTracker {
  constructor() {
    this.reset();
  }

  reset() {
    this.operationTimes = [];
    this.totalOperationTime = 0;
    this.regionsProcessedCounts = [];
    this.totalRegionsProcessed = 0;
  }

  /**
   * Adds a new measurement from a single performOperation cycle.
   * @param {number} duration - The time in milliseconds for the operation.
   * @param {number} regionCount - The number of regions processed in the operation.
   */
  addMeasurement(duration, regionCount) {
    this.operationTimes.push(duration);
    this.totalOperationTime += duration;
    this.regionsProcessedCounts.push(regionCount);
    this.totalRegionsProcessed += regionCount;
  }

  getReport() {
    const operationCount = this.operationTimes.length;
    if (operationCount === 0) {
      return '[OcrPerformance] No OCR operations in the last period.';
    }

    const avgOpTime = this.totalOperationTime / operationCount;
    const maxOpTime = Math.max(...this.operationTimes);
    const avgRegions = this.totalRegionsProcessed / operationCount;

    const report = [
      '[OcrPerformance] Stats:',
      `${operationCount} ops |`,
      `Avg Time: ${avgOpTime.toFixed(2)}ms |`,
      `Max Time: ${maxOpTime.toFixed(2)}ms |`,
      `Avg Regions/Op: ${avgRegions.toFixed(1)}`,
    ].join(' ');

    return report;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/processing.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocr/processing.js
// --- CORRECTED ---

import { parentPort } from 'worker_threads';
import pkg from 'font-ocr';
import { OCR_REGION_CONFIGS, CHAR_PRESETS } from './config.js';
import regionDefinitions from '../../constants/regionDefinitions.js';

const { recognizeText, findText } = pkg;
const lastPostedResults = new Map();

// --- UTILITIES ---

export function rectsIntersect(rectA, rectB) {
  if (
    !rectA ||
    !rectB ||
    rectA.width <= 0 ||
    rectA.height <= 0 ||
    rectB.width <= 0 ||
    rectB.height <= 0
  ) {
    return false;
  }
  return (
    rectA.x < rectB.x + rectB.width &&
    rectA.x + rectA.width > rectB.x &&
    rectA.y < rectB.y + rectB.height &&
    rectA.y + rectA.height > rectB.y
  );
}

function postUpdateOnce(type, payload) {
  const key = type;
  const prev = lastPostedResults.get(key);
  const payloadString = JSON.stringify(payload);

  if (prev === payloadString) return;

  lastPostedResults.set(key, payloadString);
  parentPort.postMessage({
    storeUpdate: true,
    type,
    payload,
  });
}

// --- GENERIC OCR REGION PROCESSING ---

export async function processOcrRegions(buffer, regions, regionKeys) {
  const ocrRawUpdates = {};
  const processingPromises = [];

  for (const regionKey of regionKeys) {
    const cfg = OCR_REGION_CONFIGS[regionKey];
    const region = regions[regionKey];
    if (!region || !cfg) continue;

    const processRegion = async () => {
      try {
        let rawData = [];
        const colors = cfg.colors || [];

        if (cfg.dictionary && Array.isArray(cfg.dictionary)) {
          rawData = findText(buffer, region, colors, cfg.dictionary) || [];
        } else {
          rawData =
            recognizeText(buffer, region, colors, cfg.allowedChars) || [];
        }

        if (regionKey === 'gameWorld') {
          ocrRawUpdates[regionKey] = rawData;
        }

        if (cfg.parser && cfg.storeAction.startsWith('uiValues/')) {
          const parsedData = cfg.parser(rawData);
          if (parsedData) {
            postUpdateOnce(cfg.storeAction, parsedData);
          }
        }
      } catch (ocrError) {
        console.error(`[OcrProcessing] OCR failed for ${regionKey}:`, ocrError);
      }
    };

    processingPromises.push(processRegion());
  }

  await Promise.all(processingPromises);

  if (Object.keys(ocrRawUpdates).length > 0) {
    postUpdateOnce('ocr/setOcrRegionsText', ocrRawUpdates);
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/ocrWorker.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/ocrWorker.js
// --- UNCHANGED ---

import { workerData } from 'worker_threads';
import { start } from './ocr/core.js';
import { IS_RUNNING_INDEX } from './ocr/config.js';

start().catch((err) => {
  console.error(
    '[OcrWorker] A fatal, unhandled error occurred during startup:',
    err,
  );

  try {
    const { sharedData } = workerData;
    if (sharedData?.syncSAB) {
      const syncArray = new Int32Array(sharedData.syncSAB);
      Atomics.store(syncArray, IS_RUNNING_INDEX, 0);
      Atomics.notify(syncArray, IS_RUNNING_INDEX);
      console.log(
        '[OcrWorker] Successfully signaled shutdown to other workers.',
      );
    } else {
      console.error(
        '[OcrWorker] Could not signal shutdown: sharedData or syncSAB not available.',
      );
    }
  } catch (e) {
    console.error(
      '[OcrWorker] An error occurred while trying to signal shutdown:',
      e,
    );
  }

  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/config.js
//start file
import path from 'path';

// --- Performance Logging ---
export const PERFORMANCE_LOGGING_ENABLED = true;
export const PERFORMANCE_LOG_INTERVAL_MS = 10000;

// --- File Paths ---
export const PREPROCESSED_BASE_DIR = path.join(
  process.cwd(),
  'resources',
  'preprocessed_minimaps',
);

console.log('PREPROCESSED_BASE_DIR:', process.cwd());
// --- Logic Constants ---
// Maps a waypoint type to the type of special avoidance area it should respect.
export const WAYPOINT_AVOIDANCE_MAP = {
  Node: 'cavebot',
  Stand: 'cavebot',
  Ladder: 'cavebot',
  Script: 'cavebot',
  Lure: 'targeting',
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/core.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/core.js

import { parentPort, workerData } from 'worker_threads';
import Pathfinder from 'pathfinder-native';
import { createLogger } from '../../utils/logger.js';
import * as config from './config.js';
import { loadAllMapData } from './dataLoader.js';
import { runPathfindingLogic } from './logic.js';
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
} from '../sharedConstants.js';

const logger = createLogger({ info: false, error: true, debug: false });

let state = null;
let pathfinderInstance = null;

const logicContext = {
  lastPlayerPosKey: null,
  lastTargetWptId: null,
  lastJsonForType: new Map(),
  lastCreatureDataHash: null, // NEW: Cache based on creature data hash
};

const { playerPosSAB, pathDataSAB } = workerData; // creaturePosSAB is removed
const playerPosArray = playerPosSAB ? new Int32Array(playerPosSAB) : null;
const pathDataArray = pathDataSAB ? new Int32Array(pathDataSAB) : null;

const REDUX_UPDATE_INTERVAL_MS = 25;
let lastReduxUpdateTime = 0;
let reduxUpdateTimeout = null;
let pendingReduxUpdatePayload = null;

function postThrottledUpdate() {
  if (pendingReduxUpdatePayload) {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'pathfinder/setPathfindingFeedback',
      payload: pendingReduxUpdatePayload,
    });
    lastReduxUpdateTime = Date.now();
    pendingReduxUpdatePayload = null;
  }
  if (reduxUpdateTimeout) {
    clearTimeout(reduxUpdateTimeout);
    reduxUpdateTimeout = null;
  }
}

function throttleReduxUpdate(payload) {
  pendingReduxUpdatePayload = payload;
  const now = Date.now();
  const timeSinceLastUpdate = now - lastReduxUpdateTime;
  if (timeSinceLastUpdate >= REDUX_UPDATE_INTERVAL_MS) {
    postThrottledUpdate();
  } else if (!reduxUpdateTimeout) {
    reduxUpdateTimeout = setTimeout(
      postThrottledUpdate,
      REDUX_UPDATE_INTERVAL_MS - timeSinceLastUpdate,
    );
  }
}

function handleMessage(message) {
  try {
    if (message.type === 'state_diff') {
      state = { ...state, ...message.payload };
    } else if (message.type === undefined) {
      state = message;
    } else if (message.type === 'shutdown') {
      if (reduxUpdateTimeout) clearTimeout(reduxUpdateTimeout);
      return;
    } else {
      return;
    }

    if (!state || !state.gameState || !state.targeting || !state.cavebot) {
      // Ensure necessary slices exist
      return;
    }

    // NEW: Guard against running pathfinder if both modules are disabled
    if (pathDataArray && !state.cavebot.enabled && !state.targeting.enabled) {
      // If pathfinder is already idle, no need to update SAB again.
      if (
        Atomics.load(pathDataArray, PATHFINDING_STATUS_INDEX) ===
        PATH_STATUS_IDLE
      ) {
        return;
      }
      // Set status to idle and update counter to notify consumers.
      Atomics.store(pathDataArray, PATHFINDING_STATUS_INDEX, PATH_STATUS_IDLE);
      Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0);
      Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
      return;
    }

    let playerMinimapPosition = null;
    if (playerPosArray) {
      playerMinimapPosition = {
        x: Atomics.load(playerPosArray, PLAYER_X_INDEX),
        y: Atomics.load(playerPosArray, PLAYER_Y_INDEX),
        z: Atomics.load(playerPosArray, PLAYER_Z_INDEX),
      };
    } else {
      playerMinimapPosition = state.gameState.playerMinimapPosition;
    }

    if (!playerMinimapPosition || typeof playerMinimapPosition.x !== 'number') {
      return;
    }

    // REMOVED: All logic reading from creaturePosSAB is gone.

    const synchronizedState = {
      ...state,
      gameState: { ...state.gameState, playerMinimapPosition },
    };

    runPathfindingLogic({
      logicContext: logicContext,
      state: synchronizedState,
      pathfinderInstance,
      logger,
      pathDataArray,
      throttleReduxUpdate,
    });
  } catch (error) {
    logger(
      'error',
      '[PathfinderCore] Unhandled error in message handler:',
      error,
    );
  }
}

export async function start() {
  logger('info', 'Pathfinder worker starting up...');
  try {
    pathfinderInstance = new Pathfinder.Pathfinder();
    logger('info', 'Native Pathfinder addon loaded successfully.');
    loadAllMapData(pathfinderInstance, logger);
  } catch (err) {
    logger(
      'error',
      `Pathfinder worker fatal error on startup: ${err.message}`,
      err,
    );
    if (parentPort) {
      parentPort.postMessage({
        fatalError: err.message || 'Unknown fatal error in worker',
      });
    }
    process.exit(1);
  }
  parentPort.on('message', handleMessage);
  parentPort.on('close', () => {
    logger('info', 'Parent port closed. Stopping pathfinder worker.');
    process.exit(0);
  });
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/dataLoader.js
//start file
import fs from 'fs';
import path from 'path';
import { PREPROCESSED_BASE_DIR } from './config.js';

/**
 * Reads all preprocessed map data from disk and loads it into the pathfinder instance.
 * @param {object} pathfinderInstance - The native Pathfinder addon instance.
 * @param {function} logger - The logger utility.
 */
export function loadAllMapData(pathfinderInstance, logger) {
  if (pathfinderInstance.isLoaded) return;

  logger('info', 'Loading pathfinding data for all Z-levels...');
  const mapDataForAddon = {};
  try {
    const zLevelDirs = fs
      .readdirSync(PREPROCESSED_BASE_DIR, { withFileTypes: true })
      .filter((d) => d.isDirectory() && d.name.startsWith('z'))
      .map((d) => d.name);

    for (const zDir of zLevelDirs) {
      const zLevel = parseInt(zDir.substring(1), 10);
      const zLevelPath = path.join(PREPROCESSED_BASE_DIR, zDir);
      try {
        const metadata = JSON.parse(
          fs.readFileSync(path.join(zLevelPath, 'walkable.json'), 'utf8'),
        );
        const grid = fs.readFileSync(path.join(zLevelPath, 'walkable.bin'));
        mapDataForAddon[zLevel] = { ...metadata, grid };
      } catch (e) {
        if (e.code !== 'ENOENT') {
          logger(
            'warn',
            `Could not load pathfinding data for Z=${zLevel}: ${e.message}`,
          );
        }
      }
    }

    pathfinderInstance.loadMapData(mapDataForAddon);

    if (pathfinderInstance.isLoaded) {
      logger(
        'info',
        'Pathfinding data successfully loaded into native module.',
      );
    } else {
      throw new Error(
        'Failed to load data into native module after reading files.',
      );
    }
  } catch (e) {
    logger('error', `Critical error during map data loading: ${e.message}`);
    throw e; // Re-throw to be caught by the worker's main error handler
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/logic.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinder/logic.js
// --- Full file with fix for controlState logic ---

import {
  PATH_LENGTH_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_WAYPOINTS_START_INDEX,
  PATH_WAYPOINT_SIZE,
  MAX_PATH_WAYPOINTS,
  PATH_CHEBYSHEV_DISTANCE_INDEX,
  PATH_START_X_INDEX,
  PATH_START_Y_INDEX,
  PATH_START_Z_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_STATUS_IDLE,
  PATH_STATUS_PATH_FOUND,
  PATH_STATUS_WAYPOINT_REACHED,
  PATH_STATUS_NO_PATH_FOUND,
  PATH_STATUS_DIFFERENT_FLOOR,
  PATH_STATUS_ERROR,
  PATH_STATUS_NO_VALID_START_OR_END,
  PATH_STATUS_BLOCKED_BY_CREATURE,
  PATH_BLOCKING_CREATURE_X_INDEX,
  PATH_BLOCKING_CREATURE_Y_INDEX,
  PATH_BLOCKING_CREATURE_Z_INDEX,
  PATH_TARGET_X_INDEX,
  PATH_TARGET_Y_INDEX,
  PATH_TARGET_Z_INDEX,
  PATH_WPT_ID_INDEX,
  PATH_INSTANCE_ID_INDEX,
} from '../sharedConstants.js';

let lastWrittenPathSignature = '';

function hashCreatureData(creatures) {
  if (!creatures || creatures.length === 0) return 0;
  const first = creatures[0].gameCoords;
  const last = creatures[creatures.length - 1].gameCoords;
  return (
    creatures.length ^
    (first.x << 8) ^
    (first.y << 16) ^
    (last.x << 4) ^
    (last.y << 24)
  );
}

export function runPathfindingLogic(context) {
  const {
    logicContext,
    state,
    pathfinderInstance,
    logger,
    pathDataArray,
    throttleReduxUpdate,
  } = context;

  try {
    const { cavebot, gameState, targeting } = state;
    const { playerMinimapPosition } = gameState;

    if (!playerMinimapPosition) {
      return;
    }

    const { x, y, z } = playerMinimapPosition;
    if (
      typeof x !== 'number' ||
      typeof y !== 'number' ||
      typeof z !== 'number'
    ) {
      logger('error', `Invalid player position: {x: ${x}, y: ${y}, z: ${z}}`);
      return;
    }

    const creaturePositions = (targeting.creatures || []).map(
      (c) => c.gameCoords,
    );

    // --- NEW: Implicit Mode Detection ---
    // Instead of reading a mode flag, we infer the mode from the available data.
    // If a dynamicTarget exists, we are in 'targeting' mode. Otherwise, 'cavebot' mode.
    const isTargetingMode = !!cavebot.dynamicTarget;

    let result = null;
    let targetIdentifier = null;

    const allSpecialAreas = state.cavebot?.specialAreas || [];
    const activeSpecialAreas = allSpecialAreas.filter((area) => area.enabled);

    // Group active areas by z-level for efficient updates.
    const newAreasByZ = {};
    for (const area of activeSpecialAreas) {
        if (!newAreasByZ[area.z]) {
            newAreasByZ[area.z] = [];
        }
        newAreasByZ[area.z].push(area);
    }

    // Determine the set of all z-levels that need checking (current and previous).
    const oldAreasByZ = logicContext.lastAreasByZ || {};
    const allZLevels = new Set([
        ...Object.keys(newAreasByZ),
        ...Object.keys(oldAreasByZ),
    ]);

    let hasChanges = false;
    for (const zStr of allZLevels) {
        const z = parseInt(zStr, 10);
        const newAreasForZ = newAreasByZ[z] || [];
        const oldAreasForZ = oldAreasByZ[z] || [];

        // A more robust check than stringify on every tick.
        // We only update if the number of areas or their content hash changes.
        // For simplicity in this refactor, we'll use stringify, but only when a change is likely.
        const newAreasJson = JSON.stringify(newAreasForZ);
        const oldAreasJson = JSON.stringify(oldAreasForZ);

        if (newAreasJson !== oldAreasJson) {
            hasChanges = true;
            logger('debug', `Special areas for z-level ${z} have changed. Updating native module.`);
            const areasForNative = newAreasForZ.map((area) => ({
                x: area.x,
                y: area.y,
                z: area.z,
                avoidance: area.avoidance,
                width: area.sizeX,
                height: area.sizeY,
            }));
            pathfinderInstance.updateSpecialAreas(areasForNative, z);
        }
    }

    if (hasChanges) {
        logicContext.lastAreasByZ = newAreasByZ;
    }

    if (isTargetingMode) {
      targetIdentifier = JSON.stringify(cavebot.dynamicTarget);
    } else if (cavebot.wptId) {
      // Cavebot mode
      const { waypointSections, currentSection, wptId } = cavebot;
      const targetWaypoint = waypointSections[currentSection]?.waypoints.find(
        (wp) => wp.id === wptId,
      );
      if (targetWaypoint) {
        targetIdentifier = targetWaypoint.id;
      }
    }

    const currentPosKey = `${x},${y},${z}`;
    const currentCreatureDataHash = hashCreatureData(targeting.creatures);

    if (
      !cavebot.forcePathRefresh &&
      logicContext.lastPlayerPosKey === currentPosKey &&
      logicContext.lastTargetWptId === targetIdentifier &&
      logicContext.lastCreatureDataHash === currentCreatureDataHash
    ) {
      return; // No change in inputs, skip pathfinding.
    }
    
    if (cavebot.forcePathRefresh) {
      throttleReduxUpdate({
        type: 'cavebot/setForcePathRefresh',
        payload: false,
      });
    }

    logicContext.lastPlayerPosKey = currentPosKey;
    logicContext.lastTargetWptId = targetIdentifier;
    logicContext.lastCreatureDataHash = currentCreatureDataHash;

    if (isTargetingMode) {
      const targetInstanceId = cavebot.dynamicTarget.targetInstanceId;

      if (!targetInstanceId) {
        // Fallback for old dynamicTarget format, but still solve Problem B.
        const obstacles = creaturePositions.filter((pos) => {
          return (
            pos.x !== cavebot.dynamicTarget.targetCreaturePos.x ||
            pos.y !== cavebot.dynamicTarget.targetCreaturePos.y ||
            pos.z !== cavebot.dynamicTarget.targetCreaturePos.z
          );
        });
        result = pathfinderInstance.findPathToGoal(
          playerMinimapPosition,
          cavebot.dynamicTarget,
          obstacles,
        );
      } else {
        const targetCreature = (targeting.creatures || []).find(
          (c) => c.instanceId === targetInstanceId,
        );

        if (targetCreature) {
          // State is consistent, target found. Use its fresh position.
          const correctedDynamicTarget = {
            ...cavebot.dynamicTarget,
            targetCreaturePos: targetCreature.gameCoords,
          };

          // Filter the fresh position from the list of obstacles.
          const obstacles = creaturePositions.filter((pos) => {
            return (
              pos.x !== correctedDynamicTarget.targetCreaturePos.x ||
              pos.y !== correctedDynamicTarget.targetCreaturePos.y ||
              pos.z !== correctedDynamicTarget.targetCreaturePos.z
            );
          });

          result = pathfinderInstance.findPathToGoal(
            playerMinimapPosition,
            correctedDynamicTarget,
            obstacles,
          );
        } else {
          // Target has disappeared. Path to its last known position.
          // `creaturePositions` is already correct (doesn't contain the disappeared target).
          result = pathfinderInstance.findPathToGoal(
            playerMinimapPosition,
            cavebot.dynamicTarget,
            creaturePositions,
          );
        }
      }
    } else if (targetIdentifier) {
      // Cavebot mode with a valid waypoint
      const { waypointSections, currentSection, wptId } = cavebot;
      const targetWaypoint = waypointSections[currentSection]?.waypoints.find(
        (wp) => wp.id === wptId,
      );
      if (targetWaypoint) {
        // REMOVED: The premature Z-level check was causing a deadlock.
        // The native pathfinder is capable of finding paths across floors.
        // The cavebot FSM is responsible for handling the path result,
        // including cases where no path is found due to floor differences.
        result = pathfinderInstance.findPathSync(
          playerMinimapPosition,
          { x: targetWaypoint.x, y: targetWaypoint.y, z: targetWaypoint.z },
          creaturePositions
        );
      }
    }

    if (targetIdentifier && !result) {
      result = {
        path: [],
        reason: 'NO_PATH_FOUND'
      };
    }

    if (!result) {
      if (pathDataArray) {
        Atomics.store(
          pathDataArray,
          PATHFINDING_STATUS_INDEX,
          PATH_STATUS_IDLE,
        );
        Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0);
        Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
      }
      return;
    }

    const rawPath = result.path || [];
    const statusString = result.reason;
    const isBlocked = result.isBlocked || false;
    const blockingCreatureCoords = result.blockingCreatureCoords || null;

    const normalizedPath = Array.isArray(rawPath) ? rawPath.slice() : [];
    const wptId = isTargetingMode ? 0 : (cavebot.wptId ? cavebot.wptId.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a }, 0) : 0);
    const instanceId = isTargetingMode ? (cavebot.dynamicTarget.targetInstanceId || 0) : 0;

    let statusCode = PATH_STATUS_IDLE;
    switch (statusString) {
      case 'PATH_FOUND':
        statusCode = PATH_STATUS_PATH_FOUND;
        break;
      case 'BLOCKED_BY_CREATURE':
        statusCode = PATH_STATUS_BLOCKED_BY_CREATURE;
        break;
      case 'WAYPOINT_REACHED':
        statusCode = PATH_STATUS_WAYPOINT_REACHED;
        break;
      case 'NO_PATH_FOUND':
        statusCode = PATH_STATUS_NO_PATH_FOUND;
        break;
      case 'NO_VALID_START':
      case 'NO_VALID_END':
        statusCode = PATH_STATUS_NO_VALID_START_OR_END;
        break;
      default:
        statusCode = PATH_STATUS_ERROR;
        break;
    }

    const pathSignature = `${statusCode}:${normalizedPath.map((p) => `${p.x},${p.y}`).join(';')}`;
    if (pathSignature !== lastWrittenPathSignature) {
      if (pathDataArray) {
        const pathLength = Math.min(normalizedPath.length, MAX_PATH_WAYPOINTS);
        const targetX =
          normalizedPath.length > 0
            ? normalizedPath[normalizedPath.length - 1].x
            : x;
        const targetY =
          normalizedPath.length > 0
            ? normalizedPath[normalizedPath.length - 1].y
            : y;
        const chebyshevDistance = Math.max(
          Math.abs(x - targetX),
          Math.abs(y - targetY),
        );

        // Get the definitive target coordinates for tagging
        let pathTargetCoords = { x: 0, y: 0, z: 0 };
        if (isTargetingMode) {
          pathTargetCoords = cavebot.dynamicTarget.targetCreaturePos;
        } else {
          const { waypointSections, currentSection, wptId } = cavebot;
          const targetWaypoint =
            waypointSections[currentSection]?.waypoints.find(
              (wp) => wp.id === wptId,
            );
          if (targetWaypoint) {
            pathTargetCoords = {
              x: targetWaypoint.x,
              y: targetWaypoint.y,
              z: targetWaypoint.z,
            };
          }
        }

        Atomics.store(pathDataArray, PATH_LENGTH_INDEX, pathLength);
        Atomics.store(
          pathDataArray,
          PATH_CHEBYSHEV_DISTANCE_INDEX,
          chebyshevDistance,
        );
        Atomics.store(pathDataArray, PATH_START_X_INDEX, x);
        Atomics.store(pathDataArray, PATH_START_Y_INDEX, y);
        Atomics.store(pathDataArray, PATH_START_Z_INDEX, z);
        Atomics.store(
          pathDataArray,
          PATH_TARGET_X_INDEX,
          pathTargetCoords.x,
        );
        Atomics.store(
          pathDataArray,
          PATH_TARGET_Y_INDEX,
          pathTargetCoords.y,
        );
        Atomics.store(
          pathDataArray,
          PATH_TARGET_Z_INDEX,
          pathTargetCoords.z,
        );
        Atomics.store(pathDataArray, PATHFINDING_STATUS_INDEX, statusCode);
        Atomics.store(pathDataArray, PATH_WPT_ID_INDEX, wptId);
        Atomics.store(pathDataArray, PATH_INSTANCE_ID_INDEX, instanceId);

        if (isBlocked && blockingCreatureCoords) {
          Atomics.store(pathDataArray, PATH_BLOCKING_CREATURE_X_INDEX, blockingCreatureCoords.x);
          Atomics.store(pathDataArray, PATH_BLOCKING_CREATURE_Y_INDEX, blockingCreatureCoords.y);
          Atomics.store(pathDataArray, PATH_BLOCKING_CREATURE_Z_INDEX, blockingCreatureCoords.z);
        } else {
          // Clear the coordinates if not blocked
          Atomics.store(pathDataArray, PATH_BLOCKING_CREATURE_X_INDEX, 0);
          Atomics.store(pathDataArray, PATH_BLOCKING_CREATURE_Y_INDEX, 0);
          Atomics.store(pathDataArray, PATH_BLOCKING_CREATURE_Z_INDEX, 0);
        }

        for (let i = 0; i < pathLength; i++) {
          const waypoint = normalizedPath[i];
          const offset = PATH_WAYPOINTS_START_INDEX + i * PATH_WAYPOINT_SIZE;
          Atomics.store(pathDataArray, offset + 0, waypoint.x);
          Atomics.store(pathDataArray, offset + 1, waypoint.y);
          Atomics.store(pathDataArray, offset + 2, waypoint.z);
        }

        Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
      }
      lastWrittenPathSignature = pathSignature;
    }

    const distance =
      statusString === 'NO_PATH_FOUND' ? null : normalizedPath.length;

    throttleReduxUpdate({
      pathWaypoints: normalizedPath,
      wptDistance: distance,
      routeSearchMs: result.performance?.totalTimeMs || 0,
      pathfindingStatus: statusString,
    });

  } catch (error) {
    logger('error', `Pathfinding error: ${error.message}`);
    throttleReduxUpdate({
      pathWaypoints: [],
      wptDistance: null,
      pathfindingStatus: 'ERROR',
    });
    if (pathDataArray) {
      Atomics.store(pathDataArray, PATHFINDING_STATUS_INDEX, PATH_STATUS_ERROR);
      Atomics.store(pathDataArray, PATH_LENGTH_INDEX, 0);
      Atomics.add(pathDataArray, PATH_UPDATE_COUNTER_INDEX, 1);
    }
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/pathfinderWorker.js
//start file
import { start } from './pathfinder/core.js';

start().catch((err) => {
  console.error('[PathfinderWorker] Failed to start worker core:', err);
  process.exit(1);
});

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/regionMonitor.js
//start file
// regionMonitor.js – CLEANED — NO BENCHMARKING
import { parentPort, workerData } from 'worker_threads';
import regionDefinitions from '../constants/regionDefinitions.js';
import { setAllRegions } from '../../frontend/redux/slices/regionCoordinatesSlice.js';
import findSequences from 'find-sequences-native';
import { FrameUpdateManager } from '../utils/frameUpdateManager.js';

// --- Worker Configuration & Setup ---
const { sharedData } = workerData;
const FULL_SCAN_INTERVAL_MS = 500;
const MIN_LOOP_DELAY_MS = 250;

if (!sharedData) throw new Error('[RegionMonitor] Shared data not provided.');
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

// --- SharedArrayBuffer Indices ---
const WIDTH_INDEX = 1;
const HEIGHT_INDEX = 2;
const IS_RUNNING_INDEX = 3;

// --- State variables ---
let lastKnownRegions = {};
let lastWidth = 0;
let lastHeight = 0;
let isShuttingDown = false;
let isScanning = false;
const frameUpdateManager = new FrameUpdateManager();

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// Helper function to remove unnecessary raw position data before sending to store
function sanitizeRegionsForStore(regions) {
  if (!regions || typeof regions !== 'object') {
    return regions;
  }

  const newRegions = { ...regions };

  // Remove raw position properties from the current level
  delete newRegions.rawPos;
  delete newRegions.rawStartPos;
  delete newRegions.rawEndPos;

  // Recursively sanitize children
  for (const key in newRegions) {
    if (
      Object.prototype.hasOwnProperty.call(newRegions, key) &&
      newRegions[key] &&
      typeof newRegions[key] === 'object'
    ) {
      newRegions[key] = sanitizeRegionsForStore(newRegions[key]);
    }
  }

  return newRegions;
}

// Helper function to calculate constrained search area based on definition
function calculateConstrainedSearchArea(def, fullSearchArea, metadata) {
  if (!def.searchArea) return fullSearchArea;

  const { searchArea } = def;
  let constrainedArea = { ...fullSearchArea };

  switch (searchArea.type) {
    case 'rightEdge':
      if (searchArea.maxFromRight) {
        const minX = Math.max(0, metadata.width - searchArea.maxFromRight);
        constrainedArea.x = Math.max(constrainedArea.x, minX);
        constrainedArea.width = Math.min(
          constrainedArea.width,
          metadata.width - constrainedArea.x,
        );
      }
      break;

    case 'leftEdge':
      if (searchArea.maxFromLeft) {
        constrainedArea.width = Math.min(
          constrainedArea.width,
          searchArea.maxFromLeft,
        );
      }
      break;

    case 'bottomHalf':
      const halfHeight = Math.floor(metadata.height / 2);
      constrainedArea.y = Math.max(constrainedArea.y, halfHeight);
      constrainedArea.height = Math.min(
        constrainedArea.height,
        metadata.height - constrainedArea.y,
      );
      break;

    case 'center':
      const centerX = Math.floor(metadata.width / 2);
      const centerY = Math.floor(metadata.height / 2);
      const quarterWidth = Math.floor(metadata.width / 4);
      const quarterHeight = Math.floor(metadata.height / 4);

      constrainedArea.x = Math.max(constrainedArea.x, centerX - quarterWidth);
      constrainedArea.y = Math.max(constrainedArea.y, centerY - quarterHeight);
      constrainedArea.width = Math.min(constrainedArea.width, quarterWidth * 2);
      constrainedArea.height = Math.min(
        constrainedArea.height,
        quarterHeight * 2,
      );
      break;
  }

  // Ensure area is valid
  constrainedArea.width = Math.max(0, constrainedArea.width);
  constrainedArea.height = Math.max(0, constrainedArea.height);

  return constrainedArea;
}

// --- Recursive Region Finding Logic ---
async function findRegionsRecursive(
  buffer,
  definitions,
  searchArea,
  baseOffset,
  parentResult,
  metadata,
) {
  const discoveryTasks = {};
  const boundingBoxDefs = {};
  const fixedDefs = {};
  const defEntries = Object.entries(definitions);
  if (defEntries.length === 0) return;

  for (const [name, def] of defEntries) {
    switch (def.type) {
      case 'single':
        const singleSearchArea = calculateConstrainedSearchArea(
          def,
          searchArea,
          metadata,
        );
        discoveryTasks[name] = {
          sequences: { [name]: def },
          searchArea: singleSearchArea,
          occurrence: 'first',
        };
        break;
      case 'boundingBox':
        const boundingBoxSearchArea = calculateConstrainedSearchArea(
          def,
          searchArea,
          metadata,
        );
        discoveryTasks[`${name}_start`] = {
          sequences: { [`${name}_start`]: def.start },
          searchArea: boundingBoxSearchArea,
          occurrence: 'first',
        };
        boundingBoxDefs[name] = def;
        break;
      case 'fixed':
        fixedDefs[name] = def;
        break;
    }
  }

  for (const [name, def] of Object.entries(fixedDefs)) {
    parentResult[name] = {
      x: baseOffset.x + def.x,
      y: baseOffset.y + def.y,
      width: def.width,
      height: def.height,
    };
  }

  if (!Object.keys(discoveryTasks).length) return;

  const discoveryResults = await findSequences.findSequencesNativeBatch(
    buffer,
    discoveryTasks,
  );
  const endpointTasks = {};
  const foundStarts = {};
  const childInvocations = [];

  for (const [name, def] of defEntries) {
    if (def.type === 'single' && discoveryResults[name]?.[name]) {
      const result = discoveryResults[name][name];
      const region = {
        x: result.x,
        y: result.y,
        width: def.width,
        height: def.height,
        rawPos: {
          x: result.x - (def.offset?.x || 0),
          y: result.y - (def.offset?.y || 0),
        },
      };
      parentResult[name] = region;
      if (def.children) {
        parentResult[name].children = {};
        childInvocations.push(() =>
          findRegionsRecursive(
            buffer,
            def.children,
            region,
            { x: region.x, y: region.y },
            parentResult[name].children,
            metadata,
          ),
        );
      }
    }
  }

  for (const [name, def] of Object.entries(boundingBoxDefs)) {
    const startResult = discoveryResults[`${name}_start`]?.[`${name}_start`];
    if (!startResult) continue;
    foundStarts[name] = startResult;
    const maxW = def.maxRight === 'fullWidth' ? metadata.width : def.maxRight;
    const maxH = def.maxDown === 'fullHeight' ? metadata.height : def.maxDown;
    const endSearchArea = {
      x: startResult.x,
      y: startResult.y,
      width: Math.min(maxW, searchArea.x + searchArea.width - startResult.x),
      height: Math.min(maxH, searchArea.y + searchArea.height - startResult.y),
    };
    if (endSearchArea.width > 0 && endSearchArea.height > 0) {
      endpointTasks[`${name}_end`] = {
        sequences: { [`${name}_end`]: def.end },
        searchArea: endSearchArea,
        occurrence: 'first',
      };
    }
  }

  let endpointResults = {};
  if (Object.keys(endpointTasks).length > 0) {
    endpointResults = await findSequences.findSequencesNativeBatch(
      buffer,
      endpointTasks,
    );
  }

  for (const [name, startPos] of Object.entries(foundStarts)) {
    const def = boundingBoxDefs[name];
    const endPos = endpointResults[`${name}_end`]?.[`${name}_end`];
    const absStartPos = { x: startPos.x, y: startPos.y };
    const rawStartPos = {
      x: absStartPos.x - (def.start.offset?.x || 0),
      y: absStartPos.y - (def.start.offset?.y || 0),
    };
    if (!endPos) {
      parentResult[name] = {
        ...absStartPos,
        width: 0,
        height: 0,
        startFound: true,
        endFound: false,
        rawStartPos,
      };
      continue;
    }
    const rectWidth = endPos.x - startPos.x + 1;
    const rectHeight = endPos.y - startPos.y + 1;
    const region = {
      ...absStartPos,
      width: rectWidth > 0 ? rectWidth : 0,
      height: rectHeight > 0 ? rectHeight : 0,
      startFound: true,
      endFound: true,
      rawStartPos,
      rawEndPos: {
        x: endPos.x - (def.end.offset?.x || 0),
        y: endPos.y - (def.end.offset?.y || 0),
      },
    };
    parentResult[name] = region;
    if (def.children) {
      parentResult[name].children = {};
      childInvocations.push(() =>
        findRegionsRecursive(
          buffer,
          def.children,
          region,
          { x: region.x, y: region.y },
          parentResult[name].children,
          metadata,
        ),
      );
    }
  }

  if (childInvocations.length > 0) {
    await Promise.all(childInvocations.map((invoke) => invoke()));
  }
}

/**
 * Processes special regions after the main recursive find.
 */
async function processSpecialRegions(buffer, regions, metadata) {
  if (regions.gameWorld?.endFound) {
    const { gameWorld } = regions;
    regions.tileSize = {
      width: Math.round(gameWorld.width / 15),
      height: Math.round(gameWorld.height / 11),
    };
  }
}

async function performFullScan(buffer, metadata) {
  const foundRegions = {};
  await findRegionsRecursive(
    buffer,
    regionDefinitions,
    { x: 0, y: 0, width: metadata.width, height: metadata.height },
    { x: 0, y: 0 },
    foundRegions,
    metadata,
  );
  await processSpecialRegions(buffer, foundRegions, metadata);
  return foundRegions;
}

async function mainLoop() {
  while (!isShuttingDown) {
    try {
      if (isScanning) {
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      const width = Atomics.load(syncArray, WIDTH_INDEX);
      const height = Atomics.load(syncArray, HEIGHT_INDEX);
      const dimensionsChanged = width !== lastWidth || height !== lastHeight;

      if (!frameUpdateManager.shouldProcess() && !dimensionsChanged) {
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      if (Atomics.load(syncArray, IS_RUNNING_INDEX) !== 1) {
        if (Object.keys(lastKnownRegions).length > 0) {
          lastKnownRegions = {};
          parentPort.postMessage({
            storeUpdate: true,
            type: setAllRegions.type,
            payload: {},
          });
        }
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      if (width <= 0 || height <= 0) {
        await delay(MIN_LOOP_DELAY_MS);
        continue;
      }

      isScanning = true;
      try {
        const metadata = { width, height };
        const newRegions = await performFullScan(sharedBufferView, metadata);

        lastWidth = width;
        lastHeight = height;
        lastKnownRegions = newRegions;

        // Sanitize the regions object to remove unnecessary data before posting
        const sanitizedRegions = sanitizeRegionsForStore(newRegions);

        parentPort.postMessage({
          storeUpdate: true,
          type: setAllRegions.type,
          payload: sanitizedRegions,
        });
      } catch (err) {
        console.error('[RegionMonitor] Error during scan:', err);
        lastKnownRegions = {};
      } finally {
        isScanning = false;
      }
    } catch (err) {
      console.error('[RegionMonitor] Error in main loop:', err);
      lastKnownRegions = {};
    }

    // Respect timing logic
    const elapsedTime = Date.now();
    const delayTime = Math.max(
      0,
      FULL_SCAN_INTERVAL_MS - (Date.now() - elapsedTime),
    );
    if (delayTime > 0) {
      await delay(delayTime);
    }
  }
}

parentPort.on('message', (message) => {
  try {
    if (message.type === 'frame-update') {
      frameUpdateManager.addDirtyRects(message.payload.dirtyRects);
      return;
    }

    if (message.type === 'shutdown') {
      isShuttingDown = true;
    }
  } catch (err) {
    console.error('[RegionMonitor] Error handling message:', err);
  }
});

async function startWorker() {
  mainLoop().catch((err) => {
    console.error('[RegionMonitor] Fatal error in main loop:', err);
    process.exit(1);
  });
}

startWorker();

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/sabStateManager.js
//start file
import {
  PLAYER_X_INDEX,
  PLAYER_Y_INDEX,
  PLAYER_Z_INDEX,
  PLAYER_POS_UPDATE_COUNTER_INDEX,
  BATTLE_LIST_COUNT_INDEX,
  BATTLE_LIST_UPDATE_COUNTER_INDEX,
  BATTLE_LIST_ENTRIES_START_INDEX,
  BATTLE_LIST_ENTRY_SIZE,
  CREATURES_COUNT_INDEX,
  CREATURES_UPDATE_COUNTER_INDEX,
  CREATURES_DATA_START_INDEX,
  CREATURE_DATA_SIZE,
  CREATURE_INSTANCE_ID_OFFSET,
  WORLD_STATE_UPDATE_COUNTER_INDEX,
  CREATURE_X_OFFSET,
  CREATURE_Y_OFFSET,
  CREATURE_Z_OFFSET,
  CREATURE_IS_REACHABLE_OFFSET,
  CREATURE_IS_ADJACENT_OFFSET,
  CREATURE_DISTANCE_OFFSET,
  CREATURE_HP_OFFSET,
  CREATURE_IS_BLOCKING_PATH_OFFSET,
  CREATURE_ABSOLUTE_X_OFFSET,
  CREATURE_ABSOLUTE_Y_OFFSET,
  CREATURE_NAME_START_OFFSET,
  CREATURE_NAME_LENGTH,
  LOOTING_REQUIRED_INDEX,
  LOOTING_UPDATE_COUNTER_INDEX,
  TARGETING_LIST_COUNT_INDEX,
  TARGETING_LIST_UPDATE_COUNTER_INDEX,
  TARGETING_LIST_DATA_START_INDEX,
  TARGETING_RULE_SIZE,
  TARGET_INSTANCE_ID_INDEX,
  TARGET_X_INDEX,
  TARGET_Y_INDEX,
  TARGET_Z_INDEX,
  TARGET_DISTANCE_INDEX,
  TARGET_IS_REACHABLE_INDEX,
  TARGET_NAME_START_INDEX,
  TARGET_UPDATE_COUNTER_INDEX,
  PATH_LENGTH_INDEX,
  PATH_CHEBYSHEV_DISTANCE_INDEX,
  PATHFINDING_STATUS_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_WAYPOINTS_START_INDEX,
  PATH_WAYPOINT_SIZE,
  MAX_PATH_WAYPOINTS,
  PATH_START_X_INDEX,
  PATH_START_Y_INDEX,
  PATH_START_Z_INDEX,
  CREATURE_MONITOR_LAST_PROCESSED_Z_INDEX,
} from './sharedConstants.js';

const hpStringToCode = {
  Full: 0,
  High: 1,
  Medium: 2,
  Low: 3,
  Critical: 4,
  Obstructed: 5,
};

const hpCodeToString = [
  'Full',
  'High',
  'Medium',
  'Low',
  'Critical',
  'Obstructed',
];

export class SABStateManager {
  constructor(sabData) {
    this.playerPosArray = sabData.playerPosSAB
      ? new Int32Array(sabData.playerPosSAB)
      : null;
    this.battleListArray = sabData.battleListSAB
      ? new Int32Array(sabData.battleListSAB)
      : null;
    this.creaturesArray = sabData.creaturesSAB
      ? new Int32Array(sabData.creaturesSAB)
      : null;
    this.lootingArray = sabData.lootingSAB
      ? new Int32Array(sabData.lootingSAB)
      : null;
    this.targetingListArray = sabData.targetingListSAB
      ? new Int32Array(sabData.targetingListSAB)
      : null;
    this.targetArray = sabData.targetSAB
      ? new Int32Array(sabData.targetSAB)
      : null;
    this.pathDataArray = sabData.pathDataSAB
      ? new Int32Array(sabData.pathDataSAB)
      : null;

    this.lastCounters = {
      playerPos: -1,
      battleList: -1,
      creatures: -1,
      looting: -1,
      targetingList: -1,
      target: -1,
      pathData: -1,
    };
  }

  // --- Player Position ---
  getPlayerPosition() {
    if (!this.playerPosArray) return null;

    const counter = Atomics.load(
      this.playerPosArray,
      PLAYER_POS_UPDATE_COUNTER_INDEX,
    );
    if (counter === this.lastCounters.playerPos) return null;

    this.lastCounters.playerPos = counter;
    return {
      x: Atomics.load(this.playerPosArray, PLAYER_X_INDEX),
      y: Atomics.load(this.playerPosArray, PLAYER_Y_INDEX),
      z: Atomics.load(this.playerPosArray, PLAYER_Z_INDEX),
    };
  }

  // --- Battle List ---
  getBattleList() {
    if (!this.battleListArray) return [];

    const count = Atomics.load(this.battleListArray, BATTLE_LIST_COUNT_INDEX);
    const entries = [];

    for (let i = 0; i < count; i++) {
      const startIdx =
        BATTLE_LIST_ENTRIES_START_INDEX + i * BATTLE_LIST_ENTRY_SIZE;
      let name = '';

      for (let j = 0; j < 32; j++) { // Read name (first 32 ints)
        const charCode = Atomics.load(this.battleListArray, startIdx + j);
        if (charCode === 0) break;
        name += String.fromCharCode(charCode);
      }

      if (name) {
        const x = Atomics.load(this.battleListArray, startIdx + 32);
        const y = Atomics.load(this.battleListArray, startIdx + 33);
        entries.push({ name, x, y });
      }
    }

    return entries;
  }

  writeBattleList(entries) {
    if (!this.battleListArray) return;

    const count = Math.min(entries.length, 50); // MAX_BATTLE_LIST_ENTRIES
    Atomics.store(this.battleListArray, BATTLE_LIST_COUNT_INDEX, count);

    for (let i = 0; i < count; i++) {
      const name = entries[i].name;
      const startIdx =
        BATTLE_LIST_ENTRIES_START_INDEX + i * BATTLE_LIST_ENTRY_SIZE;

      for (let j = 0; j < 32; j++) {
        const charCode = j < name.length ? name.charCodeAt(j) : 0;
        Atomics.store(this.battleListArray, startIdx + j, charCode);
      }
      Atomics.store(this.battleListArray, startIdx + 32, entries[i].x || 0);
      Atomics.store(this.battleListArray, startIdx + 33, entries[i].y || 0);
    }

    Atomics.add(this.battleListArray, BATTLE_LIST_UPDATE_COUNTER_INDEX, 1);
  }

  // --- Creatures ---
  getCreatures() {
    if (!this.creaturesArray) return [];

    const count = Atomics.load(this.creaturesArray, CREATURES_COUNT_INDEX);
    const creatures = [];

    for (let i = 0; i < count; i++) {
      const startIdx = CREATURES_DATA_START_INDEX + i * CREATURE_DATA_SIZE;

      let name = '';
      for (let j = 0; j < CREATURE_NAME_LENGTH; j++) {
        const charCode = Atomics.load(
          this.creaturesArray,
          startIdx + CREATURE_NAME_START_OFFSET + j,
        );
        if (charCode === 0) break;
        name += String.fromCharCode(charCode);
      }

      const hpCode = Atomics.load(
        this.creaturesArray,
        startIdx + CREATURE_HP_OFFSET,
      );

      creatures.push({
        instanceId: Atomics.load(
          this.creaturesArray,
          startIdx + CREATURE_INSTANCE_ID_OFFSET,
        ),
        name,
        hp: hpCodeToString[hpCode] || 'Full',
        gameCoords: {
          x: Atomics.load(this.creaturesArray, startIdx + CREATURE_X_OFFSET),
          y: Atomics.load(this.creaturesArray, startIdx + CREATURE_Y_OFFSET),
          z: Atomics.load(this.creaturesArray, startIdx + CREATURE_Z_OFFSET),
        },
        absoluteCoords: {
          x: Atomics.load(this.creaturesArray, startIdx + CREATURE_ABSOLUTE_X_OFFSET),
          y: Atomics.load(this.creaturesArray, startIdx + CREATURE_ABSOLUTE_Y_OFFSET),
        },
        isReachable:
          Atomics.load(
            this.creaturesArray,
            startIdx + CREATURE_IS_REACHABLE_OFFSET,
          ) === 1,
        isAdjacent:
          Atomics.load(
            this.creaturesArray,
            startIdx + CREATURE_IS_ADJACENT_OFFSET,
          ) === 1,
        isBlockingPath:
          Atomics.load(
            this.creaturesArray,
            startIdx + CREATURE_IS_BLOCKING_PATH_OFFSET,
          ) === 1,
        distance:
          Atomics.load(
            this.creaturesArray,
            startIdx + CREATURE_DISTANCE_OFFSET,
          ) / 100,
      });
    }

    return creatures;
  }

  writeCreatures(creatures) {
    if (!this.creaturesArray) return;

    const count = Math.min(creatures.length, 100); // MAX_CREATURES
    Atomics.store(this.creaturesArray, CREATURES_COUNT_INDEX, count);

    for (let i = 0; i < count; i++) {
      const creature = creatures[i];
      const startIdx = CREATURES_DATA_START_INDEX + i * CREATURE_DATA_SIZE;

      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_INSTANCE_ID_OFFSET,
        creature.instanceId || 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_X_OFFSET,
        creature.gameCoords?.x || 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_Y_OFFSET,
        creature.gameCoords?.y || 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_Z_OFFSET,
        creature.gameCoords?.z || 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_ABSOLUTE_X_OFFSET,
        creature.absoluteCoords?.x || 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_ABSOLUTE_Y_OFFSET,
        creature.absoluteCoords?.y || 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_IS_REACHABLE_OFFSET,
        creature.isReachable ? 1 : 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_IS_ADJACENT_OFFSET,
        creature.isAdjacent ? 1 : 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_DISTANCE_OFFSET,
        Math.floor((creature.distance || 0) * 100),
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_HP_OFFSET,
        hpStringToCode[creature.hp] ?? 0,
      );
      Atomics.store(
        this.creaturesArray,
        startIdx + CREATURE_IS_BLOCKING_PATH_OFFSET,
        creature.isBlockingPath ? 1 : 0,
      );

      const name = creature.name || '';
      for (let j = 0; j < CREATURE_NAME_LENGTH; j++) {
        const charCode = j < name.length ? name.charCodeAt(j) : 0;
        Atomics.store(
          this.creaturesArray,
          startIdx + CREATURE_NAME_START_OFFSET + j,
          charCode,
        );
      }
    }

    Atomics.add(this.creaturesArray, CREATURES_UPDATE_COUNTER_INDEX, 1);
  }

  // --- Looting State ---
  isLootingRequired() {
    if (!this.lootingArray) return false;
    return Atomics.load(this.lootingArray, LOOTING_REQUIRED_INDEX) === 1;
  }

  setLootingRequired(required) {
    if (!this.lootingArray) return;

    Atomics.store(this.lootingArray, LOOTING_REQUIRED_INDEX, required ? 1 : 0);
    Atomics.add(this.lootingArray, LOOTING_UPDATE_COUNTER_INDEX, 1);
  }

  // --- Targeting List ---
  getTargetingList() {
    if (!this.targetingListArray) return [];

    const count = Atomics.load(
      this.targetingListArray,
      TARGETING_LIST_COUNT_INDEX,
    );
    const rules = [];

    for (let i = 0; i < count; i++) {
      const startIdx =
        TARGETING_LIST_DATA_START_INDEX + i * TARGETING_RULE_SIZE;

      // Read name (first 32 chars)
      let name = '';
      for (let j = 0; j < 32; j++) {
        const charCode = Atomics.load(this.targetingListArray, startIdx + j);
        if (charCode === 0) break;
        name += String.fromCharCode(charCode);
      }

      // Read action (next 4 chars)
      let action = '';
      for (let j = 32; j < 36; j++) {
        const charCode = Atomics.load(this.targetingListArray, startIdx + j);
        if (charCode === 0) break;
        action += String.fromCharCode(charCode);
      }

      const priority = Atomics.load(this.targetingListArray, startIdx + 36);
      const stickiness = Atomics.load(this.targetingListArray, startIdx + 37);
      const stance = Atomics.load(this.targetingListArray, startIdx + 38);
      const distance = Atomics.load(this.targetingListArray, startIdx + 39);
      const onlyIfTrapped = Atomics.load(this.targetingListArray, startIdx + 40);

      rules.push({
        name,
        action,
        priority,
        stickiness,
        stance:
          stance === 0
            ? 'Follow'
            : stance === 1
              ? 'Stand'
              : stance === 2
                ? 'Reach'
                : 'Follow',
        distance,
        onlyIfTrapped: onlyIfTrapped === 1,
      });
    }

    return rules;
  }

  writeTargetingList(rules) {
    if (!this.targetingListArray) return;

    const count = Math.min(rules.length, 50); // MAX_TARGETING_RULES
    Atomics.store(this.targetingListArray, TARGETING_LIST_COUNT_INDEX, count);

    for (let i = 0; i < count; i++) {
      const rule = rules[i];
      const startIdx =
        TARGETING_LIST_DATA_START_INDEX + i * TARGETING_RULE_SIZE;

      // Write name (32 chars)
      const name = rule.name || '';
      for (let j = 0; j < 32; j++) {
        const charCode = j < name.length ? name.charCodeAt(j) : 0;
        Atomics.store(this.targetingListArray, startIdx + j, charCode);
      }

      // Write action (4 chars)
      const action = rule.action || '';
      for (let j = 0; j < 4; j++) {
        const charCode = j < action.length ? action.charCodeAt(j) : 0;
        Atomics.store(this.targetingListArray, startIdx + 32 + j, charCode);
      }

      // Write numeric fields
      Atomics.store(this.targetingListArray, startIdx + 36, rule.priority || 0);
      Atomics.store(
        this.targetingListArray,
        startIdx + 37,
        rule.stickiness || 0,
      );
      Atomics.store(
        this.targetingListArray,
        startIdx + 38,
        rule.stance === 'Stand'
          ? 1
          : rule.stance === 'Reach'
            ? 2
            : 0,
      );
      Atomics.store(this.targetingListArray, startIdx + 39, rule.distance || 0);
      Atomics.store(
        this.targetingListArray,
        startIdx + 40,
        rule.onlyIfTrapped ? 1 : 0,
      );
    }

    Atomics.add(
      this.targetingListArray,
      TARGETING_LIST_UPDATE_COUNTER_INDEX,
      1,
    );
  }

  // --- Current Target ---
  getCurrentTarget() {
    if (!this.targetArray) return null;

    const instanceId = Atomics.load(this.targetArray, TARGET_INSTANCE_ID_INDEX);
    if (instanceId === 0) return null;

    let name = '';
    for (let i = 0; i < 32; i++) {
      const charCode = Atomics.load(
        this.targetArray,
        TARGET_NAME_START_INDEX + i,
      );
      if (charCode === 0) break;
      name += String.fromCharCode(charCode);
    }

    return {
      instanceId,
      name,
      gameCoordinates: {
        x: Atomics.load(this.targetArray, TARGET_X_INDEX),
        y: Atomics.load(this.targetArray, TARGET_Y_INDEX),
        z: Atomics.load(this.targetArray, TARGET_Z_INDEX),
      },
      distance: Atomics.load(this.targetArray, TARGET_DISTANCE_INDEX) / 100,
      isReachable:
        Atomics.load(this.targetArray, TARGET_IS_REACHABLE_INDEX) === 1,
    };
  }

  writeCurrentTarget(target) {
    if (!this.targetArray) return;

    if (!target) {
      Atomics.store(this.targetArray, TARGET_INSTANCE_ID_INDEX, 0);
      Atomics.add(this.targetArray, TARGET_UPDATE_COUNTER_INDEX, 1);
      return;
    }

    Atomics.store(
      this.targetArray,
      TARGET_INSTANCE_ID_INDEX,
      target.instanceId || 0,
    );
    Atomics.store(
      this.targetArray,
      TARGET_X_INDEX,
      target.gameCoordinates?.x || 0,
    );
    Atomics.store(
      this.targetArray,
      TARGET_Y_INDEX,
      target.gameCoordinates?.y || 0,
    );
    Atomics.store(
      this.targetArray,
      TARGET_Z_INDEX,
      target.gameCoordinates?.z || 0,
    );
    Atomics.store(
      this.targetArray,
      TARGET_DISTANCE_INDEX,
      Math.floor((target.distance || 0) * 100),
    );
    Atomics.store(
      this.targetArray,
      TARGET_IS_REACHABLE_INDEX,
      target.isReachable ? 1 : 0,
    );

    // Write name
    const name = target.name || '';
    for (let i = 0; i < 32; i++) {
      const charCode = i < name.length ? name.charCodeAt(i) : 0;
      Atomics.store(this.targetArray, TARGET_NAME_START_INDEX + i, charCode);
    }

    Atomics.add(this.targetArray, TARGET_UPDATE_COUNTER_INDEX, 1);
  }

  // --- Path Data ---
  getPath() {
    if (!this.pathDataArray)
      return { path: [], status: 0, chebyshevDistance: 0, pathStart: null };

    const pathLength = Atomics.load(this.pathDataArray, PATH_LENGTH_INDEX);
    const status = Atomics.load(this.pathDataArray, PATHFINDING_STATUS_INDEX);
    const chebyshevDistance = Atomics.load(
      this.pathDataArray,
      PATH_CHEBYSHEV_DISTANCE_INDEX,
    );
    const pathStart = {
      x: Atomics.load(this.pathDataArray, PATH_START_X_INDEX),
      y: Atomics.load(this.pathDataArray, PATH_START_Y_INDEX),
      z: Atomics.load(this.pathDataArray, PATH_START_Z_INDEX),
    };

    const path = [];
    const safePathLength = Math.min(pathLength, MAX_PATH_WAYPOINTS);

    for (let i = 0; i < safePathLength; i++) {
      const offset = PATH_WAYPOINTS_START_INDEX + i * PATH_WAYPOINT_SIZE;
      path.push({
        x: Atomics.load(this.pathDataArray, offset + 0),
        y: Atomics.load(this.pathDataArray, offset + 1),
        z: Atomics.load(this.pathDataArray, offset + 2),
      });
    }

    return { path, status, chebyshevDistance, pathStart };
  }

  getCavebotTargetWaypoint() {
    if (!this.pathDataArray) return null;
    // This assumes the pathDataSAB is the single source of truth for the cavebot's destination
    return {
      x: Atomics.load(this.pathDataArray, PATH_TARGET_X_INDEX),
      y: Atomics.load(this.pathDataArray, PATH_TARGET_Y_INDEX),
      z: Atomics.load(this.pathDataArray, PATH_TARGET_Z_INDEX),
    };
  }

  // --- Utility Methods ---
  hasDataChanged(type) {
    if (!this[`${type}Array`]) return false;

    const counterMap = {
      playerPos: PLAYER_POS_UPDATE_COUNTER_INDEX,
      battleList: BATTLE_LIST_UPDATE_COUNTER_INDEX,
      creatures: CREATURES_UPDATE_COUNTER_INDEX,
      looting: LOOTING_UPDATE_COUNTER_INDEX,
      targetingList: TARGETING_LIST_UPDATE_COUNTER_INDEX,
      target: TARGET_UPDATE_COUNTER_INDEX,
      pathData: PATH_UPDATE_COUNTER_INDEX,
    };

    const counterIndex = counterMap[type];
    if (counterIndex === undefined) return false;

    const currentCounter = Atomics.load(this[`${type}Array`], counterIndex);
    const hasChanged = currentCounter !== this.lastCounters[type];

    if (hasChanged) {
      this.lastCounters[type] = currentCounter;
    }

    return hasChanged;
  }

  // --- Batch Operations ---
  getGameState() {
    return {
      playerPosition: this.getPlayerPosition(),
      battleList: this.getBattleList(),
      creatures: this.getCreatures(),
      isLootingRequired: this.isLootingRequired(),
      targetingList: this.getTargetingList(),
      currentTarget: this.getCurrentTarget(),
      pathData: this.getPath(),
    };
  }

  writeWorldState(state) {
    if (!this.creaturesArray || !this.battleListArray || !this.targetArray) {
      return;
    }

    // Write all the individual components of the state.
    // Note: These methods already increment their own legacy counters, which is fine.
    this.writeBattleList(state.battleList || []);
    this.writeCreatures(state.creatures || []);
    this.writeCurrentTarget(state.target || null);

    // Atomically increment the main world state counter to signal a consistent write.
    Atomics.add(this.creaturesArray, WORLD_STATE_UPDATE_COUNTER_INDEX, 1);
  }

  // --- Creature Monitor Handshake ---
  writeCreatureMonitorLastProcessedZ(zLevel) {
    if (!this.creaturesArray) return;
    Atomics.store(
      this.creaturesArray,
      CREATURE_MONITOR_LAST_PROCESSED_Z_INDEX,
      zLevel,
    );
  }

  readCreatureMonitorLastProcessedZ() {
    if (!this.creaturesArray) return null;
    return Atomics.load(
      this.creaturesArray,
      CREATURE_MONITOR_LAST_PROCESSED_Z_INDEX,
    );
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/CooldownManager.js
//start file
import { performance as perf } from 'perf_hooks';

// Configuration Section
const CONFIG = {
  ENABLE_COOLDOWN_LOGGING: false,
  DEBOUNCE_DURATION: 50,
  HISTORY_LENGTH: 3,
  MAX_COOLDOWN_DURATIONS: {
    attack: 2000,
    healing: 1000,
    support: 500,
  },
};

const COOLDOWN_DURATIONS = {
  healing: 1000,
  attack: 1950,
  support: 500,
};

export class CooldownManager {
  constructor() {
    this.cooldowns = {
      healing: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
      attack: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
      support: {
        active: false,
        startTime: 0,
        debounceEndTime: 0,
        history: [],
      },
    };
  }

  forceDeactivate(type) {
    const cooldown = this.cooldowns[type];
    const now = perf.now();

    cooldown.active = false;
    cooldown.startTime = 0;
    cooldown.debounceEndTime = now + CONFIG.DEBOUNCE_DURATION;
    cooldown.history = [];

    if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
      console.log(`${type} cooldown force-deactivated by UI state`);
    }
  }

  updateCooldown(type, isActive) {
    const now = perf.now();
    const cooldown = this.cooldowns[type];

    // Update state history
    cooldown.history.push(isActive);
    if (cooldown.history.length > CONFIG.HISTORY_LENGTH) {
      cooldown.history.shift();
    }

    // Determine consistent state
    const activeCount = cooldown.history.filter((state) => state).length;
    const consistentActive = activeCount >= Math.ceil(CONFIG.HISTORY_LENGTH / 2);

    // Activation logic
    if (consistentActive && !cooldown.active && now >= cooldown.debounceEndTime) {
      cooldown.active = true;
      cooldown.startTime = now;
      cooldown.debounceEndTime = now + COOLDOWN_DURATIONS[type] - CONFIG.DEBOUNCE_DURATION;

      if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
        console.log(`${type} cooldown activated`);
      }
    }

    // Deactivation logic
    if (!consistentActive && cooldown.active && now >= cooldown.debounceEndTime) {
      const elapsedTime = now - cooldown.startTime;
      const maxDuration = CONFIG.MAX_COOLDOWN_DURATIONS[type];

      if (elapsedTime >= COOLDOWN_DURATIONS[type] || elapsedTime >= maxDuration) {
        cooldown.active = false;
        cooldown.debounceEndTime = now + CONFIG.DEBOUNCE_DURATION;

        if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
          console.log(`${type} cooldown naturally deactivated after ${elapsedTime.toFixed(1)}ms`);
        }
      }
    }

    return cooldown.active;
  }

  getCooldownState(type) {
    const cooldown = this.cooldowns[type];
    if (cooldown.active) {
      const elapsedTime = perf.now() - cooldown.startTime;
      const maxDuration = CONFIG.MAX_COOLDOWN_DURATIONS[type];

      // Force expiration if beyond maximum allowed duration
      if (elapsedTime >= maxDuration) {
        cooldown.active = false;
        cooldown.debounceEndTime = perf.now() + CONFIG.DEBOUNCE_DURATION;

        if (CONFIG.ENABLE_COOLDOWN_LOGGING) {
          console.log(`${type} cooldown forced expiration after ${elapsedTime.toFixed(2)}ms`);
        }
      }
    }
    return cooldown.active;
  }

  getStats() {
    if (!CONFIG.ENABLE_COOLDOWN_LOGGING) return null;

    const stats = {};
    const now = perf.now();

    for (const [type, data] of Object.entries(this.cooldowns)) {
      const currentDuration = data.active ? now - data.startTime : 0;
      stats[type] = {
        isActive: data.active,
        currentActiveDuration: currentDuration,
        debounceEndTime: data.debounceEndTime,
        history: [...data.history],
      };
    }

    return stats;
  }
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/constants.js
//start file
export const OPTIONS = {
  globalDelay: 0,
  categoryDelays: {
    Healing: 200,
    Potion: 975,
    Support: 475,
    Attack: 1975,
    Equip: 250,
    Others: 50,
  },
  cooldownStateMapping: {
    Healing: 'healingCd',
    Support: 'supportCd',
    Attack: 'attackCd',
  },
  logsEnabled: false,
};

export const PARTY_MEMBER_STATUS = {
  active: {
    sequence: [
      [192, 192, 192],
      [192, 192, 192],
    ],
    direction: 'horizontal',
  },
  activeHover: {
    sequence: [
      [247, 247, 247],
      [247, 247, 247],
    ],
    direction: 'horizontal',
  },
  // inactive: {
  //   sequence: [
  //     [128, 128, 128],
  //     [128, 128, 128],
  //   ],
  //   direction: 'horizontal',
  // },
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/ruleFilterUtils.js
//start file
import parseMathCondition from '../../utils/parseMathCondition.js';
import areCharStatusConditionsMet from '../../utils/areStatusConditionsMet.js';
import { OPTIONS } from './constants.js';

let lastRuleExecutionTimes = {};
let lastCategoriesExecutionTimes = {};

export const filterEnabledRules = (rules) => rules.filter((rule) => rule.enabled);

export const filterRulesNotOnDelay = (rules) =>
  rules.filter(
    (rule) =>
      Date.now() - (lastRuleExecutionTimes[rule.id] || 0) >= (rule.delay || 0) &&
      Date.now() -
        Math.max(
          ...rules
            .filter((r) => r.category === rule.category)
            .map((r) => lastRuleExecutionTimes[r.id] || 0),
        ) >=
        OPTIONS.categoryDelays[rule.category],
  );

export const filterRulesByActiveCooldowns = (rules, directGameState) =>
  rules.filter((rule) => {
    const cooldownStateKey = OPTIONS.cooldownStateMapping[rule.category];
    return !cooldownStateKey || !directGameState[cooldownStateKey];
  });

export const filterRulesByConditions = (rules, directGameState) =>
  rules.filter((rule) => {
    return (
      parseMathCondition(
        rule.hpTriggerCondition,
        parseInt(rule.hpTriggerPercentage, 10),
        directGameState.hppc,
      ) &&
      parseMathCondition(
        rule.manaTriggerCondition,
        parseInt(rule.manaTriggerPercentage, 10),
        directGameState.mppc,
      ) &&
      areCharStatusConditionsMet(rule, directGameState) &&
      parseMathCondition(
        rule.monsterNumCondition,
        parseInt(rule.monsterNum, 10),
        directGameState.monsterNum,
      )
    );
  });

export const getAllValidRules = (rules, directGameState) => {
  const enabledRules = filterEnabledRules(rules);
  const rulesWithoutActiveCooldowns = filterRulesByActiveCooldowns(enabledRules, directGameState);
  const rulesNotOnDelay = filterRulesNotOnDelay(rulesWithoutActiveCooldowns);
  return filterRulesByConditions(rulesNotOnDelay, directGameState).sort(
    (a, b) => b.priority - a.priority,
  );
};

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor/ruleProcessor.js
//start file
import parseMathCondition from '../../utils/parseMathCondition.js';
import areCharStatusConditionsMet from '../../utils/areStatusConditionsMet.js';
import { createLogger } from '../../utils/logger.js';

const log = createLogger({ info: false, error: true, warn: true });

import { getRandomNumber } from '../../utils/getRandomNumber.js';
import { OPTIONS } from './constants.js';

class RuleProcessor {
  constructor(parentPort) {
    this.parentPort = parentPort;
    this.lastSuccessfulRuleActionTime = {}; // PRIMARY FOR DELAY on non-ManaSync rules
    this.lastCategoryExecutionTime = {};
    this.lastPartyHealActionTime = 0;
    this.lastAttackCooldownState = false;
    this.attackCooldownStartTime = null;
    this.lastKeypressTime = 0;
    this.effectiveCooldownEndTime = 0;

    // ManaSync specific state
    this.manaSyncWatchList = new Map();
    this.executedManaSyncThisCooldown = new Set();
    this.forcedManaSyncExecutedThisCooldown = new Set();

    this.pendingActionConfirmations = new Map(); // For item disappearance check

    // Attack CD Exclusivity state
    this.actionTakenThisAttackCooldown = false;
    this.healFriendRuneExecutionsThisAttackCooldown = 0;

    // Constants
    this.KEYPRESS_COOLDOWN_MS = 50;
    this.PARTY_HEAL_MIN_INTERVAL_MS = 50;
    this.MANASYNC_FORCED_EXECUTION_DELAY_MS = 740;
    this.MANASYNC_FORCED_EXECUTION_WINDOW_MS = 100;
    this.MANA_SYNC_WATCH_DURATION_MS = 800;
    this.ACTION_CONFIRMATION_TIMEOUT_MS = 300;

    this.RULE_PREFIX = {
      USER: 'userRule',
      ACTION_BAR: 'actionBarItem',
      MANA_SYNC: 'manaSync',
      PARTY_HEAL: 'healFriend',
      ROTATION: 'rotationRule',
      EQUIP: 'equipRule',
    };
    this.PARTY_HEAL_RUNE_ITEMS = new Set([
      'ultimateHealingRune',
      'intenseHealingRune',
    ]);
    this.lastRuleExecutionTime = {}; // NEW: To track last execution time for each rule
  }

  async processRules(activePreset, gameState, globalConfig) {
    // getIsTyping() is removed, need to handle this.
    // For now, we will assume it's always false or remove the check if it's not critical.
    // If it's critical, we need to find an alternative way to check typing status.
    // For this task, I will remove the check for getIsTyping() for now.
    // if (getIsTyping()) {
    //   return;
    // }

    if (!globalConfig.isOnline) {
      return;
    }

    if (!gameState.rulesEnabled) {
      return;
    }

    const now = performance.now();
    const attackCdChanged = this._handleAttackCooldownTransitions(
      now,
      gameState,
      activePreset,
      globalConfig,
    );
    let manaSyncRuleExecutedImmediately = attackCdChanged.executed;

    let manaSyncRuleExecutedFromWatch = false;
    if (
      !manaSyncRuleExecutedImmediately &&
      gameState.attackCd &&
      this.manaSyncWatchList.size > 0 &&
      !this.actionTakenThisAttackCooldown
    ) {
      manaSyncRuleExecutedFromWatch = this._processManaSyncWatch(
        now,
        gameState,
        activePreset,
        globalConfig,
      );
    }

    let manaSyncRuleForcedExecution = false;
    if (
      gameState.attackCd &&
      !this.actionTakenThisAttackCooldown &&
      !manaSyncRuleExecutedImmediately &&
      !manaSyncRuleExecutedFromWatch
    ) {
      manaSyncRuleForcedExecution = this._processForcedManaSyncExecution(
        now,
        gameState,
        activePreset,
        globalConfig,
      );
    }

    // --- Action Confirmation Processing ---
    this._processActionConfirmations(now, gameState);

    let ruleActionTriggeredThisCycle =
      manaSyncRuleExecutedImmediately ||
      manaSyncRuleExecutedFromWatch ||
      manaSyncRuleForcedExecution;

    // --- Standard Rule Processing (User, Equip, ActionBar, PartyHeal non-rune) ---
    if (!ruleActionTriggeredThisCycle) {
      const nonManaSyncPreset = activePreset.filter(
        (r) => !r.id.startsWith(this.RULE_PREFIX.MANA_SYNC),
      );
      const eligibleRules = this._filterEligibleRules(
        now,
        nonManaSyncPreset,
        gameState,
      );

      if (eligibleRules.length > 0) {
        const ruleToExecute = eligibleRules[0];
        const nonManaSyncActionSuccess = this._attemptExecutionAndHandleOutcome(
          now,
          ruleToExecute,
          gameState,
          globalConfig,
        );

        if (nonManaSyncActionSuccess) {
          ruleActionTriggeredThisCycle = true;
        }
      }
    }
  }

  // --- Filtering Logic ---
  _filterEligibleRules(now, rules, gameState) {
    let eligibleRules = rules.filter((rule) => rule.enabled);

    eligibleRules = this._filterRulesByActiveCooldowns(
      eligibleRules,
      gameState,
    );

    eligibleRules = this._filterRulesNotOnDelay(now, eligibleRules);

    eligibleRules = this._filterRulesByWalkingState(eligibleRules, gameState);

    // ADDED FILTERS
    eligibleRules = this._filterRulesByBasicConditions(eligibleRules, gameState);
    eligibleRules = this._filterRulesByItemAvailability(eligibleRules, gameState);
    // END ADDED FILTERS

    eligibleRules = eligibleRules.filter((rule) => {
      /* PartyHeal Interval Filter */
      if (rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        const timeSinceLastHeal = now - this.lastPartyHealActionTime;
        return timeSinceLastHeal >= this.PARTY_HEAL_MIN_INTERVAL_MS;
      }
      return true;
    });

    eligibleRules = eligibleRules.filter((rule) => {
      /* HealFriend Rune Exclusivity */
      if (
        rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem)
      ) {
        if (gameState.attackCd) {
          if (this.actionTakenThisAttackCooldown) {
            return false;
          }
          if (this.healFriendRuneExecutionsThisAttackCooldown >= 2) {
            return false;
          }
        }
      }
      return true;
    });

    eligibleRules = eligibleRules.filter((rule) => {
      /* Equip Rule Specifics */
      if (rule.id.startsWith(this.RULE_PREFIX.EQUIP)) {
        if (
          typeof rule.actionItem !== 'string' ||
          rule.actionItem.trim() === '' ||
          !rule.targetSlot
        )
          return false;
        if (typeof rule.equipOnlyIfSlotIsEmpty !== 'boolean') return false;

        const currentItemInSlot = gameState.equippedItems?.[rule.targetSlot];
        const itemToBeEquippedName =
          rule.itemToBeEquippedName || rule.actionItem;

        if (rule.equipOnlyIfSlotIsEmpty) {
          let expectedEmptyItemKey;
          // {{change 1}}
          if (rule.targetSlot === 'amulet') {
            expectedEmptyItemKey = 'Empty';
          } else if (rule.targetSlot === 'ring') {
            expectedEmptyItemKey = 'Empty';
          } else if (rule.targetSlot === 'boots') {
            expectedEmptyItemKey = 'Empty';
          } else {
            return false;
          }
          if (currentItemInSlot !== expectedEmptyItemKey) {
            return false;
          }
        }
        // Avoid re-equipping if the item is already in the slot
        if (currentItemInSlot === itemToBeEquippedName) {
          return false;
        }
        return true;
      }
      return true;
    });

    eligibleRules = eligibleRules.filter((rule) => {
      /* PartyHeal Final Condition */
      if (rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        return this._shouldHealFriend(rule, gameState);
      }
      return true;
    });

    eligibleRules.sort((a, b) => (b.priority || 0) - (a.priority || 0));
    return eligibleRules;
  }

  _filterRulesNotOnDelay(now, rules) {
    return rules.filter((rule) => {
      const ruleId = rule.id;
      const ruleDelay = rule.delay ?? 0;
      const category = rule.category;

      // NEW: Rule-specific cooldown
      const timeSinceLastRuleExecution = now - (this.lastRuleExecutionTime[ruleId] || 0);
      if (timeSinceLastRuleExecution < 150) { // 150ms cooldown
        return false;
      }

      // INDIVIDUAL DELAY
      const timeSinceLastSuccessfulTrigger =
        now - (this.lastSuccessfulRuleActionTime[ruleId] || 0);
      if (timeSinceLastSuccessfulTrigger < ruleDelay) {
        return false;
      }

      // CATEGORY DELAY
      if (rule.id.startsWith(this.RULE_PREFIX.USER) && category) {
        const categoryDelay = OPTIONS.categoryDelays?.[category] ?? 0;
        if (categoryDelay > 0) {
          const timeSinceCategoryLastTrigger =
            now - (this.lastCategoryExecutionTime[category] || 0);
          if (timeSinceCategoryLastTrigger < categoryDelay) {
            return false;
          }
        }
      }
      return true;
    });
  }

  _filterRulesByActiveCooldowns(rules, gameState) {
    return rules.filter((rule) => {
      if (rule.id.startsWith(this.RULE_PREFIX.USER)) {
        const cooldownStateKey = rule.category
          ? OPTIONS.cooldownStateMapping?.[rule.category]
          : null;
        return !cooldownStateKey || !gameState[cooldownStateKey];
      }
      return true;
    });
  }

  _filterRulesByWalkingState(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.USER) ||
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR)
      ) {
        return !rule.isWalking || (rule.isWalking && gameState.isWalking);
      }
      return true;
    });
  }

  _filterRulesByBasicConditions(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.USER) ||
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR) ||
        rule.id.startsWith(this.RULE_PREFIX.EQUIP)
      ) {
        const hpMet = parseMathCondition(
          rule.hpTriggerCondition,
          parseInt(rule.hpTriggerPercentage, 10),
          gameState.hppc,
        );
        const manaMet = parseMathCondition(
          rule.manaTriggerCondition,
          parseInt(rule.manaTriggerPercentage, 10),
          gameState.mppc,
        );
        let monsterMet = true;
        if (rule.monsterNumCondition != null && rule.monsterNum != null) {
          monsterMet = parseMathCondition(
            rule.monsterNumCondition,
            parseInt(rule.monsterNum, 10),
            gameState.monsterNum,
          );
        }
        const statusMet = areCharStatusConditionsMet(rule, gameState);
        return hpMet && manaMet && statusMet && monsterMet;
      }
      return true;
    });
  }

  _filterRulesByItemAvailability(rules, gameState) {
    return rules.filter((rule) => {
      if (
        rule.id.startsWith(this.RULE_PREFIX.ACTION_BAR) ||
        rule.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) ||
        rule.id.startsWith(this.RULE_PREFIX.EQUIP)
      ) {
        const requiredItemToClick = rule.actionItem;
        if (
          typeof requiredItemToClick !== 'string' ||
          requiredItemToClick.trim() === ''
        ) {
          return false;
        }

        const isCreateRuneAction =
          requiredItemToClick.includes('create') &&
          requiredItemToClick.includes('Rune');

        if (isCreateRuneAction) {
          if (!gameState.activeActionItems?.['blankRune']) {
            return false;
          }
        }

        if (!gameState.activeActionItems?.[requiredItemToClick]) {
          return false;
        }
        return true;
      }
      return true;
    });
  }

  // --- ManaSync Logic ---
  _handleAttackCooldownTransitions(now, gameState, activePreset, globalConfig) {
    const attackCdIsCurrentlyActive = gameState.attackCd;
    const attackCdJustStarted =
      attackCdIsCurrentlyActive && !this.lastAttackCooldownState;
    const attackCdJustEnded =
      !attackCdIsCurrentlyActive && this.lastAttackCooldownState;
    let executedManaSyncNow = false;

    if (attackCdJustEnded) {
      this.manaSyncWatchList.clear();
      this.executedManaSyncThisCooldown.clear();
      this.forcedManaSyncExecutedThisCooldown.clear();
      this.attackCooldownStartTime = null;
    }

    if (attackCdJustStarted) {
      this.attackCooldownStartTime = now;
      this.manaSyncWatchList.clear();
      this.executedManaSyncThisCooldown.clear();
      this.forcedManaSyncExecutedThisCooldown.clear();
      this.actionTakenThisAttackCooldown = false;
      this.healFriendRuneExecutionsThisAttackCooldown = 0;

      const manaSyncRules = activePreset
        .filter((r) => r.enabled && r.id.startsWith(this.RULE_PREFIX.MANA_SYNC))
        .sort((a, b) => (b.priority || 0) - (a.priority || 0));

      for (const rule of manaSyncRules) {
        if (executedManaSyncNow || this.actionTakenThisAttackCooldown) break;
        const conditionsMet = this._checkManaSyncConditions(rule, gameState);
        const itemIsActive = !!gameState.activeActionItems?.[rule.actionItem];
        if (conditionsMet.all) {
          if (!rule.actionItem) {
            console.warn(`[RuleProc] ManaSync ${rule.id} no actionItem.`);
            continue;
          }
          if (itemIsActive) {
            if (
              !this._hasHigherPriorityEligibleHealFriend(
                gameState,
                activePreset,
                rule.priority || 0,
                now,
              )
            ) {
              const keypressSent = this._tryExecuteAction(
                now,
                rule,
                gameState,
                globalConfig,
                'manaSyncNormal',
              );
              if (keypressSent) {
                this.executedManaSyncThisCooldown.add(rule.id);
                this.actionTakenThisAttackCooldown = true;
                executedManaSyncNow = true;
              }
            }
          } else {
            this.manaSyncWatchList.set(rule.id, {
              startTime: now,
              checkedConditions: conditionsMet,
            });
          }
        }
      }
    }
    this.lastAttackCooldownState = attackCdIsCurrentlyActive;
    return {
      changed: attackCdJustStarted || attackCdJustEnded,
      executed: executedManaSyncNow,
    };
  }

  _processManaSyncWatch(now, gameState, activePreset, globalConfig) {
    if (this.manaSyncWatchList.size === 0 || this.actionTakenThisAttackCooldown)
      return false;
    let executedFromWatch = false;
    const rulesToRemoveFromWatch = [];
    const sortedWatchKeys = Array.from(this.manaSyncWatchList.keys())
      .sort
      /* by prio */
      ();

    for (const ruleId of sortedWatchKeys) {
      if (executedFromWatch || this.actionTakenThisAttackCooldown) break;
      const watchData = this.manaSyncWatchList.get(ruleId);
      const rule = activePreset.find((r) => r.id === ruleId);
      if (
        !rule ||
        !rule.actionItem ||
        this.executedManaSyncThisCooldown.has(ruleId) ||
        now - watchData.startTime > this.MANA_SYNC_WATCH_DURATION_MS
      ) {
        rulesToRemoveFromWatch.push(ruleId);
        continue;
      }
      const itemIsNowActive = !!gameState.activeActionItems?.[rule.actionItem];
      if (itemIsNowActive) {
        const conditionsStillMet = this._checkManaSyncConditions(
          rule,
          gameState,
        );
        if (conditionsStillMet.all) {
          if (
            !this._hasHigherPriorityEligibleHealFriend(
              gameState,
              activePreset,
              rule.priority || 0,
              now,
            )
          ) {
            const keypressSent = this._tryExecuteAction(
              now,
              rule,
              gameState,
              globalConfig,
              'manaSyncNormal',
            );
            if (keypressSent) {
              this.executedManaSyncThisCooldown.add(ruleId);
              this.actionTakenThisAttackCooldown = true;
              executedFromWatch = true;
            }
          }
        }
        rulesToRemoveFromWatch.push(ruleId);
      }
    }
    rulesToRemoveFromWatch.forEach((id) => this.manaSyncWatchList.delete(id));
    return executedFromWatch;
  }

  _processForcedManaSyncExecution(now, gameState, activePreset, globalConfig) {
    if (
      !gameState.attackCd ||
      !this.attackCooldownStartTime ||
      this.actionTakenThisAttackCooldown
    )
      return false;
    const timeSinceCdStart = now - this.attackCooldownStartTime;
    const isInForcedWindow =
      timeSinceCdStart >= this.MANASYNC_FORCED_EXECUTION_DELAY_MS &&
      timeSinceCdStart <=
        this.MANASYNC_FORCED_EXECUTION_DELAY_MS +
          this.MANASYNC_FORCED_EXECUTION_WINDOW_MS;
    if (!isInForcedWindow) return false;

    const manaSyncRules = activePreset
      .filter((r) => r.enabled && r.id.startsWith(this.RULE_PREFIX.MANA_SYNC))
      .sort((a, b) => (b.priority || 0) - (a.priority || 0));
    for (const rule of manaSyncRules) {
      if (this.actionTakenThisAttackCooldown) break;
      if (
        this.executedManaSyncThisCooldown.has(rule.id) ||
        this.forcedManaSyncExecutedThisCooldown.has(rule.id)
      )
        continue;
      const conditionsMet = this._checkManaSyncConditions(rule, gameState);
      if (conditionsMet.all) {
        if (
          !this._hasHigherPriorityEligibleHealFriend(
            gameState,
            activePreset,
            rule.priority || 0,
            now,
          )
        ) {
          const keypressSent = this._tryExecuteAction(
            now,
            rule,
            gameState,
            globalConfig,
            'manaSyncForced',
          );
          if (keypressSent) {
            this.forcedManaSyncExecutedThisCooldown.add(rule.id);
            this.actionTakenThisAttackCooldown = true;
            return true;
          }
        }
      }
    }
    return false;
  }

  _checkManaSyncConditions(rule, gameState) {
    const hpMet = parseMathCondition(
      rule.hpTriggerCondition ?? '>=',
      parseInt(rule.hpTriggerPercentage ?? 0, 10),
      gameState.hppc,
    );
    const manaMet = parseMathCondition(
      rule.manaTriggerCondition ?? '<=',
      parseInt(rule.manaTriggerPercentage ?? 100, 10),
      gameState.mppc,
    );
    const statusMet = areCharStatusConditionsMet(rule, gameState);
    return { hpMet, manaMet, statusMet, all: hpMet && manaMet && statusMet };
  }

  _hasHigherPriorityEligibleHealFriend(
    gameState,
    activePreset,
    manaSyncPriority,
    now,
  ) {
    if (this.actionTakenThisAttackCooldown) return false;
    const competingHealFriends = activePreset.filter(
      (r) =>
        r.enabled &&
        r.id.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        r.requireAttackCooldown === true &&
        (r.priority || 0) > manaSyncPriority,
    );
    if (competingHealFriends.length === 0) return false;
    for (const healRule of competingHealFriends) {
      if (
        this.PARTY_HEAL_RUNE_ITEMS.has(healRule.actionItem) &&
        this.healFriendRuneExecutionsThisAttackCooldown >= 2
      )
        continue;
      const healRuleDelay = healRule.delay ?? 0;
      const timeSinceHealRuleLastTrigger =
        now - (this.lastSuccessfulRuleActionTime[healRule.id] || 0);
      if (timeSinceHealRuleLastTrigger < healRuleDelay) continue;
      if (this._shouldHealFriend(healRule, gameState) && healRule.actionItem)
        return true;
    }
    return false;
  }

  // --- Action Execution and Confirmation ---
  _processActionConfirmations(now, gameState) {
    if (this.pendingActionConfirmations.size === 0) return;
    const ruleIdsToRemove = [];
    for (const [ruleId, data] of this.pendingActionConfirmations) {
      if (
        !gameState.activeActionItems?.[data.actionItem] ||
        now - data.attemptTimestamp > this.ACTION_CONFIRMATION_TIMEOUT_MS
      ) {
        ruleIdsToRemove.push(ruleId);
      }
    }
    ruleIdsToRemove.forEach((id) => this.pendingActionConfirmations.delete(id));
  }

  _attemptExecutionAndHandleOutcome(
    now,
    ruleToExecute,
    gameState,
    globalConfig,
  ) {
    const ruleId = ruleToExecute.id;

    if (this.pendingActionConfirmations.has(ruleId)) {
      return false;
    }

    const actionSuccess = this._tryExecuteAction(
      now,
      ruleToExecute,
      gameState,
      globalConfig,
      'standard',
    );

    if (actionSuccess) {
      this.lastSuccessfulRuleActionTime[ruleId] = now;
      this.lastRuleExecutionTime[ruleId] = now; // NEW: Record rule execution time

      if (ruleToExecute.category && ruleId.startsWith(this.RULE_PREFIX.USER)) {
        this.lastCategoryExecutionTime[ruleToExecute.category] = now;
      }
      if (ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL)) {
        this.lastPartyHealActionTime = now;
        if (
          this.PARTY_HEAL_RUNE_ITEMS.has(ruleToExecute.actionItem) &&
          gameState.attackCd
        ) {
          this.actionTakenThisAttackCooldown = true;
          this.healFriendRuneExecutionsThisAttackCooldown++;
        }
      }
      if (
        typeof ruleToExecute.actionItem === 'string' &&
        ruleToExecute.actionItem.length > 0
      ) {
        this.pendingActionConfirmations.set(ruleId, {
          attemptTimestamp: now,
          actionItem: ruleToExecute.actionItem,
        });
      }
      return true;
    }
    return false;
  }

  _tryExecuteAction(now, rule, gameState, globalConfig, executionType) {
    const ruleId = rule.id;
    const isManaSync = executionType.startsWith('manaSync');
    const isPriorityRuleForCooldown =
      isManaSync ||
      (ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem) &&
        gameState.attackCd);

    if (!isPriorityRuleForCooldown && now < this.effectiveCooldownEndTime) {
      return false;
    }

    if (!rule.key) {
      console.warn(`[RuleProc] Cannot execute ${ruleId}: Missing 'key'.`);
      return false;
    }

    let actionSent = false;
    try {
      if (
        ruleId.startsWith(this.RULE_PREFIX.PARTY_HEAL) &&
        this.PARTY_HEAL_RUNE_ITEMS.has(rule.actionItem)
      ) {
        const targetMember = this._findPartyHealTarget(rule, gameState);
        if (targetMember?.uhCoordinates) {
          this.parentPort.postMessage({
            type: 'inputAction',
            payload: {
              type: 'userRule', // New priority type
              action: {
                module: 'keypress',
                method: 'sendKey',
                args: [rule.key]
              }
            }
          });
          this.parentPort.postMessage({
            type: 'inputAction',
            payload: {
              type: 'userRule', // New priority type
              action: {
                module: 'mouseController',
                method: 'leftClick',
                args: [
                  targetMember.uhCoordinates.x + getRandomNumber(0, 130),
                  targetMember.uhCoordinates.y + getRandomNumber(0, 11)
                ]
              }
            }
          });
          actionSent = true;
        } else {
          console.warn(
            `[RuleProc] PartyHeal Rune ${ruleId}: No valid target found.`,
          );
        }
      } else {
        this.parentPort.postMessage({
          type: 'inputAction',
          payload: {
            type: 'userRule', // New priority type
            action: {
              module: 'keypress',
              method: 'sendKey',
              args: [rule.key]
            }
          }
        });
        actionSent = true;
      }

      if (actionSent) {
        this.lastKeypressTime = now;
        this.effectiveCooldownEndTime = now + 150; // Changed from (isPriorityRuleForCooldown ? 25 : this.KEYPRESS_COOLDOWN_MS);
      }
      return actionSent;
    } catch (error) {
      console.error(
        `[RuleProcessor] Error during action execution for ${ruleId} (Type: ${executionType}):`,
        error,
      );
      return false;
    }
  }

  // --- Party Heal Specific Logic ---
  _shouldHealFriend(rule, gameState) {
    if (!gameState?.partyMembers || rule.friendHpTriggerPercentage == null)
      return false;
    if (rule.requireAttackCooldown && !gameState.attackCd) return false;
    const hpTriggerPercentage = parseInt(rule.friendHpTriggerPercentage, 10);
    const partyPositionIndex = parseInt(rule.partyPosition, 10);
    if (
      isNaN(partyPositionIndex) ||
      partyPositionIndex < 0 ||
      isNaN(hpTriggerPercentage)
    )
      return false;
    if (partyPositionIndex === 0) {
      return gameState.partyMembers.some(
        (m) =>
          m.isActive &&
          m.hppc != null &&
          m.hppc > 0 &&
          m.hppc <= hpTriggerPercentage,
      );
    } else {
      const targetMember = gameState.partyMembers?.[partyPositionIndex - 1];
      return (
        !!targetMember &&
        targetMember.isActive &&
        targetMember.hppc != null &&
        targetMember.hppc > 0 &&
        targetMember.hppc <= hpTriggerPercentage
      );
    }
  }

  _findPartyHealTarget(rule, gameState) {
    const hpTriggerPercentage = parseInt(rule.friendHpTriggerPercentage, 10);
    const partyPositionIndex = parseInt(rule.partyPosition, 10);
    if (
      isNaN(partyPositionIndex) ||
      partyPositionIndex < 0 ||
      isNaN(hpTriggerPercentage)
    )
      return null;
    if (partyPositionIndex === 0) {
      const potentialTargets = gameState.partyMembers
        .filter(
          (m) =>
            m.isActive &&
            m.hppc != null &&
            m.hppc > 0 &&
            m.hppc <= hpTriggerPercentage,
        )
        .sort((a, b) => a.hppc - b.hppc);
      return potentialTargets[0] || null;
    } else {
      const targetMember = gameState.partyMembers?.[partyPositionIndex - 1];
      if (
        targetMember &&
        targetMember.isActive &&
        targetMember.hppc != null &&
        targetMember.hppc > 0 &&
        targetMember.hppc <= hpTriggerPercentage
      ) {
        return targetMember;
      }
      return null;
    }
  }
}

export default RuleProcessor;
//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/screenMonitor.js
// --- REFACTORED ---

import { parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';
import { resourceBars } from '../constants/index.js';
import calculatePercentages from '../screenMonitor/calcs/calculatePercentages.js';
import RuleProcessor from './screenMonitor/ruleProcessor.js';
import { CooldownManager } from './screenMonitor/CooldownManager.js';
import { FrameUpdateManager } from '../utils/frameUpdateManager.js';
import findSequences from 'find-sequences-native';
import actionBarItems from '../constants/actionBarItems.js';

const { sharedData } = workerData;
const SCAN_INTERVAL_MS = 50;

if (!sharedData) throw new Error('[ScreenMonitor] Shared data not provided.');
const { imageSAB, syncSAB } = sharedData;
const syncArray = new Int32Array(syncSAB);
const sharedBufferView = Buffer.from(imageSAB);

const WIDTH_INDEX = 1;
const HEIGHT_INDEX = 2;
const IS_RUNNING_INDEX = 3;

let currentState = null;
let isShuttingDown = false;
let isInitialized = false;
let hasScannedInitially = false;

const cooldownManager = new CooldownManager();
const ruleProcessorInstance = new RuleProcessor(parentPort);
const frameUpdateManager = new FrameUpdateManager();

let lastCalculatedState = {
  hppc: null,
  mppc: null,
  healingCd: false,
  supportCd: false,
  attackCd: false,
  characterStatus: {},
  partyMembers: [],
  isWalking: false,
  activeActionItems: {},
  equippedItems: {},
  lastMovementTimestamp: 0,
  lastKnownPlayerMinimapPosition: null,
  monsterNum: 0,
};

const reusableGameStateUpdate = {
  storeUpdate: true,
  type: 'gameState/updateGameStateFromMonitorData',
  payload: {},
};

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function initializeWorker() {
  console.log('[ScreenMonitor] Initializing worker...');
  isInitialized = true;
}

function runRules(ruleInput) {
  const { rules, global, regionCoordinates } = currentState;
  if (!rules?.enabled) return;
  const currentPreset = rules.presets?.[rules.activePresetIndex];
  if (!currentPreset) return;
  try {
    ruleProcessorInstance.processRules(currentPreset, ruleInput, {
      ...global,
      isOnline: regionCoordinates?.regions?.onlineMarker ?? false,
    });
  } catch (error) {
    console.error('[ScreenMonitor] Rule processing error:', error);
  }
}

function calculateHealthBar(bufferToUse, metadata, healthBarRegion) {
  if (!healthBarRegion) return lastCalculatedState.hppc;
  return calculatePercentages(
    bufferToUse,
    metadata,
    healthBarRegion,
    resourceBars.healthBar,
    94,
  );
}
function calculateManaBar(bufferToUse, metadata, manaBarRegion) {
  if (!manaBarRegion) return lastCalculatedState.mppc;
  return calculatePercentages(
    bufferToUse,
    metadata,
    manaBarRegion,
    resourceBars.manaBar,
    94,
  );
}
function calculateCooldowns(cooldownsRegion) {
  const activeCooldowns = cooldownsRegion?.children || {};
  const healingCd = cooldownManager.updateCooldown(
    'healing',
    !!activeCooldowns.healing,
  );
  const supportCd = cooldownManager.updateCooldown(
    'support',
    !!activeCooldowns.support,
  );
  const attackCd = cooldownManager.updateCooldown(
    'attack',
    !!activeCooldowns.attack,
  );
  if (activeCooldowns.attackInactive) cooldownManager.forceDeactivate('attack');
  if (activeCooldowns.healingInactive)
    cooldownManager.forceDeactivate('healing');
  if (activeCooldowns.supportInactive)
    cooldownManager.forceDeactivate('support');
  return { healingCd, supportCd, attackCd };
}
function calculateCharacterStatus(statusBarRegion) {
  const characterStatus = {};
  if (statusBarRegion?.children) {
    Object.keys(statusBarRegion.children).forEach((key) => {
      characterStatus[key] = !!statusBarRegion.children[key].x;
    });
  }
  return characterStatus;
}
function calculateEquippedItems(amuletSlot, ringSlot, bootsSlot) {
  const getEquippedItem = (slotRegion) => {
    if (!slotRegion?.children) return 'Unknown';
    const foundItems = Object.keys(slotRegion.children);
    if (foundItems.length === 0) return 'Empty';
    const actualItem = foundItems.find((item) => !item.includes('empty'));
    return actualItem || 'Empty';
  };
  return {
    amulet: getEquippedItem(amuletSlot),
    ring: getEquippedItem(ringSlot),
    boots: getEquippedItem(bootsSlot),
  };
}

async function findActionItemsInHotkeyBar(hotkeyBarRegion, buffer, metadata) {
    if (!hotkeyBarRegion || !hotkeyBarRegion.width || !hotkeyBarRegion.height) {
        return {};
    }

    const tasks = {};
    for (const [key, value] of Object.entries(actionBarItems)) {
        tasks[key] = {
            sequences: { [key]: value },
            searchArea: hotkeyBarRegion,
            occurrence: "first",
        };
    }

    const results = await findSequences.findSequencesNativeBatch(buffer, tasks);
    const foundItems = {};
    for (const [itemName, itemResult] of Object.entries(results)) {
        if (itemResult[itemName]) {
            const def = actionBarItems[itemName];
            const result = itemResult[itemName];
            foundItems[itemName] = {
                x: result.x,
                y: result.y,
                width: def.direction === 'vertical' ? 1 : def.sequence.length,
                height: def.direction === 'vertical' ? def.sequence.length : 1,
                rawPos: {
                    x: result.x - (def.offset?.x || 0),
                    y: result.y - (def.offset?.y || 0),
                },
            };
        }
    }
    return foundItems;
}


async function calculateActiveActionItems(hotkeyBarRegion, bufferToUse, metadata) {
    return await findActionItemsInHotkeyBar(hotkeyBarRegion, bufferToUse, metadata);
}

function calculateWalkingState() {
  const { gameState } = currentState;
  if (!gameState?.playerMinimapPosition) return lastCalculatedState.isWalking;
  const currentPos = gameState.playerMinimapPosition;
  const lastPos = lastCalculatedState.lastKnownPlayerMinimapPosition;
  const hasPositionChanged =
    !lastPos ||
    currentPos.x !== lastPos.x ||
    currentPos.y !== lastPos.y ||
    currentPos.z !== lastPos.z;
  if (hasPositionChanged) {
    lastCalculatedState.lastMovementTimestamp = performance.now();
    lastCalculatedState.lastKnownPlayerMinimapPosition = { ...currentPos };
    return true;
  }
  const timeSinceLastMove =
    performance.now() - (lastCalculatedState.lastMovementTimestamp || 0);
  return timeSinceLastMove < 750;
}

async function processGameState() {
  if (!isInitialized || !currentState?.regionCoordinates?.regions) return;

  try {
    if (!hasScannedInitially && !frameUpdateManager.shouldProcess()) {
      lastCalculatedState.isWalking = calculateWalkingState();
      if (currentState?.rules?.enabled && currentState.gameState) {
        runRules({
          ...currentState.gameState,
          ...lastCalculatedState,
          rulesEnabled: true,
        });
      }
      return;
    }

    if (Atomics.load(syncArray, IS_RUNNING_INDEX) === 0) return;

    const width = Atomics.load(syncArray, WIDTH_INDEX);
    const height = Atomics.load(syncArray, HEIGHT_INDEX);
    const { regions } = currentState.regionCoordinates;
    if (Object.keys(regions).length === 0 || width <= 0 || height <= 0) return;

    const metadata = { width, height };
    const bufferToUse = sharedBufferView;

    lastCalculatedState.hppc = calculateHealthBar(
      bufferToUse,
      metadata,
      regions.healthBar,
    );
    lastCalculatedState.mppc = calculateManaBar(
      bufferToUse,
      metadata,
      regions.manaBar,
    );
    Object.assign(lastCalculatedState, calculateCooldowns(regions.cooldownBar));
    lastCalculatedState.characterStatus = calculateCharacterStatus(
      regions.statusBar,
    );
    lastCalculatedState.equippedItems = calculateEquippedItems(
      regions.amuletSlot,
      regions.ringSlot,
      regions.bootsSlot,
    );
    lastCalculatedState.activeActionItems = await calculateActiveActionItems(
      regions.hotkeyBar,
      bufferToUse,
      metadata
    );

    // Correctly calculate monsterNum from the battleList state.
    lastCalculatedState.monsterNum =
      currentState.battleList?.entriesCount || 0;
    lastCalculatedState.isWalking = calculateWalkingState();

    reusableGameStateUpdate.payload = {
      hppc: lastCalculatedState.hppc,
      mppc: lastCalculatedState.mppc,
      monsterNum: lastCalculatedState.monsterNum,
      partyMembers: lastCalculatedState.partyMembers,
      healingCd: lastCalculatedState.healingCd,
      supportCd: lastCalculatedState.supportCd,
      attackCd: lastCalculatedState.attackCd,
      characterStatus: lastCalculatedState.characterStatus,
      isWalking: lastCalculatedState.isWalking,
      activeActionItems: lastCalculatedState.activeActionItems,
      equippedItems: lastCalculatedState.equippedItems,
    };
    parentPort.postMessage(reusableGameStateUpdate);

    hasScannedInitially = true;

    if (currentState?.rules?.enabled && currentState.gameState) {
      runRules({
        ...currentState.gameState,
        ...lastCalculatedState,
        rulesEnabled: true,
      });
    }
  } catch (error) {
    console.error('[ScreenMonitor] Error in processGameState:', error);
  }
}

async function mainLoop() {
  console.log('[ScreenMonitor] Starting main loop...');
  while (!isShuttingDown) {
    const loopStart = performance.now();
    try {
      await processGameState();
    } catch (error) {
      console.error('[ScreenMonitor] Error in main loop:', error);
      await delay(Math.max(SCAN_INTERVAL_MS * 2, 100));
      continue;
    }
    const elapsedTime = performance.now() - loopStart;
    const delayTime = Math.max(0, SCAN_INTERVAL_MS - elapsedTime);
    if (delayTime > 0) await delay(delayTime);
  }
  console.log('[ScreenMonitor] Main loop stopped.');
}

parentPort.on('message', (message) => {
  try {
    if (message.type === 'frame-update') {
      frameUpdateManager.addDirtyRects(message.payload.dirtyRects);
      return;
    }

    if (message.type === 'shutdown') {
      isShuttingDown = true;
    } else if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      Object.assign(currentState, message.payload);
      if (message.payload.regionCoordinates) {
        hasScannedInitially = false;
      }
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
      if (!isInitialized) initializeWorker();
    }
  } catch (error) {
    console.error('[ScreenMonitor] Error handling message:', error);
  }
});

async function startWorker() {
  console.log('[ScreenMonitor] Worker starting up...');
  mainLoop().catch((error) => {
    console.error('[ScreenMonitor] Fatal error in main loop:', error);
    process.exit(1);
  });
}

startWorker();

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/sharedConstants.js
//start file
// /home/feiron/Dokumenty/Automaton/electron/workers/sharedConstants.js

// --- SharedArrayBuffer (SAB) Indices for Player Position ---
export const PLAYER_X_INDEX = 0;
export const PLAYER_Y_INDEX = 1;
export const PLAYER_Z_INDEX = 2;
export const PLAYER_POS_UPDATE_COUNTER_INDEX = 3;
export const PLAYER_POS_SAB_SIZE = 4; // x, y, z, counter

// --- SharedArrayBuffer (SAB) Indices for Pathfinder Data ---
export const PATH_LENGTH_INDEX = 0;
export const PATH_CHEBYSHEV_DISTANCE_INDEX = 1;
export const PATH_START_X_INDEX = 2;
export const PATH_START_Y_INDEX = 3;
export const PATH_START_Z_INDEX = 4;
export const PATHFINDING_STATUS_INDEX = 5;
export const PATH_UPDATE_COUNTER_INDEX = 6;
export const PATH_BLOCKING_CREATURE_X_INDEX = 7;
export const PATH_BLOCKING_CREATURE_Y_INDEX = 8;
export const PATH_BLOCKING_CREATURE_Z_INDEX = 9;
export const PATH_TARGET_X_INDEX = 10;
export const PATH_TARGET_Y_INDEX = 11;
export const PATH_TARGET_Z_INDEX = 12;
export const PATH_WPT_ID_INDEX = 13; // Waypoint ID (string hash, stored as int)
export const PATH_INSTANCE_ID_INDEX = 14; // Creature Instance ID
export const PATH_WAYPOINTS_START_INDEX = 15;

// --- Path Data Configuration ---
export const MAX_PATH_WAYPOINTS = 1000;
export const PATH_WAYPOINT_SIZE = 3; // Each waypoint is x, y, z
export const PATH_DATA_SAB_SIZE =
  PATH_WAYPOINTS_START_INDEX + MAX_PATH_WAYPOINTS * PATH_WAYPOINT_SIZE;

// --- REMOVED: All constants related to creaturePosSAB are gone ---

// --- SharedArrayBuffer (SAB) Indices for Battle List ---
export const BATTLE_LIST_COUNT_INDEX = 0;
export const BATTLE_LIST_UPDATE_COUNTER_INDEX = 1;
export const BATTLE_LIST_ENTRIES_START_INDEX = 2;
export const MAX_BATTLE_LIST_ENTRIES = 50;
export const BATTLE_LIST_ENTRY_SIZE = 34; // 32 chars for name + x + y
export const BATTLE_LIST_SAB_SIZE =
  BATTLE_LIST_ENTRIES_START_INDEX +
  MAX_BATTLE_LIST_ENTRIES * BATTLE_LIST_ENTRY_SIZE;

// --- SharedArrayBuffer (SAB) Indices for Creatures ---
export const CREATURES_COUNT_INDEX = 0;
export const CREATURES_UPDATE_COUNTER_INDEX = 1; // Legacy counter for creature-specific updates
export const WORLD_STATE_UPDATE_COUNTER_INDEX = 2; // Incremented after a consistent world state is written
export const CREATURES_DATA_START_INDEX = 3;
export const MAX_CREATURES = 100;

// --- Creature Data Structure ---
// We are allocating a fixed size for each creature's data in the SAB.
// Numbers are stored directly. Strings are stored as character codes.
// A mapping is used for HP status to save space.
//
// Each creature record contains:
// - instanceId (1 int)
// - x, y, z coordinates (3 ints)
// - isReachable (1 int, boolean)
// - isAdjacent (1 int, boolean)
// - distance (1 int, float * 100)
// - hp (1 int, mapped enum)
// - name (32 ints, char codes)
// Total size = 1+3+1+1+1+1+1+32 = 41
export const CREATURE_DATA_SIZE = 43; // Added 2 for absoluteCoords

// Indices within a single creature's data block
export const CREATURE_INSTANCE_ID_OFFSET = 0;
export const CREATURE_X_OFFSET = 1;
export const CREATURE_Y_OFFSET = 2;
export const CREATURE_Z_OFFSET = 3;
export const CREATURE_IS_REACHABLE_OFFSET = 4;
export const CREATURE_IS_ADJACENT_OFFSET = 5;
export const CREATURE_DISTANCE_OFFSET = 6;
export const CREATURE_HP_OFFSET = 7;
export const CREATURE_IS_BLOCKING_PATH_OFFSET = 8;
export const CREATURE_ABSOLUTE_X_OFFSET = 9;
export const CREATURE_ABSOLUTE_Y_OFFSET = 10;
export const CREATURE_NAME_START_OFFSET = 11;
export const CREATURE_NAME_LENGTH = 32;

export const CREATURES_SAB_SIZE =
  CREATURES_DATA_START_INDEX + MAX_CREATURES * CREATURE_DATA_SIZE + 1;

// --- SharedArrayBuffer (SAB) Indices for Creature Monitor Handshake ---
export const CREATURE_MONITOR_LAST_PROCESSED_Z_INDEX =
  CREATURES_SAB_SIZE - 1;

// --- SharedArrayBuffer (SAB) Indices for Looting State ---
export const LOOTING_REQUIRED_INDEX = 0;
export const LOOTING_UPDATE_COUNTER_INDEX = 1;
export const LOOTING_SAB_SIZE = 2;

// --- SharedArrayBuffer (SAB) Indices for Targeting List ---
export const TARGETING_LIST_COUNT_INDEX = 0;
export const TARGETING_LIST_UPDATE_COUNTER_INDEX = 1;
export const TARGETING_LIST_DATA_START_INDEX = 2;
export const MAX_TARGETING_RULES = 50;
export const TARGETING_RULE_SIZE = 41; // name(32) + action(4) + priority(1) + stickiness(1) + stance(1) + distance(1) + onlyIfTrapped(1)
export const TARGETING_LIST_SAB_SIZE =
  TARGETING_LIST_DATA_START_INDEX + MAX_TARGETING_RULES * TARGETING_RULE_SIZE;

// --- SharedArrayBuffer (SAB) Indices for Current Target ---
export const TARGET_INSTANCE_ID_INDEX = 0;
export const TARGET_X_INDEX = 1;
export const TARGET_Y_INDEX = 2;
export const TARGET_Z_INDEX = 3;
export const TARGET_DISTANCE_INDEX = 4; // multiplied by 100
export const TARGET_IS_REACHABLE_INDEX = 5;
export const TARGET_NAME_START_INDEX = 6;
export const TARGET_UPDATE_COUNTER_INDEX = 38; // 32 chars for name + 6 data fields
export const TARGET_SAB_SIZE = 39;

// --- Pathfinder Status Codes ---
export const PATH_STATUS_IDLE = 0;
export const PATH_STATUS_PATH_FOUND = 1;
export const PATH_STATUS_WAYPOINT_REACHED = 2;
export const PATH_STATUS_NO_PATH_FOUND = 3;
export const PATH_STATUS_DIFFERENT_FLOOR = 4;
export const PATH_STATUS_ERROR = 5;
export const PATH_STATUS_NO_VALID_START_OR_END = 6;
export const PATH_STATUS_BLOCKED_BY_CREATURE = 7;

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/targeting/actions.js
//start file
import { createLogger } from '../../utils/logger.js';
import {
  PLAYER_POS_UPDATE_COUNTER_INDEX,
  PATH_UPDATE_COUNTER_INDEX,
  PATH_STATUS_PATH_FOUND,
  PATH_STATUS_WAYPOINT_REACHED,
} from '../sharedConstants.js';


const MOVEMENT_COOLDOWN_MS = 50;
const CLICK_POLL_INTERVAL_MS = 5;
const MOVE_CONFIRM_TIMEOUT_STRAIGHT_MS = 400;
const MOVE_CONFIRM_TIMEOUT_DIAGONAL_MS = 750;
const MOVE_CONFIRM_GRACE_DIAGONAL_MS = 150;

const TARGET_CONFIRMATION_TIMEOUT_MS = 750;
const TARGET_ACQUISITION_COOLDOWN_MS = 250;


export function createTargetingActions(workerContext) {
  const { playerPosArray, pathDataArray, parentPort, sabStateManager } =
    workerContext;
  const logger = createLogger({ info: true, error: true, debug: true });

  let previousSelectedTargetId = null;

  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  const postInputAction = (type, action) =>
    parentPort.postMessage({ type: 'inputAction', payload: { type, action } });

  const getDirectionKey = (current, target) => {
    const dx = target.x - current.x;
    const dy = target.y - current.y;
    if (dy < 0) {
      if (dx < 0) return 'q';
      if (dx === 0) return 'w';
      if (dx > 0) return 'e';
    } else if (dy === 0) {
      if (dx < 0) return 'a';
      if (dx > 0) return 'd';
    } else if (dy > 0) {
      if (dx < 0) return 'z';
      if (dx === 0) return 's';
      if (dx > 0) return 'c';
    }
    return null;
  };

  const awaitWalkConfirmation = (posCounter, pathCounter, timeoutMs) => {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        clearInterval(intervalId);
        reject(new Error(`awaitWalkConfirmation timed out`));
      }, timeoutMs);
      const intervalId = setInterval(() => {
        const posChanged =
          playerPosArray &&
          Atomics.load(playerPosArray, PLAYER_POS_UPDATE_COUNTER_INDEX) >
            posCounter;

        if (posChanged) {
          clearTimeout(timeoutId);
          clearInterval(intervalId);
          resolve(true);
        }
      }, CLICK_POLL_INTERVAL_MS);
    });
  };

  const awaitTargetConfirmation = (desiredTargetId, timeoutMs) => {
    return new Promise((resolve) => {
      const startTime = Date.now();
      const intervalId = setInterval(() => {
        const currentTarget = sabStateManager.getCurrentTarget();
        const isTargetAcquired =
          currentTarget && currentTarget.instanceId === desiredTargetId;
        const isTimedOut = Date.now() - startTime > timeoutMs;

        if (isTargetAcquired || isTimedOut) {
          clearInterval(intervalId);
          resolve(isTargetAcquired);
        }
      }, CLICK_POLL_INTERVAL_MS);
    });
  };

  const findRuleForCreature = (creature, targetingList) => {
    if (!creature || !creature.name || !targetingList) {
      return null;
    }
    const matchingRule = targetingList.find(
      (r) => r.action === 'Attack' && r.name === creature.name,
    );
    return matchingRule || null;
  };

  
  
  
  const selectBestTarget = (
    globalState,
    currentPathfindingTarget,
    targetingContext,
  ) => {
    const { targetingList } = globalState.targeting;
    const creatures = sabStateManager.getCreatures();
    const currentTarget = sabStateManager.getCurrentTarget();

    if (!targetingList?.length || !creatures?.length) {
      return { creature: null, rule: null };
    }

    const validCandidates = creatures
      .map((creature) => {
        const rule = findRuleForCreature(creature, targetingList);
        if (!rule) {
          return null;
        }

        if (rule.onlyIfTrapped && !creature.isBlockingPath) {
          return null;
        }

        if (!creature.isReachable) {
          return null;
        }

        
        let score = -rule.priority * 1000;

        
        if (
          currentPathfindingTarget &&
          creature.instanceId === currentPathfindingTarget.instanceId
        ) {
          score -= (rule.stickiness || 0) * 100;
        }

        
        score += creature.distance;

        
        if (creature.isAdjacent) {
          score -= 500;
        }

        return {
          creature,
          rule,
          score,
        };
      })
      .filter(Boolean);

    if (validCandidates.length === 0) {
      if (previousSelectedTargetId !== null) {
        logger('debug', '[selectBestTarget] No valid targets found.');
        previousSelectedTargetId = null;
      }
      return { creature: null, rule: null };
    }

    
    validCandidates.sort((a, b) => a.score - b.score);

    const bestCandidate = validCandidates[0];
    let bestTarget = bestCandidate.creature;
    const bestRule = bestCandidate.rule;

    
    if (
      currentTarget &&
      bestTarget &&
      currentTarget.name === bestTarget.name &&
      currentTarget.instanceId !== bestTarget.instanceId
    ) {
      
      
      const currentTargetDetails = creatures.find(
        (c) => c.instanceId === currentTarget.instanceId,
      );
      if (currentTargetDetails) {
        bestTarget = currentTargetDetails;
      }
    }

    if (bestTarget && bestTarget.instanceId !== previousSelectedTargetId) {
      logger(
        'debug',
        `[selectBestTarget] New best target selected: ${bestTarget.name} (ID: ${bestTarget.instanceId})`,
      );
      previousSelectedTargetId = bestTarget.instanceId;
    }

    return { creature: bestTarget, rule: bestRule };
  };

  
  
  
  const manageTargetAcquisition = async (
    targetingContext,
    pathfindingTarget,
    globalState,
  ) => {
    const currentTarget = sabStateManager.getCurrentTarget();
    const battleList = sabStateManager.getBattleList();
    const creatures = sabStateManager.getCreatures();

    if (!pathfindingTarget) return;

    
    if (
      currentTarget &&
      currentTarget.instanceId === pathfindingTarget.instanceId
    ) {
      return;
    }

    const now = Date.now();
    if (now < targetingContext.acquisitionUnlockTime) return;

    
    let cycleState = targetingContext.ambiguousTargetCycle.get(
      pathfindingTarget.name,
    );
    if (!cycleState) {
      
      cycleState = new Set();
      targetingContext.ambiguousTargetCycle.set(pathfindingTarget.name, cycleState);
    }

    
    let potentialEntries = battleList
      .map((entry, index) => ({ ...entry, index })) 
      .filter(
        (entry) =>
          entry.name === pathfindingTarget.name && !cycleState.has(entry.index),
      );

    if (potentialEntries.length === 0) {
      logger('info', `[manageTargetAcquisition] Exhausted all entries for ${pathfindingTarget.name}. Restarting cycle.`);
      cycleState.clear();
      potentialEntries = battleList
        .map((entry, index) => ({ ...entry, index }))
        .filter(
          (entry) =>
            entry.name === pathfindingTarget.name && !cycleState.has(entry.index),
        );
       if (potentialEntries.length === 0) {
         logger('warn', `[manageTargetAcquisition] No entries found for ${pathfindingTarget.name} even after resetting cycle. Aborting.`);
         return;
       }
    }

    
    let bestUntriedEntry = null;
    if (potentialEntries.length === 1) {
      bestUntriedEntry = potentialEntries[0];
    } else {
      
      let minDistance = Infinity;
      for (const entry of potentialEntries) {
        for (const creature of creatures) {
          if (creature.name === entry.name) {
            const dist = Math.sqrt(
              Math.pow(entry.x - creature.absoluteCoords.x, 2) +
                Math.pow(entry.y - creature.absoluteCoords.y, 2),
            );
            if (dist < minDistance) {
              minDistance = dist;
              bestUntriedEntry = entry;
            }
          }
        }
      }
    }

    if (bestUntriedEntry) {
      cycleState.add(bestUntriedEntry.index); 

      targetingContext.acquisitionUnlockTime =
        now + TARGET_ACQUISITION_COOLDOWN_MS;

      const coordString = `${bestUntriedEntry.x},${bestUntriedEntry.y}`;
      logger(
        'info',
        `[Targeting] Acquiring target: ${pathfindingTarget.name} (ID: ${pathfindingTarget.instanceId}). Best untried entry at index ${bestUntriedEntry.index}. Clicking at {${coordString}}. Cycle state size for name: ${cycleState.size}.`,
      );

      postInputAction('hotkey', {
        module: 'mouseController',
        method: 'leftClick',
        args: [bestUntriedEntry.x, bestUntriedEntry.y],
      });

      
      await awaitTargetConfirmation(
        pathfindingTarget.instanceId,
        TARGET_CONFIRMATION_TIMEOUT_MS,
      );
    }
  };

  
  
  
  const updateDynamicTarget = (pathfindingTarget, rule) => {
    if (!pathfindingTarget || !rule) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'cavebot/setDynamicTarget',
        payload: null,
      });
      return;
    }

    const dynamicGoal = {
      stance: rule.stance || 'Follow',
      distance: rule.distance ?? 1,
      targetCreaturePos: pathfindingTarget.gameCoords,
      targetInstanceId: pathfindingTarget.instanceId,
    };

    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/setDynamicTarget',
      payload: dynamicGoal,
    });
  };

  
  
  
  const manageMovement = async (
    targetingContext,
    path,
    pathfindingStatus,
    playerMinimapPosition,
    pathfindingTarget,
    rule,
  ) => {
    if (!pathfindingTarget || !rule) return;
    if (sabStateManager.isLootingRequired()) return;

    const desiredDistance = rule.distance === 0 ? 1 : rule.distance;
    if (desiredDistance === 1) {
      if (pathfindingTarget.isAdjacent) return;
    } else {
      if (pathfindingTarget.distance <= desiredDistance) return;
    }

    if (rule.stance === 'Stand') return;

    if (
      !targetingContext.lastDispatchedVisitedTile ||
      targetingContext.lastDispatchedVisitedTile.x !==
        playerMinimapPosition.x ||
      targetingContext.lastDispatchedVisitedTile.y !==
        playerMinimapPosition.y ||
      targetingContext.lastDispatchedVisitedTile.z !== playerMinimapPosition.z
    ) {
      parentPort.postMessage({
        storeUpdate: true,
        type: 'cavebot/addVisitedTile',
        payload: playerMinimapPosition,
      });
      targetingContext.lastDispatchedVisitedTile = { ...playerMinimapPosition };
    }

    const now = Date.now();
    if (
      ![PATH_STATUS_PATH_FOUND, PATH_STATUS_WAYPOINT_REACHED].includes(
        pathfindingStatus,
      ) ||
      path.length < 2 ||
      now - targetingContext.lastMovementTime < MOVEMENT_COOLDOWN_MS
    )
      return;

    const nextStep = path[1];
    const dirKey = getDirectionKey(playerMinimapPosition, nextStep);

    if (dirKey) {
      const posCounter = Atomics.load(
        playerPosArray,
        PLAYER_POS_UPDATE_COUNTER_INDEX,
      );
      const pathCounter = Atomics.load(
        pathDataArray,
        PATH_UPDATE_COUNTER_INDEX,
      );
      const isDiagonal = ['q', 'e', 'z', 'c'].includes(dirKey);
      const timeout = isDiagonal
        ? MOVE_CONFIRM_TIMEOUT_DIAGONAL_MS
        : MOVE_CONFIRM_TIMEOUT_STRAIGHT_MS;

      postInputAction('movement', {
        module: 'keypress',
        method: 'sendKey',
        args: [dirKey, null],
      });
      targetingContext.lastMovementTime = now;

      try {
        await awaitWalkConfirmation(posCounter, pathCounter, timeout);
        if (isDiagonal) await delay(MOVE_CONFIRM_GRACE_DIAGONAL_MS);
      } catch (error) {
        logger(
          'debug',
          `[manageMovement] Movement failed: ${error.message}, continuous loop will retry`,
        );
      }
    }
  };

  return {
    selectBestTarget,
    manageTargetAcquisition,
    updateDynamicTarget,
    manageMovement,
  };
}


export function createAmbiguousAcquirer({ sabStateManager, parentPort, targetingContext, logger }) {
  const LL_DEFAULT_VERIFICATION_TIMEOUT = 300; 
  const LL_DEFAULT_POLL_INTERVAL = 80; 
  const LL_CLICK_GAP_MIN = 30; 
  const LL_CLICK_GAP_JITTER = 20; 
  const LL_INDEX_RETRY_COOLDOWN = 250; 
  const LL_MAX_FULL_CYCLES = 2;
  const LL_FULL_CYCLE_COOLDOWN = 800; 

  function nowMs() { return Date.now(); }
  function sleep(ms) { return new Promise((res) => setTimeout(res, ms)); }
  function jitter(ms, j) { return ms + Math.floor(Math.random() * j); }

  function defaultVerifyMatch(currentTarget, candidateEntry, targetName, strictMatch, desiredInstanceId) {
    if (!currentTarget) return false;
    if (strictMatch && desiredInstanceId) {
      return currentTarget.instanceId === desiredInstanceId;
    }
    if (candidateEntry && candidateEntry.instanceId && currentTarget.instanceId) {
      return candidateEntry.instanceId === currentTarget.instanceId;
    }
    if (currentTarget.name !== targetName) return false;
    if (candidateEntry && candidateEntry.x != null && candidateEntry.y != null) {
      const dx = Math.abs((currentTarget.x || 0) - (candidateEntry.x || 0));
      const dy = Math.abs((currentTarget.y || 0) - (candidateEntry.y || 0));
      const dz = (currentTarget.z != null && candidateEntry.z != null) ? Math.abs(currentTarget.z - candidateEntry.z) : 0;
      return Math.max(dx, dy, dz) <= 3;
    }
    return true;
  }

  async function attemptAcquireAmbiguousLowLatency(targetName, options = {}) {
    const verificationTimeoutBase = options.verificationTimeoutMs ?? LL_DEFAULT_VERIFICATION_TIMEOUT;
    const pollInterval = options.pollIntervalMs ?? LL_DEFAULT_POLL_INTERVAL;
    const indexRetryCooldown = options.indexRetryCooldownMs ?? LL_INDEX_RETRY_COOLDOWN;
    const maxFullCycles = options.maxFullCycles ?? LL_MAX_FULL_CYCLES;
    const fullCycleCooldown = options.fullCycleCooldownMs ?? LL_FULL_CYCLE_COOLDOWN;
    const strictMatch = !!options.strictMatch;
    const desiredInstanceId = options.desiredInstanceId || null;

    if (!targetingContext._ambiguousMeta) targetingContext._ambiguousMeta = new Map();
    let meta = targetingContext._ambiguousMeta.get(targetName);
    if (!meta) {
      meta = { attempted: new Map(), fullCycles: 0, cooldownUntil: 0 };
      targetingContext._ambiguousMeta.set(targetName, meta);
    }

    
    const latArr = targetingContext._ambigAdaptive?.latencies || [];
    const medianLatency = latArr.length ? latArr.slice().sort((a,b)=>a-b)[Math.floor(latArr.length/2)] : null;
    const adaptiveTimeout = medianLatency ? Math.max(verificationTimeoutBase, Math.ceil(medianLatency * 1.4)) : verificationTimeoutBase;

    if (meta.cooldownUntil && meta.cooldownUntil > nowMs()) {
      return { success: false, reason: 'cooldown_active' };
    }

    function readCandidates() {
      const battleList = sabStateManager.getBattleList() || [];
      const candidates = [];
      for (let i = 0; i < battleList.length; i += 1) {
        const e = battleList[i];
        if (!e) continue;
        if (e.name === targetName) candidates.push({ index: i, entry: e });
      }
      return candidates;
    }

    
    function postClickAtCoords(x, y) {
      parentPort.postMessage({
        type: 'inputAction',
        payload: {
          type: 'hotkey',
          action: { module: 'mouseController', method: 'leftClick', args: [x, y] },
        },
      });
    }

    while (true) {
      const candidates = readCandidates();
      if (!candidates.length) return { success: false, reason: 'no_candidates' };

      
      for (const k of Array.from(meta.attempted.keys())) {
        if (!candidates.some(c => c.index === k)) meta.attempted.delete(k);
      }

      let next = candidates.find(c => !meta.attempted.has(c.index));
      if (!next) {
        
        meta.attempted.clear();
        meta.fullCycles = (meta.fullCycles || 0) + 1;
        if (meta.fullCycles >= maxFullCycles) {
          meta.cooldownUntil = nowMs() + fullCycleCooldown;
          meta.fullCycles = 0;
          logger && logger('debug', `[AmbigAcquirer] Exhausted cycles for ${targetName}, applying short cooldown ${fullCycleCooldown}ms`);
          return { success: false, reason: 'cycles_exhausted' };
        }
        const fresh = readCandidates();
        if (!fresh.length) return { success: false, reason: 'no_candidates_after_clear' };
        next = fresh[0];
      }

      const attemptId = Math.random().toString(36).slice(2,9);
      logger && logger('debug', `[AmbigAcquirer] clicking ${targetName} index=${next.index} attempt=${attemptId}`);

      
      postClickAtCoords(next.entry.x, next.entry.y);

      
      let current = sabStateManager.getCurrentTarget();
      if (defaultVerifyMatch(current, next.entry, targetName, strictMatch, desiredInstanceId)) {
        
        targetingContext._ambigAdaptive.latencies = (targetingContext._ambigAdaptive.latencies || []).slice(-9);
        targetingContext._ambigAdaptive.latencies.push(20);
        meta.fullCycles = 0;
        return { success: true, reason: 'verified_immediate', acquiredCurrentTarget: current };
      }

      
      const start = nowMs();
      let verified = false;
      while (nowMs() - start < adaptiveTimeout) {
        await sleep(pollInterval);
        current = sabStateManager.getCurrentTarget();
        if (defaultVerifyMatch(current, next.entry, targetName, strictMatch, desiredInstanceId)) {
          const latency = nowMs() - start;
          const buf = targetingContext._ambigAdaptive.latencies || [];
          buf.push(latency);
          if (buf.length > 9) buf.shift();
          targetingContext._ambigAdaptive.latencies = buf;
          meta.fullCycles = 0;
          logger && logger('debug', `[AmbigAcquirer] verified ${targetName} at index=${next.index} latency=${latency}ms attempt=${attemptId}`);
          return { success: true, reason: 'verified', acquiredCurrentTarget: current };
        }
      }

      
      meta.attempted.set(next.index, { count: (meta.attempted.get(next.index)?.count || 0) + 1, lastTs: nowMs() });
      logger && logger('debug', `[AmbigAcquirer] verification FAILED for ${targetName} index=${next.index} attempt=${attemptId}`);

      await sleep(indexRetryCooldown);
      await sleep(jitter(LL_CLICK_GAP_MIN, LL_CLICK_GAP_JITTER));
      
    }
  }

  return {
    attemptAcquireAmbiguousLowLatency,
  };
}

//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/targeting/targetingLogic.js
//start file
// targeting/targetingLogic.js

const MOVEMENT_COOLDOWN_MS = 50;

/**
 * Selects the best target from a list of creatures based on targeting rules.
 * This function is "pure" - it doesn't consider the current state, only the best possible choice right now.
 * @returns {object|null} The best creature object or null if no valid target is found.
 */
export function selectBestTarget(sabStateManager, targetingList) {
  const creatures = sabStateManager.getCreatures();
  if (!targetingList?.length || !creatures?.length) {
    return null;
  }

  const findRuleForCreature = (creature) => {
    if (!creature || !creature.name) return null;
    return targetingList.find(
      (r) => r.action === 'Attack' && r.name === creature.name
    );
  };

  const validCandidates = creatures
    .map((creature) => {
      const rule = findRuleForCreature(creature);
      if (!rule || !creature.isReachable) {
        return null;
      }
      if (rule.onlyIfTrapped && !creature.isBlockingPath) {
        return null;
      }

      // Lower score is better.
      let score = -rule.priority * 1000; // Higher priority = much lower score.
      score += creature.distance; // Closer is better.
      if (creature.isAdjacent) {
        score -= 500; // Strongly prefer adjacent creatures.
      }

      return { creature, rule, score };
    })
    .filter(Boolean);

  if (validCandidates.length === 0) {
    return null;
  }

  validCandidates.sort((a, b) => a.score - b.score);
  return validCandidates[0].creature;
}

/**
 * Clicks the next available entry in the battle list for a given creature name.
 * @returns {{success: boolean, reason?: string, clickedIndex?: number}}
 */
export function acquireTarget(
  sabStateManager,
  parentPort,
  targetName,
  lastClickedIndex
) {
  const battleList = sabStateManager.getBattleList() || [];
  const potentialEntries = battleList
    .map((entry, index) => ({ ...entry, index }))
    .filter((entry) => entry.name === targetName);

  if (potentialEntries.length === 0) {
    return { success: false, reason: 'not_in_battlelist' };
  }

  // Find the next entry to click after the last one we tried
  let nextEntry = potentialEntries.find(
    (entry) => entry.index > lastClickedIndex
  );

  // If no entry is found after the last index, wrap around to the first one
  if (!nextEntry) {
    nextEntry = potentialEntries[0];
  }

  parentPort.postMessage({
    type: 'inputAction',
    payload: {
      type: 'hotkey',
      action: {
        module: 'mouseController',
        method: 'leftClick',
        args: [nextEntry.x, nextEntry.y],
      },
    },
  });

  return { success: true, clickedIndex: nextEntry.index };
}

/**
 * Updates the pathfinding goal for the cavebot module.
 */
export function updateDynamicTarget(parentPort, pathfindingTarget, targetingList) {
  if (!pathfindingTarget) {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/setDynamicTarget',
      payload: null,
    });
    return;
  }

  const rule = targetingList.find((r) => r.name === pathfindingTarget.name);
  if (!rule) return;

  const dynamicGoal = {
    stance: rule.stance || 'Follow',
    distance: rule.distance ?? 1,
    targetCreaturePos: pathfindingTarget.gameCoords,
    targetInstanceId: pathfindingTarget.instanceId,
  };

  parentPort.postMessage({
    storeUpdate: true,
    type: 'cavebot/setDynamicTarget',
    payload: dynamicGoal,
  });
}

/**
 * Manages movement towards the target.
 */
export async function manageMovement(
  workerContext,
  targetingContext,
  currentTarget
) {
  const {
    path,
    playerMinimapPosition,
    parentPort,
    sabStateManager,
  } = workerContext;
  const { targetingList } = targetingContext;

  if (!currentTarget || sabStateManager.isLootingRequired()) return;

  const rule = targetingList.find((r) => r.name === currentTarget.name);
  if (!rule || rule.stance === 'Stand') return;

  const desiredDistance = rule.distance === 0 ? 1 : rule.distance;
  if (
    (desiredDistance === 1 && currentTarget.isAdjacent) ||
    currentTarget.distance <= desiredDistance
  ) {
    return; // We are at the desired distance, no need to move.
  }

  const now = Date.now();
  if (
    !playerMinimapPosition ||
    path.length < 2 ||
    now - targetingContext.lastMovementTime < MOVEMENT_COOLDOWN_MS ||
    workerContext.pathInstanceId !== currentTarget.instanceId
  ) {
    return;
  }

  const getDirectionKey = (current, target) => {
    const dx = target.x - current.x;
    const dy = target.y - current.y;
    if (dy < 0) {
      if (dx < 0) return 'q';
      if (dx === 0) return 'w';
      if (dx > 0) return 'e';
    } else if (dy === 0) {
      if (dx < 0) return 'a';
      if (dx > 0) return 'd';
    } else if (dy > 0) {
      if (dx < 0) return 'z';
      if (dx === 0) return 's';
      if (dx > 0) return 'c';
    }
    return null;
  };

  const nextStep = path[1];
  const dirKey = getDirectionKey(playerMinimapPosition, nextStep);

  if (dirKey) {
    parentPort.postMessage({
      type: 'inputAction',
      payload: {
        type: 'movement',
        action: { module: 'keypress', method: 'sendKey', args: [dirKey, null] },
      },
    });
    targetingContext.lastMovementTime = now;
  }
}
//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/targetingWorker.js
//start file
// targetingWorker.js
import { parentPort, workerData } from 'worker_threads';
import { createLogger } from '../utils/logger.js';
import { SABStateManager } from './sabStateManager.js';
import { performance } from 'perf_hooks';
import {
  selectBestTarget,
  acquireTarget,
  updateDynamicTarget,
  manageMovement,
} from './targeting/targetingLogic.js';
import {
  PATH_STATUS_IDLE,
  WORLD_STATE_UPDATE_COUNTER_INDEX,
} from './sharedConstants.js';

const logger = createLogger({ info: true, error: true, debug: false });
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// --- FSM States ---
const FSM_STATE = {
  IDLE: 'IDLE',
  SELECTING: 'SELECTING',
  ACQUIRING: 'ACQUIRING',
  ENGAGING: 'ENGAGING',
};

// --- Configuration ---
const config = {
  mainLoopIntervalMs: 100,
  unreachableTimeoutMs: 400,
  acquireTimeoutMs: 400, // Time to wait for target verification after a click
};

// --- Worker State (data from other sources) ---
const workerState = {
  globalState: null,
  isInitialized: false,
  isShuttingDown: false,
  playerMinimapPosition: null,
  path: [],
  pathfindingStatus: PATH_STATUS_IDLE,
  lastWorldStateCounter: -1,
  pathWptId: 0,
  pathInstanceId: 0,
};

// --- Targeting FSM State ---
const targetingState = {
  state: FSM_STATE.IDLE,
  pathfindingTarget: null, // The creature object we WANT to target
  currentTarget: null, // The creature object we ARE currently targeting
  unreachableSince: 0, // Timestamp for when currentTarget became unreachable
  lastAcquireAttempt: {
    timestamp: 0,
    battleListIndex: -1,
    targetName: '',
  },
  lastMovementTime: 0,
};

const { creaturesSAB } = workerData;
const sabStateManager = new SABStateManager(workerData);
const creaturesArray = creaturesSAB ? new Int32Array(creaturesSAB) : null;

// --- State Transition Helper ---
function transitionTo(newState, reason = '') {
  if (targetingState.state === newState) return;
  logger(
    'debug',
    `[FSM] Transition: ${targetingState.state} -> ${newState}` +
      (reason ? ` (${reason})` : '')
  );
  targetingState.state = newState;

  if (newState === FSM_STATE.SELECTING) {
    targetingState.pathfindingTarget = null;
    targetingState.currentTarget = null;
    updateDynamicTarget(parentPort, null, []);
  }
  if (newState === FSM_STATE.ACQUIRING) {
    targetingState.lastAcquireAttempt.timestamp = 0;
  }
}

// --- FSM State Handlers ---

function handleIdleState() {
  if (
    workerState.globalState?.targeting?.enabled &&
    !sabStateManager.isLootingRequired()
  ) {
    transitionTo(FSM_STATE.SELECTING, 'Targeting enabled');
  }
}

function handleSelectingState() {
  const bestTarget = selectBestTarget(
    sabStateManager,
    workerState.globalState.targeting.targetingList
  );

  if (bestTarget) {
    targetingState.pathfindingTarget = bestTarget;
    updateDynamicTarget(
      parentPort,
      bestTarget,
      workerState.globalState.targeting.targetingList
    );
    transitionTo(FSM_STATE.ACQUIRING, `Found target: ${bestTarget.name}`);
  } else {
    transitionTo(FSM_STATE.IDLE, 'No valid targets');
  }
}

function handleAcquiringState() {
  const now = performance.now();
  const { pathfindingTarget } = targetingState;
  const creatures = sabStateManager.getCreatures();

  // 1. Always check for success first.
  const currentInGameTarget = sabStateManager.getCurrentTarget();
  const isTargetLive = currentInGameTarget
    ? creatures.some((c) => c.instanceId === currentInGameTarget.instanceId)
    : false;

  if (
    currentInGameTarget &&
    isTargetLive &&
    currentInGameTarget.name === pathfindingTarget.name &&
    currentInGameTarget.isReachable
  ) {
    targetingState.currentTarget = currentInGameTarget;
    transitionTo(
      FSM_STATE.ENGAGING,
      `Acquired target ${currentInGameTarget.name}`
    );
    return;
  }

  // 2. Check if our desired target is still valid.
  const pathfindingTargetStillExists = creatures.some(
    (c) => c.instanceId === pathfindingTarget.instanceId && c.isReachable
  );

  if (!pathfindingTargetStillExists) {
    transitionTo(
      FSM_STATE.SELECTING,
      'Pathfinding target disappeared or became unreachable'
    );
    return;
  }

  // 3. Core acquisition logic: Act or Wait.
  const hasClickedAndIsWaiting = targetingState.lastAcquireAttempt.timestamp !== 0;

  if (hasClickedAndIsWaiting) {
    if (now > targetingState.lastAcquireAttempt.timestamp + config.acquireTimeoutMs) {
      logger('debug', `[FSM-ACQUIRING] Verification for ${targetingState.lastAcquireAttempt.targetName} timed out. Will retry.`);
      targetingState.lastAcquireAttempt.timestamp = 0;
    }
    return;
  }

  if (targetingState.lastAcquireAttempt.targetName !== pathfindingTarget.name) {
    targetingState.lastAcquireAttempt.battleListIndex = -1;
    targetingState.lastAcquireAttempt.targetName = pathfindingTarget.name;
  }

  logger('debug', `[FSM-ACQUIRING] Attempting to click ${pathfindingTarget.name}`);
  const result = acquireTarget(
    sabStateManager,
    parentPort,
    pathfindingTarget.name,
    targetingState.lastAcquireAttempt.battleListIndex
  );

  targetingState.lastAcquireAttempt.timestamp = now;

  if (result.success) {
    targetingState.lastAcquireAttempt.battleListIndex = result.clickedIndex;
  } else {
    transitionTo(FSM_STATE.SELECTING, `${pathfindingTarget.name} not in battle list`);
  }
}

async function handleEngagingState() {
  const now = performance.now();
  const creatures = sabStateManager.getCreatures();
  const { globalState } = workerState;
  const targetingList = globalState.targeting.targetingList;

  const actualInGameTarget = sabStateManager.getCurrentTarget();
  if (!targetingState.currentTarget || !actualInGameTarget || actualInGameTarget.instanceId !== targetingState.currentTarget.instanceId) {
    transitionTo(FSM_STATE.SELECTING, 'Target lost or changed');
    return;
  }

  const bestOverallTarget = selectBestTarget(sabStateManager, targetingList);
  if (
    bestOverallTarget &&
    bestOverallTarget.instanceId !== targetingState.currentTarget.instanceId
  ) {
    const currentRule = targetingList.find(
      (r) => r.name === targetingState.currentTarget.name
    );
    const bestRule = targetingList.find(
      (r) => r.name === bestOverallTarget.name
    );

    if (bestRule && currentRule && bestRule.priority > currentRule.priority) {
      logger(
        'info',
        `[FSM] Preempting ${targetingState.currentTarget.name} (Prio: ${currentRule.priority}) for ${bestOverallTarget.name} (Prio: ${bestRule.priority})`
      );
      targetingState.pathfindingTarget = bestOverallTarget;
      updateDynamicTarget(parentPort, bestOverallTarget, targetingList);
      transitionTo(FSM_STATE.ACQUIRING, `Found higher priority target`);
      return;
    }
  }

  const updatedTarget = creatures.find(
    (c) => c.instanceId === targetingState.currentTarget.instanceId
  );

  if (!updatedTarget) {
    transitionTo(FSM_STATE.SELECTING, 'Target died or disappeared');
    return;
  }

  targetingState.currentTarget = updatedTarget;

  if (!updatedTarget.isReachable) {
    if (targetingState.unreachableSince === 0) {
      targetingState.unreachableSince = now;
    } else if (now - targetingState.unreachableSince > config.unreachableTimeoutMs) {
      transitionTo(
        FSM_STATE.SELECTING,
        `Target unreachable for > ${config.unreachableTimeoutMs}ms`
      );
      targetingState.unreachableSince = 0;
      return;
    }
  } else {
    targetingState.unreachableSince = 0;
  }

  await manageMovement(
    { ...workerState, parentPort, sabStateManager },
    {
      targetingList: globalState.targeting.targetingList,
      lastMovementTime: targetingState.lastMovementTime,
    },
    targetingState.currentTarget
  );
}

// --- Main Loop ---

function updateSABData() {
  if (!creaturesArray) return;
  const newWorldStateCounter = Atomics.load(
    creaturesArray,
    WORLD_STATE_UPDATE_COUNTER_INDEX
  );
  if (newWorldStateCounter > workerState.lastWorldStateCounter) {
    workerState.playerMinimapPosition = sabStateManager.getPlayerPosition();
    const pathData = sabStateManager.getPath();
    workerState.path = pathData.path;
    workerState.pathfindingStatus = pathData.status;
    workerState.pathWptId = pathData.wptId;
    workerState.pathInstanceId = pathData.instanceId;
    workerState.lastWorldStateCounter = newWorldStateCounter;
  }
}

async function performTargeting() {
  updateSABData();

  const { globalState, isInitialized } = workerState;
  if (!isInitialized || !globalState?.targeting) return;

  sabStateManager.writeTargetingList(globalState.targeting.targetingList);

  if (!globalState.targeting.enabled || sabStateManager.isLootingRequired()) {
    transitionTo(FSM_STATE.IDLE, 'Targeting disabled or looting');
  }

  const { controlState } = globalState.cavebot;

  if (controlState === 'HANDOVER_TO_TARGETING') {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/confirmTargetingControl',
    });
    return;
  }

  // <<< ADDED: Report visited tiles whenever targeting has control.
  if (controlState === 'TARGETING' && workerState.playerMinimapPosition) {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/addVisitedTile',
      payload: workerState.playerMinimapPosition,
    });
  }

  switch (targetingState.state) {
    case FSM_STATE.IDLE:
      handleIdleState();
      break;
    case FSM_STATE.SELECTING:
      handleSelectingState();
      break;
    case FSM_STATE.ACQUIRING:
      if (controlState === 'TARGETING') handleAcquiringState();
      break;
    case FSM_STATE.ENGAGING:
      if (controlState === 'TARGETING') await handleEngagingState();
      break;
  }

  const hasValidTarget =
    targetingState.state === FSM_STATE.ACQUIRING ||
    targetingState.state === FSM_STATE.ENGAGING;

  const anyValidTargetExists = selectBestTarget(
    sabStateManager,
    globalState.targeting.targetingList
  );

  if (hasValidTarget && controlState === 'CAVEBOT') {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/requestTargetingControl',
    });
  } else if (!hasValidTarget && !anyValidTargetExists && controlState === 'TARGETING') {
    parentPort.postMessage({
      storeUpdate: true,
      type: 'cavebot/releaseTargetingControl',
    });
  }
}

async function mainLoop() {
  logger('info', '[TargetingWorker] Starting FSM-based main loop...');
  while (!workerState.isShuttingDown) {
    const loopStart = performance.now();
    try {
      await performTargeting();
    } catch (error) {
      logger('error', '[TargetingWorker] Unhandled error in main loop:', error);
      await delay(1000);
    }
    const loopEnd = performance.now();
    const elapsedTime = loopEnd - loopStart;
    const delayTime = Math.max(0, config.mainLoopIntervalMs - elapsedTime);
    if (delayTime > 0) {
      await delay(delayTime);
    }
  }
  logger('info', '[TargetingWorker] Main loop stopped.');
}

// --- Worker Initialization and Message Handling ---

parentPort.on('message', (message) => {
  if (workerState.isShuttingDown) return;
  try {
    if (message.type === 'shutdown') {
      workerState.isShuttingDown = true;
      return;
    } else if (message.type === 'state_diff') {
      if (!workerState.globalState) workerState.globalState = {};
      Object.assign(workerState.globalState, message.payload);
    } else if (typeof message === 'object' && !message.type) {
      workerState.globalState = message;
      if (!workerState.isInitialized) {
        workerState.isInitialized = true;
        logger('info', '[TargetingWorker] Initial state received, starting main loop.');
        mainLoop().catch((error) => {
          logger('error', '[TargetingWorker] Fatal error in main loop:', error);
          process.exit(1);
        });
      }
    }
  } catch (error) {
    logger('error', '[TargetingWorker] Error handling message:', error);
  }
});

function startWorker() {
  if (!workerData) {
    throw new Error('[TargetingWorker] Worker data not provided');
  }
  logger('info', '[TargetingWorker] Worker initialized, waiting for initial state...');
}

startWorker();
//endFile

// /home/feiron/Dokumenty/Automaton/electron/workers/windowTitleMonitor.js
//start file
import { parentPort, workerData } from 'worker_threads';
import windowinfo from 'windowinfo-native';
import { createLogger } from '../utils/logger.js';

const log = createLogger({ info: false, debug: false });
log('info', '[WindowTitleMonitor] Worker file loaded.');

const POLLING_INTERVAL = 100;
const INITIAL_CHECK_DELAY_MS = 2500; // A one-time delay for the very first check.

let intervalId = null;
let isInitialized = false;
let isShuttingDown = false;
let currentState = null; // This worker's local copy of the Redux state.
let lastKnownLiveName = null; // An internal tracker to prevent spamming updates.

const CHARACTER_NAME_REGEX = /Tibia - (.+)/;
const getCharacterNameFromTitle = (title) => {
  const match = title.match(CHARACTER_NAME_REGEX);
  return match ? match[1] : null;
};

const reusableUpdate = {
  storeUpdate: true,
  type: 'gameState/updateCharacterNames',
  payload: {},
};

const monitorWindowTitle = async () => {
  if (!isInitialized || !currentState || isShuttingDown) {
    return;
  }

  const { windowId, display } = currentState.global;
  if (!windowId || !display) {
    return;
  }

  try {
    const windowInfo = await windowinfo.getAllInfo({ windowId, display });
    const liveCharacterName = windowInfo?.name
      ? getCharacterNameFromTitle(windowInfo.name)
      : null;

    // The core logic: We only act if the live name is different from the last live name we processed.
    if (liveCharacterName !== lastKnownLiveName) {
      log(
        'info',
        `[WindowTitleMonitor] Live name change detected: '${lastKnownLiveName || 'None'}' -> '${liveCharacterName || 'None'}'. Dispatching update.`,
      );

      const updatePayload = {
        characterName: liveCharacterName,
      };

      if (lastKnownLiveName) {
        updatePayload.lastCharacterName = lastKnownLiveName;
      }

      reusableUpdate.payload = updatePayload;
      parentPort.postMessage(reusableUpdate);

      // CRITICAL: Update our internal tracker immediately after sending.
      lastKnownLiveName = liveCharacterName;
    }

    if (!windowInfo) {
      stopMonitoring();
    }
  } catch (error) {
    log('error', '[WindowTitleMonitor] Critical error in monitor loop:', error);
    stopMonitoring();
    if (lastKnownLiveName !== null) {
      reusableUpdate.payload = {
        characterName: null,
        lastCharacterName: lastKnownLiveName,
      };
      parentPort.postMessage(reusableUpdate);
      lastKnownLiveName = null;
    }
  }
};

const startMonitoring = () => {
  if (intervalId) return;
  log(
    'info',
    `[WindowTitleMonitor] Scheduling first check in ${INITIAL_CHECK_DELAY_MS}ms.`,
  );

  // --- THIS IS THE FIX ---
  // We wait a moment before the first check to ensure the OS has registered the window title.
  setTimeout(() => {
    if (isShuttingDown) return;

    log('info', '[WindowTitleMonitor] Starting relentless polling loop.');
    // Run the check once immediately after the delay.
    monitorWindowTitle();
    // Then, start the regular interval for all subsequent checks.
    intervalId = setInterval(monitorWindowTitle, POLLING_INTERVAL);
  }, INITIAL_CHECK_DELAY_MS);
};

const stopMonitoring = () => {
  if (intervalId) {
    clearInterval(intervalId);
    intervalId = null;
    log('info', '[WindowTitleMonitor] Stopped polling loop.');
  }
};

parentPort.on('message', (message) => {
  try {
    if (message.type === 'shutdown') {
      isShuttingDown = true;
      log('info', '[WindowTitleMonitor] Received shutdown signal.');
      stopMonitoring();
      parentPort.close();
      return;
    }

    if (message.type === 'state_diff') {
      if (!currentState) currentState = {};
      Object.assign(currentState, message.payload);
    } else if (typeof message === 'object' && !message.type) {
      currentState = message;
      if (!isInitialized) {
        isInitialized = true;
        log(
          'info',
          '[WindowTitleMonitor] Received initial state. Starting monitor...',
        );
        // Initialize our tracker with the official state from the store, just once.
        lastKnownLiveName = currentState.gameState.characterName;
        startMonitoring();
      }
    }
  } catch (error) {
    log('error', '[WindowTitleMonitor] Error handling message:', error);
  }
});

log(
  'info',
  '[WindowTitleMonitor] Worker initialized and awaiting initial state.',
);

//endFile

