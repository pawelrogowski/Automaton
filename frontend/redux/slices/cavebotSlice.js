import { createSlice } from '@reduxjs/toolkit';

/**
 * A helper function whose ONLY job is to convert a legacy 'coordinates' string
 * into separate x, y, z properties. It no longer adds default values.
 * @param {object} payload - The object that might contain a `coordinates` string.
 * @returns {object} The payload with x, y, z properties if parsing occurred.
 */
const parseLegacyCoordinates = (payload) => {
  if (typeof payload.coordinates === 'string') {
    const newPayload = { ...payload };
    const coords = newPayload.coordinates.split(',');
    coords.forEach((coord) => {
      const [key, value] = coord.split(':');
      if (key && value) {
        newPayload[key.trim()] = parseInt(value.trim(), 10);
      }
    });
    delete newPayload.coordinates; // Remove the old property
    return newPayload;
  }

  return payload;
};

const initialState = {
  enabled: false, // State for the entire cavebot system
  wptId: 'null',
  wptSelection: null,
  currentSection: 'default',
  wptDistance: 0,
  routeSearchMs: 0,
  waypointSections: {
    default: {
      name: 'Default',
      waypoints: [],
    },
  },
  pathWaypoints: [],
  retryMoveDelayMs: 250,
  // The main array for our special areas
  specialAreas: [],
};

const cavebotSlice = createSlice({
  name: 'cavebot',
  initialState,
  reducers: {
    // --- WAYPOINT & GENERAL REDUCERS (Unchanged) ---
    addWaypoint: (state, action) => {
      const parsedPayload = parseLegacyCoordinates(action.payload);
      const newWaypoint = {
        type: 'Node',
        label: '',
        x: 0,
        y: 0,
        z: 0,
        range: 5,
        action: '',
        ...parsedPayload,
        id: action.payload.id,
      };
      const currentWaypoints = state.waypointSections[state.currentSection].waypoints;
      const selectedIndex = currentWaypoints.findIndex((waypoint) => waypoint.id === state.wptSelection);
      let newWaypointIndex;
      if (selectedIndex > -1) {
        newWaypointIndex = selectedIndex + 1;
        currentWaypoints.splice(newWaypointIndex, 0, newWaypoint);
      } else {
        currentWaypoints.push(newWaypoint);
        newWaypointIndex = currentWaypoints.length - 1;
      }
      if (currentWaypoints[newWaypointIndex]) {
        state.wptSelection = currentWaypoints[newWaypointIndex].id;
      }
    },
    removeWaypoint: (state, action) => {
      /* ... unchanged ... */
    },
    reorderWaypoints: (state, action) => {
      /* ... unchanged ... */
    },
    setenabled: (state, action) => {
      state.enabled = action.payload;
    },
    // The critical fix for the waypoint skipping race condition
    setwptId: (state, action) => {
      const newWptId = action.payload;
      if (state.wptId !== newWptId) {
        state.wptId = newWptId;
        state.pathWaypoints = [];
        state.wptDistance = null;
        state.routeSearchMs = 0;
      }
    },
    setwptSelection: (state, action) => {
      /* ... unchanged ... */
    },
    updateWaypoint: (state, action) => {
      /* ... unchanged ... */
    },
    setState: (state, action) => {
      return { ...initialState, ...(action.payload || {}) };
    },
    setPathfindingFeedback: (state, action) => {
      /* ... unchanged ... */
    },
    // ... other existing waypoint section reducers ...

    // --- SPECIAL AREA REDUCERS (WITH FINAL EDITS) ---

    /**
     * Adds a new special area.
     * Expects a payload object containing a unique `id` generated by the frontend.
     */
    addSpecialArea: (state, action) => {
      const newArea = {
        // Default values for a new area
        name: `Area ${state.specialAreas.length + 1}`,
        x: 0,
        y: 0,
        z: 0,
        sizeX: 1,
        sizeY: 1,
        avoidance: 100,
        type: 'cavebot',
        enabled: true, // New enabled flag defaults to true
        // The payload from the component overrides the defaults
        ...action.payload,
      };

      // Validation checks
      if (!newArea.id) {
        console.error('Action `addSpecialArea` requires an `id` in the payload.');
        return;
      }
      const nameExists = state.specialAreas.some((area) => area.name === newArea.name);
      if (nameExists) {
        console.warn(`Special area with name "${newArea.name}" already exists.`);
        return;
      }
      const idExists = state.specialAreas.some((area) => area.id === newArea.id);
      if (idExists) {
        console.error(`FATAL: Attempted to add special area with a duplicate ID: ${newArea.id}`);
        return;
      }

      state.specialAreas.push(newArea);
    },

    /**
     * Removes a special area by its unique ID.
     * Expects payload: string (the ID of the area to remove)
     */
    removeSpecialArea: (state, action) => {
      const idToRemove = action.payload;
      state.specialAreas = state.specialAreas.filter((area) => area.id !== idToRemove);
    },

    /**
     * Updates an existing special area.
     * Expects payload: { id: string, updates: object }
     * This will correctly handle updates to any key, including `enabled`.
     */
    updateSpecialArea: (state, action) => {
      const { id, updates } = action.payload;
      const existingArea = state.specialAreas.find((area) => area.id === id);

      if (existingArea) {
        if (updates.name && state.specialAreas.some((area) => area.id !== id && area.name === updates.name)) {
          console.warn(`Special area with name "${updates.name}" already exists.`);
          delete updates.name;
        }
        Object.assign(existingArea, updates);
      }
    },
  },
});

export const {
  addWaypoint,
  removeWaypoint,
  reorderWaypoints,
  setenabled,
  setwptId,
  setwptSelection,
  updateWaypoint,
  setState,
  setPathfindingFeedback,
  addWaypointSection,
  removeWaypointSection,
  setCurrentWaypointSection,
  renameWaypointSection,
  setRetryMoveDelayMs,
  addSpecialArea,
  removeSpecialArea,
  updateSpecialArea,
} = cavebotSlice.actions;

export default cavebotSlice;
