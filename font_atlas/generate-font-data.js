// generate-font-data.js
const fs = require('fs');
const path = require('path');
const { PNG } = require('pngjs');

const PNG_DIR = './png';
const OUTPUT_HEADER_FILE = './src/font_atlas_data.h';

const FILENAME_TO_CHAR_MAP = {
  space: ' ',
  colon: ':',
  period: '.',
  comma: ',',
  bracket_open: '[',
  bracket_close: ']',
  brace_open: '{',
  brace_close: '}',
  paren_open: '(',
  paren_close: ')',
  apostrophe: "'",
  quote: '"',
  backtick: '`',
  semicolon: ';',
  exclamation: '!',
  question: '?',
  slash: '/',
  backslash: '\\',
  pipe: '|',
  hyphen: '-',
  underscore: '_',
  equals: '=',
  plus: '+',
  less_than: '<',
  greater_than: '>',
  asterisk: '*',
  ampersand: '&',
  at_symbol: '@',
  hash: '#',
  dollar: '$',
  percent: '%',
  caret: '^',
};

const MANUAL_OFFSETS = {
  '!': 1,
  '"': 0,
  '#': 1,
  $: 0,
  '%': 1,
  '&': 1,
  "'": 0,
  '(': 0,
  ')': 0,
  '*': 0,
  '+': 2,
  ',': 7,
  '-': 5,
  '.': 7,
  '/': 0,
  0: 1,
  1: 1,
  2: 1,
  3: 1,
  4: 1,
  5: 1,
  6: 1,
  7: 1,
  8: 1,
  9: 1,
  ':': 3,
  ';': 3,
  '<': 2,
  '=': 3,
  '>': 2,
  '?': 1,
  '@': 1,
  A: 1,
  B: 1,
  C: 1,
  D: 1,
  E: 1,
  F: 1,
  G: 1,
  H: 1,
  I: 1,
  J: 1,
  K: 1,
  L: 1,
  M: 1,
  N: 1,
  O: 1,
  P: 1,
  Q: 1,
  R: 1,
  S: 1,
  T: 1,
  U: 1,
  V: 0,
  W: 1,
  X: 1,
  Y: 1,
  Z: 1,
  '[': 0,
  '\\': 0,
  ']': 0,
  '^': 1,
  _: 10,
  '`': 0,
  a: 3,
  b: 0,
  c: 3,
  d: 0,
  e: 3,
  f: 0,
  g: 3,
  h: 0,
  i: 1,
  j: 1,
  k: 0,
  l: 0,
  m: 3,
  n: 3,
  o: 3,
  p: 3,
  q: 3,
  r: 3,
  s: 3,
  t: 1,
  u: 3,
  v: 3,
  w: 3,
  x: 3,
  y: 3,
  z: 3,
  '{': 0,
  '|': 0,
  '}': 0,
};

function isMagicColor(r, g, b) {
  return r === 255 && g === 0 && b === 255;
}

async function generateCppHeader() {
  console.log('Starting C++ header generation...');
  const pngFiles = fs.readdirSync(PNG_DIR).filter((f) => f.endsWith('.png'));
  let cppEntries = [];

  for (const file of pngFiles) {
    const filenameBase = path.basename(file, '.png');
    const char = FILENAME_TO_CHAR_MAP[filenameBase] || (filenameBase.length === 1 ? filenameBase : null);
    if (!char) continue;

    const buffer = fs.readFileSync(path.join(PNG_DIR, file));
    const png = PNG.sync.read(buffer);
    const fontPixelOffsets = [];
    const bgPixelOffsets = [];

    for (let y = 0; y < png.height; y++) {
      for (let x = 0; x < png.width; x++) {
        const idx = (png.width * y + x) << 2;
        if (isMagicColor(png.data[idx], png.data[idx + 1], png.data[idx + 2])) {
          fontPixelOffsets.push(`{${x},${y}}`);
        } else {
          bgPixelOffsets.push(`{${x},${y}}`);
        }
      }
    }

    const characterKey = char.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    const entry = `
    {
        CharTemplate tpl;
        tpl.character = '${characterKey}';
        tpl.width = ${png.width};
        tpl.height = ${png.height};
        tpl.offset = ${MANUAL_OFFSETS[char] ?? 0};
        tpl.font_pixel_offsets = {${fontPixelOffsets.join(', ')}};
        tpl.bg_pixel_offsets = {${bgPixelOffsets.join(', ')}};
        fontAtlas.push_back(std::move(tpl));
    }`;
    cppEntries.push(entry);
  }

  // **THE FIX: Include the new structs header instead of a forward declaration.**
  const headerContent = `// font_atlas_data.h
// Generated by generate-font-data.js on ${new Date().toISOString()}
// DO NOT EDIT THIS FILE MANUALLY

#pragma once
#include "ocr_structs.h" // Include the full struct definitions

inline void HardcodedInitializeFontAtlas(std::vector<CharTemplate>& fontAtlas) {
    if (!fontAtlas.empty()) return;
    fontAtlas.reserve(${cppEntries.length});
${cppEntries.join('')}
}
`;

  const outputDir = path.dirname(OUTPUT_HEADER_FILE);
  if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });
  fs.writeFileSync(OUTPUT_HEADER_FILE, headerContent);
  console.log(`\nSuccess! Generated C++ header file at: ${OUTPUT_HEADER_FILE}`);
}

generateCppHeader().catch((err) => {
  console.error('\nAn error occurred:', err);
  process.exit(1);
});
