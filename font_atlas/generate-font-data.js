// generate-font-data.js
// Reads the existing font data file, preserves manually entered 'offset' values,
// and updates width/height from the actual PNG files. This version uses a robust
// regex parser to correctly handle all special characters.

const fs = require('fs');
const path = require('path');
const sharp = require('sharp');

// --- CONFIGURATION ---

const FONT_DIR = './';
const DATA_FILE = './font-data.js';
const REQUIRED_CHARS_STRING =
  'abcdefghijklmnopqrstuvwxyz' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '0123456789' + '[];\'\\,./-=_+{}:"|>?<`!@#$%^&*()_+';

const FILENAME_TO_CHAR_MAP = {
  space: ' ',
  colon: ':',
  period: '.',
  comma: ',',
  bracket_open: '[',
  bracket_close: ']',
  brace_open: '{',
  brace_close: '}',
  paren_open: '(',
  paren_close: ')',
  apostrophe: "'",
  quote: '"',
  backtick: '`',
  semicolon: ';',
  exclamation: '!',
  question: '?',
  slash: '/',
  backslash: '\\',
  pipe: '|',
  hyphen: '-',
  underscore: '_',
  equals: '=',
  plus: '+',
  less_than: '<',
  greater_than: '>',
  asterisk: '*',
  ampersand: '&',
  at_symbol: '@',
  hash: '#',
  dollar: '$',
  percent: '%',
  caret: '^',
};

// --- SCRIPT LOGIC ---

const CHAR_TO_FILENAME_MAP = Object.fromEntries(Object.entries(FILENAME_TO_CHAR_MAP).map(([filename, char]) => [char, filename]));

function parseExistingData(filePath) {
  if (!fs.existsSync(filePath)) {
    console.log(`No existing ${filePath} found. A new file will be created.`);
    return {};
  }

  console.log(`Loading existing data from ${filePath}...`);
  const fileContent = fs.readFileSync(filePath, 'utf8');
  const existingData = {};

  // THE CRITICAL FIX: A robust regex that correctly handles escaped characters.
  const entryRegex = /'((?:\\.|[^'\\])*)':\s*{\s*width:\s*\d+,\s*height:\s*\d+,\s*offset:\s*(\d+)/g;

  let match;
  while ((match = entryRegex.exec(fileContent)) !== null) {
    // match[1] is the captured character (e.g., 'A', '\'', '\\').
    // match[2] is the captured offset value.
    const char = match[1];
    const offset = parseInt(match[2], 10);
    existingData[char] = { offset };
  }

  if (Object.keys(existingData).length === 0) {
    console.warn(`Warning: Could not parse any entries from ${filePath}. It might be empty or malformed. A new file will be generated.`);
  } else {
    console.log(`Successfully parsed and preserved offsets for ${Object.keys(existingData).length} entries.`);
  }
  return existingData;
}

async function generateData() {
  console.log(`Starting font data update...`);

  const existingData = parseExistingData(DATA_FILE);
  const fontDataMap = new Map();
  const requiredCharsSet = new Set(REQUIRED_CHARS_STRING.split(''));

  for (const char of requiredCharsSet) {
    const filenameBase = CHAR_TO_FILENAME_MAP[char] || char;
    const fullPath = path.join(FONT_DIR, `${filenameBase}.png`);

    const existingEntry = existingData[char];
    const preservedOffset = existingEntry ? existingEntry.offset : 0;

    let width = 0;
    let height = 0;

    if (fs.existsSync(fullPath)) {
      const metadata = await sharp(fullPath).metadata();
      width = metadata.width;
      height = metadata.height;
    }

    fontDataMap.set(char, {
      width,
      height,
      offset: preservedOffset,
      filenameBase,
    });
  }

  const sortedChars = Array.from(fontDataMap.keys()).sort();
  const fontDataEntries = sortedChars.map((char) => {
    const data = fontDataMap.get(char);
    const characterKey = `'${char.replace(/\\/g, '\\\\').replace(/'/g, "\\'")}'`;

    // Generate clean, comment-free output
    return `  ${characterKey}: {
    width: ${data.width},
    height: ${data.height},
    offset: ${data.offset},
    data: loadCharData('${data.filenameBase}')
  }`;
  });

  const fileContent = `// font-data.js
// Generated by the generate-font-data.js script on ${new Date().toISOString()}

/**
 * This is a placeholder for the function you use to load PNG data.
 * It should take a filename base (e.g., 'A', 'bracket_open') and return
 * the character's pixel data as a Node.js Buffer.
 *
 * @param {string} charFilenameBase - The base name of the PNG file (e.g., 'A', 'bracket_open').
 * @returns {Buffer}
 */
function loadCharData(charFilenameBase) {
  // In your real code, this function reads a file like \`\${charFilenameBase}.png\`
  // and returns its pixel data as a Node.js Buffer.
  // This is just an example placeholder.
  // import fs from 'fs';
  // import path from 'path';
  // return fs.readFileSync(path.join(__dirname, 'fonts', \`\${charFilenameBase}.png\`));
  return Buffer.from([]);
}

export default {
${fontDataEntries.join(',\n')}
};
`;

  fs.writeFileSync(DATA_FILE, fileContent);

  console.log(`\nSuccess! âœ¨`);
  console.log(`Updated ${DATA_FILE} with ${fontDataMap.size} total entries.`);
  console.log(`You can now safely run this script again after making changes.`);
}

generateData().catch((error) => {
  console.error('\nAn error occurred:', error.message);
  process.exit(1);
});
